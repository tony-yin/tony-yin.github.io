<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tony&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tony-yin.github.io/"/>
  <updated>2017-09-12T11:16:28.572Z</updated>
  <id>https://tony-yin.github.io/</id>
  
  <author>
    <name>Tony</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Disk pull and plug record</title>
    <link href="https://tony-yin.github.io/2017/09/10/Disk-pull-and-plug-record/"/>
    <id>https://tony-yin.github.io/2017/09/10/Disk-pull-and-plug-record/</id>
    <published>2017-09-09T18:21:45.000Z</published>
    <updated>2017-09-12T11:16:28.572Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/pull_device.png" alt="pull disk"></center><p>最近在做磁盘拔插后的<code>OSD</code>热恢复功能。在反复拔插盘的实践过程中，遇到了一个难题，就是时常会由于拔盘，然后再插盘后盘符发生了改变，<code>kernel</code>和<code>udev</code>接收不到任何<code>device</code>增加或删除的事件消息，<br>由于我是基于<code>udev</code>监测磁盘的插拔，所以一旦感知不到的话，就无法进行相应的恢复操作，所以在此对拔盘的记录进行一些记录，并在大量操作中得出总结。</p><a id="more"></a><h2 id="Operation-Record"><a href="#Operation-Record" class="headerlink" title="Operation Record"></a>Operation Record</h2><p><code>normal</code>: 表示正常情况，没有被拔</p><table><thead><tr><th style="text-align:center">env</th><th style="text-align:center">udev monitor</th><th style="text-align:center">UI data</th><th style="text-align:center">disk alias</th><th style="text-align:center">device</th><th style="text-align:center">lsblk</th><th style="text-align:center">mount info</th><th style="text-align:center">mount point </th></tr></thead><tbody><tr><td style="text-align:center">normal</td><td style="text-align:center">-</td><td style="text-align:center">/dev/sdg1</td><td style="text-align:center">osd4-data</td><td style="text-align:center">/dev/sdg</td><td style="text-align:center">exist</td><td style="text-align:center">exist</td><td style="text-align:center">/data/osd.1</td></tr><tr><td style="text-align:center">first pull</td><td style="text-align:center">remove sdg</td><td style="text-align:center">empty</td><td style="text-align:center">remove</td><td style="text-align:center">remove</td><td style="text-align:center">remove</td><td style="text-align:center">exist</td><td style="text-align:center">exist, readerror</td></tr><tr><td style="text-align:center">first plug</td><td style="text-align:center">add sdd</td><td style="text-align:center">/dev/sdd1</td><td style="text-align:center">osd4-data</td><td style="text-align:center">/dev/sdd</td><td style="text-align:center">exist</td><td style="text-align:center">exist</td><td style="text-align:center">exist, readerror</td></tr><tr><td style="text-align:center">second pull</td><td style="text-align:center">no remove</td><td style="text-align:center">empty</td><td style="text-align:center">osd4-data</td><td style="text-align:center">/dev/sdd</td><td style="text-align:center">not change</td><td style="text-align:center">exist</td><td style="text-align:center">exist, readerror</td></tr><tr><td style="text-align:center">second plug</td><td style="text-align:center">All Not Change</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">- </td></tr><tr><td style="text-align:center">clear mount</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">exist</td><td style="text-align:center">-</td><td style="text-align:center">exist</td><td style="text-align:center">remove</td><td style="text-align:center">change style</td></tr><tr><td style="text-align:center">third pull</td><td style="text-align:center">remove sdd</td><td style="text-align:center">empty</td><td style="text-align:center">remove</td><td style="text-align:center">remove</td><td style="text-align:center">remove</td><td style="text-align:center">remove</td><td style="text-align:center">change style</td></tr><tr><td style="text-align:center">third plug</td><td style="text-align:center">add sdd</td><td style="text-align:center">/dev/sdd1</td><td style="text-align:center">osd4-data</td><td style="text-align:center">/dev/sdd</td><td style="text-align:center">exist</td><td style="text-align:center">exist</td><td style="text-align:center">exist, readerror</td></tr></tbody></table><h2 id="Before-pull"><a href="#Before-pull" class="headerlink" title="Before pull"></a>Before pull</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/before_pull.png" alt="before pull"></center><h2 id="First-pull"><a href="#First-pull" class="headerlink" title="First pull"></a>First pull</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/first_pull.png" alt="First pull"></center><h2 id="Read-error"><a href="#Read-error" class="headerlink" title="Read error"></a>Read error</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/readerror.png" alt="Read error"></center><h2 id="First-plug"><a href="#First-plug" class="headerlink" title="First plug"></a>First plug</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/first_plug.png" alt="First plug"></center><h2 id="Second-pull"><a href="#Second-pull" class="headerlink" title="Second pull"></a>Second pull</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/second_pull.png" alt="Second pull"></center><h2 id="Second-plug"><a href="#Second-plug" class="headerlink" title="Second plug"></a>Second plug</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/second_pull.png" alt="Second plug"></center><h2 id="Clear-mount-info"><a href="#Clear-mount-info" class="headerlink" title="Clear mount info"></a>Clear mount info</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/clear_mount.png" alt="Clear mount info"></center><h2 id="Third-plug-udev-monitor"><a href="#Third-plug-udev-monitor" class="headerlink" title="Third plug udev monitor"></a>Third plug udev monitor</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/third_plug.png" alt="Third pull"></center><h2 id="Third-plug"><a href="#Third-plug" class="headerlink" title="Third plug"></a>Third plug</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/third_plug_alias.png" alt="Third plug"></center><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>通过上面的表格和图片，如果拔盘前没有卸载<code>mount</code>链接，那么可以发现：</p><ul><li>下次插盘，磁盘名称不再是原来的名称，在当前排序最后的一个磁盘名往后追加，比如当前最后一块盘是<code>sdf</code>，那么就改名为<code>sdg</code></li><li><code>lsblk</code>显示<code>device</code>列表不会变化，<code>alias name</code>也是不会变化</li><li>再次拔盘，<code>device</code>列表不会变化，<code>udev monitor</code>不会接收到任何设备的删除的事件信息</li><li>再次插盘，<code>device</code>列表不会变化，<code>udev monitor</code>不会接收到任何设备的添加的事件信息</li></ul><p>如果清除了<code>mount</code>信息，插拔变得正常起来</p><ul><li><code>udev</code>可以正常接收设备添加和删除的信息</li><li><code>lsblk</code>可以正常显示设备列表，会随着磁盘的拔盘而更新显示，<code>alias name</code>也是如此</li><li>磁盘名称变回正常，即开机最原始的名称，例如上文的<code>sdd</code></li></ul><p>所以针对一块硬盘的拔插只要做好即时清除<code>mount</code>就够了，那么这个时候拔另外插槽的一块盘呢？<br>结果是：</p><ul><li>第一次拔盘： <code>udev</code>感知到（<code>remove</code> 当前磁盘名），<code>device</code>列表和<code>alias name</code>消失 </li><li>第一次插盘： <code>udev</code>感知到（<code>add</code> <strong>sdg</strong>），<code>device</code>增加了<code>sdg</code>，<code>alias name</code>增加，没有变化</li><li>第二次拔盘： 一切都没了反应</li><li>清除<code>mount</code>信息后，插盘：无反应</li><li>删除<code>alias name</code>： 无反应</li><li>无论怎么样都没反应，也许除了开机或者这快盘插在别的插槽内</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h3><p>目前来看，只要拔盘超过两块，一旦第二块盘的磁盘名称变了跟之前名称不一样，那么之后再怎么清理<code>mount</code>信息或者反复拔插都不会被<code>udev</code>感知到<br>理论上来说，要实现硬盘热替换，那就得保证<code>udev</code>每次都能检测到硬盘的插入，拔盘检测倒不是那么重要，<br>针对这种情况，目前没发现什么比较好的解决方案，唯一一种也是我当前采用的方案，在检测拔盘事件时会触发一个脚本，做拔的盘的<code>mount</code>信息的检查，如果存在<code>mount</code>信息，那么就<code>umount</code>掉，这是一种比较完美的场景，也就是说要保证每次插盘前，当前盘在系统中都不存在任何<code>mount</code>信息</p><p>这种方案还是太完美化了，还需要大量的测试，期望能找出更能经得起推敲的方案</p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>测试过程中偶然发现每次硬盘插入如果被<code>udev</code>感知到，也会执行大量的<code>udev rules</code>，其中包括创建设备，建立连接，建立连接这个事情就包括硬盘分区的<code>alias</code>，而我们感知到磁盘设备插入执行脚本在这之前，找了一系列的方案，都没能够使得让脚本在它<code>alias</code>之后再执行</p><p>这里有一份官方的解释：<a href="http://www.reactivated.net/writing_udev_rules.html#external-run" target="_blank" rel="external">http://www.reactivated.net/writing_udev_rules.html#external-run</a></p><p>至于为什么脚本依赖这个别名，那是因为系统存的<code>data path</code>还是<code>journal path</code>都是以别名的形式，如果我们能够在别名之后执行脚本，那么理想情况下系统<code>db</code>之前存的别名会自动和插入的盘匹配建立连接，不需要我们再做过多的事情，否则我们得在每次创建<code>osd</code>的时候再存原始路径，记录分区信息等等，还有<code>/etc/fstab</code>存的都是别名，这样就导致有些操作无法进行，还有一些其他的矛盾暂时还没想到</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/pull_device.png&quot; alt=&quot;pull disk&quot;&gt;&lt;/center&gt;

&lt;p&gt;最近在做磁盘拔插后的&lt;code&gt;OSD&lt;/code&gt;热恢复功能。在反复拔插盘的实践过程中，遇到了一个难题，就是时常会由于拔盘，然后再插盘后盘符发生了改变，&lt;code&gt;kernel&lt;/code&gt;和&lt;code&gt;udev&lt;/code&gt;接收不到任何&lt;code&gt;device&lt;/code&gt;增加或删除的事件消息，&lt;br&gt;由于我是基于&lt;code&gt;udev&lt;/code&gt;监测磁盘的插拔，所以一旦感知不到的话，就无法进行相应的恢复操作，所以在此对拔盘的记录进行一些记录，并在大量操作中得出总结。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
      <category term="Udev" scheme="https://tony-yin.github.io/tags/Udev/"/>
    
      <category term="Osd" scheme="https://tony-yin.github.io/tags/Osd/"/>
    
      <category term="Disk" scheme="https://tony-yin.github.io/tags/Disk/"/>
    
  </entry>
  
  <entry>
    <title>Linux Udev</title>
    <link href="https://tony-yin.github.io/2017/09/10/Linux-Udev/"/>
    <id>https://tony-yin.github.io/2017/09/10/Linux-Udev/</id>
    <published>2017-09-09T18:20:27.000Z</published>
    <updated>2017-09-12T06:04:17.161Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/night_king800x600_1x.jpg" alt="udev"></center><p>在我入门<code>udev</code>，看着各种各样的资料觉得这个东西很高深的时候，突然瞄到一篇文章里面说道： 要树立一个信念：<code>udev</code>很简单，当时不以为然，现在深表赞同。看起来很高端很遥远的<code>Title</code>，比如<code>Linux Kernel</code>，比如软硬件交互，比如热插拔等等，其实掌握几个<code>rules</code>，然后再动手实践实践，对比着讲解，就能知道七七八八了，想要再深入，就多看看文档实现和内核源码，其实很多东西都是这样，了解了就很简单，没事了解一点就比别人多知道一些，共勉 </p><a id="more"></a><h2 id="Udev-是什么"><a href="#Udev-是什么" class="headerlink" title="Udev 是什么"></a>Udev 是什么</h2><p><code>udev</code>是<code>linux kernel</code>的设备管理器，处理硬件的添加和删除，但它的功能远远不仅于此。比如<code>U</code>盘插入，电脑是如何即时的做出响应？耳机插入又是如何做到自动关闭外部音量？这些都跟<code>udev</code>有关。虽然<code>udev</code>很强大，功能很多，本来就针对<code>SCSI</code>硬盘设备的插拔做一些经验的分享。至于为什么我会研究到这个东西，是因为最近在做<code>ceph</code>相关的项目，需要实现一个类似热插拔的<code>feature</code>，懂的人应该很清楚，就是拔插硬盘后，<code>osd</code>自动恢复，主要应用于硬盘寿命即将到期，替换新盘的场景，不明白的同学也不要紧，因为本文主要讨论的是<code>udev</code></p><h2 id="Udev-Rules"><a href="#Udev-Rules" class="headerlink" title="Udev Rules"></a>Udev Rules</h2><p><code>udev</code>管理各种各样的设备，比如<code>usb</code>,<code>scsi</code>,<code>cd</code>等等，为了区别设备类型，精确匹配，<code>udev</code>制定了一套特色的<code>rules</code>，为什么说特色呢？因为我觉得它用最简洁的语法满足了方方面面的需求</p><p>这里推荐一些有用的<code>link</code>：</p><ul><li><a href="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html" target="_blank" rel="external">UDEV Primer</a>  <code>udev</code>入门必读，可以快速将<code>udev</code>了解一番</li><li><a href="http://www.reactivated.net/writing_udev_rules.html" target="_blank" rel="external">Writing udev rules</a>  经典文章，看完这个基本就能掌握<code>udev rules</code></li><li><a href="http://www.lai18.com/content/1612267.html" target="_blank" rel="external">Writing udev rules 修订版</a>  国内论坛对格式样式做了一些修改，有洁癖的可以看看</li><li><a href="http://blog.csdn.net/nhczp/article/details/4099647" target="_blank" rel="external">Writing udev rules 译</a>  翻译版本，英文不好的可以中英文对比着看</li><li><a href="http://www.jinbuguo.com/systemd/udev.html#" target="_blank" rel="external">udev 中文手册</a>  这位金步国先生为开源事业做出了杰出的贡献，早前就看过他翻译的<code>Apache</code>的手册</li><li><a href="http://wiki.dreamrunner.org/public_html/Embedded-System/kernel/udev-rules.html" target="_blank" rel="external">Writing udev rules and kernel examples</a>  看够了上面各种规则，来看看具体的例子吧</li><li><a href="http://blog.csdn.net/lqrensn/article/details/8097288" target="_blank" rel="external">Udev 详解</a>  文章如名，真的很详细</li><li><a href="http://www.cnblogs.com/qigaohua/p/6673930.html" target="_blank" rel="external">Udev 使用方法</a>  一些特殊的技巧  </li></ul><p>大家看完上面的文章应该知道<code>rules</code>文件的位置和规则,下面我贴一些我实践中的代码和例子</p><h3 id="Rules-Example"><a href="#Rules-Example" class="headerlink" title="Rules Example"></a>Rules Example</h3><p>这是两条分别针对<code>SCSI</code>硬盘设备的添加和删除的<code>rules</code>，设备事件分别会触发相应的脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">KERNEL==&quot;sd[a-z]&quot;, ACTION==&quot;add&quot;, SUBSYSTEM==&quot;block&quot;, RUN+=&quot;/usr/bin/python /root/test.py %k add&quot;</div><div class="line">KERNEL==&quot;sd[a-z]&quot;, ACTION==&quot;remove&quot;, SUBSYSTEM==&quot;block&quot;, RUN+=&quot;/usr/bin/python /root/test.py %k remove&quot;</div></pre></td></tr></table></figure></p><h3 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h3><ul><li>执行外部命令必须加上环境变量路径, 上面的这个也可以不加<code>/usr/bin/python</code>，但是必须在<code>py</code>脚本头部加上<code>shebang</code>：<code>#! /usr/bin/python</code></li><li><code>RUN</code>可以运行程序外的程序，而<code>PROGRAM</code>不是做这个事情的，而是为了生成之后需要的变量</li></ul><h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><ul><li><a href="http://www.cnblogs.com/daishuguang/p/4192703.html" target="_blank" rel="external">hashtag and shebang</a></li><li><a href="http://smilejay.com/2012/03/linux_shebang/" target="_blank" rel="external">shebang</a></li></ul><h2 id="Udevadm"><a href="#Udevadm" class="headerlink" title="Udevadm"></a>Udevadm</h2><p><code>udevadm</code>是一个<code>udev</code>的管理工具，可以用来获取设备信息(<code>info</code>)，监视和控制udev运行时的行为(<code>control</code>)，请求内核事件(<code>trigger</code>)，管理事件队列(<code>settle</code>)，以及提供简单的调试机制(<code>test</code>)。很实用，很好用！！！</p><h3 id="推荐-Link"><a href="#推荐-Link" class="headerlink" title="推荐 Link"></a>推荐 Link</h3><ul><li><a href="http://www.jinbuguo.com/systemd/udevadm.html" target="_blank" rel="external">udevadm 中文手册</a>  很全，很基础 ~~</li><li><a href="http://fibrevillage.com/sysadmin/93-udevadm-usage-examples" target="_blank" rel="external">udevadm command examples</a>  很多<code>udevadm</code>的命令可以借鉴，说不定以后可以用到呢？</li></ul><p>介绍几个我具体使用过的例子：</p><h3 id="udevadm-info"><a href="#udevadm-info" class="headerlink" title="udevadm info"></a>udevadm info</h3><p>可以从<code>udev</code>数据库中提取设备信息,此外，还可以从<code>sysfs</code>中提取设备的属性， 以帮助创建与此设备匹配的<code>udev</code>规则</p><p>获取<code>/dev/sdb</code>的<code>path</code>信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">udevadm info -q path -n /dev/sdb</div></pre></td></tr></table></figure></p><h3 id="udevadm-test"><a href="#udevadm-test" class="headerlink" title="udevadm test"></a>udevadm test</h3><p>模拟向<code>udev</code>发送设备信息，并不会真的触发，<strong>而是将触发后的过程信息打印出来</strong>，对调试很有帮助</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">udevadm test --action=&apos;add&apos; `udevadm info -q path -n /dev/sdb`</div></pre></td></tr></table></figure><p><strong>注意：</strong> <code>test</code>不会真正触发事件，而<code>trigger</code>可以</p><h3 id="udevadm-trigger"><a href="#udevadm-trigger" class="headerlink" title="udevadm trigger"></a>udevadm trigger</h3><p>可以真正触发<code>udev</code>事件，但是不会真正改变硬件，只是触发<code>kernel</code>和<code>udev</code>的事件，会触发<code>udev rules</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">udevadm trigger -v --action=add --sysname-match=sda</div></pre></td></tr></table></figure><p><strong>注意：</strong> </p><ul><li>不加<code>sysname-match</code>那么会触发所有设备，如果是<code>action=remove</code>，那么则会移除很多设备，甚至导致<code>sshd</code>服务停掉</li><li>后面是<code>sda</code>而不是<code>/dev/sda</code>因为它是根据<code>pci</code>路径来定位<code>name</code>的，比如<code>sda</code>的路径是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/sys/devices/pci0000:00/0000:00:10.0/host2/target2:0:0/2:0:0:0/block/sda</div></pre></td></tr></table></figure></li></ul><h3 id="udevadm-control"><a href="#udevadm-control" class="headerlink" title="udevadm control"></a>udevadm control</h3><ul><li><p>重载<code>udev rules</code>，对之后触发的新设备有效，对之前已经触发的无效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">udevadm control --relaod-rules</div></pre></td></tr></table></figure></li><li><p>更改<code>udev</code>日志等级为<code>info</code>，<code>udev</code>默认等级为<code>err</code>，可以在<code>/etc/udev/udev.conf</code>中查看，日志具体信息可以在<code>syslog</code>中查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">udevadm control --log-priority=info</div></pre></td></tr></table></figure></li></ul><h2 id="More-about-udev"><a href="#More-about-udev" class="headerlink" title="More about udev"></a>More about udev</h2><p><code>udev</code>还有很多有意思的地方，如果想要更加深入的学习，那么除了熟练地掌握<code>rules</code>等技巧，还要对其实现原理有了解，这就得多看文档，多看源码了，建议大家有条件的情况下多看源码，多看原始的东西，因为经过别人的总结就可能会变味，相互对比，不要一味依赖别人总结的产物</p><ul><li><a href="https://my.oschina.net/bwhite/blog/808995" target="_blank" rel="external">Linux 自动挂载usb设备 小例子</a>  如何在<code>usb</code>设备插入后自动挂载？</li><li><a href="http://www.jianshu.com/p/dd6cecd7755a" target="_blank" rel="external">udev使用笔记</a>  这篇文章里面那张图片不错</li><li><a href="http://blog.csdn.net/fjb2080/article/details/5009791" target="_blank" rel="external">写个程序检测我们的设备插拔</a>  模仿内核源码简单地实现一个设备插拔的检测</li><li><a href="http://www.itnose.net/detail/6691523.html" target="_blank" rel="external">linux下热插拔事件的产生是怎样通知到用户空间</a>  事件传递过程，<code>udev</code>源码解析</li><li><a href="http://blog.csdn.net/bingqingsuimeng/article/details/7950639" target="_blank" rel="external">热插拔的工作原理 hotplug机制和udev</a>  <code>udev</code>原理讲解</li><li><a href="http://blog.csdn.net/sunweizhong1024/article/details/7928530" target="_blank" rel="external">Uevent 上报event事件给上层的详细讲解</a>  <code>uevent</code>源码讲解</li><li><a href="http://blog.csdn.net/bingqingsuimeng/article/details/7924756" target="_blank" rel="external">linux内核空间和用户空间的是怎样区别的，如何交互，如何从用户空间进入内核空间</a>  内核空间和用户空间的一些剖析</li><li><a href="http://blog.chinaunix.net/uid-24943863-id-3223000.html" target="_blank" rel="external">Netlink实现热拔插监控 </a>  消息传输用的是什么？<code>Netlink</code>是如何做到的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/night_king800x600_1x.jpg&quot; alt=&quot;udev&quot;&gt;&lt;/center&gt;

&lt;p&gt;在我入门&lt;code&gt;udev&lt;/code&gt;，看着各种各样的资料觉得这个东西很高深的时候，突然瞄到一篇文章里面说道： 要树立一个信念：&lt;code&gt;udev&lt;/code&gt;很简单，当时不以为然，现在深表赞同。看起来很高端很遥远的&lt;code&gt;Title&lt;/code&gt;，比如&lt;code&gt;Linux Kernel&lt;/code&gt;，比如软硬件交互，比如热插拔等等，其实掌握几个&lt;code&gt;rules&lt;/code&gt;，然后再动手实践实践，对比着讲解，就能知道七七八八了，想要再深入，就多看看文档实现和内核源码，其实很多东西都是这样，了解了就很简单，没事了解一点就比别人多知道一些，共勉 &lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
      <category term="Udev" scheme="https://tony-yin.github.io/tags/Udev/"/>
    
  </entry>
  
  <entry>
    <title>Magicloud Route</title>
    <link href="https://tony-yin.github.io/2017/09/10/Magicloud-Route/"/>
    <id>https://tony-yin.github.io/2017/09/10/Magicloud-Route/</id>
    <published>2017-09-09T18:19:35.000Z</published>
    <updated>2017-09-12T11:30:20.002Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/hardware_family_1x.png" alt="router"></center><p><code>Magicloud</code>是我目前负责的一个基于<code>ceph</code>的分布式存储项目，为了方便刚刚参与项目的成员熟悉整个项目的路由并能够快速着手，在这里对整个项目的路由梳理了一下，以图形为主，凸出整个流程的走向</p><a id="more"></a><p><code>Magicloud</code>目前有两种方式进行前后端通信，一种是<code>Ajax</code>,一种是<code>Restful Api</code></p><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>以前台<code>UI</code>的主机角色获取所有<code>Osd</code>列表为例：</p><center><img src="http://on-img.com/chart_image/599851a6e4b0b7b347e0e378.png" alt="image"></center><h3 id="Restful-API"><a href="#Restful-API" class="headerlink" title="Restful API"></a>Restful API</h3><center><img src="http://on-img.com/chart_image/59994a6ae4b06df7265d5447.png" alt="image"></center>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/hardware_family_1x.png&quot; alt=&quot;router&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;code&gt;Magicloud&lt;/code&gt;是我目前负责的一个基于&lt;code&gt;ceph&lt;/code&gt;的分布式存储项目，为了方便刚刚参与项目的成员熟悉整个项目的路由并能够快速着手，在这里对整个项目的路由梳理了一下，以图形为主，凸出整个流程的走向&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Route" scheme="https://tony-yin.github.io/tags/Route/"/>
    
  </entry>
  
  <entry>
    <title>Osd Enable and Disable</title>
    <link href="https://tony-yin.github.io/2017/09/10/Osd-Enable-and-Disable/"/>
    <id>https://tony-yin.github.io/2017/09/10/Osd-Enable-and-Disable/</id>
    <published>2017-09-09T18:18:33.000Z</published>
    <updated>2017-09-12T12:30:41.184Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/circles_js_039_dribbble.gif" alt="osd"></center><p>对项目中<code>osd</code>的<code>enable</code>和<code>disable</code>的代码流程的总结</p><a id="more"></a><h2 id="Osd-Disable"><a href="#Osd-Disable" class="headerlink" title="Osd Disable"></a>Osd Disable</h2><p>1.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stop_ezs3_service: stop_ezs3_service</div></pre></td></tr></table></figure></p><p>2.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stop osd</div></pre></td></tr></table></figure></p><p>3.<code>disable osd</code></p><ul><li>load config: /etc/mcs3/storage.conf(存储卷的配置信息，即<code>osd</code>的配置信息)</li><li>service ganglia-monitor stop’ returns ‘Stopping Ganglia Monitor Daemon: gmond.</li><li>get osd id by osd name </li><li>stop osd<ul><li>ezs3-ha service_ceph stop osd0</li><li>kill -9 xxx</li><li>ceph osd down 0, ceph osd out 0, ceph osd rm 0</li></ul></li><li>disable osd</li><li>umount:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mount_point = &quot;/data/osd.&#123;&#125;&quot;.format(self.get_osd_id())</div><div class="line">if os.path.ismount(mount_point):</div><div class="line">umount -f -l /data/osd.0 ?</div><div class="line">   ......</div><div class="line">   sed -i &apos;\@/data/osd.0@d&apos; /etc/fstab</div></pre></td></tr></table></figure></li></ul><p>4.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete part_map</div></pre></td></tr></table></figure></p><p>5.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set partition map</div></pre></td></tr></table></figure></p><p>6.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cl.node_management.osd_disabled</div></pre></td></tr></table></figure></p><h2 id="Osd-Enable"><a href="#Osd-Enable" class="headerlink" title="Osd Enable"></a>Osd Enable</h2><ul><li>prepare enable osd</li><li>set public interace,cluster interface(if cluster interface is true) and save in ceph.conf (osd, interface等信息存放文件：/etc/ceph/ceph.conf)</li><li>consolidate_raid_configure<ul><li>查看池信息：/opt/MegaRAID/MegaCli/MegaCli64 -AdpBbuCMD -Aall |grep Exit |tr -d “\n”</li><li>a series of megaci command</li></ul></li><li>记录 osd 的状态： role.set(OSD, RoleState.ENABLING)</li><li>enable osd (@monlock ?)<ul><li>update task info(有空看下代码，如何实现ajax轮询的)</li><li>get_partition_map:</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">try: </div><div class="line">    kvstore.get(&apos;partition_map&apos;, timeout, timeout!=0) </div><div class="line">catch: </div><div class="line">    rados -p .ezs3 get partition_map -</div></pre></td></tr></table></figure><ul><li>stop ezs3 service</li><li>创建桶节点并且建立link</li><li>service ganglia-monitor stop</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if not host_osd_enabled: </div><div class="line">    ceph osd crush add-bucket &#123;&#125; host&quot;.format(crush_host_bucket)</div><div class="line">    ceph osd crush link &#123;&#125; pool=default&quot;.format(crush_host_bucket)</div></pre></td></tr></table></figure><ul><li>StorageVolume<ul><li>enable_osd<ul><li>ceph osd create</li><li>mount: mount -o noatime,user_xattr /dev/disk/by-partlabel/osd1-data /data/osd.0</li><li>add osd and save</li><li>ceph mon getmap -o /tmp/monmap（二进制文件）</li><li>ceph-osd -i {osd_id} –monmap /tmp/monmap –mkfs –mkjournal</li><li>start osd: <code>ezs3-ha service_ceph start osd0</code></li><li>ceph osd crush add {osd_id} 0 pool=default host={crush_host_bucket}</li><li>set osd uuid and osd post  stop command</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/circles_js_039_dribbble.gif&quot; alt=&quot;osd&quot;&gt;&lt;/center&gt;

&lt;p&gt;对项目中&lt;code&gt;osd&lt;/code&gt;的&lt;code&gt;enable&lt;/code&gt;和&lt;code&gt;disable&lt;/code&gt;的代码流程的总结&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Osd" scheme="https://tony-yin.github.io/tags/Osd/"/>
    
  </entry>
  
  <entry>
    <title>Disk Mon Daemon</title>
    <link href="https://tony-yin.github.io/2017/09/10/Disk-Mon-Daemon/"/>
    <id>https://tony-yin.github.io/2017/09/10/Disk-Mon-Daemon/</id>
    <published>2017-09-09T18:17:19.000Z</published>
    <updated>2017-09-12T05:56:08.950Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/demonabel.gif" alt="daemon"></center><p>最近在做监控<code>SSD</code>磁盘健康状态这个需求的时候，发现项目中专门针对磁盘写了一个<code>daemon</code>，之前对<code>daemon</code>只是表面上的了解，所以这次正好深入学习下,了解一下这样做的原因和好处以及如何在以后的工作中熟练运用<code>daemon</code><br><a id="more"></a></p><h2 id="Daemon相关知识了解"><a href="#Daemon相关知识了解" class="headerlink" title="Daemon相关知识了解"></a>Daemon相关知识了解</h2><ul><li><a href="http://www.linfo.org/daemon.html" target="_blank" rel="external">Daemon Definition</a></li><li><a href="https://stackoverflow.com/questions/17954432/creating-a-daemon-in-linux" target="_blank" rel="external">Creating a daemon in Linux</a></li><li><a href="http://www.enderunix.org/docs/eng/daemon.php" target="_blank" rel="external">Unix Daemon Server Programming</a></li><li><a href="http://www.netzmafia.de/skripten/unix/linux-daemon-howto.html" target="_blank" rel="external">Linux Daemon Writing HOWTO</a></li><li><a href="http://www.cnblogs.com/mickole/p/3188321.html" target="_blank" rel="external">守护进程详解及创建，daemon()使用</a></li></ul><h2 id="MCS3DiskMonitor-Daemon使用"><a href="#MCS3DiskMonitor-Daemon使用" class="headerlink" title="MCS3DiskMonitor Daemon使用"></a>MCS3DiskMonitor Daemon使用</h2><ol><li><code>pid</code>文件路径： <code>/var/run/mcs3-smart-monitor.pid</code></li><li><code>daemon</code>所在位置: <code>/etc/init.d/</code></li><li><code>log</code>打印位置：<code>/var/log/mccloudstor/mcs3-disk-mon.log</code></li><li>操作方式：</li></ol><ul><li><code>service mcs3-smart-monitor start</code></li><li><code>service mcs3-smart-monitor stop</code></li><li><code>service mcs3-smart-monitor restart</code></li></ul><blockquote><p>改动<code>daemon</code>相关代码，需<code>restart daemon</code>才可以生效</p></blockquote><h2 id="MCS3DiskMonitor-Daemon-process"><a href="#MCS3DiskMonitor-Daemon-process" class="headerlink" title="MCS3DiskMonitor Daemon process"></a>MCS3DiskMonitor Daemon process</h2><p><strong>1.</strong> 单位时间避免邮件重复发送： 通过声明一个全局变量<code>send_email_time</code>, 记录当前时间的一个小时的时间，一旦发送邮件立即更新该变量为当前时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">sent_mail_time = datetime.datetime.now() - datetime.timedelta(0,3600) # 1 hour</div><div class="line"></div><div class="line">def send_disk_status_notification(disk_status):</div><div class="line">    global sent_mail_time</div><div class="line">    now = datetime.datetime.now()</div><div class="line">    if now &lt; sent_mail_time + datetime.timedelta(0,3600):</div><div class="line">        logger.info(&quot;Notification sent within one hour before. System will not send again.&quot;)</div><div class="line">        return</div><div class="line">            host = socket.gethostname()</div><div class="line">    title = &quot;Host &#123;&#125; Disk Health Status Warning!&quot;.format(host)</div><div class="line">    message = disk_status</div><div class="line">    try:</div><div class="line">        utils.send_notification(title, message)</div><div class="line">        sent_mail_time = datetime.datetime.now()</div><div class="line">    except Exception as e:</div><div class="line">        logger.error(str(e))</div></pre></td></tr></table></figure><p><strong>2.</strong> 执行命令报错影响其他代码的执行，有以下几处命令执行：</p><p><code>line48</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">output = utils.do_cmd(&quot;zpool status|grep state&quot;, force=True)</div></pre></td></tr></table></figure></p><p><code>line71~75</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">VDSTATE1 = do_cmd(MEGACLI_BIN + &quot; -cfgdsply -aALL -NoLog | grep State&quot;) </div><div class="line">VDSTATE2 = do_cmd(MEGACLI_BIN + &quot; -AdpAllInfo -aALL -NoLog | grep Degraded&quot;)</div><div class="line">VDSTATE3 = do_cmd(MEGACLI_BIN + &quot; -AdpAllInfo -aALL -NoLog | grep Offline&quot;)</div><div class="line">PDSTATE1 = do_cmd(MEGACLI_BIN + &quot; -AdpAllInfo -aALL -NoLog | grep \&quot;Critical Disks\&quot;&quot;)</div><div class="line">PDSTATE2 = do_cmd(MEGACLI_BIN + &quot; -AdpAllInfo -aALL -NoLog | grep \&quot;Failed Disks\&quot;&quot;)</div></pre></td></tr></table></figure></p><blockquote><p>暂时处理方法：在这些方法的外面单独包一层<code>try catch</code></p></blockquote><p><strong>3.</strong> <code>SSD Disk</code>信息获取</p><ul><li>获取健康寿命</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">smartctl -a -d megaraid,&#123;&#125; &#123;&#125;|grep &apos;Media_Wearout_Indicator&apos;</div></pre></td></tr></table></figure><ul><li>获取磁盘序列号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">smartctl -a -d megaraid,&#123;&#125; &#123;&#125;|grep &apos;Serial Number&apos;</div></pre></td></tr></table></figure><ul><li>判断是否为SSD Disk：如果为<code>1</code>则为机械硬盘，如果为<code>0</code>则为<code>SSD Disk</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /sys/block/&#123;&#125;/queue/rotational  // param such as sda or sdb etc</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/demonabel.gif&quot; alt=&quot;daemon&quot;&gt;&lt;/center&gt;


&lt;p&gt;最近在做监控&lt;code&gt;SSD&lt;/code&gt;磁盘健康状态这个需求的时候，发现项目中专门针对磁盘写了一个&lt;code&gt;daemon&lt;/code&gt;，之前对&lt;code&gt;daemon&lt;/code&gt;只是表面上的了解，所以这次正好深入学习下,了解一下这样做的原因和好处以及如何在以后的工作中熟练运用&lt;code&gt;daemon&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
      <category term="Daemon" scheme="https://tony-yin.github.io/tags/Daemon/"/>
    
  </entry>
  
  <entry>
    <title>Network Down Notification</title>
    <link href="https://tony-yin.github.io/2017/09/10/network-down-notification/"/>
    <id>https://tony-yin.github.io/2017/09/10/network-down-notification/</id>
    <published>2017-09-09T18:14:34.000Z</published>
    <updated>2017-09-12T11:58:13.285Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/network.png" alt="network"></center><p>项目中要做一个<code>network</code> <code>down</code>了之后给用户发送邮件提醒的功能，这里面涉及到的问题有：</p><ul><li>如何监测 network 状态</li><li>network down之后，如何发送邮件</li><li>public network 和 storage network的用处和场景</li></ul><a id="more"></a><h2 id="get-role-interfaces"><a href="#get-role-interfaces" class="headerlink" title="get role interfaces"></a>get role interfaces</h2><h2 id="get-interfaces"><a href="#get-interfaces" class="headerlink" title="get interfaces"></a>get interfaces</h2><h2 id="get-interface-info"><a href="#get-interface-info" class="headerlink" title="get interface info"></a>get interface info</h2><h3 id="获取-MAC-和-busid"><a href="#获取-MAC-和-busid" class="headerlink" title="获取 MAC 和 busid"></a>获取 MAC 和 busid</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">syspath = os.path.join(&quot;/sys/class/net/&quot;, interface)  // interface such as &apos;eth0&apos;</div><div class="line">mac = linecache.getline(os.path.join(syspath, &quot;address&quot;), 1)[:-1].upper()</div><div class="line">buspath = os.path.realpath(syspath)</div><div class="line">bus_id = os.path.basename(os.path.dirname(os.path.dirname(buspath)))</div></pre></td></tr></table></figure><ul><li>MAC: 直接在<code>syspath</code>目录下读取<code>address</code>文件</li><li>假设为<code>eth0</code>,查看<code>eth0</code>目录可见该目录被建立了软连接，并不是真实地址，所以需要取出它的真实地址，这个需要使用<code>python</code>中的<code>os.path.realpath()</code>处理获得<code>0000:03:00.0</code>,作为下一步<code>lspci</code>的参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@ceph133:/sys/class/net# ll eth0</div><div class="line">lrwxrwxrwx 1 root root 0  8月  8 01:26 eth0 -&gt; ../../devices/pci0000:00/0000:00:15.0/0000:03:00.0/net/eth0/</div></pre></td></tr></table></figure><h3 id="获取网卡信息"><a href="#获取网卡信息" class="headerlink" title="获取网卡信息"></a>获取网卡信息</h3><p><code>lspci -s</code>后面的参数为<code>pci</code>设备的地址，也叫<code>pci寻址</code>，这个地址由总线编号、插槽编号和功能块编号信息组成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lspci -m -s xxx // 这边的参数就是上面的bus_id</div></pre></td></tr></table></figure></p><blockquote><p>具体<code>lspci</code>信息请参照：<br><a href="http://coolnull.com/2246.html" target="_blank" rel="external">lspci命令详解</a><br><a href="http://blog.csdn.net/xiadidi/article/details/18408169" target="_blank" rel="external">LSPCI命令详解分析</a></p></blockquote><h3 id="获取网卡状态"><a href="#获取网卡状态" class="headerlink" title="获取网卡状态"></a>获取网卡状态</h3><p>通过<code>ethtool</code>工具获取网卡状态，就是看<code>Link detected</code>是否为<code>yes</code>，<code>yes</code>表示已激活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/sbin/ethtool eth0 | grep &apos;Link detected: yes&apos; | wc -l</div></pre></td></tr></table></figure><h2 id="bond-filter"><a href="#bond-filter" class="headerlink" title="bond filter"></a>bond filter</h2><h2 id="Network-down-notification"><a href="#Network-down-notification" class="headerlink" title="Network down notification"></a>Network down notification</h2><p><strong>1.</strong> 目前无论是<code>storage</code>还是<code>public</code>网卡只要<code>down</code>其中一个都无法发送<code>email</code>:</p><ul><li>public: <code>visit foreign network and connect smtp server</code></li><li>storage: <code>connect ceph rados to get notification info, such as send account and smtp server etc</code><br>所以只能<code>monitor</code>除这两个以外的网卡</li></ul><p><strong>2.</strong> <code>Python</code></p><ul><li><code>log</code>打印的文件取决于当前文件进程的初始化<code>log level</code></li><li><code>logger</code>: <code>handler</code>, <code>formatter</code>, <code>filter</code></li><li><code>dictdefault</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/network.png&quot; alt=&quot;network&quot;&gt;&lt;/center&gt;

&lt;p&gt;项目中要做一个&lt;code&gt;network&lt;/code&gt; &lt;code&gt;down&lt;/code&gt;了之后给用户发送邮件提醒的功能，这里面涉及到的问题有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何监测 network 状态&lt;/li&gt;
&lt;li&gt;network down之后，如何发送邮件&lt;/li&gt;
&lt;li&gt;public network 和 storage network的用处和场景&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Network" scheme="https://tony-yin.github.io/tags/Network/"/>
    
      <category term="Notification" scheme="https://tony-yin.github.io/tags/Notification/"/>
    
  </entry>
  
  <entry>
    <title>Python Oracle</title>
    <link href="https://tony-yin.github.io/2017/09/10/Python-Oracle/"/>
    <id>https://tony-yin.github.io/2017/09/10/Python-Oracle/</id>
    <published>2017-09-09T17:02:41.000Z</published>
    <updated>2017-09-12T10:59:06.123Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/oracle_2.png" alt="oracle"></center><p>近期在做<code>Intel</code>的测试，需要监测各种故障情况下的热恢复或者热迁移等功能，比如拔线测试，拔盘测试，断电测试等，来检验分布式的稳定性和灵活性，以<code>Oracle</code>为例，需要一直向数据库中写数据，然后在发生故障时，通过观察插入数据的情况来判断是否能够处理异常情况，所以我需要写一个脚本，能够做到通过<code>python</code>自动连接<code>oracle</code>数据库并自动插入数据。</p><a id="more"></a><blockquote><p>当前环境：Linux Centos 7</p></blockquote><h3 id="1-下载安装包cx-Oracle"><a href="#1-下载安装包cx-Oracle" class="headerlink" title="1. 下载安装包cx_Oracle"></a>1. 下载安装包cx_Oracle</h3><p>由于我本地<code>Python</code>版本是<code>2.7</code>,所以选择是<code>2.7</code>版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://pypi.python.org/packages/e1/18/00987c6a9af9568ee87d1fcba877407684a3f1b87515e5eb82d5d5acb9ff/cx_Oracle-6.0rc1-py27-1.x86_64.rpm#md5=ff8f5cce07bd5ec8ed3ce5c79d451474</div></pre></td></tr></table></figure><p>参考:</p><blockquote><ul><li><a href="https://oracle.github.io/python-cx_Oracle/" target="_blank" rel="external">python-cx_Oracle</a></li><li><a href="https://pypi.python.org/pypi/cx_Oracle/5.3" target="_blank" rel="external">安装包列表</a></li></ul></blockquote><h3 id="2-安装cx-Oracle"><a href="#2-安装cx-Oracle" class="headerlink" title="2. 安装cx_Oracle"></a>2. 安装cx_Oracle</h3><ul><li>安装：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm -ivh cx_Oracle-6.0rc1-py27-1.x86_64.rpm</div></pre></td></tr></table></figure><ul><li>查看当前<code>python</code>引入模块库的路径</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root ~]# python</div><div class="line">Python 2.7.5 (default, Nov  6 2016, 00:28:07) </div><div class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-11)] on linux2</div><div class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div><div class="line">&gt;&gt;&gt; import sys</div><div class="line">&gt;&gt;&gt; print sys.path</div><div class="line">[&apos;&apos;, &apos;/usr/lib/python2.7/site-packages/AliyunUtil-0.0.1-py2.7.egg&apos;, &apos;/usr/lib/python2.7/site-packages/cloud_init-0.7.6-py2.7.egg&apos;, &apos;/usr/lib64/python27.zip&apos;, &apos;/usr/lib64/python2.7&apos;, &apos;/usr/lib64/python2.7/plat-linux2&apos;, &apos;/usr/lib64/python2.7/lib-tk&apos;, &apos;/usr/lib64/python2.7/lib-old&apos;, &apos;/usr/lib64/python2.7/lib-dynload&apos;, &apos;/usr/lib64/python2.7/site-packages&apos;, &apos;/usr/lib/python2.7/site-packages&apos;]</div></pre></td></tr></table></figure><ul><li>检查安装路径，如果<code>cx_Oracle.so</code>文件不在以上<code>python</code>引入路径内需要将该文件拷贝到以上<code>python</code>引入路径,所以我这里不需要进行拷贝操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root ~]# rpm -qa | grep cx_Oracle | xargs rpm -ql</div><div class="line">/usr/lib64/python2.7/site-packages/cx_Oracle-6.0rc1-py2.7.egg-info</div><div class="line">/usr/lib64/python2.7/site-packages/cx_Oracle-6.0rc1-py2.7.egg-info/PKG-INFO</div><div class="line">/usr/lib64/python2.7/site-packages/cx_Oracle-6.0rc1-py2.7.egg-info/SOURCES.txt</div><div class="line">/usr/lib64/python2.7/site-packages/cx_Oracle-6.0rc1-py2.7.egg-info/dependency_links.txt</div><div class="line">/usr/lib64/python2.7/site-packages/cx_Oracle-6.0rc1-py2.7.egg-info/top_level.txt</div><div class="line">/usr/lib64/python2.7/site-packages/cx_Oracle.so</div></pre></td></tr></table></figure><h3 id="3-下载-Oracle-Library"><a href="#3-下载-Oracle-Library" class="headerlink" title="3. 下载 Oracle Library"></a>3. 下载 Oracle Library</h3><p>由于<code>Oracle</code>官网下载东西存在<code>Auth</code>认证，所以简单点就点击选中的<code>rpm</code>包保存在<code>windows</code>上，然后上传到<code>linux</code>上即可</p><p><strong>注意：</strong></p><blockquote><ul><li>下载的版本要和连接的<code>Oracle</code>基本一致，我需要连接的<code>oracle</code>版本是<code>11.2</code>，所以我下载的是<code>oracle-instantclient11.2-basic-11.2.0.3.0-1.x86_64.rpm</code></li><li><strong>操作系统要和之前下载的<code>cx_Oracle</code>要一致</strong>，这很重要！！！我在这个上面栽了跟头，花了比较多的时间。。。所以我需要下载<code>64</code>位的</li><li>在<code>Oracle</code>官网下载东西你得先勾选<code>Accept License Agreement</code>，否则你下载不了</li><li>其次你得有<code>Oracle</code>的账号</li></ul></blockquote><h3 id="4-安装-Oracle-Library"><a href="#4-安装-Oracle-Library" class="headerlink" title="4. 安装 Oracle Library"></a>4. 安装 Oracle Library</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm -ivh oracle-instantclient11.2-basic-11.2.0.3.0-1.x86_64.rpm</div></pre></td></tr></table></figure><h3 id="5-配置环境变量"><a href="#5-配置环境变量" class="headerlink" title="5. 配置环境变量"></a>5. 配置环境变量</h3><ul><li><strong>修改<code>Oracle</code>安装路径</strong></li></ul><p>将<code>client64</code>改为<code>client</code>，至于为什么要改暂时还不清楚，只知道不改的话会报错<code>Oracle Client library cannot be loaded: libclntsh.so: cannot open shared object file: No such file or directory</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /usr/lib/oracle/11.2/</div><div class="line">mv client64 client</div></pre></td></tr></table></figure><ul><li>打开<code>/etc/profile</code>,追加环境变量路径</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/profile</div></pre></td></tr></table></figure><ul><li>配置环境变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 查看Oracle安装路径</div><div class="line">[root@iZbp180vortqapb7yf8217Z ~]# rpm -qa | grep oracle | xargs rpm -ql</div><div class="line">/usr/lib/oracle/11.2/client64/bin/adrci</div><div class="line">/usr/lib/oracle/11.2/client64/bin/genezi</div><div class="line">/usr/lib/oracle/11.2/client64/lib/libclntsh.so.11.1</div><div class="line">/usr/lib/oracle/11.2/client64/lib/libnnz11.so</div><div class="line">/usr/lib/oracle/11.2/client64/lib/libocci.so.11.1</div><div class="line">/usr/lib/oracle/11.2/client64/lib/libociei.so</div><div class="line">/usr/lib/oracle/11.2/client64/lib/libocijdbc11.so</div><div class="line">/usr/lib/oracle/11.2/client64/lib/ojdbc5.jar</div><div class="line">/usr/lib/oracle/11.2/client64/lib/ojdbc6.jar</div><div class="line">/usr/lib/oracle/11.2/client64/lib/xstreams.jar</div><div class="line">// 追加ORACLE_HOME环境变量路径</div><div class="line">export ORACLE_HOME=/usr/lib/oracle/11.2/client64</div><div class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ORACLE_HOME/lib</div></pre></td></tr></table></figure><ul><li>生效配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.bashrc</div></pre></td></tr></table></figure><h3 id="6-检查是否可以引入cx-Oracle"><a href="#6-检查是否可以引入cx-Oracle" class="headerlink" title="6. 检查是否可以引入cx_Oracle"></a>6. 检查是否可以引入<code>cx_Oracle</code></h3><p><code>import</code>没有报错，说明之前的辛苦没有白费</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root client64]# python</div><div class="line">Python 2.7.5 (default, Nov  6 2016, 00:28:07) </div><div class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-11)] on linux2</div><div class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div><div class="line">&gt;&gt;&gt; import cx_Oracle</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure><h3 id="7-连接-Oracle"><a href="#7-连接-Oracle" class="headerlink" title="7. 连接 Oracle"></a>7. 连接 Oracle</h3><p>一个插入10条数据的Python脚本demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: UTF-8 -*-</div><div class="line">import cx_Oracle</div><div class="line">con = cx_Oracle.connect(&apos;test/test@xxx.xxx.xxx.xxx/xe&apos;)</div><div class="line">cur = con.cursor()</div><div class="line">for n in range(1, 10):</div><div class="line">    cur.execute(&apos;insert into test(id, name) values (1, n);&apos;)</div><div class="line">cur.close()</div><div class="line">con.close()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/oracle_2.png&quot; alt=&quot;oracle&quot;&gt;&lt;/center&gt;

&lt;p&gt;近期在做&lt;code&gt;Intel&lt;/code&gt;的测试，需要监测各种故障情况下的热恢复或者热迁移等功能，比如拔线测试，拔盘测试，断电测试等，来检验分布式的稳定性和灵活性，以&lt;code&gt;Oracle&lt;/code&gt;为例，需要一直向数据库中写数据，然后在发生故障时，通过观察插入数据的情况来判断是否能够处理异常情况，所以我需要写一个脚本，能够做到通过&lt;code&gt;python&lt;/code&gt;自动连接&lt;code&gt;oracle&lt;/code&gt;数据库并自动插入数据。&lt;/p&gt;
    
    </summary>
    
      <category term="teach" scheme="https://tony-yin.github.io/categories/teach/"/>
    
    
      <category term="Python" scheme="https://tony-yin.github.io/tags/Python/"/>
    
      <category term="Oracle" scheme="https://tony-yin.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle Linux And Oracle Database 11g R2 Intsallation</title>
    <link href="https://tony-yin.github.io/2017/09/10/oracle_install/"/>
    <id>https://tony-yin.github.io/2017/09/10/oracle_install/</id>
    <published>2017-09-09T16:53:06.000Z</published>
    <updated>2017-09-12T10:36:11.363Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/oracle_1.png" alt="oralce"></center><p>最近工作中用到了<code>Oracle</code>作为<code>Intel</code>测试的数据库，在装<code>Oracle Linux</code>和<code>Oracle Database 11g R2</code>折腾了很久，这篇文章就这两点对大家分享一些我安装过程中遇到的问题和注意点，<code>rac</code>暂时还未配置，稍后找时间补上</p><a id="more"></a><blockquote><p>友情提醒： 本文参照<code>link</code>较多，请细心并且耐心地进行每一步操作</p><h3 id="Resource-Link"><a href="#Resource-Link" class="headerlink" title="Resource Link"></a>Resource Link</h3><ul><li><a href="https://pan.baidu.com/s/1pL7ENn9" target="_blank" rel="external">Oracle Linux ISO</a></li><li><a href="https://pan.baidu.com/s/1qYufAQo" target="_blank" rel="external">Linux Oracle Database 11g R2</a> </li><li><a href="https://pan.baidu.com/s/1kV3JpCr" target="_blank" rel="external">Windows Oracle Database 11g R2</a> </li></ul></blockquote><h3 id="Oracle-Linux-Installation"><a href="#Oracle-Linux-Installation" class="headerlink" title="Oracle Linux Installation"></a>Oracle Linux Installation</h3><p><strong>参考列表：</strong></p><ul><li><a href="https://wenku.baidu.com/view/afd5ca9e5022aaea998f0fa2.html" target="_blank" rel="external">oracle linux 6.5 安装 oracle 11gR2图文详解</a></li><li><a href="https://pan.baidu.com/s/1miDQEoC" target="_blank" rel="external">Oracle 11g R2（自己整理的Word，带详细RAC配置）</a></li></ul><blockquote><p>以下操作步骤基本是按上面两条<code>link</code>走的，有一些地方不一样或者是没必要的我会在下面详细讲解，我装的时候以<code>link1</code>为主线，然后参照<code>link2</code>的<code>word</code>文档进行，没有特殊标记的一般都是根据<code>link1</code>操作，大家也可以这样操作，可以少遇一些坑，节省一些时间~~~</p></blockquote><p><strong>注意点：</strong></p><ul><li><code>Base server</code>这一步很关键<ul><li>勾选<code>Oracle Linux Server</code>, <code>Resilient Storage</code>和 <code>Scalable Filesystem Support</code>（参照<code>link2</code>）</li><li>勾选<code>Customize Now</code>，这一步依然非常关键，只有勾选了才可以装一些<code>Oracle Linux</code>需要的套件</li><li>需要手动添加安装的套件（系统默认勾选的不要删掉，这边的操作只添加勾选）：<ul><li><code>Base System</code>：<code>Compatibility libraries</code></li><li><code>Servers</code>: <code>System administration tools</code></li><li><code>Desktops</code>: <code>Desktop</code>、<code>Desktop Platform</code>、<code>Fonts</code>、<code>General Purpose Desktop</code>、<code>Graphical Administration Tools</code>、<code>Input Methods</code>、<code>X Window System</code></li><li><code>Development</code>: <code>Additional Development</code>、<code>Development Tools</code></li><li><code>Appilication</code>: <code>Internet Browser</code></li></ul></li></ul></li><li>安装应该是<code>1390</code>个包，装好直接<code>reboot</code></li><li>这时候创建普通用户的时候，千万不要创建<code>oracle</code>用户，否则之后会有很多麻烦</li></ul><h3 id="Oracle-Linux-Configuration（important-and-complicated）"><a href="#Oracle-Linux-Configuration（important-and-complicated）" class="headerlink" title="Oracle Linux Configuration（important and complicated）"></a>Oracle Linux Configuration（important and complicated）</h3><p><strong>下面讲的主要是和两个文档不同的地方（依然以<code>link1</code>为主线）：</strong></p><p><strong>1.</strong> <code>selinux</code>需要<code>dsiable</code></p><p><strong>2.</strong> <code>/etc/sysctl.conf</code>参照<code>link2</code>，<code>kernel.shmmax = 536870912</code>（这行参照<code>link2</code>）</p><p><strong>3.</strong> <code>/etc/security/limits.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">oracle soft nproc 16384</div><div class="line">oracle hard nproc 16384</div><div class="line">oracle soft nofile 4096</div><div class="line">oracle hard nofile 65536</div><div class="line">oracle soft stack 10240</div></pre></td></tr></table></figure></p><p><strong>4.</strong> <code>oracle linux 6.5</code>光盘下载包（我是通过<code>yum</code>安装,没有安装的大部分都是系统已经安装了，少部分是没必要安装）</p><ul><li>需要安装：<ul><li><code>ksh</code></li><li><code>libaio-devel.i686</code></li><li><code>libaio-devel.x86_64</code></li><li><code>libaio.i686</code></li><li><code>libstdc++.i686</code></li><li><code>libstdc++-4.4.7-18.el6.i686</code></li><li><code>compat-libstdc++-33.i686</code></li></ul></li><li>不需要安装：<ul><li><code>numactl-devel-2*x86_64*</code></li></ul></li></ul><blockquote><p>由于我本地的是<code>libstdc++-4.4.7-4.el6.x86_64</code>，而安装的是<code>libstdc++-4.4.7-18.el6.i686</code>，版本不匹配会造成<code>yum</code>报错，而这个库作为众多库的依赖还不能删除，所以只能强行升级：<code>yum install libstdc++-4.4.7-18.el6.i686</code>，然后再安装<code>i686</code>文件</p></blockquote><p><strong>5.</strong> 路径、权限与环境变量配置<br>这一步参照: <a href="https://oracle-base.com/articles/linux/automating-database-startup-and-shutdown-on-linux" target="_blank" rel="external">Automating Database Startup and Shutdown on Linux</a></p><p><strong>附上脚本和<code>~/.bash_profile</code>:</strong></p><p><code>start_all.sh</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">. /home/oracle/scripts/setEnv.sh</div><div class="line"></div><div class="line">export ORAENV_ASK=NO</div><div class="line">. oraenv</div><div class="line">export ORAENV_ASK=YES</div><div class="line"></div><div class="line">dbstart $ORACLE_HOME</div></pre></td></tr></table></figure><p><code>stop_all.sh</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">. /home/oracle/scripts/setEnv.sh</div><div class="line"></div><div class="line">export ORAENV_ASK=NO</div><div class="line">. oraenv</div><div class="line">export ORAENV_ASK=YES</div><div class="line"></div><div class="line">dbshut $ORACLE_HOME</div></pre></td></tr></table></figure><p><code>setenv.sh</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># Oracle Settings</div><div class="line">export TMP=/tmp</div><div class="line">export TMPDIR=$TMP</div><div class="line"></div><div class="line">export ORACLE_HOSTNAME=tonydb.localdomain</div><div class="line">export ORACLE_UNQNAME=sampledb</div><div class="line">export ORACLE_BASE=/home/oracle/app/oracle</div><div class="line">export ORACLE_HOME=$ORACLE_BASE/product/11.2.0/dbhome_1</div><div class="line">export ORACLE_SID=sampledb</div><div class="line"></div><div class="line">export PATH=/usr/sbin:/usr/local/bin:$PATH</div><div class="line">export PATH=$ORACLE_HOME/bin:$PATH</div><div class="line"></div><div class="line">export LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/lib</div><div class="line">export CLASSPATH=$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib</div></pre></td></tr></table></figure><p><code>~/.bash_profile</code>最后一行追加： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">. /home/oracle/scripts/setenv.sh</div></pre></td></tr></table></figure><p><strong>6.</strong> 安装<code>FTP</code>并上传<code>zip</code>文件（这一步有需求就执行，我是通过<code>windows</code>传输到<code>linux</code>上）</p><blockquote><p>安装包在页面最上方<code>Resource Link</code>的第二个<code>link</code>，有两个<code>zip</code>包，都是需要的，这就是<code>Oracle Database 11g R2</code>的包，下面就开始安装数据库了，离成功也就不远了</p></blockquote><h3 id="Oracle-Database-11g-R2-Installation"><a href="#Oracle-Database-11g-R2-Installation" class="headerlink" title="Oracle Database 11g R2 Installation"></a>Oracle Database 11g R2 Installation</h3><p><strong>参照：</strong> <a href="https://www.tecmint.com/oracle-database-11g-release-2-installation-in-linux/" target="_blank" rel="external">Oracle Database 11g Release 2 Installation on RHEL/CentOS 6.x/5.x/4.x</a>，以这个<code>link</code>的步骤为主，<code>link1</code>和<code>link2</code>为辅</p><ol><li><p>如果出现<code>next button</code>闪退的现象，进入<code>preference</code>里面调节屏幕分辨率即可</p></li><li><p><code>check</code>时候报错，如果你在上面安装了那么就<code>ignore</code>吧，因为这些包都安装了，只不过版本比它<code>check</code>的高：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">libaio-0.3.105</div><div class="line">compat-libstdc++-33-3.2.3</div><div class="line">libaio-devel-0.3.105</div><div class="line">libgcc-3.4.6</div><div class="line">libstdc++-3.4.6</div><div class="line">unixODBC-2.2.11</div><div class="line">unixODBC-2.2.11</div><div class="line">unixODBC-devel-2.2.11</div><div class="line">unixODBC-devel-2.2.11</div><div class="line">pdksh-5.2.14</div></pre></td></tr></table></figure></li></ol><h3 id="Oracle-Listener-Configuration"><a href="#Oracle-Listener-Configuration" class="headerlink" title="Oracle Listener Configuration"></a>Oracle Listener Configuration</h3><p><strong>参照：</strong> <a href="http://blog.csdn.net/haiross/article/details/13613931" target="_blank" rel="external">Oracle Listener</a></p><blockquote><p>最后<code>test</code>不成功也没关系，先保存设置进行下一步，这边把<code>lsnrcetl</code>起起来就可以了，先不要进入<code>oracle</code>命令行，需要等下一步创建了数据库再进行<code>startup</code>等操作</p></blockquote><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><blockquote><p><code>dbca</code>进入创建向导，填写正确的<code>sid</code>，<code>sid</code>不用填<code>ORCL</code>,就用同步生成的就好，不同的数据库可以拥有不同的<code>sid</code>，按照默认的配置不断地<code>next</code>就好</p></blockquote><ul><li>安装后的默认数据库为orcl，如需创建新的数据库<ul><li>使用辅助工具(Linux UI mode)<blockquote><p>root@oracledb: xhost local:oracledb<br>root@oracledb: su - oracle<br>oracle@oracledb: dbca</p></blockquote></li><li>使用em管理WebUI</li></ul></li><li>创建表空间<ul><li>使用sqlplus<blockquote><p>su - oracle (Windows下此步骤省略)<br>sqlplus / as sysdba<br>create tablespace test_space datafile ‘/opt/oracle/oradata/test_data.dbf’ size 500M</p></blockquote></li><li>使用em管理WebUI</li></ul></li><li>创建用户    <ul><li>使用sqlplus<blockquote><p>su - oracle (Windows下此步骤省略)<br>sqlplus / as sysdba<br>create user test identified by test default tablespace test_space;</p></blockquote></li><li>使用em管理WebUI</li></ul></li><li>授权用户权限<ul><li>使用sqlplus<blockquote><p>su - oracle (Windows下此步骤省略)<br>sqlplus / as sysdba<br>grant connect, resource to test;</p></blockquote></li><li>使用em管理WebUI</li></ul></li><li>授权DBA权限（RMAN需要dba权限来运行）<ul><li>使用sqlplus<blockquote><p>su - oracle (Windows下此步骤省略)<br>sqlplus / as sysdba<br>grant sysdba to test;</p></blockquote></li><li>使用em管理WebUI</li></ul></li><li>数据库启动/关闭<ul><li>切换用户<blockquote><p>root@oracledb: su - oracle</p></blockquote></li><li>启动监听<blockquote><p>lsnrctl start</p></blockquote></li><li>启动实例<blockquote><p>su - oracle (Windows下此步骤省略)<br>sqlplus /nolog<br>conn /as sysdba<br>startup</p></blockquote></li><li>关闭实例<blockquote><p>su - oracle (Windows下此步骤省略)<br>sqlplus /nolog<br>conn /as sysdba<br>shutdown immediate<br>exit</p></blockquote></li><li>关闭监听<blockquote><p>lsnrctl stop</p></blockquote></li></ul></li><li>归档日志模式启动/关闭<ul><li>启动归档日志模式<blockquote><p>sqlplus /as sysdba<br>shutdown immediate<br>startup mount<br>alter database archivelog<br>alter database open</p></blockquote></li><li>关闭归档日志模式<blockquote><p>sqlplus /as sysdba<br>shutdown immediate<br>startup mount<br>alter database noarchivelog<br>alter database open</p></blockquote></li></ul></li></ul><p>作者： Tony</p><p>日期： 2017/06/26</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/oracle_1.png&quot; alt=&quot;oralce&quot;&gt;&lt;/center&gt;

&lt;p&gt;最近工作中用到了&lt;code&gt;Oracle&lt;/code&gt;作为&lt;code&gt;Intel&lt;/code&gt;测试的数据库，在装&lt;code&gt;Oracle Linux&lt;/code&gt;和&lt;code&gt;Oracle Database 11g R2&lt;/code&gt;折腾了很久，这篇文章就这两点对大家分享一些我安装过程中遇到的问题和注意点，&lt;code&gt;rac&lt;/code&gt;暂时还未配置，稍后找时间补上&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Oracle" scheme="https://tony-yin.github.io/tags/Oracle/"/>
    
      <category term="Oracle Linux" scheme="https://tony-yin.github.io/tags/Oracle-Linux/"/>
    
      <category term="Oracle 11g R2" scheme="https://tony-yin.github.io/tags/Oracle-11g-R2/"/>
    
  </entry>
  
  <entry>
    <title>Moodle Local Plugin</title>
    <link href="https://tony-yin.github.io/2017/09/09/Moodle-Local-Plugin/"/>
    <id>https://tony-yin.github.io/2017/09/09/Moodle-Local-Plugin/</id>
    <published>2017-09-09T15:05:05.000Z</published>
    <updated>2017-09-12T07:11:46.151Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/moodle-logo-concept.png" alt="moodle"></center><p><code>Local</code>插件在<code>Moodle</code>中相比于其他插件算是比较容易上手的一个插件，<code>Local</code>插件中前后台分离，不用遨游在杂糅前后端的代码里。学会<code>Local</code>插件是上手其他插件的前提，其实一旦学会<code>Local</code>插件也会发现其他插件不过是它的一种变种形式罢了，只要举一反三就能很快掌握。</p><a id="more"></a><h2 id="Moodle-Local-插件架构"><a href="#Moodle-Local-插件架构" class="headerlink" title="Moodle Local 插件架构"></a>Moodle Local 插件架构</h2><center><img src="http://on-img.com/chart_image/58b5173ce4b01d80b64d335e.png" alt="image"></center><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="Template"><a href="#Template" class="headerlink" title="Template"></a><a href="https://docs.moodle.org/dev/Templates" target="_blank" rel="external">Template</a></h3><p>服务器配置了相应的<code>url</code>，所以每个插件的加载首页都是<code>index.php</code>，但是并不意味着页面的代码就在<code>index.php</code>中，首先在<code>index.php</code>中调用<code>renderer.php</code> 中相应的页面渲染方法，例如  <code>render_index_page($page)</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public function render_index_page($page) &#123;</div><div class="line">$data = $page-&gt;export_for_template($this);</div><div class="line">    render_from_template(&apos;local_xxx/index&apos;, $data)</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>在这个方法中，首先调用了<code>index_page</code>这个类中的 <code>export_for_template</code> 方法，获得页面静态加载需要的数据，例如<code>mustache</code>模板需要的数据，<code>data</code>数组的索引与模板名称一一对应，例如<code>mustache</code>文件中若有 &#123;&#123;<code>#user</code>&#125;&#125;<code>hello!</code>&#123;&#123;<code>/user</code>&#125;&#125;，那么对应 class 一定存在 <code>$data[&#39;user&#39;] = xxxx</code>；</li><li>以 <code>render_from_template(&#39;local_xxx/index&#39;, $data)</code> 为例， <code>local_xxx/index</code>，<code>template</code>目录下必定有文件名为<code>index.mustache</code>的文件，这是<code>moodle</code> 封装好的命名规范，而<code>mustache</code>文件就是页面展示的代码所在了；</li><li>通过&#123;&#123;<code>#js</code>&#125;&#125;<code>require xxx</code>&#123;&#123;<code>/js</code>&#125;&#125;引入对应的<code>JavaScript</code>文件；</li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a><a href="https://docs.moodle.org/dev/CSS" target="_blank" rel="external">CSS</a></h3><p>每个 local 插件中都存在一个<code>style.css</code>这样的一个<code>css</code>样式文件，系统运行时，会将每个模块的<code>css</code>文件内容合并到一起，所以如果有两个名称一样的<code>css</code>，则会发生覆盖的现象，所以建议起名字统一在最前面加上当前的插件名称，要注意的是，每次新增、修改或者删除<code>css</code>文件内容后，如若需要立即查看效果，必要以<code>admin</code>角色进入系统，然后<strong>清空缓存</strong>；</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a><a href="https://docs.moodle.org/dev/Javascript_Modules" target="_blank" rel="external">JavaScript</a></h3><p>目前系统中的<code>js</code>是基于<code>RequireJS</code>框架，遵循<code>AMD</code>开发规范，利用<code>Grunt</code>构建的。<code>amd</code>目录下有<code>src</code>目录和<code>build</code>目录，<code>src</code>下的<code>xxx.js</code>是供开发时编写调试使用，而<code>build</code>目录下的<code>min.js</code>则是网站实际运行时所使用的<code>js</code>文件，经过压缩可以大幅度提升运行速度。所以每次修改<code>js</code>完毕后，提交代码切勿忘记生成对应的<code>min.js</code>文件并提供，生成命令为 <code>grunt uglify</code>；</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="db"><a href="#db" class="headerlink" title="db"></a><a href="https://docs.moodle.org/dev/Data_definition_API" target="_blank" rel="external">db</a></h3><ol><li><p>access.php<br>主要负责记录权限的配置；</p></li><li><p>service.php<br>负责接收<code>ajax</code>提交，配置对应的后台<code>API</code>的类名、路径 和方法名等信息，并将对应的<code>ajax</code>方法存入数据库中；</p></li><li><p>install.xml<br>用于安装系统时表结构的对应生成；</p></li><li><p>install.php<br>用于安装系统时数据库的缺省数据的提供；</p></li><li><p>upgrade.php <a href="https://note.youdao.com/share/?token=18D5479D0AFA4286A46EACE741345DF5&amp;gid=29389535" target="_blank" rel="external">开发规范</a><br>用于系统表结构变化等版本升级事项的实现，由于生产环境中客户已有大量数据存在于数据库中，所以这时候不能采取重装系统的方式更改表结构或者更改数据库等操作，这时候就得借助<code>upgrade.php</code>平滑升级。</p></li></ol><h3 id="后台-API"><a href="#后台-API" class="headerlink" title="后台 API"></a>后台 API</h3><ol><li><p>externallib.php<br>负责编写<code>service.php</code>中<code>ajax</code>提交方法对应的后台方法，并调用<code>lib.php</code>中的<code>API</code>实现；</p></li><li><p>lib.php<br>负责方法的具体实现，代码与数据库的数据交互</p></li><li><p>lang/en/xxx.php 和 lang/zh_cn/xxx.php</p></li></ol><p><code>en</code>目录下的表示英文翻译语言文件，<code>zh_cn</code>目录下的表示中文翻译语言文件，具体调用方法为： </p><ul><li><code>php</code>中： <code>get_string(字符串名, 插件名)</code></li><li><code>mustache</code>中： &#123;&#123;<code>#str</code>&#125;&#125;<code>字符串名, 插件名</code>&#123;&#123;<code>/str</code>&#125;&#125;</li></ul><p>作者：Tony<br>2017年02月28日</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/moodle-logo-concept.png&quot; alt=&quot;moodle&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;code&gt;Local&lt;/code&gt;插件在&lt;code&gt;Moodle&lt;/code&gt;中相比于其他插件算是比较容易上手的一个插件，&lt;code&gt;Local&lt;/code&gt;插件中前后台分离，不用遨游在杂糅前后端的代码里。学会&lt;code&gt;Local&lt;/code&gt;插件是上手其他插件的前提，其实一旦学会&lt;code&gt;Local&lt;/code&gt;插件也会发现其他插件不过是它的一种变种形式罢了，只要举一反三就能很快掌握。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Moodle" scheme="https://tony-yin.github.io/tags/Moodle/"/>
    
      <category term="PHP" scheme="https://tony-yin.github.io/tags/PHP/"/>
    
  </entry>
  
</feed>
