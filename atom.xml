<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tony&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tony-yin.github.io/"/>
  <updated>2018-11-03T18:46:09.253Z</updated>
  <id>https://tony-yin.github.io/</id>
  
  <author>
    <name>Tony</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>批量创建和删除磁盘分区脚本</title>
    <link href="https://tony-yin.github.io/2019/10/02/Batch-Create-And-Delete-Disk-Partition-Script/"/>
    <id>https://tony-yin.github.io/2019/10/02/Batch-Create-And-Delete-Disk-Partition-Script/</id>
    <published>2019-10-02T05:07:06.000Z</published>
    <updated>2018-11-03T18:46:09.253Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/floppy_disk_600-450.png" alt="Disk Partition"></center><p>最近在做批量启用<code>OSD</code>的性能优化，需要反复的删除磁盘分区，以保证彻底的删除数据，然后就要批量创建分区，保证足够量的分区数量创建足够多的<code>OSD</code>，由于数量较多，每次手动搞都要二十几次，所以针对创建和删除写了两个脚本，支持单一、批量和选择大小等功能</p><a id="more"></a><h2 id="清空分区"><a href="#清空分区" class="headerlink" title="清空分区"></a>清空分区</h2><h3 id="脚本名称"><a href="#脚本名称" class="headerlink" title="脚本名称"></a>脚本名称</h3><p><code>clean_disks.py</code></p><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ul><li><code>python clean_disks.py [disk_name1, disk_name2 ...]</code> </li><li>支持单磁盘和多磁盘清空</li><li>支持脚本参数，如果没有参数，默认清空所有磁盘分区，加磁盘参数则可清空指定磁盘分区, 多磁盘则累加多位磁盘参数</li><li>为了保证安全，脚本不会清空系统磁盘，脚本会做过滤工作</li></ul><h3 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h3><ul><li>清空所有磁盘分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python clean_disks.py</span><br></pre></td></tr></table></figure><ul><li>清空<code>sdb</code>的分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python clean_disks.py sdb</span><br></pre></td></tr></table></figure><ul><li>清空<code>sdb</code>和<code>sdc</code>的分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python clean_disks.py sdb sdc</span><br></pre></td></tr></table></figure><h3 id="脚本代码"><a href="#脚本代码" class="headerlink" title="脚本代码"></a>脚本代码</h3><blockquote><p><code>do_exec</code>是我自己写一个模块，可以调用<code>shell</code>命令，所以用的时候需要转换一下</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import do_exec</span><br><span class="line"></span><br><span class="line">def clean_disk(disk_name):</span><br><span class="line">    print &apos;disk: &#123;&#125; clean start ...&apos;.format(disk_name)</span><br><span class="line">    do_exec(&apos;sgdisk -Zog /dev/&#123;&#125;&apos;.format(disk_name))</span><br><span class="line">    print &apos;disk: &#123;&#125; clean done ...&apos;.format(disk_name)</span><br><span class="line"></span><br><span class="line">mount_info = do_exec(&apos;mount&apos;)</span><br><span class="line">sys_disk_name = mount_info[5:8]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">    disks = sys.argv[1:]</span><br><span class="line">    for disk_name in disks:</span><br><span class="line">        if disk_name == sys_disk_name:</span><br><span class="line">            print &apos;&#123;&#125; is system disk, can\&apos;t be clean!&apos;.format(disk_name)</span><br><span class="line">        else:</span><br><span class="line">            clean_disk(disk_name)</span><br><span class="line">else:</span><br><span class="line">    all_disks = do_exec(&apos;lsblk&apos;).splitlines()</span><br><span class="line">    for disk in all_disks:</span><br><span class="line">        if (disk.startswith(&apos;sd&apos;)):</span><br><span class="line">            disk_name = disk.split()[0]</span><br><span class="line">            if disk_name != sys_disk_name:</span><br><span class="line">                clean_disk(disk_name)</span><br></pre></td></tr></table></figure><h2 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h2><h3 id="脚本名称-1"><a href="#脚本名称-1" class="headerlink" title="脚本名称"></a>脚本名称</h3><p><code>create_partitions.py</code></p><h3 id="使用说明-1"><a href="#使用说明-1" class="headerlink" title="使用说明"></a>使用说明</h3><ul><li><code>python create_partitions.py size num [disk_name1, disk_name2 ...]</code>, <code>size</code>为分区大小，<code>num</code>为分区数</li><li>支持单磁盘和多磁盘创建分区</li><li>支持脚本参数，如果没有参数，默认为所有磁盘创建分区，加磁盘参数则可清空指定磁盘分区, 多磁盘则累加多位磁盘参数</li><li>为了保证安全，脚本不会为系统磁盘创建磁盘分区，脚本会做过滤工作</li></ul><h3 id="使用范例-1"><a href="#使用范例-1" class="headerlink" title="使用范例"></a>使用范例</h3><ul><li>为<code>sdb</code>和<code>sdc</code>分别都创建两个大小为<code>100G</code>的分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python create_partitions.py 100G 2 sdb sdc</span><br></pre></td></tr></table></figure><ul><li>为所有磁盘创建三个大小为<code>10G</code>的分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python create_partitions.py 10G 3</span><br></pre></td></tr></table></figure><ul><li>为<code>sdc</code>创建四个大小为<code>1T</code>的分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python create_partitions.py 1024G 4 sdc</span><br></pre></td></tr></table></figure><h3 id="脚本代码-1"><a href="#脚本代码-1" class="headerlink" title="脚本代码"></a>脚本代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import do_exec</span><br><span class="line"></span><br><span class="line">size = sys.argv[1]</span><br><span class="line">num = sys.argv[2]</span><br><span class="line">mount_info = do_exec(&apos;mount&apos;)</span><br><span class="line">sys_disk_name = mount_info[5:8]</span><br><span class="line"></span><br><span class="line">def parted_disks(num, size, disk):</span><br><span class="line">    for i in range(int(num)):</span><br><span class="line">        do_exec(&apos;sgdisk -n &#123;&#125;:0:+&#123;&#125; /dev/&#123;&#125;&apos;.format(i+1, size, disk))</span><br><span class="line">        print &apos;disk &#123;&#125; partition &#123;&#125; done ...&apos;.format(disk, i+1)</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 3:</span><br><span class="line">    disks = sys.argv[3:]</span><br><span class="line">    for disk in disks:</span><br><span class="line">        if disk == sys_disk_name:</span><br><span class="line">            print &apos;&#123;&#125; is system disk, can\&apos;t be parted!&apos;.format(disk)</span><br><span class="line">        else:</span><br><span class="line">            parted_disks(num, size, disk)</span><br><span class="line">else:</span><br><span class="line">    all_disks = do_exec(&apos;lsblk&apos;).splitlines()</span><br><span class="line">    for disk in all_disks:</span><br><span class="line">        if (disk.startswith(&apos;sd&apos;)):</span><br><span class="line">            disk_name = disk.split()[0]</span><br><span class="line">            if disk_name != sys_disk_name:</span><br><span class="line">                parted_disks(num, size, disk)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/floppy_disk_600-450.png&quot; alt=&quot;Disk Partition&quot;&gt;&lt;/center&gt;

&lt;p&gt;最近在做批量启用&lt;code&gt;OSD&lt;/code&gt;的性能优化，需要反复的删除磁盘分区，以保证彻底的删除数据，然后就要批量创建分区，保证足够量的分区数量创建足够多的&lt;code&gt;OSD&lt;/code&gt;，由于数量较多，每次手动搞都要二十几次，所以针对创建和删除写了两个脚本，支持单一、批量和选择大小等功能&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Disk" scheme="https://tony-yin.github.io/tags/Disk/"/>
    
      <category term="Partition" scheme="https://tony-yin.github.io/tags/Partition/"/>
    
      <category term="Script" scheme="https://tony-yin.github.io/tags/Script/"/>
    
  </entry>
  
  <entry>
    <title>块设备持久化命名和多路径</title>
    <link href="https://tony-yin.github.io/2018/11/04/Block-device-persistent-name-and-multipath/"/>
    <id>https://tony-yin.github.io/2018/11/04/Block-device-persistent-name-and-multipath/</id>
    <published>2018-11-04T15:15:26.000Z</published>
    <updated>2018-11-04T11:16:00.755Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/fork-in-the-road.png" alt="persistent name"></center><p>众所周知，我们看到的磁盘通常是<code>/dev/sda</code>，<code>/dev/sdb</code>这样的名称，我们可以通过这些磁盘名称对磁盘进行各种操作，例如挂载，分区和格式化等等。但是，如果你的机器上有不止一个<code>SATA</code>，<code>SCSI</code>或<code>IDE</code>磁盘控制器，那么它们所对应的设备节点将会依随机次序添加。这样就可能导致每次引导时设备的名字如<code>/dev/sda</code>与<code>/dev/sdb</code>互换了，再比如硬盘拔插导致磁盘乱序等等，最终导致系统不可引导、<code>kernel panic</code>、或者设备不可见。持久化命名可以解决这些问题。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>持久化命名，顾名思义即一次性或者是短暂的命名，它是一种长久的并且稳定靠谱的命名方案。与之形成鲜明对比的就是<code>/dev/sda</code>这种非持久化命名，这两种命名方案各有各的用处，本文着重对持久化命名进行介绍。持久化命名方案有四种：<code>by-label</code>、<code>by-uuid</code>、<code>by-id</code>和<code>by-path</code>。对于那些使用<code>GUID</code>分区表（<code>GPT</code>）的磁盘，还有额外的两种方案：<code>by-partlabel</code>和<code>by-partuuid</code>。你也可以使用<code>Udev</code>静态设备名方案，这个我们就不作详细解释。下面我将对每种持久化命名方案进行详细的介绍和讲解，不难发现上面所提到的命名方式在<code>/dev</code>目录下都存在一个与之名字对应的文件夹：</p><h2 id="by-label"><a href="#by-label" class="headerlink" title="by-label"></a>by-label</h2><p><code>label</code>表示标签的意思，几乎每一个文件系统都有一个标签。所有有标签的分区都在<code>/dev/disk/by-label</code>目录中列出。这个目录随着分区标签的变动而被动态地创建和销毁。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /dev/disk/by-label</span><br><span class="line"> </span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 10 May 27 23:31 DATA -&gt; ../../sda3</span><br><span class="line">lrwxrwxrwx 1 root root 10 May 27 23:31 SYSTEM -&gt; ../../sda2</span><br></pre></td></tr></table></figure><p>标签必须是唯一的，标签是文件系统的一个属性，所以无法持久地表示单一磁盘阵列设备。</p><p><strong>注意：</strong><code>label</code>是通过从设备中的内容（即数据）获取，所以如果将该内容拷贝至另一个设备中，我们也可以通过<code>blkid</code>来获取磁盘的<code>label</code>。</p><h2 id="by-uuid"><a href="#by-uuid" class="headerlink" title="by-uuid"></a>by-uuid</h2><p><code>UUID</code>是给每个文件系统唯一标识的一种机制，这个标识是在分区格式化时通过文件系统工具生成，比如<code>mkfs</code>，这个唯一标识可以起到解决冲突的作用。所有<code>GNU/Linux</code>文件系统（包括<code>swap</code>和原始加密设备的<code>LUKS</code>头）都支持<code>UUID</code>。<code>FAT</code>和<code>NTFS</code>文件系统并不支持<code>UUID</code>，但是在<code>/dev/disk/by-uuid</code>目录下还是存在着一个更为简单的<code>UID</code>（唯一标识）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /dev/disk/by-uuid/</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 10 May 27 23:31 0a3407de-014b-458b-b5c1-848e92a327a3 -&gt; ../../sda2</span><br><span class="line">lrwxrwxrwx 1 root root 10 May 27 23:31 b411dc99-f0a0-4c87-9e05-184977be8539 -&gt; ../../sda3</span><br><span class="line">lrwxrwxrwx 1 root root 10 May 27 23:31 CBB6-24F2 -&gt; ../../sda1</span><br><span class="line">lrwxrwxrwx 1 root root 10 May 27 23:31 f9fe0b69-a280-415d-a03a-a32752370dee -&gt; ../../sda4</span><br></pre></td></tr></table></figure><p>使用<code>UUID</code>方法的优点是，名称冲突发生的可能性大大低于使用<code>Label</code>的方式。更深层次地讲，它是在创建文件系统时自动生成的。例如，即使设备插入到另一个系统(可能有一个标签相同的设备)，它仍然是唯一的。</p><p>缺点是<code>uuid</code>使得许多配置文件(例如<code>fstab</code>或<code>crypttab</code>)中的长代码行难以读取和破坏格式。此外，每当一个分区被调整大小或重新格式化时，都会生成一个新的UUID，并且必须(手动)调整配置。</p><h2 id="by-path"><a href="#by-path" class="headerlink" title="by-path"></a>by-path</h2><p>该目录中的条目提供一个符号名称，该符号名称通过用于访问设备的<strong>硬件路径</strong>引用存储设备，首先引用<code>PCI hierachy</code>中的存储控制器，并包括<code>SCSI host</code>、<code>channel</code>、<code>target</code>和<code>LUN</code>号，以及可选的分区号。虽然这些名字比使用<code>major</code>和<code>minor</code>号或<code>sd</code>名字更容易，但必须使用谨慎以确保<code>target</code>号不改变在光纤通道<code>SAN</code>环境中(例如，通过使用持久绑定)，如果一个主机适配器切换到到一个不同的<code>PCI</code>插槽的话这个路径也会随之改变。此外，如果<code>HBA</code>无法探测，或者如果驱动程序以不同的顺序加载，或者系统上安装了新的<code>HBA</code>，那么<code>SCSI</code>主机号都有可能会发生变化。附带路径清单的一个例子是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/disk/by-path/pci-0000:03:00.0-scsi-0:1:0:0</span><br></pre></td></tr></table></figure><p>也许还会带着分区号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/disk/by-path/pci-0000:03:00.0-scsi-0:1:0:0-part1</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 上面说了很多种情况都会导致<code>by-path</code>的值可能发生变化，但是在同一时间来说，<code>by-path</code>的值是和物理设备是唯一对应的，也就是说不管怎么说<code>by-path</code>是对应物理机器上面的某个位置的，根据<code>by-path</code>可以获取对应物理位置的设备。（此前<code>megaraid</code>通过逻辑磁盘获取物理磁盘位置就是根据这个原理）</p><p>对于<code>iSCSI</code>设备，路径/名称映射从目标名称和门户信息映射到<code>sd</code>名称。<br>应用程序通常不适合使用这些基于路径的名称。这是因为这些路径引用可能会更改存储设备，从而可能导致将不正确的数据写入设备。基于路径的名称也不适用于多路径设备，因为基于路径的名称可能被误认为是单独的存储设备，导致不协调的访问和数据的意外修改。</p><p>此外，基于路径的名称是特定于系统的。当设备被多个系统访问时，例如在集群中，这会导致意外的数据更改。</p><h2 id="by-id"><a href="#by-id" class="headerlink" title="by-id"></a>by-id</h2><p>此目录中的条目提供一个符号名称，该符号名称通过唯一标识符(与所有其他存储设备不同)引用存储设备。标识符是设备的属性，但不存储在设备的内容(即数据)中。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dev/disk/by-id/scsi-3600508e000000000ce506dc50ab0ad05</span><br><span class="line">/dev/disk/by-id/wwn-0x600508e000000000ce506dc50ab0ad05</span><br></pre></td></tr></table></figure><p>该<code>id</code>从设备的全局<code>ID</code>（<code>WWID</code>）或设备序列号中获取。<code>/dev/disk/by-id</code>条目也可能包含一个分区号。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dev/disk/by-id/scsi-3600508e000000000ce506dc50ab0ad05-part1</span><br><span class="line">/dev/disk/by-id/wwn-0x600508e000000000ce506dc50ab0ad05-part1</span><br></pre></td></tr></table></figure><p><code>World Wide Identifier</code>（<code>WWID</code>）可用于可靠的识别设备。<code>SCSI</code>标准要求所有<code>SCSI</code>设备提供一个持久的、系统无关的<code>ID</code>。<code>WWID</code>标识符保证对每个存储设备都是唯一的，并且独立于用于访问设备的路径。</p><p>这个标识符可以通过发出<code>SCSI</code>查询来获取设备标识重要厂商数据(第<code>0x83</code>页)或单位序列号(第<code>0x80</code>页)。从这些<code>wwid</code>到当前<code>/dev/sd</code>名称的映射可以在<code>/dev/disk/by-id/</code>目录中维护的符号链接中看到。<br>例如，具有页<code>0x83</code>标识符的设备将具有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scsi-3600508b400105e210000900000490000 -&gt; ../../sda</span><br></pre></td></tr></table></figure><p>或者，具有页<code>0x80</code>标识符的设备将具有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scsi-SSEAGATE_ST373453LW_3HW1RHM6 -&gt; ../../sda</span><br></pre></td></tr></table></figure><p><code>Red Hat Enterprise Linux 5</code>自动维护从基于<code>wwid</code>的设备名称到系统上当前<code>/dev/sd</code>名称的正确映射。应用程序可以使用<code>/dev/ disk/by-id/</code>的链接引用磁盘上的数据，即使设备的路径改变，甚至当从不同系统访问该设备时都是如此。</p><p>但是当设备被插入到硬件控制器的端口时，而这个端口又受另一个子系统控制（即多路径），<code>by-id</code>的值也会改变。多路径设备会在下面详细讲解。</p><h2 id="by-partlabel-amp-amp-by-partuuid"><a href="#by-partlabel-amp-amp-by-partuuid" class="headerlink" title="by-partlabel &amp;&amp; by-partuuid"></a>by-partlabel &amp;&amp; by-partuuid</h2><p>这两个和上面提到的<code>by-label</code>和<code>by-uuid</code>类似，只不过是在<code>GPT</code>磁盘上。</p><h2 id="多路径设备"><a href="#多路径设备" class="headerlink" title="多路径设备"></a>多路径设备</h2><p>所谓多路径设备指的是从一个系统到一个设备存在多个路径，这种现象主要出现在光纤网络的<code>SAN</code>下，主要是做数据链路冗余以达到高可用的效果，<strong>即对应底层一个物理设备，可能存在多个路径表示它</strong>，具体参考<code>refer</code>下面有关文章。</p><p>如果从一个系统到一个设备有多个路径，那么<code>device-mapper-multipath</code>使用<code>WWID</code>来检测它。然后在<code>/dev/mapper/wwid</code>中显示一个“伪设备”，例如<code>/dev/ mapper/3600508b400105df70000000ac0000</code>。</p><p><code>Device-mapper-multipath</code>显示映射到非持久标识符：<code>Host:Channel:Target:LUN</code>， <code>/dev/sd</code>名称，以及<code>major:minor</code>号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3600508b400105df70000e00000ac0000 dm-2 vendor,product </span><br><span class="line">[size=20G][features=1 queue_if_no_path][hwhandler=0][rw] </span><br><span class="line">\_ round-robin 0 [prio=0][active] </span><br><span class="line"> \_ 5:0:1:1 sdc 8:32  [active][undef] </span><br><span class="line"> \_ 6:0:1:1 sdg 8:96  [active][undef]</span><br><span class="line">\_ round-robin 0 [prio=0][enabled] </span><br><span class="line"> \_ 5:0:0:1 sdb 8:16  [active][undef] </span><br><span class="line"> \_ 6:0:0:1 sdf 8:80  [active][undef]</span><br></pre></td></tr></table></figure><p><code>Device-mapper-multipath</code>在系统上自动维护每个基于<code>wwid</code>的设备名称和其对应的<code>/dev/sd</code>名称的正确映射。这些名称即使是在路径发生改变时也是持久的，并且当从不同的系统访问设备时它们仍然是一致的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了方便管理和使用设备，<code>linux</code>操作系统给我们提供了上面这么多持久化命名方式。它们各自有各自的优势和使用场景。<code>by-label</code>和<code>by-uuid</code>都和文件系统相关，<code>by-label</code>是通过读取设备中的内容获取，<code>by-uuid</code>则是随着每次文件系统的创建而创建，所以<code>by-uuid</code>的持久化程度更高一些；持久化程度最高的要属<code>by-path</code>和<code>by-id</code>了，因为它们都是根据物理设备的位置或者信息而和链接做对应的，<code>by-path</code>会因为路径的变化而变化；而<code>by-id</code>则不会因为路径或者系统的改变而改变，它只会在多路径的情况下发生改变。这两个在通过虚拟设备名称寻找物理设备的场景下都十分有用。</p><p>多路径设备则帮助我们在<code>SAN</code>等场景下提高了数据传输的可用性，目前由于网络带宽的发展，它在<code>iscsi</code>场景下也频繁亮相。</p><h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ul><li><a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_%28简体中文%29" target="_blank" rel="noopener">Persistent block device naming</a></li><li><a href="http://fibrevillage.com/storage/578-understanding-device-names-managed-by-the-udev-mechanism" target="_blank" rel="noopener">Understanding Device Names Managed by the udev mechanism</a></li><li><a href="https://wiki.archlinux.org/index.php/Udev_%28简体中文%29#.E8.AE.BE.E7.BD.AE.E9.9D.99.E6.80.81.E8.AE.BE.E5.A4.87.E5.90.8D" target="_blank" rel="noopener">Udev</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/online_storage_reconfiguration_guide/persistent_naming" target="_blank" rel="noopener">PERSISTENT NAMING</a></li><li><a href="https://www.linuxquestions.org/questions/linux-server-73/how-to-find-wwn-for-dev-sdc-917269/" target="_blank" rel="noopener">How to find WWN for /dev/sdc</a></li><li><a href="https://unix.stackexchange.com/questions/86764/understanding-dev-disk-by-folders" target="_blank" rel="noopener">understanding /dev/disk/by- folders</a></li><li><a href="https://blog.csdn.net/jiaping0424/article/details/51591257" target="_blank" rel="noopener">multipath 路径切换</a></li><li><a href="http://www.cnblogs.com/jyzhao/p/7200585.html" target="_blank" rel="noopener">multipath多路径实验01-构建iSCSI模拟环境</a></li><li><a href="http://www.cnblogs.com/jyzhao/p/7208620.html" target="_blank" rel="noopener">multipath多路径实验02-配置多路径软件</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-devmapper/index.html" target="_blank" rel="noopener">Linux 内核中的 Device Mapper 机制</a></li><li><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/6/html/dm_multipath/mpio_description" target="_blank" rel="noopener">DM-MULTIPATH 概述</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/fork-in-the-road.png&quot; alt=&quot;persistent name&quot;&gt;&lt;/center&gt;

&lt;p&gt;众所周知，我们看到的磁盘通常是&lt;code&gt;/dev/sda&lt;/code&gt;，&lt;code&gt;/dev/sdb&lt;/code&gt;这样的名称，我们可以通过这些磁盘名称对磁盘进行各种操作，例如挂载，分区和格式化等等。但是，如果你的机器上有不止一个&lt;code&gt;SATA&lt;/code&gt;，&lt;code&gt;SCSI&lt;/code&gt;或&lt;code&gt;IDE&lt;/code&gt;磁盘控制器，那么它们所对应的设备节点将会依随机次序添加。这样就可能导致每次引导时设备的名字如&lt;code&gt;/dev/sda&lt;/code&gt;与&lt;code&gt;/dev/sdb&lt;/code&gt;互换了，再比如硬盘拔插导致磁盘乱序等等，最终导致系统不可引导、&lt;code&gt;kernel panic&lt;/code&gt;、或者设备不可见。持久化命名可以解决这些问题。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Disk" scheme="https://tony-yin.github.io/tags/Disk/"/>
    
  </entry>
  
  <entry>
    <title>Daily Article Vol7(2018/6/1 ~ 2018/6/30)</title>
    <link href="https://tony-yin.github.io/2018/07/01/Daily-Article-Vol7/"/>
    <id>https://tony-yin.github.io/2018/07/01/Daily-Article-Vol7/</id>
    <published>2018-07-01T05:07:06.000Z</published>
    <updated>2018-11-03T17:07:41.150Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/6.png" alt="6"></center><p>这是<code>Daily Article</code>系列文章的第七篇，主要记录了<code>2018/6/1 ~ 2018/6/30</code>之间的阅读记录。</p><a id="more"></a><p>六月份主要做了几件事，一个是基于<code>python</code>实现一个守护进程，从<code>unix</code>实现守护进程的底层原理撸了一遍，加深了对<code>linux</code>底层进程一些概念的了解，正好也接触了“骑着企鹅采树莓”系列文章，讲的很不错，通俗易懂；然后把之前基于<code>pci path</code>寻找逻辑磁盘的物理位置整理了下，研究了一波块设备持久化命名；然后学习了下<code>kvm</code>虚拟化技术，并在此之上研究了下虚拟机迁移技术，这其中包括虚拟机到虚拟机的迁移，<code>kvm</code>虚拟机到<code>vmware</code>虚拟机的迁移，虚拟机到物理机的迁移，物理机到物理机的迁移等等；最后研究了下多路径设备，概念有点混乱，不断地啃资料终于有点明白了。不得不说，这些底层的知识真是又多又复杂，只能慢慢啃，加油咯。</p><ol><li><a href="https://unix.stackexchange.com/questions/86764/understanding-dev-disk-by-folders" target="_blank" rel="noopener">understanding /dev/disk/by- folders</a>(6/1) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/online_storage_reconfiguration_guide/persistent_naming" target="_blank" rel="noopener">PERSISTENT NAMING</a>(6/2) <i class="fa fa-star"></i></li><li><a href="http://fibrevillage.com/storage/578-understanding-device-names-managed-by-the-udev-mechanism" target="_blank" rel="noopener">Understanding Device Names Managed by the udev mechanism</a>(6/3) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">Persistent block device naming</a>(6/4) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://wiki.archlinux.org/index.php/Udev_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E8.AE.BE.E7.BD.AE.E9.9D.99.E6.80.81.E8.AE.BE.E5.A4.87.E5.90.8D" target="_blank" rel="noopener">udev (简体中文)</a>(6/9) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://www.linuxquestions.org/questions/linux-server-73/how-to-find-wwn-for-dev-sdc-917269/" target="_blank" rel="noopener">How to find WWN for /dev/sdc</a>(6/9)</li><li><a href="http://www.cnblogs.com/songyaqi/p/4553069.html9.html/l-anaconda/index.html" target="_blank" rel="noopener">SSO单点登录的实现原理是怎样的</a>(6/10)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/sdk/python/python-6/index.html" target="_blank" rel="noopener">可爱的 Python：Curses 编程</a>(6/10)</li><li><a href="http://blog.51cto.com/830909/1751106" target="_blank" rel="noopener">Django cookie和session</a>(6/10)</li><li><a href="https://www.jianshu.com/p/40ec55c6e614?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">这也许是你看到过的最通俗易懂的ElasticSearch文章了（理论篇）</a>(6/10) <i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="https://elasticsearch.cn/slides/109#page=21" target="_blank" rel="noopener">饿了么在ELasticsearch自动化运维平台和监控平台的应用实践</a>(6/10)</li><li><a href="https://humansky.com/2011/12/accidentally-adding-a-git-submodule/" target="_blank" rel="noopener">ACCIDENTALLY ADDING A GIT SUBMODULE</a>(6/11)</li><li><a href="https://www.jianshu.com/p/4e412f48e820?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">聊聊MySQL、HBase、ES的特点和区别</a>(6/12) <i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="http://www.cnblogs.com/qiaoyihang/p/6262806.html" target="_blank" rel="noopener">行存储和列存储</a>(6/13)</li><li><a href="https://time.geekbang.org/column/article/1610" target="_blank" rel="noopener">【极客时间：左耳听风】洞悉PaaS平台的本质</a>(6/13) <i class="fa fa-star"></i></li><li><a href="https://coolshell.cn/articles/17459.html" target="_blank" rel="noopener">【CoolShell】关于高可用的系统</a>(6/13) <i class="fa fa-star"></i></li><li><a href="https://time.geekbang.org/column/article/301" target="_blank" rel="noopener">【极客时间：左耳听风】编程范式游记（1）- 起源</a>(6/14)<i class="fa fa-star"></i></li><li><a href="https://blog.csdn.net/asware/article/details/4159366" target="_blank" rel="noopener">python fork</a>(6/15)</li><li><a href="https://blog.csdn.net/taiyang1987912/article/details/44850999" target="_blank" rel="noopener">Python实例浅谈之五Python守护进程和脚本单例运行</a>(6/16) <i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="https://www.jianshu.com/p/e3f3d49093ca" target="_blank" rel="noopener">Python实现守护进程</a>(6/18) <i class="fa fa-star"></i></li><li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p14_launching_daemon_process_on_unix.html#id1" target="_blank" rel="noopener">在Unix系统上面启动守护进程</a>(6/19) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://yq.aliyun.com/articles/41477?spm=5176.100240.searchblog.39.HyGU9I" target="_blank" rel="noopener">《APUE》读书笔记—第十三章守护进程</a>(6/19) <i class="fa fa-star"></i><i class="fa fa-star"></i> </li><li><a href="http://www.cnblogs.com/vamei/archive/2012/09/20/2694466.html" target="_blank" rel="noopener">【骑着企鹅采树莓】Linux进程基础</a>(6/20) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="http://www.cnblogs.com/vamei/archive/2012/10/07/2713023.html" target="_blank" rel="noopener">【骑着企鹅采树莓】Linux进程关系</a>(6/20) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://www.cnblogs.com/vamei/p/6415434.html" target="_blank" rel="noopener">【骑着企鹅采树莓】树莓派：一个关于教育的故事</a>(6/21)</li><li><a href="http://www.cnblogs.com/vamei/p/6424666.html" target="_blank" rel="noopener">【骑着企鹅采树莓】树莓派心脏：ARM的逆袭</a>(6/21)  <i class="fa fa-star"></i></li><li><a href="http://www.cnblogs.com/vamei/p/6718942.html" target="_blank" rel="noopener">【骑着企鹅采树莓】树莓派的大脑：Linux</a>(6/22)</li><li><a href="https://my.oschina.net/guol/blog/156607" target="_blank" rel="noopener">Linux策略路由</a>(6/22)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-linux-br1/index.html" target="_blank" rel="noopener">【迁移Linux系统1】如何迁移备份和裸机恢复Linux系统</a>(6/24)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-linux-br2/index.html" target="_blank" rel="noopener">【迁移Linux系统2】利用 KIWI Imaging System 定制裸机恢复光盘）</a>(6/26)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-mgrtvm1/index.html" target="_blank" rel="noopener">【虚拟机迁移技术漫谈1】如何在虚拟机和物理机以及虚拟机和虚拟机之间的迁移系统</a>(6/24)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-mgrtvm2/index.html" target="_blank" rel="noopener">【虚拟机迁移技术漫谈2】KVM虚拟机在物理主机之间迁移的实现</a>(6/24) <i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-mgrtvm3/index.html" target="_blank" rel="noopener">【虚拟机迁移技术漫谈3】迁移 VMware 虚拟机到 KVM</a>(6/25) <i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-kvm/" target="_blank" rel="noopener">【虚拟机迁移技术漫谈4】KVM 虚拟机在 IBM System x 上应用</a>(6/25) <i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="https://www.ibm.com/developerworks/cn/aix/library/0808_shenlf_ivm/" target="_blank" rel="noopener">【虚拟机迁移技术漫谈5】在IBM集成虚拟化管理器上进行动态分区迁移</a>(6/26)</li><li><a href="http://www.cnblogs.com/biangbiang/p/3222458.html" target="_blank" rel="noopener">利用Qemu Guest Agent (Qemu-ga) 实现 Openstack 监控平台</a>(6/26)</li><li><a href="http://www.zoues.com/2015/10/13/qemu-guest-agent/" target="_blank" rel="noopener">利用qemu-guest-agent冻结文件系统</a>(6/26)</li><li><a href="http://blog.51cto.com/aishangwei/2124944" target="_blank" rel="noopener">kvm 快照</a>(6/26)</li><li><a href="https://access.redhat.com/solutions/732773" target="_blank" rel="noopener">How to enable QEMU guest agent in KVM</a>(6/26)</li><li><a href="http://www.ruanyifeng.com/blog/2018/06/ddos.html" target="_blank" rel="noopener">DDOS 攻击的防范教程</a>(6/27)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-libvirt/index.html" target="_blank" rel="noopener">Libvirt 虚拟化库剖析</a>(6/27) <i class="fa fa-star"></i></li><li><a href="https://www.ibm.com/developerworks/cn/aix/redbooks/live-mobility/" target="_blank" rel="noopener">IBM 动态分区迁移(Live Partition Mobility)技术-概述</a>(6/27)</li><li><a href="http://www.cnblogs.com/vamei/archive/2012/10/04/2711818.html" target="_blank" rel="noopener">【骑着企鹅采树莓】Linux信号基础</a>(6/27) <i class="fa fa-star"></i></li><li><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/6/html/dm_multipath/mpio_description" target="_blank" rel="noopener">DM-MULTIPATH 概述</a>(6/28)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-devmapper/index.html" target="_blank" rel="noopener">Linux 内核中的 Device Mapper 机制</a>(6/28) <i class="fa fa-star"></i></li><li><a href="https://wsgzao.github.io/post/multipath/" target="_blank" rel="noopener">Multipath 多路径配置实践心得</a>(6/28)</li><li><a href="http://www.cnblogs.com/jyzhao/p/7200585.html" target="_blank" rel="noopener">multipath多路径实验01-构建iSCSI模拟环境</a>(6/30) <i class="fa fa-star"></i></li><li><a href="http://www.cnblogs.com/jyzhao/p/7208620.html" target="_blank" rel="noopener">multipath多路径实验02-配置多路径软件</a>(6/30)</li><li><a href="https://blog.csdn.net/jiaping0424/article/details/51591257" target="_blank" rel="noopener">multipath 路径切换</a>(6/30) <i class="fa fa-star"></i></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/6.png&quot; alt=&quot;6&quot;&gt;&lt;/center&gt;

&lt;p&gt;这是&lt;code&gt;Daily Article&lt;/code&gt;系列文章的第七篇，主要记录了&lt;code&gt;2018/6/1 ~ 2018/6/30&lt;/code&gt;之间的阅读记录。&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
      <category term="Daily-Article" scheme="https://tony-yin.github.io/tags/Daily-Article/"/>
    
  </entry>
  
  <entry>
    <title>Python Snack 最佳实践</title>
    <link href="https://tony-yin.github.io/2018/06/03/Python-Snack-Best-Practice/"/>
    <id>https://tony-yin.github.io/2018/06/03/Python-Snack-Best-Practice/</id>
    <published>2018-06-03T05:07:06.000Z</published>
    <updated>2018-11-03T17:07:41.150Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/python_snack.jpg" alt="python snack"></center><p>  了解<code>linux</code>的人应该听说过<code>Newt</code>，<code>Newt</code>是一个为<code>RedHat</code>安装程序而设计的基于文本的窗口开发工具，它是由<code>c</code>语言编写并不依赖<code>X</code>包，<code>linux</code>下的<code>dialog</code>和<code>whiptail</code>都是基于它。而我们今天讨论的<code>snack</code>则是<code>Newt</code>提供的<code>python</code>接口，<code>redhat</code>的系统都自带这个模块，本文就如何使用<code>snack</code>制作伪终端页面展开讲解，并配合代码展示实现效果。</p><a id="more"></a><h2 id="用餐介绍"><a href="#用餐介绍" class="headerlink" title="用餐介绍"></a>用餐介绍</h2><p>为啥说是最佳实践呢？因为我使用<code>snack</code>的过程中，上网查阅相关资料，发现有关信息甚少。偶尔几篇文章都是处于<code>API</code>或者<code>Demo</code>的级别，并且讲的都不全，更别说高级扩展功能了。我正好工作需要给我们的一个系统做一个终端部署控制台<code>UI</code>，所以我就使用了<code>python snack</code>来实现，期间不断新需求，不断迭代，从基本页面到增删改查，再到校验、再到配置导入、再到进度条等等，不断的迭代开发让我对<code>snack</code>不断地加深认知，它支持的或不支持的我都想办法一一解决，所以在这把我这段时间的收货进行总结并分享给需要的人。</p><h2 id="上菜单"><a href="#上菜单" class="headerlink" title="上菜单"></a>上菜单</h2><p>本文实践的需求是做一个部署控制台工具，该工具主要分为三个阶段：基础配置、高级配置和部署进度。基础配置页面需要我们创建一些主机，填写一些主机的信息，比如<code>IP</code>、<code>Hostname</code>和<code>Password</code>，然后高级配置我们也需要创建一些主机，不过我们可以复用基础设置的主机，所以我们的工具要支持在高级配置中导入基础配置的功能，在高级配置中我们还有一个全局配置，也就是不限于单个主机的配置（其中具体部署原理和是非，我就不多展开赘述，这不是本文的重点）。最后就是进度条页面，我们可以展示部署的过程阶段和相关时间信息。</p><center><img src="http://ow0mgad6r.bkt.clouddn.com/deploy_console.gif" alt="deploy console"></center><blockquote><p>项目地址：<a href="https://github.com/tony-yin/Best-practice-of-python-snack" target="_blank" rel="noopener">https://github.com/tony-yin/Best-practice-of-python-snack</a></p></blockquote><h2 id="开胃凉菜"><a href="#开胃凉菜" class="headerlink" title="开胃凉菜"></a>开胃凉菜</h2><h3 id="远古时代"><a href="#远古时代" class="headerlink" title="远古时代"></a>远古时代</h3><p>先上几道凉菜，给大家开开胃。所谓的凉菜就是介绍一下<code>python snack</code>的基础组件，基础组件很多，类似<code>html</code>，主要有：</p><ul><li>Textbox</li><li>TextboxReflowed</li><li>Button</li><li>Compactbutton</li><li>Checkbox</li><li>Listbox</li><li>SingleRadioButton</li><li>Scale</li><li>Entry</li></ul><p>然后就是一些组合组件，也就是基于上述基础组件封装而得到，主要有：</p><ul><li>RadioBar</li><li>ButtonBar</li><li>CheckboxTree</li></ul><p>上面这些组件就是所有的基础组件（组合组件也算基础组件），这些组件最终呈现还需要<code>grid</code>和<code>form</code>这两个组件，<code>grid</code>表示“网格”的意思，跟<code>html</code>中的<code>table</code>类似，由行和列组成，我们的基础组件需要放在网格中来实现页面布局；而<code>form</code>也类似“表单”，我们需要把<code>grid</code>填充到<code>form</code>中，运行后，就可以看到图形化页面了。</p><h3 id="工业革命"><a href="#工业革命" class="headerlink" title="工业革命"></a>工业革命</h3><p>经过上面基础组件的介绍，想必你对<code>snack</code>的组件有了充分的了解，这时候你可以参考文末的<code>refer</code>做几个小<code>demo</code>，做了之后你会发现页面是出来了，emmm… 可是感觉好繁琐哦，很多重复性的代码，而且页面布局也怪怪的，如果要把布局搞好，又需要加很多代码。</p><p>我们把用基础组件的阶段称之为“远古时代”，每做一个<code>window</code>，都得一瓦一砖地慢慢堆砌，这样效率太低了，所以我们急需一波“工业革命”来提高生产力。</p><p><code>python snack</code>似乎考虑到了这个问题，它在上述基础组件之外还提供了<code>dialog</code>相关组件，<code>dialog</code>组件即集大成者，一个<code>dialog</code>组件就是一个<code>window</code>，也就是我们上面所说的<code>form</code>，并且该<code>form</code>中填充了必需的各种基础组件，<code>dialog</code>组件主要有：</p><ul><li>ListboxChoiceWindow</li><li>ButtonChoiceWindow</li><li>EntryWindow</li></ul><h3 id="返璞归真"><a href="#返璞归真" class="headerlink" title="返璞归真"></a>返璞归真</h3><p>当今社会，大家吃惯了大鱼大肉，反而更是想念农村的野味。同理，我们用惯了“工业革命”的产物，发现虽然可用，但是仅仅停留在基础可用级别上，想换换样式，加加自己的定制化需求，都是有限的，完全达不到新需求的技术实现要求。所以，我们不能只知道用别人实现的现成的产物，我们可以尝试着“返璞归真”一下，回归最初的“远古时代”，自己实现一把“工业革命”。所谓的“dialog”组件无非也就是基础组件的封装而已，我们也可以自己实现一套自己的组件库，这个在前端是非常流行的，例如<code>font-awesome</code>、<code>iview</code>、<code>ant-design</code>等等。这里我们自己实现了以下<code>dialog</code>：</p><ul><li>ExtButtonChoiceWindow</li><li>ExtAlert</li><li>ExtCheckboxWindow</li><li>ExtListboxChoiceWindow</li><li>ExtEntryWindow</li><li>ExtPwdEntryWindow</li><li>ExtProgressWindow</li><li>ExtTextWindow</li></ul><p>扩展的功能主要有：</p><ul><li>热键支持扩展</li><li>按钮样式扩展</li><li>布局大小自动化扩展</li><li>暗文输入框扩展</li><li>弹出窗口扩展</li><li>进度条窗口信息展示扩展</li><li>动态展示扩展</li></ul><blockquote><p>扩展组件库地址：<a href="https://github.com/tony-yin/Best-practice-of-python-snack/blob/master/widget_extlib.py" target="_blank" rel="noopener">widget extend library</a></p></blockquote><h2 id="管饱正菜"><a href="#管饱正菜" class="headerlink" title="管饱正菜"></a>管饱正菜</h2><p>凉菜不够，正菜来凑。上面就是把<code>python snack</code>的<code>API</code>罗列了一下，做个小<code>Demo</code>还行，但是距离产品化还很远，接下来我结合我做部署控制台工具的实践经历分享一下几个“正菜”，必须够硬，不接受反驳，不接受批评， O(∩_∩)O ~</p><h3 id="热键"><a href="#热键" class="headerlink" title="热键"></a>热键</h3><p><code>python snack</code>提供了两种帮助用户使用的途径，一种是窗口下方的操作提示栏，另一个就是热键了。热键就是快捷键，比如我们可以敲击键盘上面的<code>ESC</code>键实现页面的返回。我们可以通过调用<code>grid</code>的<code>runOnce</code>接口获取热键的输入，例如<code>hotkey = g.runOnce()</code>，然后我们根据<code>hotkey</code>的值进行判断并执行对应的操作。</p><h3 id="页面切换"><a href="#页面切换" class="headerlink" title="页面切换"></a>页面切换</h3><p>当我们存在多个页面的时候，我们需要页面切换的功能，翻阅文档，并没有发现提供类似的功能。在我们的工具中，页面切换主要有两种方式，一种是点击<code>button</code>，一种是热键，既然没有原生的页面切换接口，我们就根据触发方式手动切换页面。比如我们想实现页面<code>1</code>点击<code>next</code>按钮想跳转页面<code>2</code>，那我们只需要获取<code>button</code>的返回值，判断是否为<code>next</code>，如果是<code>next</code>，直接调用页面<code>2</code>的方法即可，热键同理，即判断热键内容是否为对应热键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ret, button, lb = ExtListboxChoiceWindow(</span><br><span class="line">    screen, </span><br><span class="line">    &apos;Distribute Storage Config&apos;,</span><br><span class="line">    &apos;Distribute Storage Config&apos;,</span><br><span class="line">    ips,</span><br><span class="line">    buttons=(&quot;prev&quot;, &quot;next&quot;, &quot;exit&quot;),</span><br><span class="line">    width=50,</span><br><span class="line">    height=5,</span><br><span class="line">)                                                                                                                                        </span><br><span class="line">if button == &quot;exit&quot; or ret == &quot;ESC&quot;:</span><br><span class="line">    screen.finish()</span><br><span class="line">elif button == &quot;prev&quot;:</span><br><span class="line">    Welcome_Deploy_Window()</span><br><span class="line">elif button == &quot;next&quot;:</span><br><span class="line">    Additional_Config_Window()</span><br><span class="line">elif lb is not None:</span><br><span class="line">    Basic_Host_Window(lb)</span><br></pre></td></tr></table></figure><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><p>增删改查永远是一个软件系统绕不开的基础功能。</p><p><strong>“查”：</strong></p><p>首先是整体查看，我们可以通过一个列表展示所有信息，这时候我们可以用<code>ExtListboxChoiceWindow</code>组件来实现；然后就是单个查看了，我们可能有多条信息，我们想查看单个信息的详细内容时，我们可以通过点击具体的<code>item</code>进入详细信息的<code>dialog</code>，如何实现呢？<code>listbox</code>中有一个<code>current</code>的概念，也就是<code>listbox</code>中每个<code>li</code>的唯一标识，我们可以用列表的<code>index</code>来填充，因为往往列表页面的信息也无非是数组或者是列表的方式，我们获取到当前的<code>current</code>，即获取到数组的索引，然后就是根据索引查值了，我们再调用新增页面，将查到的值赋值到<code>Textbox</code>即可，<code>Textbox</code>有一个<code>setText</code>就是做这个事情的。当然我们的<code>ExtEntryWindow</code>组件也可以做到赋值填充。请参考上述代码中的<code>lb</code>，其实就是<code>listbox</code>的<code>li.current()</code>接口。</p><p><strong>“增”：</strong></p><p>我们可以通过一个新增按钮或者<code>listbox</code>中的一个<code>li</code>作为新增按钮来触发新增操作，点击后出现一个<code>dialog</code>，<code>dialog</code>中有一些<code>Textbox</code>、<code>Radio</code>、<code>Checkbox</code>等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def Basic_Host_Window(current, data=None):</span><br><span class="line">    buttons = [ &apos;save&apos;, &apos;cancel&apos;, &apos;exit&apos;]</span><br><span class="line">    if not data:</span><br><span class="line">        data = [&apos;IP Address:&apos;, &apos;Hostname:&apos;, &apos;Password:&apos;]</span><br><span class="line">        if current != &apos;add&apos;:</span><br><span class="line">            data = get_format_data(Basic_Config[current], BASIC_TYPE)</span><br><span class="line">            buttons.insert(1, &apos;Delete&apos;)</span><br><span class="line"></span><br><span class="line">    host = ExtEntryWindow(</span><br><span class="line">        screen,</span><br><span class="line">        &apos;&#123;&#125; host&apos;.format(&apos;Add&apos; if current == &apos;add&apos; else &apos;Edit&apos;),</span><br><span class="line">        &apos;Please fill storage host info.&apos;,</span><br><span class="line">        data,</span><br><span class="line">        width = 40, </span><br><span class="line">        entryWidth = 40, </span><br><span class="line">        buttons = buttons</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p><strong>“改”：</strong></p><p>修改操作的方法是在<code>list</code>页面选中需要修改的项，然后进入详情页面，可以查看之前创建时填写的信息，也就是我们在“查”中查看单个信息提到的方式，我们所要做的就是在用户点击<code>save</code>按钮的时候，获取用户编辑后的数据，再进行一次修改即可，在我们工具中，此操作就是根据索引修改数组中对应索引的数据而已。</p><p><strong>“删”：</strong></p><p>有增就有删，这边我暂时还没实现批量删除的功能，一方面<code>python snack</code>的支持功能有限，一方面时间有限，所以我只实现了单个删除的功能，在新增和编辑的页面添加一个<code>delete</code>按钮即可，为了提醒用户错删，我们还要加上一个确认提示框。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if host[1] == &quot;delete&quot;:</span><br><span class="line">    button = ExtButtonChoiceWindow(</span><br><span class="line">        screen,</span><br><span class="line">        &apos;Delete host&apos;,</span><br><span class="line">        &apos;Are you sure to delete current host?&apos;</span><br><span class="line">    )</span><br><span class="line">    if button == &quot;ok&quot;:</span><br><span class="line">        del(Basic_Config[current])</span><br><span class="line">    else:</span><br><span class="line">        Basic_Host_Window(current)</span><br></pre></td></tr></table></figure><h3 id="组件扩展"><a href="#组件扩展" class="headerlink" title="组件扩展"></a>组件扩展</h3><p>构建自己的组件库真的很有必要，对于默认的<code>button</code>样式，我真是吐槽到不想再吐槽，它居然还认为自己的<code>border</code>很<code>nice</code>？！所以最终构建自己的组件库的初衷就是想把各个<code>dialog</code>中的<code>button</code>改为<code>compactbutton</code>，没办法，默认的<code>dialog</code>组件不给改呀，所以我们得自己返璞归真一下。</p><p>当然我们做扩展组件库，也不是仅仅因为一个<code>button</code>样式，还有很多新需求都要依赖自己扩展的组件。比如热键，原生<code>dialog</code>无法支持热键；还有进度条的进度时间和任务信息展示；还有<code>Gridform</code>的动态布局等等。具体就不一一介绍了，想深入了解的直接看代码，做个小<code>Demo</code>，一目了然。</p><h2 id="爽口甜菜"><a href="#爽口甜菜" class="headerlink" title="爽口甜菜"></a>爽口甜菜</h2><p>充实的正菜吃饱了，是时候来一波甜菜漱漱口，解解渴了。</p><p>在做进度条页面的时候，想除了显示进度任务完成信息之外，还想显示一下开始时间和花费时间。发现<code>python</code>的<code>time</code>模块比较坑爹，对于时间差的转换支持不行，查阅资料只发现<code>datetime</code>可以将时间差转换为微秒、秒和小时三个单位，但是我想实现时间差的自动转换，也就是<code>60s</code>自动转换为<code>1min</code>，<code>60min</code>转为<code>1h</code>，<code>24h</code>转为<code>1d</code>，超越天为单位的我就不进行转换了，逻辑不难，只是拿出来分享给有需要的人，不必重复造轮子罢了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def get_time_interval(start_time):</span><br><span class="line">    start_time = datetime.fromtimestamp(start_time)</span><br><span class="line">    now_time = datetime.fromtimestamp(time.time())</span><br><span class="line">    interval = (now_time - start_time).seconds</span><br><span class="line">    format_interval = get_format_interval(interval)                                                                                          </span><br><span class="line">    return format_interval</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_format_interval(interval):</span><br><span class="line">    if interval &lt; 60:</span><br><span class="line">        format_interval = &quot;&#123;&#125;s&quot;.format(str(interval))</span><br><span class="line">    elif 60 &lt;= interval &lt; 60*60:</span><br><span class="line">        format_interval = &quot;&#123;&#125;min &#123;&#125;s&quot;.format(</span><br><span class="line">            str(interval/60), str(interval%60))</span><br><span class="line">    elif 60*60 &lt;= interval &lt; 60*60*24:</span><br><span class="line">        format_interval = &quot;&#123;&#125;h &#123;&#125;min &#123;&#125;s&quot;.format(</span><br><span class="line">            str(interval/(60*60)),</span><br><span class="line">            str(interval%(60*60)/60),</span><br><span class="line">            str(interval%(60*60)%60)</span><br><span class="line">        )</span><br><span class="line">    elif 60*60*24 &lt;= interval:</span><br><span class="line">        format_interval = &quot;&#123;&#125;d &#123;&#125;h &#123;&#125;min &#123;&#125;s&quot;.format( </span><br><span class="line">str(interval/(60*60*24)),</span><br><span class="line">            str(interval%(60*60*24)/60*60),</span><br><span class="line">            str(interval%(60*60)/60),</span><br><span class="line">            str(interval%(60*60)%60)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    return format_interval</span><br></pre></td></tr></table></figure><h2 id="用餐总结"><a href="#用餐总结" class="headerlink" title="用餐总结"></a>用餐总结</h2><p>原本只是想做一个终端图形化的进度条页面，但是后续需求越来越多，导致做成了一个部署控制台工具，整个工程开发和优化花了大约两个星期的时间，项目中遇到的很多难点和问题很多都与<code>python snack</code>无关，所以没有做详细解释，就比如上述的甜菜，大家有兴趣的自行翻阅代码即可。</p><p><code>python snack</code>还有很多未知的我没有使用，比如<code>checkbox tree</code>等，但我相信万变不离其宗，有了这次实践，其他组件的使用和扩展应该不会花很多时间，其实做这个东西，我最深的感触就是前端发展的迅速，<code>python snack</code>是<code>2000</code>年初的产物了，很多页面逻辑跟<code>jQuery</code>比起来要弱的多，更别说现在的<code>angular</code>，<code>vue</code>等等了，但是领域不同，毕竟是伪终端页面，能做成这样已经不错了。如果是真正的桌面图形化界面（<code>GUI</code>），有<code>pyqt</code>这种神器，功能貌似很强大。</p><p>我在之前的一个项目中，就使用过<code>python snack</code>做的控制台，当然当时不知道是用这个技术做的，当时觉得蛮牛的，尝试过修改终端文字成汉子，后来没有成功，便不了了之。这次机缘巧合，工作需要做这么一个控制台，在工作中学习和使用自己感兴趣的技术的感觉真是爽呀。工作中运用技术和自己业余时间学习新技术并做个小<code>Demo</code>完全是不一样的，工作中运用会不断有新需求，不断精益求精，不断深入。所以以工作作为平台，实现自己的技术价值，会有很大的成就感，与大家共勉咯。(#^.^#)</p><blockquote><p>完整项目代码地址：<a href="https://github.com/tony-yin/Best-practice-of-python-snack" target="_blank" rel="noopener">https://github.com/tony-yin/Best-practice-of-python-snack</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/python_snack.jpg&quot; alt=&quot;python snack&quot;&gt;&lt;/center&gt;

&lt;p&gt;  了解&lt;code&gt;linux&lt;/code&gt;的人应该听说过&lt;code&gt;Newt&lt;/code&gt;，&lt;code&gt;Newt&lt;/code&gt;是一个为&lt;code&gt;RedHat&lt;/code&gt;安装程序而设计的基于文本的窗口开发工具，它是由&lt;code&gt;c&lt;/code&gt;语言编写并不依赖&lt;code&gt;X&lt;/code&gt;包，&lt;code&gt;linux&lt;/code&gt;下的&lt;code&gt;dialog&lt;/code&gt;和&lt;code&gt;whiptail&lt;/code&gt;都是基于它。而我们今天讨论的&lt;code&gt;snack&lt;/code&gt;则是&lt;code&gt;Newt&lt;/code&gt;提供的&lt;code&gt;python&lt;/code&gt;接口，&lt;code&gt;redhat&lt;/code&gt;的系统都自带这个模块，本文就如何使用&lt;code&gt;snack&lt;/code&gt;制作伪终端页面展开讲解，并配合代码展示实现效果。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
      <category term="Python" scheme="https://tony-yin.github.io/tags/Python/"/>
    
      <category term="Snack" scheme="https://tony-yin.github.io/tags/Snack/"/>
    
      <category term="Console" scheme="https://tony-yin.github.io/tags/Console/"/>
    
  </entry>
  
  <entry>
    <title>Daily Article Vol6(2018/5/1 ~ 2018/5/31)</title>
    <link href="https://tony-yin.github.io/2018/06/01/Daily-Article-Vol6/"/>
    <id>https://tony-yin.github.io/2018/06/01/Daily-Article-Vol6/</id>
    <published>2018-06-01T05:07:06.000Z</published>
    <updated>2018-11-03T17:07:41.150Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/5-2.png" alt="May"></center><p>五月份主要基于<code>python sna</code>实现了一个终端伪图形化界面的部署控制台，提供了填写配置信息、校验信息、导入信息和进度监控等功能，详情请见<a href="http://www.tony-yin.top/2018/06/03/Python-Snack-Best-Practice/" target="_blank" rel="noopener">【Python Snack 最佳实践】</a>。这是我之前一直感兴趣想做的事情，这次正好借助工作的契机对其有了深入的了解和学习，收获颇多。五月份假期多，团建，还有工作进度赶，导致自己的阅读时间受到了影响，大多数阅读都是围绕着工作内容，极客时间这些<code>APP</code>、技术博客和微信公众号的很多技术资源，自己都没有规律地学习。这些都不是借口啦，主要还是陷入吃鸡，不能自拔，哈哈哈。（已经卸了，我这个人容易上瘾然而又有点嫌麻烦，这对我来说是最简单有效的方式）</p><a id="more"></a><p>加入公司两个多月了，工作内容不断增多，难度也不断加大，由起初的合作工作到现在的独立负责某个<code>task</code>，也渐渐地忙了起来，总体来说还是游刃有余，能把自己的工作量<code>cover</code>住，希望自己继续加油。不过，这段时间大多数工作内容跟<code>ceph</code>关系不大，比如<code>ctdb rados</code>、<code>megaraid location</code>、<code>deploy console</code>等，毕竟是做产品，工作内容还是依赖产品需求，不过我还是不希望以后工作内容长期游离于<code>ceph</code>之外，因为今天的期望就是深入<code>ceph</code>，深入存储，如果工作上满足不了我的话，自己课余时间要挤一点时间做做研究了。不过好在现在项目上除了<code>ceph</code>也有很多东西是目前的我所不懂的，有学习的机会也不错，只要每天都能学习到不熟悉的东西便是极好的。除了存储，我们组也在往大数据和检索的方向靠，这两个我也都蛮感兴趣的，最近也稍微了解了下<code>elaticsearch</code>，目前好像很火的样子，六月底南京有一个<code>ES</code>线下沙龙，已经报名参加了，吼吼。</p><p>加油咯 ~</p><ol><li><a href="http://www.voidcn.com/article/p-yvycalqd-brm.html" target="_blank" rel="noopener">Django实现CAS+OAuth2</a>(5/5) <i class="fa fa-star"></i></li><li><a href="https://weibo.com/p/1001603934517592239583?mod=zwenzhang#_loginLayer_1525517479194" target="_blank" rel="noopener">NVMe over Fabric</a>(5/6) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://www.wzxue.com/ceph-librbd-block-library/" target="_blank" rel="noopener">解析Ceph: Librbd–块存储库</a>(5/7)</li><li><a href="https://draveness.me/docker" target="_blank" rel="noopener">Docker 核心技术与实现原理</a>(4)(5/11 ~ 5/13) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://blog.csdn.net/feng88724/article/details/7262514" target="_blank" rel="noopener">【Django】@login_required用法简介</a>(5/14)</li><li><a href="http://www.nowamagic.net/academy/detail/1318909" target="_blank" rel="noopener">request.META里包含了哪些数据？</a>(5/15)</li><li><a href="https://blog.csdn.net/naipeng/article/details/77162764" target="_blank" rel="noopener">CTDB代码流程简要梳理</a>(5/16) <i class="fa fa-star"></i></li><li><a href="https://blog.csdn.net/liuying_1001/article/details/77994642" target="_blank" rel="noopener">ctdb原理介绍</a>(5/17~5/18) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://opstrip.com/2017/06/14/howto-monitor-raidCard-status-with-commandline-MegaCli/" target="_blank" rel="noopener">MegaCli:如何使用命令行监控RAID卡状态</a>(5/18)</li><li><a href="http://www.cnblogs.com/lustralisk/p/pythonProgressBar.html" target="_blank" rel="noopener">Python实现控制台中的进度条</a>(5/21)</li><li><a href="https://coolshell.cn/articles/677.html" target="_blank" rel="noopener">用PYTHON写NCURSES UI</a>(5/22)</li><li><a href="https://blog.csdn.net/naipeng/article/details/77162764" target="_blank" rel="noopener">NEWT 程序设计指南</a>(5/23)</li><li><a href="http://www.wanware.com/tsgdocs/snack.html" target="_blank" rel="noopener">Quick Guide to Python’s Snack Module</a>(5/23)</li><li><a href="http://www.cnblogs.com/Xjng/p/3869869.html" target="_blank" rel="noopener">python在linux制作图形界面（snack）</a>(5/23)</li><li><a href="https://blog.csdn.net/taiyang1987912/article/details/49273601" target="_blank" rel="noopener">python在linux(anaconda)的图形界面（snack）</a>(5/24)</li><li><a href="https://npyscreen.readthedocs.io/introduction.html#example-code" target="_blank" rel="noopener">An introduction to npyscreen</a>(5/24)</li><li><a href="https://helloacm.com/creating-ui-controls-under-linux-shell-console-using-whiptail-utility/" target="_blank" rel="noopener">Creating UI Controls under Linux Shell Console using whiptail Utility</a>(5/25)</li><li><a href="https://www.linuxjournal.com/article/2807" target="_blank" rel="noopener">Dialog: An Introductory Tutorial</a>(5/25)</li><li><a href="https://askubuntu.com/questions/747143/create-a-progress-bar-in-bash" target="_blank" rel="noopener">Create a progress bar in bash</a>(5/25)</li><li><a href="https://www.tecmint.com/monitor-copy-backup-tar-progress-in-linux-using-pv-command/" target="_blank" rel="noopener">How to Monitor Progress of (Copy/Backup/Compress) Data using ‘pv’ Command</a>(5/25)</li><li><a href="http://blog.ihipop.info/2010/10/1736.html" target="_blank" rel="noopener">Python中如何写控制台进度条的整理</a>(5/26) <i class="fa fa-star"></i></li><li><a href="https://www.ibm.com/developerworks/cn/linux/sdk/python/python-6/index.html" target="_blank" rel="noopener">可爱的 Python：Curses 编程</a>(5/26)</li><li><a href="http://wklken.me/posts/2012/02/19/python-ini-configparser.html" target="_blank" rel="noopener">PYTHON读取修改INI配置文件[CONFIGPARSER]</a>(5/31)</li><li><a href="https://www.jianshu.com/p/4202a2051668" target="_blank" rel="noopener">Python 解析配置模块之ConfigParser详解</a>(5/31) <i class="fa fa-star"></i></li><li><a href="http://www.cnblogs.com/huey/p/4334152.html" target="_blank" rel="noopener">Python(2.7.6) ConfigParser - 读写配置文件</a>(5/31)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/5-2.png&quot; alt=&quot;May&quot;&gt;&lt;/center&gt;

&lt;p&gt;五月份主要基于&lt;code&gt;python sna&lt;/code&gt;实现了一个终端伪图形化界面的部署控制台，提供了填写配置信息、校验信息、导入信息和进度监控等功能，详情请见&lt;a href=&quot;http://www.tony-yin.top/2018/06/03/Python-Snack-Best-Practice/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【Python Snack 最佳实践】&lt;/a&gt;。这是我之前一直感兴趣想做的事情，这次正好借助工作的契机对其有了深入的了解和学习，收获颇多。五月份假期多，团建，还有工作进度赶，导致自己的阅读时间受到了影响，大多数阅读都是围绕着工作内容，极客时间这些&lt;code&gt;APP&lt;/code&gt;、技术博客和微信公众号的很多技术资源，自己都没有规律地学习。这些都不是借口啦，主要还是陷入吃鸡，不能自拔，哈哈哈。（已经卸了，我这个人容易上瘾然而又有点嫌麻烦，这对我来说是最简单有效的方式）&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
      <category term="Daily-Article" scheme="https://tony-yin.github.io/tags/Daily-Article/"/>
    
  </entry>
  
  <entry>
    <title>Ctdb Rados（二）：多场景断网高可用</title>
    <link href="https://tony-yin.github.io/2018/05/20/Ctdb-Rados-2/"/>
    <id>https://tony-yin.github.io/2018/05/20/Ctdb-Rados-2/</id>
    <published>2018-05-20T05:07:06.000Z</published>
    <updated>2018-11-03T17:07:41.151Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/ping-600x450.png" alt="ping"></center><p>之前写过一篇文章【<a href="http://www.tony-yin.top/2018/04/20/Ctdb-Rados-All-Banned/" target="_blank" rel="noopener">Ctdb Rados方式导致All Banned的问题</a>】，谈到了当<code>ctdb</code>将<code>recovery lock</code>设置成<code>rados</code>的方式后，断网<code>master</code>节点会造成所有<code>ctdb</code>节点<code>All Banned</code>，主要原因是<code>master</code>意外断网没有释放锁，其他节点无法获取到锁，当时的解决方案是每<code>5</code>分钟检查一次<code>ctdb</code>状态，如果连续两次发生了<code>All Banned</code>的情况，则手动删除<code>lock</code>，这种做法在最近的测试中遇到了一些问题，本文对这些问题进行剖析并对相应的解决方案进行分享。</p><a id="more"></a><blockquote><p>完整代码地址：<a href="https://github.com/tony-yin/Ctdb-Rados-Monitor" target="_blank" rel="noopener">https://github.com/tony-yin/Ctdb-Rados-Monitor</a></p></blockquote><h2 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h2><p>如果基于原来的做法，<code>ctdb</code>发生<code>All Banned</code>的情况，需要十分钟的监控时间加上两分钟左右的<code>recovery</code>时间，也就是说大概需要十二分钟才能恢复<code>ctdb</code>服务，这样看来高可用有点名实其副了，这个也会明显地影响存储业务的正常运行。后来，我们讨论出新的方案：每<code>5s</code>检查一次<code>ctdb</code>的状态，<code>All Banned</code>的次数累计到<code>5</code>次才确定为该故障场景，然后手动删除<code>lock</code>，最终要保证<code>ctdb</code>能够在<code>2min</code>内完成恢复。</p><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p><code>cron tab</code>最短周期只支持分钟级别，所以如何<code>5s</code>检查一次便是一个问题。</p><p>代码是死的，人是活的，虽然<code>cron tab</code>只支持分钟级别，但是我们可以每分钟调用一个脚本，然后在这个脚本中遍历<code>12</code>次，每次调用<code>ctdb monitor</code>脚本，然后<code>sleep 5s</code>，这样就可以达到每<code>5s</code>检查一次<code>ctdb</code>的效果了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ctdb_monitor</span></span><br><span class="line">* * * * * root /etc/ctdb/cron-seconds</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cron-seconds</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for((i=1;i&lt;=12;i++));do</span><br><span class="line">    ../monitor_ctdb</span><br><span class="line">sleep 5</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>这样检查到<code>ctdb</code>发生<code>All Banned</code>情况，只需要花费<code>25s</code>，剩下的就是<code>recovery</code>的时间了。</p><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p>当<code>ctdb master</code>节点的<code>network</code>服务断掉，其他两个节点（我的开发环境是三节点的虚拟机环境）便会选举一个为<code>master</code>节点，然后去获取<code>lock</code>，因为原<code>master</code>没有释放锁，导致所有节点<code>All Banned</code>，即使我们手动删除了锁，但是这时候其他两个节点仍然处于<code>Banned</code>的情况，需要等到<code>Ban Timeout</code>才会再次尝试获取锁并开始恢复过程，这个<code>timeout</code>的时间是<code>300s</code>，即<code>5min</code>，这显然是我们不能接受的，所以我们要在删除<code>lock</code>后，重启所有节点的<code>ctdb</code>服务。</p><p>不过该如何触发该重启操作呢？</p><p>我们在删除<code>lock</code>后将<code>ctdb</code>所有节点的<code>ip</code>作为对象存进<code>rados</code>中，然后在每<code>5s</code>监控的脚本中，查看<code>rados</code>中是否存在本节点的<code>ip</code>对象，如果有，则尝试重启<code>ctdb</code>操作，重启后便删除该对象。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function save_nodes_ip() &#123;</span><br><span class="line">    nodes=$(ctdb listnodes)</span><br><span class="line">    for node in $nodes; do</span><br><span class="line">        echo "$node" &gt; $node</span><br><span class="line">        rados -p rbd put $node $node</span><br><span class="line">        rm -f $node</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function get_current_node_ips() &#123;</span><br><span class="line">    ips=$(/usr/sbin/ip addr | grep "inet " | awk '&#123;print $2&#125;')</span><br><span class="line">    echo $ips</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function monitor_nodes_ip_in_rados() &#123;</span><br><span class="line">    ips=$(get_current_node_ips)</span><br><span class="line">    for ipinfo in $ips; do</span><br><span class="line">        ip=$&#123;ipinfo%/*&#125;</span><br><span class="line">        if $(timeout 10 rados -p rbd ls | grep "$ip" -qw); then</span><br><span class="line">            systemctl restart ctdb</span><br><span class="line">            rados -p rbd rm $ip</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么三个节点的<code>ip</code>都要存入<code>rados</code>，这个是因为原<code>master</code>节点恢复网络后，<code>ctdb</code>服务的状态为<code>failed</code>，同样需要重启<code>ctdb</code>服务才能正常恢复原<code>master</code>节点。 </p><p><strong>注意：</strong></p><p>这边有两个问题，当时浪费了我不少时间，问题不是多么深奥，但是不易发现。。。</p><p>第一个问题便是<code>ips=$(/usr/sbin/ip addr | grep &quot;inet &quot; | awk &#39;{print $2}&#39;)</code>这行代码，原来的写法是<code>ips=$(ip addr | grep &quot;inet &quot; | awk &#39;{print $2}&#39;)</code>，当时发现<code>ip</code>总是获取不到，然后无论是命令行还是脚本运行都可以正常获取到，后来还是同事提醒才发现在<code>crontab</code>脚本中，<code>shell</code>命令默认是<code>/usr/bin/</code>下的，而<code>ip</code>命令则是<code>/usr/sbin/</code>下，所以这里的命令我们需要全路径。（这个需要格外注意！！！被坑的不要不要的。。。）</p><p>第二个问题便是<code>rados -p rbd ls | grep &quot;$ip&quot; -qw</code>这行代码，当时没注意写成了<code>rados -p rbd ls | grep &quot;$ip&quot; -w</code>，发现<code>if</code>判断时常有问题，一开始还以为不能<code>grep</code>数字什么的，后来才发现没有加<code>q</code>，<code>q</code>表示安静模式，不打印任何标准输出，如果有匹配的内容则立即返回状态值0。</p><h2 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h2><p>“断网”这个词不够具体，在实际生产环境中，一个集群中，一般都会有多个网络，就拿本人的<code>ceph</code>集群环境来说（物理机环境，并非前文提及的虚拟机开发环境），<code>ceph</code>有个<code>public network</code>和<code>cluster network</code>，而<code>ctdb</code>也有它的<code>node network</code>和<code>public network</code>，<code>ceph</code>的<code>public</code>和<code>ctdb</code>的<code>public</code>是同一网段，<code>ceph</code>的<code>cluster</code>是单独网段，<code>ctdb</code>的<code>node</code>是单独的网段。所以<code>ctdb master</code>断网可以分为三种情况：</p><ul><li>拔掉<code>ctdb master node</code>网段网线</li><li>拔掉<code>ctdb master public</code>网段网线</li><li>断掉<code>ctdb master network</code>服务</li></ul><p>当拔掉<code>ctdb master public</code>网段网线，这没有什么好说的，<code>ctdb master</code>节点服务还存在，只是<code>master</code>节点上的<code>public address</code>不可用了，会漂移到其他节点上。</p><h3 id="问题1-1"><a href="#问题1-1" class="headerlink" title="问题1"></a>问题1</h3><p>当拔掉<code>ctdb master node</code>网段网线后，<code>master</code>节点仍然有<code>public</code>网卡，（<strong>这里注意</strong>）它仍然可以获取其他<code>ctdb</code>节点的状态，而其他节点却不可以获取它的状态，因为<code>master</code>的<code>node</code>节点<code>ip</code>不存在。所以造成的结果就是原<code>master</code>节点还默认自己是<code>master</code>节点，而其他的节点却又选举出了新的<code>master</code>，我们的脚本因为<code>All Banned</code>手动删除了<code>lock</code>，这时候其他节点可以正常恢复<code>ctdb</code>服务，但是当<code>ctdb master</code>节点断网再恢复后，它还以为自己是<code>master</code>，会不断去获取锁，而原来的锁已经被我们手动删除，这时候新的锁被新的<code>master</code>掌握，所以此时产生脑裂，我们要牺牲原<code>master</code>节点，也就是断网节点，所以需要重启它。这个重启触发机制我们是通过在每次删除<code>lock</code>之后在<code>rados</code>中存入<code>ctdb</code>所有节点的<code>ip</code>作为<code>object</code>（这就是为什么要存入所有节点的<code>ip</code>），然后只要发现有这个<code>object</code>便执行<code>ctdb</code>重启操作，然后便删除这个对象。至于为什么要存所有对象是因为除了原<code>master</code>需要重启之外，另外两个正常节点发生<code>All Banned</code>的情况，默认<code>timeout</code>时间是<code>300s</code>（这个上面也提到过），我们为了减少恢复时间，直接在删除<code>lock</code>后重启<code>ctdb</code>；</p><h2 id="问题2-1"><a href="#问题2-1" class="headerlink" title="问题2"></a>问题2</h2><p>由于现在<code>ctdb</code>的锁是放在<code>rados</code>中，而不是以前的<code>cephfs</code>的方式了。所以当<code>master</code>断网再恢复时，它会不断地去<code>rados</code>获取他原来的锁，这是获取锁的进程越来越多，会阻塞住<code>rados</code>服务，我们可以通过<code>ps -ef | grep rados_helper</code>看到进程不断变多，那么<code>rados</code>服务不能正常读写就影响到我们上一条的机制，不能读<code>rados</code>中是否含有本节点<code>ip</code>的对象，就没办法进行重启操作，那么这样它就会不断地继续获取<code>lock</code>，所以我们在这里又加了一个机制，如果<code>ps -ef | grep rados_helper</code>的数目超过<code>6</code>个，就默认启动重启<code>ctdb</code>服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function monitor_get_lock_timeout() &#123;</span><br><span class="line">    count=$(ps -ef | grep rados_helper | wc -l)</span><br><span class="line">    if [ $count -ge $RADOS_HELPER_PROCESS_MAX ]; then</span><br><span class="line">        systemctl restart ctdb</span><br><span class="line">        update_last_ctdb_restart_time</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h2><p><code>ctdb</code>目前重启的机制有点多，有自身自带的故障重启，也有我们监控脚本的异常情况，很容易发生重复重启，还有可能<code>rados_helper</code>堆积的进程很多，比如<code>20</code>个，我们的脚本是<code>5s</code>一次，也许<code>20</code>个的时候重启了，过<code>5s</code>，进程释放也需要时间，可能此时还有<code>10</code>个，那么大于我们规定的<code>6</code>个，就会继续重启，这种重复重启没有必要，所以我们要加上<code>ctdb</code>重启的周期限定<code>2min</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function get_ctdb_restart_interval() &#123;</span><br><span class="line">    last_time=$(get_ctdb_restart_last_time)</span><br><span class="line">    if [ -z "$last_time" ]; then</span><br><span class="line">        interval=$(expr $RESTART_CTDB_INTERVAL_MAX + 1)</span><br><span class="line">    else</span><br><span class="line">        current_time=$(date +%s)</span><br><span class="line">        interval=$(expr $current_time - $last_time)</span><br><span class="line">    fi</span><br><span class="line">    echo $interval</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑并解决以上提到的问题，基本上可以覆盖以上三种断网的场景了，在监控和管理<code>ctdb</code>的过程中，一定要小心，不能影响到业务正常运行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>生产环境网络结构错综复杂，往往在虚拟机上开发的功能当时好好的，到了物理机上面测试会发生各种问题，此时，我们首先要搞清楚网络拓扑结构，熟悉硬件配置，各网段的作用和相互之间的关联，这样遇到问题我们可以顺藤摸瓜，同样<code>ctdb</code>的原理也需要掌握才能了解它各种行为的触发机制，才能更好的定制化监控和管理。之后我会花点时间好好地研究一下<code>ctdb</code>，然后再单独做分享。</p><blockquote><p>完整代码地址：<a href="https://github.com/tony-yin/Ctdb-Rados-Monitor" target="_blank" rel="noopener">https://github.com/tony-yin/Ctdb-Rados-Monitor</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/ping-600x450.png&quot; alt=&quot;ping&quot;&gt;&lt;/center&gt;

&lt;p&gt;之前写过一篇文章【&lt;a href=&quot;http://www.tony-yin.top/2018/04/20/Ctdb-Rados-All-Banned/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ctdb Rados方式导致All Banned的问题&lt;/a&gt;】，谈到了当&lt;code&gt;ctdb&lt;/code&gt;将&lt;code&gt;recovery lock&lt;/code&gt;设置成&lt;code&gt;rados&lt;/code&gt;的方式后，断网&lt;code&gt;master&lt;/code&gt;节点会造成所有&lt;code&gt;ctdb&lt;/code&gt;节点&lt;code&gt;All Banned&lt;/code&gt;，主要原因是&lt;code&gt;master&lt;/code&gt;意外断网没有释放锁，其他节点无法获取到锁，当时的解决方案是每&lt;code&gt;5&lt;/code&gt;分钟检查一次&lt;code&gt;ctdb&lt;/code&gt;状态，如果连续两次发生了&lt;code&gt;All Banned&lt;/code&gt;的情况，则手动删除&lt;code&gt;lock&lt;/code&gt;，这种做法在最近的测试中遇到了一些问题，本文对这些问题进行剖析并对相应的解决方案进行分享。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Ctdb" scheme="https://tony-yin.github.io/tags/Ctdb/"/>
    
  </entry>
  
  <entry>
    <title>Megaraid 磁盘定位</title>
    <link href="https://tony-yin.github.io/2018/05/12/Megaraid_Location/"/>
    <id>https://tony-yin.github.io/2018/05/12/Megaraid_Location/</id>
    <published>2018-05-12T05:07:06.000Z</published>
    <updated>2018-11-03T17:07:41.150Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/mega_drive-600x450.png" alt="mega drive"></center><p>早前写过一篇【<a href="http://www.tony-yin.top/2018/01/05/RaidCardToolUtils/" target="_blank" rel="noopener">利用Raid卡工具获取逻辑盘是否为SSD</a>】的文章，大概讲述了如何通过<code>raid</code>卡工具判断一个逻辑磁盘对应物理磁盘是否为<code>SSD</code>，当时主要提到了<code>megacli</code>和<code>sas3ircu</code>这两种工具，核心是如何通过<code>raid</code>卡工具定位到逻辑磁盘对应的物理磁盘的位置，当时的方式现在看来在有些场景会存在缺陷。</p><a id="more"></a><p>当时的方案主要是先通过<code>lspci</code>获取<code>raid</code>卡型号，然后找到对应的<code>raid</code>卡型号，紧接着通过<code>lsscsi</code>命令获取逻辑磁盘的<code>targetid</code>，再通过<code>raid</code>卡工具根据<code>targetid</code>定位到对应的物理盘。当时的方案在多<code>controller</code>的场景下存在问题，可能会出现重复<code>target id</code>的情况，所以这时候只能再借助<code>controller id</code>来定位唯一的磁盘了。总而言之，想真正定位逻辑磁盘对应的物理磁盘，就必须要获取到磁盘的<code>controller id</code>，<code>enclosure id</code>和<code>slot number</code>，有了这三个参数，便可以获取该磁盘的信息，或者对该物理磁盘进行点灯、响音和做<code>raid</code>等操作。</p><p>那么，具体如何定位逻辑磁盘的物理位置呢？且看下文分析</p><h2 id="获取-raid-卡信息"><a href="#获取-raid-卡信息" class="headerlink" title="获取 raid 卡信息"></a>获取 raid 卡信息</h2><p>通过<code>lspci</code>命令可以获取到操作系统上所有<code>raid</code>卡信息，我们可以看到每个<code>raid</code>卡最前面都有一串数字，比如第一行是<code>02:00.0</code>，第二行是<code>03:00.0</code>，这里的<code>02</code>和<code>03</code>表示的是<code>raid</code>卡的<code>busid</code>，即<code>raid</code>卡控制器在<code>pci</code>总线上的<code>id</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# lspci | grep "LSI Logic"</span><br><span class="line">02:00.0 RAID bus controller: LSI Logic / Symbios Logic MegaRAID SAS-3 3008 [Fury] (rev 02)</span><br><span class="line">03:00.0 RAID bus controller: LSI Logic / Symbios Logic MegaRAID SAS-3 3108 [Invader] (rev 02)</span><br></pre></td></tr></table></figure><h2 id="获取磁盘-pcipath"><a href="#获取磁盘-pcipath" class="headerlink" title="获取磁盘 pcipath"></a>获取磁盘 pcipath</h2><p>在<code>linux</code>中，一切皆文件，每个文件都有自己的唯一标识，对于磁盘而言，<code>pcipath</code>就是它的唯一标识，<code>pci</code>总线上面有很多控制器，比如<code>scsi</code>控制器，而磁盘又存在于<code>scsi</code>控制器上，所以我们可以在<code>lsscsi</code>命令获取到的<code>scsi</code>设备列表中查看到操作系统上的磁盘信息。</p><p>以<code>sda</code>为例，我们可以在<code>/dev/disk/by-path</code>目录下查看到磁盘的<code>pcipath</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# ll /dev/disk/by-path/</span><br><span class="line">total 4</span><br><span class="line">lrwxrwxrwx 1 root root   9 May 11 10:30 pci-0000:02:00.0-scsi-0:2:0:0 -&gt; ../../sda</span><br><span class="line">lrwxrwxrwx 1 root root  10 May 11 10:30 pci-0000:02:00.0-scsi-0:2:0:0-part1 -&gt; ../../sda1</span><br><span class="line">lrwxrwxrwx 1 root root  10 May 11 10:30 pci-0000:02:00.0-scsi-0:2:0:0-part2 -&gt; ../../sda2</span><br><span class="line">lrwxrwxrwx 1 root root   9 May 11 16:22 pci-0000:02:00.0-scsi-0:2:1:0 -&gt; ../../sdb</span><br><span class="line">lrwxrwxrwx 1 root root   9 May 11 16:22 pci-0000:02:00.0-scsi-0:2:10:0 -&gt; ../../sdk</span><br></pre></td></tr></table></figure><p>由于在<code>linux</code>中，<code>udev</code>是用户态的设备管理，所以我们也可以通过<code>udev</code>获取。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# udevadm info --query=symlink --name=sda</span><br><span class="line">disk/by-id/scsi-36509a4c0ac86790022337b9105005435 disk/by-id/wwn-0x6509a4c0ac86790022337b9105005435 disk/by-path/pci-0000:02:00.0-scsi-0:2:0:0</span><br></pre></td></tr></table></figure><p>这边我们可以得到磁盘<code>sda</code>的<code>pcipath</code>为<code>pci-0000:02:00.0-scsi-0:2:0:0</code>，<code>02</code>就是磁盘的<code>raid</code>卡的<code>bus id</code>，后面的<code>00</code>表示<code>channel id</code>，再后面的<code>0:2:0:0</code>就和<code>lsscsi</code>获取的一样了，其中<code>2</code>就表示<code>target id</code>。</p><p>所以通过<code>bud id</code>，我们可以获取到磁盘对应的<code>raid</code>卡型号，根据对应的<code>raid</code>卡工具操作磁盘。这边我们只讨论<code>megaraid</code>，所以工具也就是<code>megacli</code>了。</p><h2 id="获取-controller-id"><a href="#获取-controller-id" class="headerlink" title="获取 controller id"></a>获取 controller id</h2><p>上面我们获取到了磁盘的<code>target id</code>和对应<code>raid</code>卡的<code>bus id</code>，而对于<code>megacli</code>工具而言，每个<code>raid</code>卡都有一个与之对应的<code>controller</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# /opt/MegaRAID/MegaCli/MegaCli64 -AdpGetPciInfo -aall -NoLog</span><br><span class="line"></span><br><span class="line">PCI information for Controller 0</span><br><span class="line">--------------------------------</span><br><span class="line">Bus Number      : 2</span><br><span class="line">Device Number   : 0</span><br><span class="line">Function Number : 0</span><br><span class="line"></span><br><span class="line">PCI information for Controller 1</span><br><span class="line">--------------------------------</span><br><span class="line">Bus Number      : 3</span><br><span class="line">Device Number   : 0</span><br><span class="line">Function Number : 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exit Code: 0x00</span><br></pre></td></tr></table></figure><p>这边我们可以看到<code>megacli</code>获取到了两个<code>controller</code>，也就对应上面<code>lspci</code>获取到的两张<code>raid</code>卡。细心的朋友可以发现这边有一个<code>Bus Number</code>，分别为<code>2</code>和<code>3</code>，而我们上面获取到了<code>raid</code>卡的<code>bus id</code>分别为<code>02</code>和<code>03</code>，没错，这边的<code>Bus Number</code>和<code>bus id</code>是对应的，只是<code>Bus number</code>没有自动填补成两位数，所以我们可以通过<code>bus id</code>得到<code>sda</code>所对应的<code>controller</code>为<code>0</code>。</p><blockquote><p><strong>注意：</strong><br>原本系统中版本<code>8.07.07</code>的<code>megacli</code>工具获取<code>raid</code>卡信息的时候会存在问题，每次<code>Bus Number</code>都会变化，我们只要升级<code>megacli</code>即可，我这边是把<code>megacli</code>升级到了<code>8.07.14</code>版本。</p><p>安装包地址：<a href="https://github.com/tony-yin/Megaraid_location/blob/master/MegaCli-8.07.14-1.noarch.rpm" target="_blank" rel="noopener">https://github.com/tony-yin/Megaraid_location/blob/master/MegaCli-8.07.14-1.noarch.rpm</a></p></blockquote><h2 id="获取磁盘组"><a href="#获取磁盘组" class="headerlink" title="获取磁盘组"></a>获取磁盘组</h2><p>此时，我们拥有了<code>controller id</code>，可以获取该<code>controller</code>下所有的磁盘组信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# /opt/MegaRAID_new/MegaCli/MegaCli64  -LdPdInfo -a0 -NoLog</span><br><span class="line">Adapter #0</span><br><span class="line"></span><br><span class="line">Number of Virtual Disks: 13</span><br><span class="line">Virtual Drive: 0 (Target Id: 0)</span><br><span class="line">Name                :</span><br><span class="line">RAID Level          : Primary-1, Secondary-0, RAID Level Qualifier-0</span><br><span class="line">Size                : 558.375 GB</span><br><span class="line">Sector Size         : 512</span><br><span class="line">Is VD emulated      : No</span><br><span class="line">Mirror Data         : 558.375 GB</span><br><span class="line">State               : Optimal</span><br><span class="line">Strip Size          : 64 KB</span><br><span class="line">Number Of Drives    : 2</span><br><span class="line">Span Depth          : 1</span><br><span class="line">Default Cache Policy: WriteThrough, ReadAheadNone, Direct, No Write Cache if Bad BBU</span><br><span class="line">Current Cache Policy: WriteThrough, ReadAheadNone, Direct, No Write Cache if Bad BBU</span><br><span class="line">Default Access Policy: Read/Write</span><br><span class="line">Current Access Policy: Read/Write</span><br><span class="line">Disk Cache Policy   : Disk's Default</span><br><span class="line">Encryption Type     : None</span><br><span class="line">Default Power Savings Policy: Controller Defined</span><br><span class="line">Current Power Savings Policy: None</span><br><span class="line">Can spin up in 1 minute: Yes</span><br><span class="line">LD has drives that support T10 power conditions: Yes</span><br><span class="line">LD's IO profile supports MAX power savings with cached writes: No</span><br><span class="line">Bad Blocks Exist: No</span><br><span class="line">Is VD Cached: No</span><br><span class="line">Number of Spans: 1</span><br><span class="line">Span: 0 - Number of PDs: 2</span><br><span class="line"></span><br><span class="line">PD: 0 Information</span><br><span class="line">Enclosure Device ID: 32</span><br><span class="line">Slot Number: 12</span><br><span class="line">Drive's position: DiskGroup: 0, Span: 0, Arm: 0</span><br><span class="line">Enclosure position: 1</span><br><span class="line">Device Id: 12</span><br><span class="line">WWN: 50000398181A974C</span><br><span class="line">Sequence Number: 2</span><br><span class="line">Media Error Count: 0</span><br><span class="line">Other Error Count: 0</span><br><span class="line">Predictive Failure Count: 0</span><br><span class="line">Last Predictive Failure Event Seq Number: 0</span><br><span class="line">PD Type: SAS</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后我们可以根据<code>target id</code>获取对应的磁盘组信息，<code>target id</code>与上面的<code>Target Id</code>所对应，这样我们可以过滤得到唯一的磁盘组信息。这边我们可以看到<code>sda</code>对应<code>Target Id</code>为<code>0</code>的磁盘组，该<code>raid</code>类型为<code>raid1</code>，虚拟磁盘组中有两块物理盘，然后我们可以获取这两块物理盘的<code>enclosure id</code>和<code>slot number</code>，这样再加上前文的<code>controller id</code>，我们就可以完完全全地定位到具体一块磁盘的物理位置。</p><h2 id="一键定位"><a href="#一键定位" class="headerlink" title="一键定位"></a>一键定位</h2><p>针对这种需求，本人根据以上逻辑写了一个简单的脚本可以一键获取磁盘的定位。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# ./get_disk_location.py sda</span><br><span class="line">['0:32:12', '0:32:13']</span><br></pre></td></tr></table></figure><p>这边<code>0:32:12</code>分别表示磁盘的<code>controller id</code>，<code>enclosure id</code>和<code>slot number</code>。</p><blockquote><p>完整代码地址：<a href="https://github.com/tony-yin/Megaraid_location/" target="_blank" rel="noopener">https://github.com/tony-yin/Megaraid_location/</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前的做法大部分场景可行，但是在一些场合偶尔会发现问题，总感觉还是不够靠谱，身边的人还有通过<code>sda</code>，<code>sdb</code>这种排列顺序来查找和<code>megacli</code>中显示磁盘的对应关系的，就更不靠谱了。<code>linux</code>操作系统是可以识别到具体硬件设备的，所以是肯定存在方法识别硬件对应的逻辑设备的，本文通过<code>pcipath</code>获取到设备的唯一标识，然后根据<code>pcipath</code>中的<code>bus id</code>和<code>megacli</code>中的<code>cobtroller</code>建立连接，最后通过<code>target id</code>锁定唯一磁盘组中的磁盘信息。</p><p>通过这种方式，我们不需要肉眼判断，也不需要顾虑部分场景方案不适用，这完全就是操作系统使用的方式，使用这种最基础，最底层的方式实现，真是让人豁然开朗。这跟看源码类似，了解一个功能的背后具体实现，你才知道最正确的姿势，不用去碰，去凑，这种感觉真好。</p><p>给大家推荐一本书《<code>Linux</code>设备驱动程序》，这本书详细讲解了<code>linux</code>中各种设备与驱动的细节，很底层也很枯燥，不过看完后应该会很有收获。希望大家在使用各种已有工具和框架的基础上，多去了解背后的实现机制，这样可以帮助我们更好地实现更深层次的需求。</p><h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ol><li><a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">Persistent block device naming</a></li><li><a href="https://github.com/eLvErDe/hwraid" target="_blank" rel="noopener">hwraid</a></li><li><a href="https://github.com/louwrentius/showtools" target="_blank" rel="noopener">showtools</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-scsi-subsystem/" target="_blank" rel="noopener">Linux SCSI 子系统剖析</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/mega_drive-600x450.png&quot; alt=&quot;mega drive&quot;&gt;&lt;/center&gt;

&lt;p&gt;早前写过一篇【&lt;a href=&quot;http://www.tony-yin.top/2018/01/05/RaidCardToolUtils/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;利用Raid卡工具获取逻辑盘是否为SSD&lt;/a&gt;】的文章，大概讲述了如何通过&lt;code&gt;raid&lt;/code&gt;卡工具判断一个逻辑磁盘对应物理磁盘是否为&lt;code&gt;SSD&lt;/code&gt;，当时主要提到了&lt;code&gt;megacli&lt;/code&gt;和&lt;code&gt;sas3ircu&lt;/code&gt;这两种工具，核心是如何通过&lt;code&gt;raid&lt;/code&gt;卡工具定位到逻辑磁盘对应的物理磁盘的位置，当时的方式现在看来在有些场景会存在缺陷。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Megaraid" scheme="https://tony-yin.github.io/tags/Megaraid/"/>
    
  </entry>
  
  <entry>
    <title>Django CAS Token 解决方案</title>
    <link href="https://tony-yin.github.io/2018/05/02/Django_CAS_Token_Solution/"/>
    <id>https://tony-yin.github.io/2018/05/02/Django_CAS_Token_Solution/</id>
    <published>2018-05-02T05:07:06.000Z</published>
    <updated>2018-11-03T17:07:41.151Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/cas-600x450.jpg" alt="cas"></center><p><code>CAS</code>单点登录主要是为了解决主系统和子系统的统一登录问题，能够做到任意一个子系统登录成功后，再登录其他子系统后不再需要认证，让用户不用重复地进行登录认证。<code>CAS</code>单点登录的方案很多，并且大多数都是采用<code>session</code>的方式，而本文结合个人实践，着重讨论<code>django cas token</code>的解决方案。</p><a id="more"></a><p>本方案中，<code>cas</code>客户端和服务端都采用了开源项目，服务端是<a href="https://github.com/jbittel/django-mama-cas" target="_blank" rel="noopener">django-mama-cas</a>，而客户端是<a href="https://github.com/mingchen/django-cas-ng" target="_blank" rel="noopener">django-cas-ng</a>。</p><h2 id="CAS-Server"><a href="#CAS-Server" class="headerlink" title="CAS Server"></a>CAS Server</h2><p>服务端相比于客户端要简单地多，根据<code>github</code>步骤一步步下载和配置就好。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django-mama-cas</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">INSTALLED_APPS = (</span><br><span class="line">    <span class="string">'mama_cas'</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重要！，service是client的IP，是个数组，可以在后面添加SERVICE的HOST:PORT。</span></span><br><span class="line">MAMA_CAS_SERVICES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'SERVICE'</span>: <span class="string">'http://127.0.1.1:8000'</span>,</span><br><span class="line">        <span class="string">'CALLBACKS'</span>: [</span><br><span class="line">            <span class="string">'mama_cas.callbacks.user_model_attributes'</span>,     <span class="comment"># 返回除了password的所有Field</span></span><br><span class="line">            <span class="comment"># 'mama_cas.callbacks.user_name_attributes', # 只返回 username</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">'LOGOUT_ALLOW'</span>: <span class="keyword">True</span>,</span><br><span class="line">        <span class="string">'LOGOUT_URL'</span>: <span class="string">'http://127.0.1.1:8000/accounts/callback'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># urls.py</span></span><br><span class="line">url(<span class="string">r''</span>, include(<span class="string">'mama_cas.urls'</span>)),</span><br></pre></td></tr></table></figure><h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><p>首先是一些基本的客户端配置，比如<code>server ip</code>等，但是<code>django-cas-ng</code>默认是通过<code>session</code>的方式认证的，而我们需要通过<code>token</code>的方式认证，所以如果想继续用<code>django-cas-ng</code>来解决问题，那要么查看它是否有原生支持的接口，要么改源码。改源码可能不大友好，所以我优先研究了一下<code>django-cas-ng</code>的原生支持，无意中发现<a href="https://github.com/mingchen/django-cas-ng#view-wrappers-example" target="_blank" rel="noopener">view-wrappers-example</a>可以继承它原生的登录接口做一些封装，而我们完全通过继承原生的登录方法，然后加入我们的<code>token</code>相关代码。所以<code>urls.py</code>里面登录的方法我们写的是我们写在<code>view.py</code>中封装的登录方法，而并非默认的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">INSTALLED_APPS = (</span><br><span class="line">    <span class="comment"># ... other installed apps</span></span><br><span class="line">    <span class="string">'django_cas_ng'</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">AUTHENTICATION_BACKENDS = (</span><br><span class="line">    <span class="string">'django_cas_ng.backends.CASBackend'</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：这是cas server的地址</span></span><br><span class="line">CAS_SERVER_URL = <span class="string">'http://127.0.0.1:8000'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存入所有CAS 服务端返回的user数据。</span></span><br><span class="line">CAS_APPLY_ATTRIBUTES_TO_USER = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># urls.py</span></span><br><span class="line"><span class="keyword">import</span> view <span class="keyword">import</span> *</span><br><span class="line">url(<span class="string">r'^accounts/login$'</span>, cas_login, name=<span class="string">'cas_login'</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">#view.py</span></span><br><span class="line"><span class="keyword">from</span> django_cas_ng <span class="keyword">import</span> views <span class="keyword">as</span> baseviews</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cas_login</span><span class="params">(request, **kwargs)</span>:</span></span><br><span class="line">    r = baseviews.login(request, **kwargs)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.user.is_anonymous():</span><br><span class="line">        token = get_token(request)</span><br><span class="line">        <span class="keyword">if</span> token:</span><br><span class="line">            r.set_cookie(<span class="string">'token'</span>, token)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'Get token error'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'User is anonymous'</span>)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token</span><span class="params">(request, *args, **kwargs)</span>:</span></span><br><span class="line">    user = request.user</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        request_hash = AuthToken.get_request_hash(request)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            token = generate_token()    <span class="comment"># function used to geneate token, this place won't show more detail codes</span></span><br><span class="line">            token.refresh()</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">print</span> e</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> token.key</span><br></pre></td></tr></table></figure><p>生成<code>token</code>的方法我就不详细描述了，这边主要提供了一个思路，我们将<code>django-cas-ng</code>原生的登录方法进行了继承，然后生成<code>token</code>并放到了<code>session</code>当中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要为<code>CAS Token</code>方案提供一个思路，如果集成进已有项目中，肯定会遇到很多细节问题，不过万变不离其宗，我们首先要熟悉手中运用的工具，然后要善于在此基础之上根据自己的定制需求进行开发，多看看文档和源码，每一次可能都会有新的发现。</p><h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ol><li><a href="https://www.jianshu.com/p/d97a3d367037" target="_blank" rel="noopener">使用django-mama-cas快速搭建CAS服务</a></li><li><a href="http://www.voidcn.com/article/p-yvycalqd-brm.html" target="_blank" rel="noopener">Django实现CAS+OAuth2</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/cas-600x450.jpg&quot; alt=&quot;cas&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;code&gt;CAS&lt;/code&gt;单点登录主要是为了解决主系统和子系统的统一登录问题，能够做到任意一个子系统登录成功后，再登录其他子系统后不再需要认证，让用户不用重复地进行登录认证。&lt;code&gt;CAS&lt;/code&gt;单点登录的方案很多，并且大多数都是采用&lt;code&gt;session&lt;/code&gt;的方式，而本文结合个人实践，着重讨论&lt;code&gt;django cas token&lt;/code&gt;的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Django" scheme="https://tony-yin.github.io/tags/Django/"/>
    
      <category term="CAS" scheme="https://tony-yin.github.io/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>Daily Article Vol 5 - (2018/4/1 ~ 2018/4/30)</title>
    <link href="https://tony-yin.github.io/2018/05/01/Daily-Article-Vol5/"/>
    <id>https://tony-yin.github.io/2018/05/01/Daily-Article-Vol5/</id>
    <published>2018-05-01T02:07:06.000Z</published>
    <updated>2018-11-03T17:07:41.150Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/hello_april_600x450.png" alt="April"></center><p>这是<code>Daily Article</code>系列的第五篇，罗列了<code>2018</code>年<code>4</code>月的阅读清单。</p><a id="more"></a><p>本月是在新公司工作的第一个月，主要做了利用<code>python</code>搭建<code>NAS</code>服务稳定性测试框架、<code>CTDB</code>使用<code>rados object</code>作为<code>lock file</code>、利用<code>django</code>做<code>CAS</code>单点登录。首先<code>python</code>搭建<code>NAS</code>服务稳定性测试框架的工作就是通过<code>python</code>对<code>NAS</code>服务进行连接，并进行读写操作，该框架不需要任何挂载操作便可以对<code>NAS</code>服务进行连接和读写操作，目前支持<code>NFS</code>、<code>CIFS</code>和<code>FTP</code>，具体请参考<a href="http://www.tony-yin.top/2018/04/08/python_nas_stable_test/" target="_blank" rel="noopener">基于Python的NAS稳定性测试框架</a>；然后就是<code>CTDB</code>使用<code>rados object</code>作为<code>lockfile</code>这种方案的实践，期间也遇到了<code>Nodes All Banned</code>这种问题并解决了；最后就是采用<code>django-mama-cas</code>作为服务端，<code>django-cas-ng</code>作为客户端，搭建了一套<code>CAS</code>环境，并对目前的项目进行集成。</p><p>个人课余时间的话，一方面关注的是<code>python</code>和<code>django</code>有关的知识，因为工作中要用到，其次就是围绕着<code>ceph</code>和存储相关知识的了解和学习了。上周在扫盲区的过程中，看到了很久之前了解的<code>nvme over fabric</code>这个概念，然后又去深入地了解了一下。这一了解又引申出了无数的盲区，比如<code>RDMA</code>、<code>nvme</code>、<code>nvme overip</code>、<code>FC</code>等等，而这些技术也很新，文档不多，并且大多数都是很枯燥的，只能逼着自己慢慢地啃下去。感慨技术变革真是日新月异的同时，也感慨扫盲区的速度远远赶不上盲区生成的速度，每天都会有好多自己不知道或者不是特别了解原理的概念，等待着自己去学习和深入。不过呢，也正如之前一位前辈讲过，很多人都觉得这个技术牛逼，那个技术牛逼，不是那么容易学会的，也正是因为这种心态，很多人都不去学习，而很多学习的人即使没有到达最顶峰，比不学的人多了解一点就强一些。所以人生苦短，没事多看看总没坏处。</p><p>碎片时间也会看极客时间上面的专栏，我已经买了两个专栏。从目前的观看效果来说，首先我觉得还是不错的，但是很多内容都是概念上面的东西，仿佛是为了写文章而写文章，缺少落地的东西，经常围绕着一个概念反复强调，我觉得还不如多讲讲具体的场景更容易让别人接受一些。对于我而言，分布式，服务治理，服务分发这些概念和场景我都有经历过，所以我还蛮能接受的，我想很多没有经历过这些开发的童鞋直接看也许会感觉到云里雾里的。但是还是那句话，多看一点总是有好处的，因为很多东西你看了，你没到一定层次是不会了解的，你提前看了，也许之后某一天就会有一种豁然开朗的感觉。但是我们还是要讲究方法的，时间是有限的，我们要在有限的时间学习更多的知识。我认为看这些文章，目的不是为了一步登天，获得什么实质效应，事实上他也不会给你这种回报，我们要做的就是从上面获取一些技术概念、原理和本质，由此作为一个引子，自己找项目，找场景去实践，去深入，光说不练假把式，只有实践了才能深入，然后最好的就是能够在产品中不断运用和学习相关技术了，这样才是最好的学习和掌握。因为很多时间如果固步自封，很多概念你都不知道，更别谈去学习了。最后我会专门整理一篇文章，把我看过的极客时间的文章分享出来，这样可以让一些童鞋免费了解和学习，我这边用的是极客时间提供的分享的功能，也不算违规，每次分享只有十个名额，所以大家先到先得。emmm，看很多同学买课很积极，很多同学却很消极，我觉得前者起码有学习的想法，后者就不谈了，但是针对前者我想说的是，不是花的钱越多就有用的，而是学到手，记到脑子里才属于自己的，希望大家都能不断学习，越变越好，happy everyday！</p><ol><li><a href="https://www.jianshu.com/p/6f67a4b9dad3" target="_blank" rel="noopener">django2.0入门教程第一节</a>(4/2) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://www.jianshu.com/p/b8d73d39f184" target="_blank" rel="noopener">django2.0入门教程第二节</a>(4/2) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://www.jianshu.com/p/2004b8dbebb4" target="_blank" rel="noopener">django2.0入门教程第三节</a>(4/2) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://www.jianshu.com/p/e2a09d2a4a2f" target="_blank" rel="noopener">django2.0入门教程第四节</a>(4/2) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://time.geekbang.org/column/article/ed937b37244d4db63f60e5f00be38fce/share" target="_blank" rel="noopener">【极客时间-左耳听风】：分布式系统关键技术：服务调度</a>(4/3)</li><li><a href="http://www.woshipm.com/data-analysis/872543.html" target="_blank" rel="noopener">数据分析入门：初识数据埋点（一）</a>(4/7) <i class="fa fa-star"></i></li><li><a href="https://www.jianshu.com/p/5b33bbd61c48" target="_blank" rel="noopener">docker初体验</a>(4/7)</li><li><a href="https://www.jianshu.com/p/f43659a58d71" target="_blank" rel="noopener">构建FTP文件传输服务器</a>(4/8)</li><li><a href="https://blog.csdn.net/bear_huangzhen/article/details/41806903?from=singlemessage" target="_blank" rel="noopener">FTP文件传输协议</a>(4/8)</li><li><a href="https://www.jianshu.com/p/05212313d0e2" target="_blank" rel="noopener">ftp实现原理以及抓包分析</a>(4/8)</li><li><a href="https://www.jianshu.com/p/e99519739b5e" target="_blank" rel="noopener">Linux下ftp服务搭建之小试牛刀</a>(4/8)</li><li><a href="https://blog.csdn.net/u014245412/article/details/72286348" target="_blank" rel="noopener">python 操作samba文件服务器</a>(4/10) <i class="fa fa-star"></i></li><li><a href="https://yq.aliyun.com/articles/578927?utm_content=m_45816" target="_blank" rel="noopener">佛系程序员的月薪五万指南</a>(4/12) <i class="fa fa-star"></i></li><li><a href="https://lingxiankong.github.io/2013-12-23-python-setup.html" target="_blank" rel="noopener">关于python中的setup.py</a>(4/13) <i class="fa fa-star"></i></li><li><a href="https://time.geekbang.org/column/article/b307919cc599a82c542ec39e7aa3ddc7/share" target="_blank" rel="noopener">【极客时间-左耳听风】：分布式系统关键技术：流量与数据调度</a>(4/16) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="http://blog.sina.com.cn/s/blog_8c243ea30102uxaw.html" target="_blank" rel="noopener">分布式高可用CTDB方案</a>(4/16)</li><li><a href="https://ceph.com/planet/ctdb使用rados-object作为lock-file/" target="_blank" rel="noopener">CTDB使用rados object作为lock file</a>(4/16) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://blog.csdn.net/naipeng/article/details/75045177" target="_blank" rel="noopener">关于CTDB</a>(4/17)</li><li><a href="http://www.zphj1987.com/2017/04/20/where-is-cephfs-data-store/" target="_blank" rel="noopener">Cephfs的文件存到哪里了</a>(4/21)</li><li><a href="http://blog.jobbole.com/56574/" target="_blank" rel="noopener">最佳日志实践</a>(4/22) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://zhuanlan.zhihu.com/p/27363484" target="_blank" rel="noopener">最佳日志实践（v2.0）</a>(4/23) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="http://www.zphj1987.com/2017/06/09/use-graylog-get-Ceph-status/" target="_blank" rel="noopener">使用日志系统graylog获取Ceph集群状态</a>(4/23) <i class="fa fa-star"></i></li><li><a href="http://www.zphj1987.com/2017/07/13/CEPHFS-op-to-graylog/" target="_blank" rel="noopener">Cephfs 操作输出到日志查询系统</a>(4/23) <i class="fa fa-star"></i></li><li><a href="https://blog.csdn.net/xiaqunfeng123/article/details/56675696?locationNum=1&amp;fps=1" target="_blank" rel="noopener">bluestore调研</a>(4/23) <i class="fa fa-star"></i></li><li><a href="https://zhuanlan.zhihu.com/p/24312755" target="_blank" rel="noopener">Python打包时添加非代码文件的坑</a>(4/24)</li><li><a href="https://www.jianshu.com/p/d910a70dfee7" target="_blank" rel="noopener">cephfs介绍和功能测试</a>(4/24)</li><li><a href="http://xiaqunfeng.cc/2017/01/20/%E5%9D%97%E5%AD%98%E5%82%A8%E7%9A%84%E4%B8%96%E7%95%8C/#more" target="_blank" rel="noopener">块存储的世界</a>(4/24) <i class="fa fa-star"></i></li><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432712108300322c61f256c74803b43bfd65c6f8d0d0000#0" target="_blank" rel="noopener">python virtualenv</a>(4/24) <i class="fa fa-star"></i></li><li><a href="http://stackeye.com/2014/08/rpmbuild-in-action/" target="_blank" rel="noopener">rpmbuild实战</a>(4/25) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://zhuanlan.zhihu.com/p/28492389" target="_blank" rel="noopener">使用RPM方式安装Linux软件</a>(4/25)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-rpm/index.html" target="_blank" rel="noopener">RPM 打包技术与典型 SPEC 文件分析</a>(4/25) <i class="fa fa-star"></i></li><li><a href="http://mp.weixin.qq.com/s?src=11&amp;timestamp=1524706491&amp;ver=839&amp;signature=nEMLgYwV4GI9Pd19glqGgJS6DR7sfrZesONMDXvpIWz34-KhzcYGK8h*WE7DjAFpXU9NYztsheG7Doy29A2zEC-V2bw*zFNgXbyy5VK2vRBR83sVVudSgxEsbAN0R8iW&amp;new=1" target="_blank" rel="noopener">RDMA(远程直接内存访问)技术浅析</a>(4/26) <i class="fa fa-star"></i></li><li><a href="https://blog.csdn.net/chenhaifeng2016/article/details/78072498?locationNum=4&amp;fps=1" target="_blank" rel="noopener">RDMA技术</a>(4/26) <i class="fa fa-star"></i></li><li><a href="https://www.csdn.net/article/1970-01-01/302809" target="_blank" rel="noopener">Fabric是否代表网络架构的未来？</a> <i class="fa fa-star-half-full"></i></li><li><a href="http://dy.163.com/v2/article/detail/CDG9CD7G05179LAH.html" target="_blank" rel="noopener">2017下一代数据中心网络研究报告</a>(4/27)</li><li><a href="http://book.51cto.com/art/201105/266135.htm" target="_blank" rel="noopener">统一Fabric和互联云</a>(4/27)</li><li><a href="http://net.zol.com.cn/459/4598330.html" target="_blank" rel="noopener">浅谈数据中心网络架构的发展</a>(4/27) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://blog.csdn.net/memblaze_2011/article/details/51820631" target="_blank" rel="noopener">为了部落：NVMe over Fabric诞生记</a> <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="http://www.cnblogs.com/rodenpark/p/6220519.html" target="_blank" rel="noopener">NVMe over Fabrics：概念、应用和实现</a>(4/28)</li><li><a href="https://blog.csdn.net/u010616442/article/details/70773956" target="_blank" rel="noopener">NVME概述</a>(4/28)</li><li><a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1524808998&amp;ver=841&amp;signature=56U4bzWNuWUqlDANFQNBFPkSc2dX-R*HeLL9y7vN*ha-Ph0PrOfhkEPUfB8R*Gy-SLlwFeMqCUKDneUkeDPfpgT-igBpw77SSCr6Hhl9Ul29OsEMtzY1B2-JPQbBd1vH&amp;new=1" target="_blank" rel="noopener">详谈NVMe over Fabric技术发展简史</a>(4/29) <i class="fa fa-star"></i></li><li><a href="http://www.voidcn.com/article/p-yvycalqd-brm.html" target="_blank" rel="noopener">Django实现CAS+OAuth2</a> <i class="fa fa-star"></i></li><li><a href="https://weibo.com/p/1001603934517592239583?mod=zwenzhang#_loginLayer_1525517479194" target="_blank" rel="noopener">NVMe over Fabric</a> <i class="fa fa-star"></i><i class="fa fa-star"></i></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/hello_april_600x450.png&quot; alt=&quot;April&quot;&gt;&lt;/center&gt;

&lt;p&gt;这是&lt;code&gt;Daily Article&lt;/code&gt;系列的第五篇，罗列了&lt;code&gt;2018&lt;/code&gt;年&lt;code&gt;4&lt;/code&gt;月的阅读清单。&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
      <category term="Daily-Article" scheme="https://tony-yin.github.io/tags/Daily-Article/"/>
    
  </entry>
  
  <entry>
    <title>Ctdb Rados方式导致All Banned的问题</title>
    <link href="https://tony-yin.github.io/2018/04/20/Ctdb-Rados-All-Banned/"/>
    <id>https://tony-yin.github.io/2018/04/20/Ctdb-Rados-All-Banned/</id>
    <published>2018-04-20T05:07:06.000Z</published>
    <updated>2018-11-03T17:07:41.150Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/lock.jpg" alt="lock object"></center><p><code>ctdb</code>最近专门为<code>ceph</code>提供了一种<code>raods object</code>作为文件锁的方式，<code>lock file</code>可以放在对象存储中，而不是<code>cephfs</code>，从而大大降低了系统宕机的延时。在此方案的实践中，我们发现<code>master</code>节点宕机会导致严重的<code>All Banned</code>的问题，本文则围绕该问题展开讨论和提供本人的解决方案。</p><a id="more"></a><p>很多系统都在用<code>ctdb</code>做<code>HA</code>，今天我们讨论的是基于<code>cephfs</code>的<code>ctdb HA</code>方案。<code>ctdb</code>的作用是在一个共享文件系统中，当所有节点都访问同一个文件时，<code>ctdb</code>会选举出一个<code>master</code>节点获得<code>lock</code>，我们之前的做法是把这个<code>lock file</code>放在<code>cephfs</code>的共享目录中，但是当其中某个节点<code>down</code>了之后，会导致<code>cephfs</code>这个目录卡死，进一步导致<code>lock file</code>在其他节点都获取不到，只有等到锁超时了之后才能获取到，而这个超时时间默认是<code>300s</code>，再加上<code>ctdb</code>的监控检测和恢复的时间，切换的时间少则十几分钟，多则几十分钟，这对于高可用场景来说无疑是灾难级的。</p><h2 id="具体场景"><a href="#具体场景" class="headerlink" title="具体场景"></a>具体场景</h2><p><code>ctdb</code>的编译和安装我就不说了，大家可以参考磨渣的文章：<a href="http://www.zphj1987.com/2018/01/06/CTDB-use-rados-object-as-lock-file/" target="_blank" rel="noopener">CTDB使用rados object作为lock file</a>。在<code>ceph</code>集群中所有节点安装好<code>ctdb</code>后，起服务后通过<code>systemctl status ctdb</code>可以发现<code>reclock</code>是通过<code>ctdb_mutex_ceph_rados_helper</code>的方式，就说明<code>ctdb rados</code>的方式配置成功了。</p><p>然后我们可以通过<code>rados -p rbd ls</code>也可以看到自己配置的锁存在于<code>rbd pool</code>中。这时我们断电一个<code>slave</code>节点，一分钟左右后可以实现节点切换。但是我们的测试发现当断网<code>master</code>节点的时候，就会造成长时间的卡住，且节点并不会切换。详细查看可以发现断网后，<code>master</code>节点没有释放<code>lock</code>，然后其他的集群节点选举出了<code>master</code>节点后，试图获取锁，但是由于之前的<code>master</code>节点一直没有释放，所以一直获取不到，然后就不停的去获取，<code>ctdb</code>的机制是如果有不断的这种行为，就会让所有节点<code>All Banned</code>。因为<code>slave</code>节点并不拥有锁，所以不存在之前的问题。</p><p>这个问题是比较严重的，因为不存在超时机制，拥有锁的节点断网或者断电，所以不会因为超时就释放锁。所以就会一直就卡着，并且一直实现不了切换节点。这就意味着一旦这种情况发生，客户的业务就会发生中断，这是无法接受的。并且我们也发现了如果使用原来将<code>lock file</code>放在<code>cephfs</code>目录的方式，断网或者断电主节点并不会发生这种情况，后来大概看了下源码大概是因为<code>cephfs</code>自己的机制会强制释放共享目录中文件的锁。</p><p>具体报错如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# ctdb status</span><br><span class="line">Warning: All nodes are banned.</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们的解决方案没有尝试着修改<code>ctdb</code>的源码，而是通过定时监控<code>ctdb</code>的状态。如果是主节点上面的<code>ctdb</code>，并且如果是<code>rados</code>方式的话，每<code>3</code>分钟查看一下<code>ctdb status</code>的状态，如果有连续两次的状态都是<code>All Banned</code>的话，我们就认为目前主节点发生了不释放锁的问题，我们就主动地删除<code>lock object</code>。部分代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">function check_if_master() &#123;</span><br><span class="line">    MASTER_PNN=$(ctdb recmaster)</span><br><span class="line">    CURRENT_PNN=$(ctdb pnn)</span><br><span class="line">    if [ $MASTER_PNN -eq $CURRENT_PNN ]; then</span><br><span class="line">        echo true</span><br><span class="line">    else</span><br><span class="line">        echo false</span><br><span class="line">    fi  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function get_lock_name() &#123;</span><br><span class="line">    LOCK_INFO=$(grep rados $CTDB_CONFIG_FILE | awk '&#123;print $5&#125;')</span><br><span class="line">    LOCK_NAME=$&#123;LOCK_INFO:0:-1&#125;</span><br><span class="line">    echo $LOCK_NAME</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function monitor_lock() &#123;</span><br><span class="line">    STATUS_FILE=/etc/ctdb/status.txt</span><br><span class="line">    CTDB_STATUS=$(ctdb status 2&gt;&amp;1)</span><br><span class="line">    ALL_BANNED="Warning: All nodes are banned."</span><br><span class="line"></span><br><span class="line">    if [ ! -f "$STATUS_FILE" ]; then</span><br><span class="line">        echo "$CTDB_STATUS" &gt; $STATUS_FILE</span><br><span class="line">    else</span><br><span class="line">        if [ "$CTDB_STATUS" = "$ALL_BANNED" ]; then</span><br><span class="line">            LAST_CTDB_STATUS=$(cat $STATUS_FILE)</span><br><span class="line">            if [ "$LAST_CTDB_STATUS" = "$ALL_BANNED" ]; then</span><br><span class="line">                LOCKNAME=$(get_lock_name)</span><br><span class="line">                echo $(date)" Ctdb all nodes banned: Second time" &gt;&gt; /var/log/monitor_ctdb.log</span><br><span class="line">                echo $(date)" Remove ctdb rados lock: "$LOCKNAME &gt;&gt; /var/log/monitor_ctdb.log</span><br><span class="line">                rados -p rbd rm $LOCKNAME </span><br><span class="line">                echo -n "" &gt; $STATUS_FILE</span><br><span class="line">            else</span><br><span class="line">                echo $(date)" Ctdb all nodes banned: First time" &gt;&gt; /var/log/monitor_ctdb.log</span><br><span class="line">                echo "$ALL_BANNED" &gt; $STATUS_FILE</span><br><span class="line">            fi</span><br><span class="line">        else</span><br><span class="line">            echo -n "" &gt; $STATUS_FILE</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTDB_CONFIG_FILE=/etc/sysconfig/ctdb</span><br><span class="line">if $(grep rados $CTDB_CONFIG_FILE -q); then</span><br><span class="line">    if $(check_if_master); then</span><br><span class="line">        monitor_lock</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><blockquote><p>完整代码地址：<code>https://github.com/tony-yin/Ctdb-Rados-Monitor</code></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>也许我的这种做法不是最优方案，希望遇到同样问题的同学可以一起讨论，拥有更好解决方案的可以一起分享。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/lock.jpg&quot; alt=&quot;lock object&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;code&gt;ctdb&lt;/code&gt;最近专门为&lt;code&gt;ceph&lt;/code&gt;提供了一种&lt;code&gt;raods object&lt;/code&gt;作为文件锁的方式，&lt;code&gt;lock file&lt;/code&gt;可以放在对象存储中，而不是&lt;code&gt;cephfs&lt;/code&gt;，从而大大降低了系统宕机的延时。在此方案的实践中，我们发现&lt;code&gt;master&lt;/code&gt;节点宕机会导致严重的&lt;code&gt;All Banned&lt;/code&gt;的问题，本文则围绕该问题展开讨论和提供本人的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Ctdb" scheme="https://tony-yin.github.io/tags/Ctdb/"/>
    
      <category term="Rados" scheme="https://tony-yin.github.io/tags/Rados/"/>
    
      <category term="HA" scheme="https://tony-yin.github.io/tags/HA/"/>
    
  </entry>
  
  <entry>
    <title>基于Python的NAS稳定性测试框架</title>
    <link href="https://tony-yin.github.io/2018/04/08/python_nas_stable_test/"/>
    <id>https://tony-yin.github.io/2018/04/08/python_nas_stable_test/</id>
    <published>2018-04-08T05:07:06.000Z</published>
    <updated>2018-11-03T17:07:41.150Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/nas.jpg" alt="NAS Stable Test"></center><p>最近公司有个集群一直在跑着，领导想要测测它上面<code>NAS</code>服务的稳定性，也就是看看正常持续的读写会不会导致<code>NAS</code>服务异常，这个其实通过<code>fio</code>或者<code>cosbench</code>这类的工具测试起来很容易，但是这样一是没有挑战性，二是比较机械，可扩展性低。比如并行测试、进程保护和异常通知等等这些是机械地运用工具测试所做不到的，所以我们尝试做了一套基于<code>NAS</code>稳定性测试的框架。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>整个测试框架打包和发布都是通过RPM的方式，方便测试人员一键部署。部署之后测试工作由<code>supervisor</code>管理，实时监控后台进程的运行状态，发生异常时可以进行重启等自动化操作。所有读写操作都是通过<code>python</code> 连接NAS服务，无需做任何挂载工作。主要测试工作是通过<code>celery</code>实现任务调度，支持并行多个NAS服务的读写测试，<code>broker</code>和<code>backend store</code>都采用了<code>rabbitmq</code>。后端注册了<code>register</code>、<code>nfs</code>、<code>cifs</code>和<code>ftp</code>四个<code>job</code>，定时每<code>10</code>分钟执行一次，设置最大开启<code>worker</code>数为<code>5</code>个。<code>Job</code>注册进消息队列中后，<code>celery worker</code>会自动去消费，针对服务器中不同的<code>NAS</code>服务进行读写操作，每个任务的执行结果最后都会记录在日志中，出了异常通过邮件通知管理员。</p><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>整个项目的框架图如下：</p><center><img src="http://ow0mgad6r.bkt.clouddn.com/NAS_Stable_Test%E6%A1%86%E6%9E%B6%E5%9B%BE.png" alt="Nas_Stable_Test架构图"></center><h2 id="NAS服务读写流程"><a href="#NAS服务读写流程" class="headerlink" title="NAS服务读写流程"></a>NAS服务读写流程</h2><p>由于每个<code>NAS</code>服务的测试方式是一致的，所以下面就以单个<code>NAS</code>服务的流程来介绍。首先<code>client</code>端向<code>server</code>的<code>NAS</code>服务端口发起连接，<code>server</code>端接收到<code>client</code>端的请求后建立连接。<code>Client</code>在<code>/tmp</code>目录下生成固定大小<code>1G</code>的文件，并且记录该文件的<code>MD5</code>值，然后将该文件上传至远端NAS服务目录（即对<code>NAS</code>服务进行写操作），上传完成后将该文件从本地删除。接着对之前上传至<code>NAS</code>服务目录的文件进行下载（即对<code>NAS</code>服务进行读操作），下载完成后再次记录文件<code>MD5</code>值，并删除掉远端<code>NAS</code>服务目录对应的文件。最后对两次记录的<code>MD5</code>值进行比较，判断上传和下载的文件是否一致，并将比较结果记录在日志中，再次删除本地下载的文件。<code>NAS</code>服务读写流程图如下：</p><center><img src="http://ow0mgad6r.bkt.clouddn.com/NAS_Stable_Test%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Nas_Stable_Test流程图"></center><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装libnfs"><a href="#安装libnfs" class="headerlink" title="安装libnfs"></a>安装libnfs</h3><p>通过<code>pip</code>安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install libnfs</span><br></pre></td></tr></table></figure><p>一般会报这个错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libnfs/libnfs_wrap.c:2969:25: fatal error: nfsc/libnfs.h: No such file or directory</span><br></pre></td></tr></table></figure><p>这个错看起来是缺少这个头文件的包，但是通过<code>yum search libnfs</code>是找不到相关的包的，所以我们只能去官网下载<code>rpm</code>包然后在安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 下载rpm</span><br><span class="line">wget http://li.nux.ro/download/nux/dextop/el7/x86_64//libnfs-1.9.8-1.el7.nux.x86_64.rpm</span><br><span class="line">wget http://li.nux.ro/download/nux/dextop/el7/x86_64//libnfs-devel-1.9.8-1.el7.nux.x86_64.rpm</span><br><span class="line">## 安装rpm</span><br><span class="line">yum localinstall libnfs-1.9.8-1.el7.nux.x86_64.rpm</span><br><span class="line">yum localinstall libnfs-devel-1.9.8-1.el7.nux.x86_64.rpm</span><br></pre></td></tr></table></figure><h3 id="安装pysmb"><a href="#安装pysmb" class="headerlink" title="安装pysmb"></a>安装pysmb</h3><p>这个比较简单，直接<code>pip</code>安装就可以了，也没遇到什么问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pysmb</span><br></pre></td></tr></table></figure><h2 id="NAS服务相关代码实现"><a href="#NAS服务相关代码实现" class="headerlink" title="NAS服务相关代码实现"></a>NAS服务相关代码实现</h2><p>这里只贴出部分<code>python</code>连接或者操作具体<code>Nas</code>服务的代码实现，如果想要了解或者贡献整个项目，请关注：<a href="https://github.com/tony-yin/python_nas" target="_blank" rel="noopener">Github python_nas项目</a></p><h3 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h3><h4 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def open(self):</span><br><span class="line">    self.nfs = libnfs.NFS(&apos;nfs://&#123;&#125;&apos;.format(self.mount_point))        </span><br><span class="line">    log.info(&apos;nfs connect successfully!&apos;)</span><br></pre></td></tr></table></figure><h4 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h4><p>这里有个关键点就是分段读写文件，避免内存溢出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def read(self):</span><br><span class="line">log.info(&apos;nfs read start...&apos;)</span><br><span class="line">a = self.nfs.open(&apos;/&#123;&#125;&apos;.format(self.filename), mode=&apos;r&apos;)          </span><br><span class="line">with open(self.download_path, &apos;a&apos;) as f:                          </span><br><span class="line">    while True: </span><br><span class="line">        content = a.read(1024*1024)                               </span><br><span class="line">        if content == &apos;&apos;:</span><br><span class="line">            break</span><br><span class="line">        f.write(content)                                          </span><br><span class="line">a.close()</span><br><span class="line">    log.info(&apos;nfs read end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def write(self, content):                                             </span><br><span class="line">log.info(&apos;nfs write start...&apos;)                                    </span><br><span class="line">a = self.nfs.open(&apos;/&#123;&#125;&apos;.format(self.filename), mode=&apos;w+&apos;)         </span><br><span class="line">a.seek(self.file_size)</span><br><span class="line">a.write(content)</span><br><span class="line">a.close()</span><br><span class="line">log.info(&apos;nfs write end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def delete(self):</span><br><span class="line">    log.info(&apos;nfs file delete start...&apos;)</span><br><span class="line">self.nfs.unlink(&apos;/&#123;&#125;&apos;.format(self.filename))</span><br><span class="line">log.info(&apos;nfs file delete end...&apos;)</span><br></pre></td></tr></table></figure><h3 id="CIFS"><a href="#CIFS" class="headerlink" title="CIFS"></a>CIFS</h3><h4 id="Connect-1"><a href="#Connect-1" class="headerlink" title="Connect"></a>Connect</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def open(self):</span><br><span class="line">    self.smb = SMBConnection(</span><br><span class="line">        self.username,</span><br><span class="line">        self.password,</span><br><span class="line">        self.my_name.encode(&apos;utf-8&apos;),</span><br><span class="line">        self.remote_name.encode(&apos;utf-8&apos;),</span><br><span class="line">        use_ntlm_v2=True</span><br><span class="line">    )</span><br><span class="line">    self.smb.connect(self.host, self.port)</span><br><span class="line">    log.info(&apos;cifs connect successfully!&apos;)</span><br></pre></td></tr></table></figure><h4 id="Read-1"><a href="#Read-1" class="headerlink" title="Read"></a>Read</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def read(self):</span><br><span class="line">    log.info(&apos;cifs read start...&apos;)</span><br><span class="line">    file_obj = open(self.download_path, &apos;wb&apos;)</span><br><span class="line">    self.smb.retrieveFile(</span><br><span class="line">        self.directory,</span><br><span class="line">        self.filename,</span><br><span class="line">        file_obj</span><br><span class="line">    )</span><br><span class="line">    file_obj.close()</span><br><span class="line">    log.info(&apos;cifs read end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Write-1"><a href="#Write-1" class="headerlink" title="Write"></a>Write</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def write(self):</span><br><span class="line">log.info(&apos;cifs write start...&apos;)</span><br><span class="line">file_obj = open(self.client_path, &apos;rb&apos;)</span><br><span class="line">self.smb.storeFile(</span><br><span class="line">    self.directory,</span><br><span class="line">    self.filename,</span><br><span class="line">    file_obj</span><br><span class="line"> )</span><br><span class="line">file_obj.close()</span><br><span class="line">log.info(&apos;cifs write end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Delete-1"><a href="#Delete-1" class="headerlink" title="Delete"></a>Delete</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def delete(self):</span><br><span class="line">log.info(&apos;cifs delete start...&apos;)</span><br><span class="line">self.smb.deleteFiles(&apos;path3&apos;, self.filename)</span><br><span class="line">log.info(&apos;cifs delete end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def close(self):</span><br><span class="line">    self.smb.close()</span><br></pre></td></tr></table></figure><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><h4 id="Connect-2"><a href="#Connect-2" class="headerlink" title="Connect"></a>Connect</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def open(self):</span><br><span class="line">    self.ftp = FTP()</span><br><span class="line">    self.ftp.connect(</span><br><span class="line">        host=self.host.encode(&apos;utf-8&apos;),</span><br><span class="line">        port=self.port.encode(&apos;utf-8&apos;)</span><br><span class="line">    )</span><br><span class="line">    self.ftp.login(self.username, self.password)</span><br><span class="line">    log.info(&apos;ftp connect successfully!&apos;)</span><br></pre></td></tr></table></figure><h4 id="Read-2"><a href="#Read-2" class="headerlink" title="Read"></a>Read</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def read(self):</span><br><span class="line">log.info(&apos;ftp read start...&apos;)                                     </span><br><span class="line">buff_size = 1024</span><br><span class="line">fp = open(self.download_path, &quot;wb&quot;)                               </span><br><span class="line">self.ftp.retrbinary(</span><br><span class="line">    &quot;RETR &#123;&#125;&quot;.format(self.filename),</span><br><span class="line">    fp.write,</span><br><span class="line">    buff_size                                                     </span><br><span class="line">)   </span><br><span class="line">fp.close()</span><br><span class="line">log.info(&apos;ftp read end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Write-2"><a href="#Write-2" class="headerlink" title="Write"></a>Write</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def write(self):</span><br><span class="line">log.info(&apos;ftp write start...&apos;)                                    </span><br><span class="line">buff_size = 1024</span><br><span class="line"> fp = open(self.client_path, &quot;rb&quot;)</span><br><span class="line">self.ftp.storbinary(</span><br><span class="line">    &quot;STOR &#123;&#125;&quot;.format(self.filename),</span><br><span class="line">    fp,</span><br><span class="line">   buff_size</span><br><span class="line">)</span><br><span class="line">fp.close()</span><br><span class="line">log.info(&apos;ftp write end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Delete-2"><a href="#Delete-2" class="headerlink" title="Delete"></a>Delete</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def delete(self):</span><br><span class="line">log.info(&apos;ftp delete start...&apos;)</span><br><span class="line">self.ftp.delete(self.filename)</span><br><span class="line">log.info(&apos;ftp delete end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Close-1"><a href="#Close-1" class="headerlink" title="Close"></a>Close</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def close(self):</span><br><span class="line">    self.ftp.quit(self.filename)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还有一些其他的<code>API</code>接口就不一一赘述了，具体实现细节大家可以查看<code>github</code>上面的项目代码，具体地址我会在文末贴出。整个项目的核心是通过<code>celery</code>实现任务的调度，还有全程通过<code>python</code>连接和操作<code>nas</code>服务，后续还会不断完善~~~</p><blockquote><p><strong>项目地址：</strong><a href="https://github.com/tony-yin/python_nas" target="_blank" rel="noopener">https://github.com/tony-yin/python_nas</a></p></blockquote><p><br></p><blockquote><p>参考列表：<br><a href="https://pypi.org/project/libnfs/" target="_blank" rel="noopener">python 操作samba文件服务器</a><br><a href="https://blog.csdn.net/u014245412/article/details/72286348" target="_blank" rel="noopener">python libnfs</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/nas.jpg&quot; alt=&quot;NAS Stable Test&quot;&gt;&lt;/center&gt;

&lt;p&gt;最近公司有个集群一直在跑着，领导想要测测它上面&lt;code&gt;NAS&lt;/code&gt;服务的稳定性，也就是看看正常持续的读写会不会导致&lt;code&gt;NAS&lt;/code&gt;服务异常，这个其实通过&lt;code&gt;fio&lt;/code&gt;或者&lt;code&gt;cosbench&lt;/code&gt;这类的工具测试起来很容易，但是这样一是没有挑战性，二是比较机械，可扩展性低。比如并行测试、进程保护和异常通知等等这些是机械地运用工具测试所做不到的，所以我们尝试做了一套基于&lt;code&gt;NAS&lt;/code&gt;稳定性测试的框架。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Python" scheme="https://tony-yin.github.io/tags/Python/"/>
    
      <category term="NAS" scheme="https://tony-yin.github.io/tags/NAS/"/>
    
  </entry>
  
  <entry>
    <title>Daily Article Vol 4 - (2018/3/1 ~ 2018/3/31)</title>
    <link href="https://tony-yin.github.io/2018/04/01/Daily_Article_Vol4/"/>
    <id>https://tony-yin.github.io/2018/04/01/Daily_Article_Vol4/</id>
    <published>2018-04-01T02:13:25.000Z</published>
    <updated>2018-11-03T17:07:41.150Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/2018_march.jpg" alt="Daily Article 3"></center><p>这个月主要因为离职和入职，花费了大量时间和相关的人沟通，还有办理了很多手续，包括找房子和搬家等等。真是忙的焦头烂额，奢侈地给自己放了一个星期的假期。</p><a id="more"></a><p>离开了工作了两年的公司，真是感慨万千。还没毕业就到这家公司实习，然后提前试用、转正。师父耐心的指导，无论是技术上还是生活上都受益匪浅，帮我扎实地掌握了一名软件开发工程师应该具备的技能；钱总作为<code>CTO</code>仿佛身上一直贴着技术控的标签，殊不知竟各项全能，机缘巧合带我做起了<code>Ceph</code>，这一年中不仅从钱总身上学到了很多高新技术，也从每次吃饭饭桌上、下班路上、地铁上倾听他年轻的故事中受益很多，常常听起来热血沸腾。还有很多帮助过我和关心过我的人就不一一点名了。总之，大家都很厉害，也正是因为如此，在我工作的两年中，我能够不断感受到压力，不断进步，并且以后会一直以你们为我的榜样，以后还要多多指教，多交流多切磋。</p><p>入职了新的公司，规模和规范都比原来上了一个档次，正式了许多，上下班都要打卡，一开始不习惯，下班总是忘记。。还有经常开会，要写很多设计和方案，感觉不像以后有师父和钱总这样带我走了，哈哈，但也多了很多参与感，大事小事都可以提出自己的想法，也可以从同事的想法中学习很多。也是巧合，之前网上因博客结缘的一位小伙伴现在和我同组，负责带我熟悉各方面，顿时轻松了很多，他人也很<code>nice</code>，看的出来很热爱技术，身上有很多值得我学习的点，算是一个挺优秀的同龄人了。总体来说，对新公司的印象还是不错的，好好加油吧！</p><p>这个月我买了极客时间上面陈皓老师（左耳朵耗子）的专栏，没买但想看的朋友可以点击我下面分享的链接观看，每个链接都有十个免费的观看圈，先到先到，如果觉得收获很大的话，建议买了看看，受益绝不止这<code>199</code>哦~~~</p><p>新公司任务调度用到了<code>celery</code>框架，感觉还蛮好用的，还在熟悉中…</p><ol><li><a href="http://www.sebastien-han.fr/blog/2015/04/27/ceph-manually-repair-object/" target="_blank" rel="noopener">Ceph: manually repair object</a>(3/2) <i class="fa fa-star"></i><i class="fa fa-star"></i> </li><li><a href="http://blog.csdn.net/younger_china/article/details/75150261" target="_blank" rel="noopener">【分析】Ceph数据一致性检查 - Scrub的介绍</a>(3/5)</li><li><a href="http://blog.csdn.net/younger_china/article/details/75149045" target="_blank" rel="noopener">【分析】Ceph数据一致性检查 - 端到端的数据校验</a>(3/5)</li><li><a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx5d7aad8e7ec33bfd&amp;redirect_uri=https%3A%2F%2Faccount.geekbang.org%2Faccount%2Foauth%2Fcallback%3Ftype%3Dwechatopen%26ident%3D60f4b1%26redirect%3Dhttps%253A%252F%252Ftime.geekbang.org%252Fcolumn%252Farticle%252F45c83454a044f89f8eff69b8a7dbeac3%252Fshare%253Ffailedurl%253Dhttps%253A%252F%252Ftime.geekbang.org%252Fcolumn%252Farticle%252F45c83454a044f89f8eff69b8a7dbeac3%252Fshare&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=d2b1c68fbd5a953da5f04515e46f9b48&amp;connect_redirect=1#wechat_redirect" target="_blank" rel="noopener">洞悉技术的本质，享受科技的乐趣</a>(3/17)</li><li><a href="https://time.geekbang.org/column/article/e3b6ea4c823d2c319bcbce9a1dc23501/share" target="_blank" rel="noopener">程序员如何用技术变现（上）</a>(3/17) <i class="fa fa-star"></i></li><li><a href="https://time.geekbang.org/column/article/c260269c38db5276c17f1be49718f74a/share" target="_blank" rel="noopener">程序员如何用技术变现（下）</a>(3/17)</li><li><a href="https://time.geekbang.org/column/article/70f255c35f7e58cb008e4410659cb39e/share" target="_blank" rel="noopener">Equifax信息泄露始末</a>(3/18)</li><li><a href="https://time.geekbang.org/column/article/3aa6350a995faf76c32e61ba6f7db3e9/share" target="_blank" rel="noopener">从Equifax信息泄露看数据安全</a>(3/18)</li><li><a href="https://time.geekbang.org/column/article/66c547af27e04afd4b7c2f8444d0971f/share" target="_blank" rel="noopener">何为技术领导力</a>(3/18)</li><li><a href="https://time.geekbang.org/column/article/0294f13512d5b6608115a601eb373287/share" target="_blank" rel="noopener">如何拥有技术领导力</a>(3/18)</li><li><a href="https://time.geekbang.org/column/article/5df06f61f6d635f5fc71b27ccc39902d/share" target="_blank" rel="noopener">每个程序员都该知道的事</a>(3/19)</li><li><a href="https://time.geekbang.org/column/article/af44ced83be43d287e728d2eaee10afc/share" target="_blank" rel="noopener">Go语言，Docker和新技术</a>(3/19)</li><li><a href="https://time.geekbang.org/column/article/946c705caf3299894fcc991bc59992de/share" target="_blank" rel="noopener">答疑解惑：渴望、热情和选择</a>(3/20)</li><li><a href="https://time.geekbang.org/column/article/ef3daa17d473e583835df8248082f6fc/share" target="_blank" rel="noopener">如何成为一个大家愿意追随的Leader？</a>(3/20)</li><li><a href="http://blog.51cto.com/hongtengfei/1684809" target="_blank" rel="noopener">NFS服务详细分析</a>(3/21) <i class="fa fa-star"></i></li><li><a href="http://blog.csdn.net/acs713/article/details/7322082" target="_blank" rel="noopener">理解Linux系统/etc/init.d目录和/etc/rc.local脚本</a>(3/21)</li><li><a href="https://time.geekbang.org/column/article/73253891c16c684d3c9dcfd02dfcb54f/share" target="_blank" rel="noopener">分布式系统架构的冰与火</a>(3/21) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://time.geekbang.org/column/article/a3b4de20403567fbdf305bdd4e403026/share" target="_blank" rel="noopener">从亚马逊的实践，谈分布式系统的难点</a>(3/22) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://blog.csdn.net/a18829898663/article/details/71065999" target="_blank" rel="noopener">访问网络文件共享服务-CIFS</a>(3/23) <i class="fa fa-star"></i></li><li><a href="https://www.liaoxuefeng.com/article/00137760323922531a8582c08814fb09e9930cede45e3cc000" target="_blank" rel="noopener">任务调度利器：Celery</a>(3/26)</li><li><a href="https://www.jianshu.com/p/1840035cb510" target="_blank" rel="noopener">异步任务神器 Celery 简明笔记</a>(3/26)</li><li><a href="http://www.open-open.com/lib/view/open1426298834326.html" target="_blank" rel="noopener">Python 并行分布式框架：Celery</a>(3/26) <i class="fa fa-star"></i></li><li><a href="https://www.jianshu.com/p/9c04890615ba" target="_blank" rel="noopener">Redis实现简单消息队列</a>(3/27) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://www.cnblogs.com/davidshen/p/8145984.html" target="_blank" rel="noopener">cifs协议与samba服务</a>(3/28~3/29) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://linuxtoy.org/archives/selinux-introduction.html" target="_blank" rel="noopener">SELinux 入门</a>(3/29)</li><li><a href="http://www.cnblogs.com/shanyou/archive/2013/02/04/2891300.html" target="_blank" rel="noopener">Ring Buffer 有什么特别?</a>(3/29) <i class="fa fa-star"></i></li><li><a href="https://time.geekbang.org/column/article/f9126577b469b13317889a99ea70d2f0/share" target="_blank" rel="noopener">分布式系统的技术栈</a>(3/30) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://time.geekbang.org/column/article/8efeb52c4015735a7ea424e0cff861c1/share" target="_blank" rel="noopener">分布式系统关键技术：全栈监控</a>(3/31) <i class="fa fa-star"></i><i class="fa fa-star"></i></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/2018_march.jpg&quot; alt=&quot;Daily Article 3&quot;&gt;&lt;/center&gt;

&lt;p&gt;这个月主要因为离职和入职，花费了大量时间和相关的人沟通，还有办理了很多手续，包括找房子和搬家等等。真是忙的焦头烂额，奢侈地给自己放了一个星期的假期。&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
      <category term="Daily-Article" scheme="https://tony-yin.github.io/tags/Daily-Article/"/>
    
  </entry>
  
  <entry>
    <title>硬件环境测试环境模拟</title>
    <link href="https://tony-yin.github.io/2018/03/09/Hardware-Test-Tool/"/>
    <id>https://tony-yin.github.io/2018/03/09/Hardware-Test-Tool/</id>
    <published>2018-03-09T06:35:06.000Z</published>
    <updated>2018-11-03T17:07:41.151Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/hardware-600x450.jpg" alt="hardware"></center><p>最近在做一个<code>feature</code>，测试的时候需要硬件环境的支撑。一般我们开发环境都是虚拟机，所以针对这种开发工作的自测无法进行，比如虚拟机上没有物理磁盘，没有<code>raid</code>卡等，为了一个小功能的测试，需要出<code>build</code>，需要硬件环境的部署和安装，这个工作量着实不小。</p><p>往往针对这种情况，作为开发人员可以针对硬件环境的具体需求，尽可能在自己的环境上做模拟，也就是我们俗称的“打桩”。</p><a id="more"></a><p>就拿我这次做的需求来说吧，我想获取磁盘的相关信息，获取方式是通过<code>raid</code>卡工具，可能是<code>megacli</code>，也可能是<code>sas3ircu</code>等等，这个取决于<code>lspci</code>查看<code>raid</code>卡的型号，然后还要通过<code>lsblk</code>和<code>lsscsi</code>工具获取相关信息。</p><p>我的做法是针对这些工具，自己写一个简易的小工具，就比如<code>lsblk</code>我也写一个<code>lsblk</code>的脚本，里面的代码也很简单，先找一个硬件环境，将<code>lsblk</code>读取的内容重定向到文件中，这时候我们自己写的脚本直接去读这个文件就可以了。务必要保证各个软件工具的一致性。</p><p>以<code>lsblk</code>为例，我可能需求两种情况<code>lsblk</code>和<code>lsblk -l</code>：</p><p><code>lsblk</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash                                                        </span></span><br><span class="line"></span><br><span class="line">lsblk_path=$(dirname $0)</span><br><span class="line">if [ $# -eq 0 ]; then</span><br><span class="line">    echo "$(cat $lsblk_path"/lsblk.txt")"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">while getopts ":l" opt; do</span><br><span class="line">    case $opt in  </span><br><span class="line">        l)  </span><br><span class="line">            echo "$(cat $lsblk_path"/lsblk_list.txt")"</span><br><span class="line">            ;;  </span><br><span class="line">        \?) </span><br><span class="line">            echo "Invalid option: -$OPTARG"</span><br><span class="line">            ;;  </span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><code>lsblk.txt</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">NAME     MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT </span><br><span class="line">sda        8:0    0   3.7T  0 disk </span><br><span class="line">├─sda1     8:1    0  30.5M  0 part ar</span><br><span class="line">├─sda2     8:2    0 488.3M  0 part ar</span><br><span class="line">├─sda3     8:3    0  93.1G  0 part /rt</span><br><span class="line">├─sda4     8:4    0   256G  0 part [SWAP]WA</span><br><span class="line">└─sda5     8:5    0   3.3T  0 part /data/osd.0sd</span><br><span class="line">sdb        8:16   0 372.1G  0 disk </span><br><span class="line">└─sdb1     8:17   0 372.1G  0 part ar</span><br><span class="line">sdc        8:32   0   2.7T  0 disk </span><br><span class="line">└─sdc1     8:33   0   2.7T  0 part /data/osd.1sd</span><br><span class="line">sdd        8:48   0   2.7T  0 disk </span><br><span class="line">└─sdd1     8:49   0   2.7T  0 part /data/osd.2sd</span><br><span class="line">sde        8:64   0   2.7T  0 disk </span><br><span class="line">└─sde1     8:65   0   2.7T  0 part /data/osd.3sd</span><br><span class="line">sdf        8:80   0   2.7T  0 disk </span><br><span class="line">└─sdf1     8:81   0   2.7T  0 part /data/osd.11d.</span><br><span class="line">sdg        8:96   0   2.7T  0 disk </span><br><span class="line">└─sdg1     8:97   0   2.7T  0 part /data/osd.12d.</span><br><span class="line">sdh        8:112  0   2.7T  0 disk </span><br><span class="line">└─sdh1     8:113  0   2.7T  0 part ar</span><br><span class="line">sdi        8:128  0   2.7T  0 disk </span><br><span class="line">└─sdi1     8:129  0   2.7T  0 part /data/osd.8sd</span><br><span class="line">sdj        8:144  0   2.7T  0 disk </span><br><span class="line">└─sdj1     8:145  0   2.7T  0 part /data/osd.9sd</span><br><span class="line">sdk        8:160  0   2.7T  0 disk </span><br><span class="line">└─sdk1     8:161  0   2.7T  0 part /data/osd.10d.</span><br><span class="line">sdl        8:176  0   2.7T  0 disk </span><br><span class="line">└─sdl1     8:177  0   2.7T  0 part ar</span><br><span class="line">sdm        8:192  0   2.7T  0 disk </span><br><span class="line">└─sdm1     8:193  0   2.7T  0 part ar</span><br><span class="line">sdn        8:208  0   2.7T  0 disk </span><br><span class="line">└─sdn1     8:209  0   2.7T  0 part ar</span><br><span class="line">sdo        8:224  0   2.7T  0 disk </span><br><span class="line">└─sdo1     8:225  0   2.7T  0 part</span><br><span class="line">sdp        8:240  0   2.7T  0 disk</span><br><span class="line">└─sdp1     8:241  0   2.7T  0 part</span><br><span class="line">sdq       65:0    0   2.7T  0 disk</span><br><span class="line">└─sdq1    65:1    0   2.7T  0 part</span><br><span class="line">sdr       65:16   0   2.7T  0 disk</span><br><span class="line">└─sdr1    65:17   0   2.7T  0 part</span><br><span class="line">sds       65:32   0   2.7T  0 disk</span><br><span class="line">└─sds1    65:33   0   2.7T  0 part</span><br><span class="line">sdt       65:48   0   2.7T  0 disk</span><br><span class="line">└─sdt1    65:49   0   2.7T  0 part</span><br><span class="line">sdu       65:64   0   2.7T  0 disk</span><br><span class="line">└─sdu1    65:65   0   2.7T  0 part</span><br><span class="line">sdv       65:80   0 744.7G  0 disk</span><br><span class="line">├─sdv1    65:81   0    50G  0 part</span><br><span class="line">├─sdv2    65:82   0    50G  0 part</span><br><span class="line">├─sdv3    65:83   0    50G  0 part</span><br><span class="line">├─sdv4    65:84   0    50G  0 part</span><br><span class="line">├─sdv5    65:85   0    50G  0 part</span><br><span class="line">├─sdv6    65:86   0    50G  0 part</span><br><span class="line">├─sdv7    65:87   0    50G  0 part</span><br><span class="line">├─sdv8    65:88   0    50G  0 part</span><br><span class="line">├─sdv9    65:89   0    50G  0 part</span><br><span class="line">├─sdv10   65:90   0    50G  0 part</span><br><span class="line">├─sdv11   65:91   0    50G  0 part</span><br><span class="line">└─sdv12   65:92   0    50G  0 part</span><br></pre></td></tr></table></figure><p><code>lsblk_list.txt</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0   3.7T  0 disk </span><br><span class="line">sda1     8:1    0  30.5M  0 part </span><br><span class="line">sda2     8:2    0 488.3M  0 part </span><br><span class="line">sda3     8:3    0  93.1G  0 part /</span><br><span class="line">sda4     8:4    0   256G  0 part [SWAP]</span><br><span class="line">sda5     8:5    0   3.3T  0 part /data/osd.0</span><br><span class="line">sdb      8:16   0 372.1G  0 disk </span><br><span class="line">sdb1     8:17   0 372.1G  0 part </span><br><span class="line">sdc      8:32   0   2.7T  0 disk </span><br><span class="line">sdc1     8:33   0   2.7T  0 part /data/osd.1</span><br><span class="line">sdd      8:48   0   2.7T  0 disk </span><br><span class="line">sdd1     8:49   0   2.7T  0 part /data/osd.2</span><br><span class="line">sde      8:64   0   2.7T  0 disk </span><br><span class="line">sde1     8:65   0   2.7T  0 part /data/osd.3</span><br><span class="line">sdf      8:80   0   2.7T  0 disk </span><br><span class="line">sdf1     8:81   0   2.7T  0 part /data/osd.11</span><br><span class="line">sdg      8:96   0   2.7T  0 disk </span><br><span class="line">sdg1     8:97   0   2.7T  0 part /data/osd.12</span><br><span class="line">sdh      8:112  0   2.7T  0 disk </span><br><span class="line">sdh1     8:113  0   2.7T  0 part </span><br><span class="line">sdi      8:128  0   2.7T  0 disk </span><br><span class="line">sdi1     8:129  0   2.7T  0 part /data/osd.8</span><br><span class="line">sdj      8:144  0   2.7T  0 disk </span><br><span class="line">sdj1     8:145  0   2.7T  0 part /data/osd.9</span><br><span class="line">sdk      8:160  0   2.7T  0 disk </span><br><span class="line">sdk1     8:161  0   2.7T  0 part /data/osd.10</span><br><span class="line">sdl      8:176  0   2.7T  0 disk </span><br><span class="line">sdl1     8:177  0   2.7T  0 part </span><br><span class="line">sdm      8:192  0   2.7T  0 disk </span><br><span class="line">sdm1     8:193  0   2.7T  0 part </span><br><span class="line">sdn      8:208  0   2.7T  0 disk </span><br><span class="line">sdn1     8:209  0   2.7T  0 part </span><br><span class="line">sdo      8:224  0   2.7T  0 disk </span><br><span class="line">sdo1     8:225  0   2.7T  0 part</span><br><span class="line">sdp      8:240  0   2.7T  0 disk</span><br><span class="line">sdp1     8:241  0   2.7T  0 part</span><br><span class="line">sdq     65:0    0   2.7T  0 disk</span><br><span class="line">sdq1    65:1    0   2.7T  0 part</span><br><span class="line">sdr     65:16   0   2.7T  0 disk</span><br><span class="line">sdr1    65:17   0   2.7T  0 part</span><br><span class="line">sds     65:32   0   2.7T  0 disk</span><br><span class="line">sds1    65:33   0   2.7T  0 part</span><br><span class="line">sdt     65:48   0   2.7T  0 disk</span><br><span class="line">sdt1    65:49   0   2.7T  0 part</span><br><span class="line">sdu     65:64   0   2.7T  0 disk</span><br><span class="line">sdu1    65:65   0   2.7T  0 part</span><br><span class="line">sdv     65:80   0 744.7G  0 disk</span><br><span class="line">sdv1    65:81   0    50G  0 part</span><br><span class="line">sdv2    65:82   0    50G  0 part</span><br><span class="line">sdv3    65:83   0    50G  0 part</span><br><span class="line">sdv4    65:84   0    50G  0 part</span><br><span class="line">sdv5    65:85   0    50G  0 part</span><br><span class="line">sdv6    65:86   0    50G  0 part</span><br><span class="line">sdv7    65:87   0    50G  0 part</span><br><span class="line">sdv8    65:88   0    50G  0 part</span><br><span class="line">sdv9    65:89   0    50G  0 part</span><br><span class="line">sdv10   65:90   0    50G  0 part</span><br><span class="line">sdv11   65:91   0    50G  0 part</span><br><span class="line">sdv12   65:92   0    50G  0 part</span><br></pre></td></tr></table></figure><p>还有一些其他工具我就不详细贴代码了，具体请去<code>github</code>上查看。</p><p>项目地址：<a href="https://github.com/tony-yin/Hardware_Test_Tool" target="_blank" rel="noopener">https://github.com/tony-yin/Hardware_Test_Tool</a></p><p>操作步骤：</p><p>1.下载代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:tony-yin/Hardware_Test_Tool.git</span><br></pre></td></tr></table></figure><p>2.安装工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build install</span><br></pre></td></tr></table></figure><p>3.卸载工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build uninstall</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/hardware-600x450.jpg&quot; alt=&quot;hardware&quot;&gt;&lt;/center&gt;

&lt;p&gt;最近在做一个&lt;code&gt;feature&lt;/code&gt;，测试的时候需要硬件环境的支撑。一般我们开发环境都是虚拟机，所以针对这种开发工作的自测无法进行，比如虚拟机上没有物理磁盘，没有&lt;code&gt;raid&lt;/code&gt;卡等，为了一个小功能的测试，需要出&lt;code&gt;build&lt;/code&gt;，需要硬件环境的部署和安装，这个工作量着实不小。&lt;/p&gt;
&lt;p&gt;往往针对这种情况，作为开发人员可以针对硬件环境的具体需求，尽可能在自己的环境上做模拟，也就是我们俗称的“打桩”。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Test" scheme="https://tony-yin.github.io/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>Daily Article Vol 3 - (2018/2/1 ~ 2018/2/28)</title>
    <link href="https://tony-yin.github.io/2018/03/01/Daily-Article-Vol3/"/>
    <id>https://tony-yin.github.io/2018/03/01/Daily-Article-Vol3/</id>
    <published>2018-03-01T02:13:25.000Z</published>
    <updated>2018-11-03T17:07:41.150Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/february-600x450.jpg" alt="Daily Article 3"></center><p>这段期间，一方面是因为过年，另一方面因为换工作，所以诸事缠身，导致每天阅读学习的量严重受影响，不能保持每天都有固定的时间学习和阅读，还是自己的问题，不应该找借口。之后，不管什么事情，必须要保证每天的学习量和阅读量，养成雷打不动的好习惯。</p><p>这是<code>Daily Article</code>系列的第三篇，罗列了<code>2018</code>年<code>2</code>月的阅读清单。</p><a id="more"></a><hr><ol><li><a href="https://my.oschina.net/u/2460844/blog/669769" target="_blank" rel="noopener">ceph的数据存储之路(10) —–ceph对象存储的ls命令实现及思考</a>(2/1 ~ 2/5) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://python.jobbole.com/82270/" target="_blank" rel="noopener">八大排序算法的 Python 实现</a>(2/6)</li><li><a href="https://georgezhuo.github.io/georgezhuo.github.io/2015/12/22/ceph-message/" target="_blank" rel="noopener">Ceph解析-消息处理模块</a>(2/7) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://www.wzxue.com/ceph-network/" target="_blank" rel="noopener">解析Ceph: 网络层的处理</a>(2/7)</li><li><a href="http://blog.csdn.net/skdkjzz/article/details/41980631" target="_blank" rel="noopener">ceph存储 ceph集群消息处理</a>(2/8)</li><li><a href="https://my.oschina.net/u/2460844/blog/531646" target="_blank" rel="noopener">ceph的数据存储之路(1) —rbd设备介绍</a>(2/11) <i class="fa fa-star"></i></li><li><a href="https://my.oschina.net/u/2460844/blog/531686" target="_blank" rel="noopener">ceph的数据存储之路(2) —– rbd到osd的数据映射</a>(2/11)</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513393&amp;idx=1&amp;sn=c1d6caca8ef9972f1105df982f15bb58&amp;chksm=80d679f2b7a1f0e410fd53691d68a9ada158aac2b8814fe329d6dfed86ee54b68a53eb84cdb0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">张大胖学递归</a>(2/16) <i class="fa fa-star"></i></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513387&amp;idx=1&amp;sn=99665948d0b968cf15c5e7a01ffe166c&amp;chksm=80d679e8b7a1f0febad077b57e8ad73bfb4b08de74814c45e1b1bd61ab4017b5041942403afb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">张大胖的socket</a>(2/17) <i class="fa fa-star"></i></li><li><a href="https://my.oschina.net/u/2460844/blog/532755?p=2&amp;temp=1519178944837#blog-comments-list" target="_blank" rel="noopener">ceph的数据存储之路(4) —– rbd client 端的数据请求处理</a>(2/18~2/20) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513353&amp;idx=1&amp;sn=a5dc69542fae6aabf0fef9b5f5881a9d&amp;chksm=80d679cab7a1f0dc530bd1745c2c9552b739afc701ecb2f8e1eba8624d1fefc2c3cc64cd1d30&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">学习面向对象的令狐冲</a>(2/21) <i class="fa fa-star"></i></li><li><a href="http://mp.weixin.qq.com/s/wyt-0y3lEhewa2cpeILYSQ" target="_blank" rel="noopener">张大胖学数据库</a>(2/22)</li><li><a href="https://mp.weixin.qq.com/s/tSF_w9xUOj3Q2hmOxJkwLg" target="_blank" rel="noopener">数据库村的旺财和小强</a>(2/23) <i class="fa fa-star"></i></li><li><a href="https://my.oschina.net/u/2460844/blog/534390?p=1&amp;temp=1519628036891#blog-comments-list" target="_blank" rel="noopener">ceph的数据存储之路(5) —–osd数据处理</a>(2/24 ~ 2/26) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDE0NjUxMQ==&amp;mid=2651256389&amp;idx=1&amp;sn=e11edcce5722853f442b9a7b8211787e&amp;chksm=f2901e65c5e79773c7690f29e35dbd1870a5bfdb92c70541979f5d080d6580e3af9ba85fff66&amp;mpshare=1&amp;scene=23&amp;srcid=0502SazrSPsWnszP3xfdEId4#rd" target="_blank" rel="noopener"> Ceph开发每周谈 Vol 70 | RGW 同步到 AWS S3 | Elastic Search API 整合</a>(2/26)</li><li><a href="http://ceph.com/planet/ceph-osd%E4%BB%8Efilestore-%E8%BD%AC%E6%8D%A2%E5%88%B0-bluestore%E7%9A%84%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">Ceph OSD从filestore 转换到 bluestore的方法</a>(2/27)</li><li><a href="https://my.oschina.net/u/2460844/blog/535007" target="_blank" rel="noopener">ceph的数据存储之路(6) —–pg的创建</a>(2/28)</li><li><a href="https://www.sogou.com/link?url=6IqLFeTuIyjnBL6rnEdhCp_rFXz42FvmEhOk1arvVrbkYalcctcthKCfjFS1STqz" target="_blank" rel="noopener">XSKY在OpenStack场景下的优势</a>(2/28)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/february-600x450.jpg&quot; alt=&quot;Daily Article 3&quot;&gt;&lt;/center&gt;

&lt;p&gt;这段期间，一方面是因为过年，另一方面因为换工作，所以诸事缠身，导致每天阅读学习的量严重受影响，不能保持每天都有固定的时间学习和阅读，还是自己的问题，不应该找借口。之后，不管什么事情，必须要保证每天的学习量和阅读量，养成雷打不动的好习惯。&lt;/p&gt;
&lt;p&gt;这是&lt;code&gt;Daily Article&lt;/code&gt;系列的第三篇，罗列了&lt;code&gt;2018&lt;/code&gt;年&lt;code&gt;2&lt;/code&gt;月的阅读清单。&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
      <category term="Daily-Article" scheme="https://tony-yin.github.io/tags/Daily-Article/"/>
    
  </entry>
  
  <entry>
    <title>Daily Article Vol 2 - (2018/1/1 ~ 2018/1/31)</title>
    <link href="https://tony-yin.github.io/2018/02/01/Daily-Article-Vol2/"/>
    <id>https://tony-yin.github.io/2018/02/01/Daily-Article-Vol2/</id>
    <published>2018-02-01T02:07:06.000Z</published>
    <updated>2018-11-03T17:07:41.151Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/2018-01-600x450.png" alt="Daily Article Vol2"></center><p>这是<code>Daily Article</code>系列的第二篇，罗列了<code>2018</code>年<code>1</code>月的阅读清单。</p><a id="more"></a><ol><li><a href="http://datawarehouse4u.info/OLTP-vs-OLAP.html" target="_blank" rel="noopener">OLTP vs. OLAP</a>(1/2)</li><li><a href="http://blog.csdn.net/zhanghaocore/article/details/9820215" target="_blank" rel="noopener">OLTP和OLAP的区别</a>(1/2)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-31/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 31｜ZetaScale 开源 | DMClock</a>(1/2)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-32/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 32｜Ceph-osd on 4.x 内核异常</a>(1/3)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-33/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 33｜Encode 改进方案</a>(1/3)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-34/" target="_blank" rel="noopener">Ceph开发每周谈Vol 34 | Ceph Days 亚太路演 | Ceph OSD CLASS 支持 LUA 编程</a>(1/3)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-35/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 35 | Ceph Developer Month</a>(1/3)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-36/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 36|Ebay 的 CephFS 使用深度报告</a>(1/4)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-37/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 37｜NVME Over Fabric｜FAST</a>(1/4)</li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665514131&amp;idx=1&amp;sn=a11640045e1458c0e3ba866d23541526&amp;chksm=80d67cd0b7a1f5c6c4dee2cb64b6f173524d443dae8be471bb901eebeec4db5d1773818080b7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">【码农翻身】 浏览器：一个家族的奋斗</a>(1/6) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665514143&amp;idx=1&amp;sn=28ea209c00309e6b93d8d1f76032d7a4&amp;chksm=80d67cdcb7a1f5ca81d8d454a98af56d58b22f6058f100e21ff30e70867ea6e3e922a4f000bf&amp;scene=21%23wechat_redirect" target="_blank" rel="noopener">【码农翻身】 浏览器家族的安全反击战</a>(1/6) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://mp.weixin.qq.com/s/YvYvL0siJT1UhO0tXnYVNA" target="_blank" rel="noopener">【码农翻身】 黑客三兄弟</a>(1/6) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513220&amp;idx=1&amp;sn=bb9c4df63cf6994d6aab9d77a10fe628&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">【码农翻身】 GitHub/Stackoverflow 找工作时有什么用？</a>(1/6)</li><li><a href="https://mp.weixin.qq.com/s/-BMCUuIWYE3O_oC3ZNNJRg" target="_blank" rel="noopener">【码农翻身】 我是一个线程(修订版)</a>(1/7) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://www.freeoa.net/osuport/botinstal/instal-compile-linux-ipvs-mod_3170.html" target="_blank" rel="noopener">Linux下安装编译IPVS内核模块</a>(1/8) <i class="fa fa-star"></i></li><li><a href="https://www.tuicool.com/articles/RfmI3u" target="_blank" rel="noopener">How to Repack Deb Files on Debian and Ubuntu</a> <i class="fa fa-star"></i>(1/8)</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665514224&amp;idx=1&amp;sn=5b802dfab658a626a197635cf56c9bac&amp;chksm=80d67cb3b7a1f5a585f778b28ceb88855b140ff090c0d0b00f10e9e9b889c81c20190ba80a06&amp;scene=38#wechat_redirect" target="_blank" rel="noopener">什么是DevOps</a> <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star-half-full"></i>(1/8)</li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=416915373&amp;idx=1&amp;sn=f80a13b099237534a3ef777d511d831a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">我是一个线程</a> <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star-half-full"></i>(1/8)</li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513059&amp;idx=1&amp;sn=a2eaf97d9e3000d15a33681d1b720463&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Javascript: 一个屌丝的逆袭</a> <i class="fa fa-star"></i><i class="fa fa-star"></i>(1/9)</li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513094&amp;idx=1&amp;sn=a2accfc41107ac08d74ec3317995955e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">TCP/IP 之 大明王朝的邮差</a> <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i>(1/9)</li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513375&amp;idx=1&amp;sn=e11745d5cb28fa1f89465f8d0e5fae1a&amp;chksm=80d679dcb7a1f0cadec0a1db45b3fa3f6eabde4a9e56a77acf551fbc1511e6b8f055ee2c97e3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">TCP/IP 之 大明内阁</a> <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i>(1/9)</li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513384&amp;idx=1&amp;sn=82c45e4430618270a744e212d2f57990&amp;chksm=80d679ebb7a1f0fd27fe1814765a0e60b1c293ca4e09403271b4bb3f38f317439956fdca1bc1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">TCP/IP 之 蓟辽督师</a> <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i>(1/10)</li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513017&amp;idx=1&amp;sn=5550ee714abd36d0b580713f673e670b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">CPU 阿甘</a> <i class="fa fa-star"></i>(1/10)</li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513254&amp;idx=1&amp;sn=a4d1912b6259c3e65c0e172fb5a10dbb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">CPU 阿甘之烦恼</a> <i class="fa fa-star"></i>(1/10)</li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NTU2MTQwNA==&amp;mid=2650655754&amp;idx=1&amp;sn=0b03b942ecdb25ef45ea3a9cbff686c3&amp;chksm=beffc6d989884fcf49c79c662162ed7852b17e192b7f40fcda040308eb10b26a9b187f675940&amp;scene=0&amp;key=78733623947167cee9eb37fa8148459e73e455140b258998bf251e0d57524ceaaa6187e820f481781748d004b780efc58804a25dfdf285670ca35369d0e62d2d8e7cd8ca84306d36da7105f9c8042683&amp;ascene=0&amp;uin=MjEzMTAwMzgyNQ%3D%3D&amp;devicetype=iMac+MacBookAir7%2C1+OSX+OSX+10.12.6+build(16G29)&amp;version=12020810&amp;nettype=WIFI&amp;lang=zh_CN&amp;fontScale=100" target="_blank" rel="noopener">开源万岁！2018 年开源技术的 10 大发展趋势</a>(1/10)</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIxMTE0ODU5NQ%3D%3D&amp;mid=2650236979&amp;idx=1&amp;sn=71f07d1741a57f8fd429d76d37fd8a07&amp;chksm=8f5a026fb82d8b7931f95e747224b1049d1b0cf72f72babbf6629e183fa15c72570be4fc7253" target="_blank" rel="noopener">面试过阿里等互联网大公司，我知道了这些套路</a>(1/11)</li><li><a href="https://www.oschina.net/question/2928191_2272289" target="_blank" rel="noopener">访谈 | 鸟哥惠新宸：程序员应该不断提升自身的不可替代性</a>(1/15)</li><li><a href="https://mp.weixin.qq.com/s/_-7C_ZfFfvNKhBQzSB6j4Q" target="_blank" rel="noopener">黑客三兄弟（续）</a> <i class="fa fa-star"></i><i class="fa fa-star"></i>(1/19)</li><li><a href="https://mp.weixin.qq.com/s/vyHlB9pem4rv4htJS9ca6Q" target="_blank" rel="noopener">我是一个网卡</a> <i class="fa fa-star"></i><i class="fa fa-star"></i>(1/20)</li><li><a href="https://mp.weixin.qq.com/s/VyGQ4-Dn4UX2Z0CrCHgUqw" target="_blank" rel="noopener">我是一个路由器</a> <i class="fa fa-star"></i><i class="fa fa-star"></i>(1/21)</li><li><a href="https://mp.weixin.qq.com/s/KtHxMoc1_3sQd4d_MuKKJA" target="_blank" rel="noopener">我是一个进程</a> <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i>(1/22)</li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513289&amp;idx=1&amp;sn=ab19dcad7b1dc217463f155fe106091a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">我是一块硬盘（上）</a> <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star-half-full"></i>(1/22)</li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513292&amp;idx=1&amp;sn=5b1c87dc72a20c92883924080174b16b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">我是一块硬盘（下）</a> <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star-half-full"></i>(1/23)</li><li><a href="https://mp.weixin.qq.com/s/gliuPj9tfZkr9oXQn9re2w" target="_blank" rel="noopener">如何维护一个好的技术博客？</a> <i class="fa fa-star"></i>(1/23)</li><li><a href="https://mp.weixin.qq.com/s/643URs9k_EQIMWGmb35QkQ" target="_blank" rel="noopener">算法分析神器—时间复杂度</a> <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star-half-full"></i>(1/23)</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513299&amp;idx=1&amp;sn=264f4d0891e1b96fb5e356dc7b6c91dc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">我是一个键盘</a> <i class="fa fa-star"></i><i class="fa fa-star"></i> (1/24)</li><li><a href="https://mengkang.net/1129.html" target="_blank" rel="noopener">PHP 面试题 - 如果没有 mb 系列函数，如何切割多字节字符串</a>(1/28)</li><li><a href="http://www.quts.me/ceph-readwrite/" target="_blank" rel="noopener">ceph读写流程分析</a>(1/28)</li><li><a href="https://segmentfault.com/a/1190000013010835" target="_blank" rel="noopener">Token 认证的来龙去脉</a>(1/29) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://bean-li.github.io/ceph-read-flow/" target="_blank" rel="noopener">ceph 读流程(1)</a>(1/29) <i class="fa fa-star"></i></li><li><a href="https://mp.weixin.qq.com/s/gI1TjeAYjqgNo4RKqEqF-Q" target="_blank" rel="noopener">一个项目做完以后，不能就让它这么“完”了</a>(1/30)</li><li><a href="https://mp.weixin.qq.com/s/hDKQ1ITzTvi20kTA11xa1g" target="_blank" rel="noopener">科学与星球大战：当科幻遇到现实</a>(1/30) <i class="fa fa-star"></i></li><li><a href="https://bean-li.github.io/ceph-read-2/" target="_blank" rel="noopener">ceph 读流程(2)</a>(1/31) <i class="fa fa-star"></i></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/2018-01-600x450.png&quot; alt=&quot;Daily Article Vol2&quot;&gt;&lt;/center&gt;

&lt;p&gt;这是&lt;code&gt;Daily Article&lt;/code&gt;系列的第二篇，罗列了&lt;code&gt;2018&lt;/code&gt;年&lt;code&gt;1&lt;/code&gt;月的阅读清单。&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
      <category term="Daily-Article" scheme="https://tony-yin.github.io/tags/Daily-Article/"/>
    
  </entry>
  
  <entry>
    <title>实现RBD导出NFS高可用（二）：提供多虚拟IP访问</title>
    <link href="https://tony-yin.github.io/2018/01/28/RBD-HA-2/"/>
    <id>https://tony-yin.github.io/2018/01/28/RBD-HA-2/</id>
    <published>2018-01-28T05:07:06.000Z</published>
    <updated>2018-11-03T17:07:41.151Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/rbd2-600x450.jpg" alt="RBD-HA-2"></center><p>之前分享过一篇<a href="http://www.tony-yin.top/2017/12/07/RBD-HA/" target="_blank" rel="noopener">【通过 Keepalived 实现 Ceph RBD 的高可用】</a>，主要讲解了将<code>RBD</code>导出为<code>NFS</code>，然后通过<code>keepalived</code>实现高可用，保证当提供虚拟<code>IP</code>节点发生故障时，可以自动切换节点，使得业务不发生中断。</p><p>这样可以基本使用<code>RBD</code>代替<code>CephFS</code>对外提供<code>Ceph</code>服务，至于为什么不用<code>CephFS</code>就不多说了，不清楚的可以去看上一篇。虽然说这样可以保证无单点故障，但是有一点还是不如<code>CephFS</code>，那就是<code>CephFS</code>可以实现多节点同时提供服务，而<code>RBD</code>说白了其实同时只有一个节点能提供服务，当客户端流量高的时候，<code>RBD</code>方式的带宽并不能满足需求。就比如都是三个节点，<code>CephFS</code>可以将客户端流量分流到三个节点，而<code>RBD</code>只能用一个节点，而带宽上限又取决与网卡、磁盘和<code>IO</code>等等原因，所以同样的硬件设施<code>RBD</code>的带宽性能是跟不上的，本文就多虚拟<code>IP</code>暴露访问方式进行分享。</p><a id="more"></a><h2 id="CephFS-amp-RBD"><a href="#CephFS-amp-RBD" class="headerlink" title="CephFS &amp; RBD"></a>CephFS &amp; RBD</h2><p>此前的文章我们<code>Ceph</code>集群只有一个<code>RBD image</code>，并且只通过一个<code>vip</code>暴露这个<code>image</code>让客户端通过<code>NFS</code>访问。这与<code>CephFS</code>的差距就在没有充分利用每个节点的资源，所以我们可以大胆设想一下是否可以通过<code>RBD</code>对外提供多个<code>vip</code>，每个节点都能被<code>NFS</code>访问呢？理想很美好，现实很残酷。如果一个<code>RBD</code>对多个节点同时提供读写的话，会导致不一致的后果，现在<code>RBD</code>并不能做到<code>CephFS</code>那样多个节点同时提供服务且保证读写一致。那怎么办呢？</p><p>虽然一个<code>RBD image</code>不能同时被多客户端访问，但是我们是否可以创建多个<code>RBD image</code>，然后利用多个<code>vip</code>对外提供访问呢？这样听起来貌似可行，但是还是存在诸多问题，比如如何暴露多虚拟<code>IP</code>，如何将<code>IP</code>绑定到具体的<code>RBD image</code>，如何保证多<code>RBD image</code>的高可用等等，下文将就这些技术细节进行详细地分析。</p><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>客户端有多种应用场景，对流量要求较高的情况下，我们可以为每一种应用场景都提供一个<code>vip</code>用于<code>NFS</code>方式访问<code>Ceph</code>存储集群。然后每个<code>vip</code>各自对应集群中的一个<code>RBD image</code>，<code>RBD image</code>尽量均匀的分布到各个节点上，这样才能把性能提升到最高，比如集群有三个节点的话，如果暴露三个<code>vip</code>，那么必须要分布到三个不同的节点上，如果要提供四个<code>vip</code>的话，那么前三个<code>vip</code>均匀地分布到三个节点上，第四个<code>vip</code>就在第一个节点上暴露，以此类推，这边说的第一个节点只是我们自己将三个节点进行逻辑上的排序，我们需要通过一些算法确保<code>vip</code>分布均匀，具体看下文分析。</p><h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><p>一般在完成一个<code>feature</code>之前，我们往往需要做一个<code>design</code>，对要做的事情和流程进行设计和评估，这样不但可以梳理流程，使得之后动手的时候思路清晰，更重要的是可以预见一些问题和难点，尽早与 团队成员进行交流，选择最佳方案，防止真正做的时候走弯路。这边涉及的技术点主要有：</p><h3 id="Keepalived暴露多个VIP"><a href="#Keepalived暴露多个VIP" class="headerlink" title="Keepalived暴露多个VIP"></a>Keepalived暴露多个VIP</h3><p><code>keepalived</code>暴露单个<code>vip</code>很常见，具体格式网上都有，而暴露多个<code>vip</code>就要注意一些细节，比如<code>router_id</code>，<code>ins_name</code>，<code>priority</code>等等，对于一个节点而言，它上面<code>keepalived</code>暴露<code>vip</code>的情况完全是由配置文件<code>keepalived.conf</code>所决定的，而对于<code>keepalived.conf</code>而言，一个<code>vip</code>其实就是<code>ins</code>，而<code>ins_name</code>和<code>router_id</code>要求同一个<code>keepalived</code>组内成员相同，我们这边就默认<code>router_id</code>就是<code>vip</code>隔着小数点的四位整数相加的和，而<code>ins_name</code>则是将<code>vip</code>的小数点换成下划线。</p><h3 id="VIP动态均匀分布"><a href="#VIP动态均匀分布" class="headerlink" title="VIP动态均匀分布"></a>VIP动态均匀分布</h3><p><code>vip</code>均匀分布要保证尽可能的均匀，比如三个节点，如果要提供两个<code>vip</code>的话，那就随意挑选两个节点作为<code>vip</code>绑定，如果四个<code>vip</code>的话，则是三个节点各自绑定一个<code>vip</code>后再任意选择一个节点作为第四个<code>vip</code>绑定。我们这边的做法是先将所有节点进行排序，将两个节点作为一个<code>keepalived</code>组，下两个节点为另外一组，假设有三个节点，我们设为<code>1, 2, 3</code>，那么如果要暴露三个<code>vip</code>，我们就需要三个<code>keepalived</code>组，这边三个组分别是<code>1, 2</code>，<code>3, 1</code>和<code>2, 3</code>，然后组内其中第一个节点为<code>master</code>，第二个节点为<code>backup</code>。这样可以基本保证所有<code>vip</code>的均匀分布，具体算法实现参见下文。</p><h3 id="多RBD高可用"><a href="#多RBD高可用" class="headerlink" title="多RBD高可用"></a>多RBD高可用</h3><p>上一篇文章中只有一个<code>RBD</code>，所以高可用就围绕它一个，发生故障后随意切换节点即可，因为我们每个节点都是一个<code>keepalived</code>组的成员。但是如果有多个<code>RBD</code>的话，我们如果随意切换的话，那么<code>RBD</code>分布就会变得不均匀。上文提及的算法可以保证<code>vip</code>的均匀分布，两两节点作为一个<code>keepalived</code>组，这样我们即使一个节点掉了，切换也只会在当前组内切换，而<code>vip</code>一开始绑定节点的时候就根据相应算法保证了每个<code>RBD</code>的均匀分布，所以这边组内切换不会影响分布的均匀性。</p><p>上一篇文章中提过<code>keepalived</code>的机制，当主节点<code>down</code>了，主节点会触发我们自己写的<code>ChangetoBackup.sh</code>，而副节点则会触发<code>ChangetoMaster.sh</code>。之前由于只有一个<code>RBD</code>，所以当时做的比较无脑，<code>ChangetoMaster.sh</code>直接遍历当前节点上面的所有<code>RBD</code>，然后通过之前记录的<code>RBD</code>和<code>UI</code>上创建的<code>目录</code>的映射关系进行挂载，而<code>ChangetoBackup.sh</code>也是一样的<code>umount</code>所有<code>RBD</code>的挂载点。针对目前的多<code>RBD</code>的情况，这样的做法肯定是不行的，因为现在我们一个节点可能是一个或多个<code>vip</code>的<code>master</code>，也可能是另外一个或多个<code>vip</code>的<code>backup</code>，如果我们还是像之前那样一股脑的全部卸载或者挂载，那么造成的后果显而易见，就是业务中断，暴露服务节点紊乱。所以最合理的应该对号入座，一个<code>vip</code>对应一个<code>RBD image</code>，哪个<code>vip</code>出现了问题，作为该<code>vip</code>的<code>master</code>节点，应该只<code>umount</code>该<code>vip</code>绑定<code>RBD</code>所对应的目录，而<code>backup</code>节点应该只<code>mount</code>对应的目录。其他不相关<code>RBD</code>和其对应的目录，我们都不应该有所操作。那么我们只有在触发<code>ChangetoMaster.sh</code>和<code>ChangetoBackup.sh</code>这两个脚本的时候加上“目录”这个参数，具体实现详见下文分析。</p><h3 id="大容量RBD-image的创建和删除"><a href="#大容量RBD-image的创建和删除" class="headerlink" title="大容量RBD image的创建和删除"></a>大容量RBD image的创建和删除</h3><p>我们系统的实现是<code>UI</code>上创建目录，后端<code>daemon</code>轮询根据目录信息做对应的事情，比如前端<code>UI</code>创建了目录，后端就是在创建<code>RBD image</code>，而生产环境上面的容量的要求都是很高的，往往都是几十<code>T</code>，甚至上百<code>T</code>,但是熟悉<code>RBD</code>的朋友都知道创建如此大的<code>RBD image</code>是需要很长的时间的，那这样就不但会影响当前目录能够提供服务的时间，也会阻塞住代码，影响之后目录的创建。之前我们的做法是一开始我们可以创建一个比较小的<code>image</code>，然后我们后台选择在业务不繁忙的时候进行定时扩容，这也可以算是暂时止血了。但是后来测试发现删除<code>image</code>才是真的慢，这边就不像创建那样有曲线救国的方式了，所以这边无论是创建还是删除<code>RBD image</code>我们都不能做成同步的方式了，我们采取了另起一个线程单独做这个事情，不影响后端业务的正常处理。</p><h3 id="快照保证扩容的安全性"><a href="#快照保证扩容的安全性" class="headerlink" title="快照保证扩容的安全性"></a>快照保证扩容的安全性</h3><p>在我们的测试过程中，发现对<code>RBD image</code>扩容会偶尔发生文件系统出错的情况，这种情况是很危险的，一旦文件系统发生问题，并且用<code>e2fsck</code>等工具修复不了的话，那么数据恢复是很困难的，我们必须要保证客户数据的安全性。所以我们用了<code>RBD</code>的<code>snapshot</code>的功能，在每次扩容之前为<code>RBD image</code>做快照，这样即使发生了问题，我们起码可以做到最小程度的损失。</p><h2 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h2><h3 id="Keepalived暴露多个VIP-1"><a href="#Keepalived暴露多个VIP-1" class="headerlink" title="Keepalived暴露多个VIP"></a>Keepalived暴露多个VIP</h3><p>当<code>UI</code>创建一个<code>vip</code>的时候，我们就要加一个<code>ins</code>，以下就是我们添加一个<code>ins</code>的<code>API</code>，本文所有代码都是<code>python</code>写的，大家凑合看吧。（部分代码和接口不是很全，文章尾部将会贴出详细代码的地址）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_keepalived_ins</span><span class="params">(self, vip, folder, state)</span>:</span></span><br><span class="line">    vrrp_ins = <span class="string">"""</span></span><br><span class="line"><span class="string">vrrp_instance VI_&#123;ins_name&#125; &#123;&#123;</span></span><br><span class="line"><span class="string">    state &#123;state&#125;</span></span><br><span class="line"><span class="string">    interface &#123;pubif&#125;</span></span><br><span class="line"><span class="string">    priority &#123;priority&#125;</span></span><br><span class="line"><span class="string">    virtual_router_id &#123;router_id&#125;</span></span><br><span class="line"><span class="string">    advert_int 1</span></span><br><span class="line"><span class="string">    authentication &#123;&#123;</span></span><br><span class="line"><span class="string">        auth_type PASS</span></span><br><span class="line"><span class="string">        auth_pass 1111</span></span><br><span class="line"><span class="string">    &#125;&#125;</span></span><br><span class="line"><span class="string">    track_script &#123;&#123;</span></span><br><span class="line"><span class="string">        chk_nfs</span></span><br><span class="line"><span class="string">    &#125;&#125;</span></span><br><span class="line"><span class="string">    notify_master "/etc/keepalived/ChangeToMaster.sh &#123;folder&#125;"</span></span><br><span class="line"><span class="string">    notify_backup "/etc/keepalived/ChangeToBackup.sh &#123;folder&#125;"</span></span><br><span class="line"><span class="string">    virtual_ipaddress &#123;&#123;</span></span><br><span class="line"><span class="string">        &#123;vip&#125;</span></span><br><span class="line"><span class="string">    &#125;&#125;</span></span><br><span class="line"><span class="string">&#125;&#125;</span></span><br><span class="line"><span class="string">"""</span>.format(ins_name = vip.replace(<span class="string">'.'</span>, <span class="string">'_'</span>).replace(<span class="string">'/'</span>, <span class="string">'_'</span>),</span><br><span class="line">           state = state,</span><br><span class="line">           priority =  <span class="number">200</span> <span class="keyword">if</span> state == <span class="string">"MASTER"</span> <span class="keyword">else</span> <span class="number">100</span>,</span><br><span class="line">           router_id = self.get_router_id(vip),</span><br><span class="line">           pubif = get_public_interface(),</span><br><span class="line">           folder = folder,</span><br><span class="line">           vip = vip)</span><br><span class="line">        <span class="keyword">return</span> vrrp_ins</span><br></pre></td></tr></table></figure><p>这边我们可以看到<code>ins_name</code>和<code>router_id</code>都是根据<code>vip</code>转换成特定格式，标识<code>ins</code>的唯一性。而<code>priority</code>则是根据<code>state</code>来决定，<code>state</code>为<code>master</code>时，<code>priority</code>为<code>200</code>，而<code>backup</code>的<code>priority</code>为<code>100</code>。至于如何获取<code>state</code>，这个涉及到<code>vip</code>均匀算法，后续会讲。</p><h3 id="VIP动态均匀分布-1"><a href="#VIP动态均匀分布-1" class="headerlink" title="VIP动态均匀分布"></a>VIP动态均匀分布</h3><p>假设三个节点，为<code>1, 2, 3</code>，三个<code>vip</code>，为<code>a, b, c</code>，那么最后<code>a</code>对应的节点为<code>1, 2</code>，<code>b</code>对应的节点为<code>3, 1</code>，<code>c</code>对应的节点为<code>2, 3</code>，具体实现算法是先将所有<code>vip</code>进行排序，获取要操作<code>vip</code>的<code>index</code>，然后获取集群内所有节点，然后将上面获取的<code>index</code>乘以<code>2</code>，再对所有节点的个数做余数，然后可以获得一个整数，这个整数就是<code>vip</code>对应<code>master</code>节点在所有节点数组中的<code>index</code>，这种算法大家应该很容易从规律中推算出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_my_state</span><span class="params">(self, vip_idx)</span>:</span></span><br><span class="line">    nodes = get_all_nodes()</span><br><span class="line">    nodes.sort()</span><br><span class="line">    idx = vip_idx * <span class="number">2</span> % len(nodes)</span><br><span class="line">    my_ip = get_public_ip()</span><br><span class="line">    <span class="keyword">if</span> my_ip == nodes[idx]:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'MASTER'</span></span><br><span class="line">    <span class="keyword">elif</span> my_ip == nodes[(idx + <span class="number">1</span>) % len(nodes)]:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'BACKUP'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h3 id="多RBD高可用-1"><a href="#多RBD高可用-1" class="headerlink" title="多RBD高可用"></a>多RBD高可用</h3><p>我们在创建目录的时候，需要获取当前节点是否为<code>master</code>，之前那个只有一个<code>vip</code>，所以当前节点要么是<code>master</code>，要么是<code>backup</code>，但是这边的话，一个节点可能是一个<code>vip</code>的<code>master</code>的同时也可能是另一个<code>vip</code>的<code>backup</code>，所以是否为<code>master</code>是要根据目录而定的。在这边我们在创建目录、删除目录、创建<code>vip</code>和删除<code>vip</code>时，更新一个<code>vip</code>和目录之间的映射关系。这个<code>map</code>我是存在<code>ceph</code>的<code>leveldb</code>中，至于为什么不存在节点本地，是因为这份数据必须要保证所有节点强一致，放在本地节点，可能会因为一些故障原因导致之后内容不一致的情况。</p><p>这边我们要求在创建目录前，必须要存在空闲<code>vip</code>可以提供目录绑定。所以当创建一个<code>vip</code>时，此时应该没有目录需要绑定，我们建立一个<code>key</code>和<code>value</code>都是<code>vip</code>的字典；当创建一个目录的时候，随机找到一个空闲<code>vip</code>进行绑定，建立一个<code>key</code>为<code>vip</code>，<code>value</code>为目录名的字典；当删除<code>vip</code>时，肯定是存在其他空闲<code>vip</code>的，所以在删除原来对应<code>map</code>后，我们要找到其他一个空闲<code>vip</code>与之前删除<code>vip</code>对应的目录进行绑定；当删除目录时，只要将对应关系中的<code>value</code>换成<code>key</code>，也就是对应的<code>vip</code>了。</p><p>有了这个<code>map</code>，我们就可以实时获取目录和<code>vip</code>的信息和之间的对应关系。</p><p><code>vip.py</code></p><p>负责当<code>vip</code>发生变化时，更新<code>ip_folder_map</code>，以及<code>ip_folder_map</code>的读写<code>API</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ip_folder_map</span><span class="params">()</span>:</span></span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    ip_folder_map = LevelDB(<span class="string">"ip_folder_map"</span>)</span><br><span class="line">    result = json.loads(ip_folder_map)[<span class="string">"ip_folder_map"</span>]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_ip_folder_map</span><span class="params">(ip_folder_map)</span>:</span></span><br><span class="line">    ip_folder_map = LevelDB(<span class="string">"ip_folder_map"</span>)</span><br><span class="line">    ip_folder_map.set(json.dumps(&#123;<span class="string">"ip_folder_map"</span>: ip_folder_map&#125;))</span><br><span class="line">    ip_folder_map.save()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_ip_folder_map_by_ip</span><span class="params">(ips)</span>:</span></span><br><span class="line">    ip_folder_map = get_ip_folder_map()</span><br><span class="line">    old_ips = ip_folder_map.keys()</span><br><span class="line">    <span class="keyword">if</span> len(ips) &gt; len(old_ips):</span><br><span class="line">        new_ip = list(set(ips) - set(old_ips))[<span class="number">0</span>]</span><br><span class="line">        ip_folder_map[new_ip] = new_ip</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        del_ip = list(set(old_ips) - set(ips))[<span class="number">0</span>]</span><br><span class="line">        folder = ip_folder_map[del_ip]</span><br><span class="line">        <span class="keyword">del</span> ip_folder_map[del_ip]</span><br><span class="line">        <span class="keyword">if</span> folder != del_ip:</span><br><span class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> ip_folder_map.iteritems():</span><br><span class="line">                <span class="keyword">if</span> k == v:</span><br><span class="line">                    ip_folder_map[k] = folder</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">    set_ip_folder_map(ip_folder_map)</span><br></pre></td></tr></table></figure><p><code>folder.py</code></p><p>负责当<code>folder</code>发生变化时，更新<code>ip_folder_map</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vip</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_ip_folder_map_by_folder</span><span class="params">(folder, type)</span>:</span></span><br><span class="line">    ip_folder_map = vip.get_ip_folder_map()</span><br><span class="line">    folder = get_folder_path(folder)</span><br><span class="line">    <span class="keyword">if</span> type == <span class="string">"add"</span>:</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> ip_folder_map.iteritems():</span><br><span class="line">            <span class="keyword">if</span> k == v:</span><br><span class="line">                ip_folder_map[k] = folder</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elif</span> type == <span class="string">"delete"</span>:</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> ip_folder_map.iteritems():</span><br><span class="line">            <span class="keyword">if</span> v == folder:</span><br><span class="line">                ip_folder_map[k] = k</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    vip.set_ip_folder_map(ip_folder_map)</span><br></pre></td></tr></table></figure><p>上面说了在切换节点的时候，需要传递目录参数，保证只操作对应目录。而脚本是静态的，目录确是动态的，所以我们需要在目录或者<code>vip</code>发生变化的时候对原来的<code>keepalived.conf</code>进行更新，添加目录参数。也就是说当<code>vip</code>发生变化时，我们根据当前<code>vip</code>选择添加或者减少<code>ins</code>，并且更新每个<code>ins</code>调用脚本后面追加的参数；而<code>folder</code>发生变化时，<code>vip</code>调用脚本后面追加的参数也需要更新，要么是<code>vip</code>，要么是<code>folder</code>。这边也需要用到上面的<code>ip_folder_map</code>，因为每个<code>ins</code>就是一个<code>vip</code>，而每个<code>vip</code>对应一个<code>folder</code>。所以我们这边当目录或者<code>vip</code>发生变化时，会根据<code>ip_folder_map</code>更新<code>keepalived.conf</code>，具体实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_keepalived_conf</span><span class="params">(self)</span>:</span></span><br><span class="line">        kconf = <span class="string">"""global_defs &#123;</span></span><br><span class="line"><span class="string">    notification_email &#123;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    router_id NFS_HA_112</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">vrrp_script chk_nfs &#123;</span></span><br><span class="line"><span class="string">    script "/etc/keepalived/check_nfs.sh"</span></span><br><span class="line"><span class="string">    interval 2</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">        vips = self.ip_folder_map.keys()</span><br><span class="line">        vips.sort()</span><br><span class="line">        <span class="keyword">for</span> vip, folder <span class="keyword">in</span> self.ip_folder_map.items():</span><br><span class="line">            vip_idx = vips.index(vip)</span><br><span class="line">            state = self.get_my_state(vip_idx)</span><br><span class="line">            <span class="keyword">if</span> state <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                kconf += self.add_keepalived_ins(vip, folder, state)</span><br><span class="line">        <span class="keyword">with</span> open(KEEPALIVED_CONF_PATH, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.writelines(kconf)</span><br><span class="line">        do_shell(<span class="string">'service keepalived reload'</span>)</span><br></pre></td></tr></table></figure><p>下面是添加一个<code>ins</code>的模板，上面也贴过代码，至于这边再次贴一遍的目的是想侧重展示一下脚本后面参数的动态变化的实现方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_keepalived_ins</span><span class="params">(self, vip, folder, state)</span>:</span></span><br><span class="line">        vrrp_ins = <span class="string">"""</span></span><br><span class="line"><span class="string">vrrp_instance VI_&#123;ins_name&#125; &#123;&#123;</span></span><br><span class="line"><span class="string">    state &#123;state&#125;</span></span><br><span class="line"><span class="string">    interface &#123;pubif&#125;</span></span><br><span class="line"><span class="string">    priority &#123;priority&#125;</span></span><br><span class="line"><span class="string">    virtual_router_id &#123;router_id&#125;</span></span><br><span class="line"><span class="string">    advert_int 1</span></span><br><span class="line"><span class="string">    authentication &#123;&#123;</span></span><br><span class="line"><span class="string">        auth_type PASS</span></span><br><span class="line"><span class="string">        auth_pass 1111</span></span><br><span class="line"><span class="string">    &#125;&#125;</span></span><br><span class="line"><span class="string">    track_script &#123;&#123;</span></span><br><span class="line"><span class="string">        chk_nfs</span></span><br><span class="line"><span class="string">    &#125;&#125;</span></span><br><span class="line"><span class="string">    notify_master "/etc/keepalived/ChangeToMaster.sh &#123;folder&#125;"</span></span><br><span class="line"><span class="string">    notify_backup "/etc/keepalived/ChangeToBackup.sh &#123;folder&#125;"</span></span><br><span class="line"><span class="string">    virtual_ipaddress &#123;&#123;</span></span><br><span class="line"><span class="string">        &#123;vip&#125;</span></span><br><span class="line"><span class="string">    &#125;&#125;</span></span><br><span class="line"><span class="string">&#125;&#125;</span></span><br><span class="line"><span class="string">"""</span>.format(ins_name = vip.replace(<span class="string">'.'</span>, <span class="string">'_'</span>).replace(<span class="string">'/'</span>, <span class="string">'_'</span>),</span><br><span class="line">           state = state,</span><br><span class="line">           priority =  <span class="number">200</span> <span class="keyword">if</span> state == <span class="string">"MASTER"</span> <span class="keyword">else</span> <span class="number">100</span>,</span><br><span class="line">           router_id = self.get_router_id(vip),</span><br><span class="line">           pubif = get_public_interface(),</span><br><span class="line">           folder = folder,</span><br><span class="line">           vip = vip)</span><br><span class="line">        <span class="keyword">return</span> vrrp_ins</span><br></pre></td></tr></table></figure><p>触发脚本：</p><p><code>ChangetoMaster.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">folder=<span class="string">"<span class="variable">$(dirname $1)</span>/<span class="variable">$(basename $1)</span>"</span></span><br><span class="line">fname=$(basename <span class="variable">$folder</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$folder</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> $(mount | grep -q <span class="string">"<span class="variable">$folder</span> "</span>); <span class="keyword">then</span></span><br><span class="line">        umount -f <span class="variable">$folder</span> &gt; /dev/null</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    device=$(rbd showmapped | awk <span class="string">'/image_'</span><span class="variable">$fname</span><span class="string">' / &#123;print $5&#125;'</span>)</span><br><span class="line">    <span class="keyword">if</span> [ -b <span class="string">"<span class="variable">$device</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        mount <span class="variable">$device</span> <span class="variable">$folder</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">service nfs-kernel-server restart</span><br></pre></td></tr></table></figure><p><code>ChangetoBackup.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">folder=<span class="variable">$1</span></span><br><span class="line">service nfs-kernel-server stop</span><br><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$folder</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> $(mount | grep -q <span class="string">"<span class="variable">$folder</span> "</span>); <span class="keyword">then</span></span><br><span class="line">        umount -f <span class="variable">$folder</span> &gt; /dev/null</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">service nfs-kernel-server start</span><br></pre></td></tr></table></figure><h3 id="大容量RBD-image的创建和删除-1"><a href="#大容量RBD-image的创建和删除-1" class="headerlink" title="大容量RBD image的创建和删除"></a>大容量RBD image的创建和删除</h3><p>在另外一个端口另起一个线程，通过异步的方式实现，主要利用<code>python</code>的<code>rpyc</code>模块实现，忧郁项目保密性等原因，只贴上部分关键代码，给大家提供一些思路。</p><p>以删除<code>RBD image</code>为例，调用<code>remove_image</code>方法，进入装饰器，从而在新现成做删除操作，不再阻塞之前进程的流程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rbd_background</span><span class="params">()</span>:</span></span><br><span class="line">    conn = connect(<span class="string">'localhost'</span>, RBD_PORT)</span><br><span class="line">    module = conn.modules[<span class="string">'rbd_utils'</span>]</span><br><span class="line">    async_func = rpyc.<span class="keyword">async</span>(getattr(module, func_name))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> async_func</span><br><span class="line">    </span><br><span class="line"><span class="meta">@rbd_utils.rbd_background</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_image</span><span class="params">(pool, image)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            logger.info(<span class="string">'rbd &#123;&#125; delete start'</span>.format(image))</span><br><span class="line">            do_shell(<span class="string">'rbd rm &#123;&#125;/&#123;&#125; &gt;&gt; /var/log/rbd_rm.log'</span>.format(pool, image))</span><br><span class="line">            logger.info(<span class="string">'rbd &#123;&#125; delete finish'</span>.format(image))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            logger.error(<span class="string">'rbd &#123;&#125; delete error'</span>.format(image))</span><br><span class="line">            time.sleep(<span class="number">30</span>)</span><br></pre></td></tr></table></figure><h3 id="快照保证扩容的安全性-1"><a href="#快照保证扩容的安全性-1" class="headerlink" title="快照保证扩容的安全性"></a>快照保证扩容的安全性</h3><p>首先介绍一下定时扩容的脚本：</p><p><code>monitor_rbd.sh</code>：当<code>RBD image</code>可利用空间小于<code>50%</code>或者小于<code>50T</code>时，扩容<code>50T</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> convert_to_MB()</span><br><span class="line">&#123;</span><br><span class="line">    size=<span class="variable">$1</span></span><br><span class="line">    unit=<span class="variable">$&#123;size:(-1):1&#125;</span></span><br><span class="line">    nr=<span class="variable">$&#123;size/$unit/&#125;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$unit</span> <span class="keyword">in</span></span><br><span class="line">        (k|K|\)) <span class="built_in">echo</span> <span class="string">"<span class="variable">$nr</span> / 1024"</span> | bc;;</span><br><span class="line">        (m|M|\)) <span class="built_in">echo</span> <span class="string">"<span class="variable">$nr</span>"</span>;;</span><br><span class="line">        (g|G|\)) <span class="built_in">echo</span> <span class="string">"<span class="variable">$nr</span> * 1024"</span> | bc;;</span><br><span class="line">        (t|T|\)) <span class="built_in">echo</span> <span class="string">"<span class="variable">$nr</span> * 1024 * 1024"</span> | bc;;</span><br><span class="line">        (p|P|\)) <span class="built_in">echo</span> <span class="string">"<span class="variable">$nr</span> * 1024 * 1024 * 1024"</span> | bc;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">"Error: cannot convert to MB: <span class="variable">$size</span>"</span>;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> get_available_size()</span><br><span class="line">&#123;</span><br><span class="line">    disk=<span class="variable">$1</span></span><br><span class="line">    unit_size=$(convert_to_MB <span class="string">'50T'</span>)</span><br><span class="line">    </span><br><span class="line">    disk_size=$(df -h | grep <span class="variable">$disk</span> | awk <span class="string">'&#123;print $2&#125;'</span>)</span><br><span class="line">    disk_size=$(convert_to_MB <span class="variable">$disk_size</span>)</span><br><span class="line">    pool=$(rbd showmapped | grep <span class="variable">$disk</span> | awk <span class="string">'&#123;print $2&#125;'</span>)</span><br><span class="line">    available_pool_size=$(ceph df | grep <span class="variable">$pool</span> | awk <span class="string">'&#123;print $5&#125;'</span>)</span><br><span class="line">    available_pool_size=$(convert_to_MB <span class="variable">$available_pool_size</span>)</span><br><span class="line">    <span class="keyword">if</span> [ $(<span class="built_in">echo</span> <span class="string">"<span class="variable">$available_pool_size</span> &lt; <span class="variable">$unit_size</span>"</span> | bc) -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">        new_size=$(<span class="built_in">echo</span> <span class="string">"<span class="variable">$disk_size</span> + <span class="variable">$available_pool_size</span>"</span> | bc)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        new_size=$(<span class="built_in">echo</span> <span class="string">"<span class="variable">$disk_size</span> + <span class="variable">$unit_size</span>"</span> | bc)</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;new_size%.*&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> check_and_enlarge_disk()</span><br><span class="line">&#123;</span><br><span class="line">    disk=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$disk</span>"</span> = <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Error: You must specify the disk name"</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Checking the disk [/dev/<span class="variable">$disk</span>] ..."</span></span><br><span class="line">    <span class="keyword">if</span> ! rbd showmapped | grep -q <span class="variable">$disk</span>; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Error: Cannot find the disk [<span class="variable">$disk</span>]"</span></span><br><span class="line">        <span class="built_in">return</span> 2</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    disk_usage=$(df | grep <span class="variable">$disk</span> | awk <span class="string">'&#123;print $5&#125;'</span>)</span><br><span class="line">    available_disk_size=$(df | grep <span class="variable">$disk</span> | awk <span class="string">'&#123;print $4&#125;'</span>)</span><br><span class="line">    available_disk_size=$(convert_to_MB <span class="string">"<span class="variable">$&#123;available_disk_size&#125;</span>k"</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"  The disk use% is <span class="variable">$&#123;disk_usage&#125;</span>"</span></span><br><span class="line">    disk_usage=<span class="variable">$&#123;disk_usage/\%/&#125;</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$disk_usage</span> -lt 50 -a <span class="variable">$available_disk_size</span> -gt 1024 * 1024 * 50 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'Less then 50% use and more then 50TB available space left, just quit'</span></span><br><span class="line">        <span class="built_in">return</span> 0</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'Enlarging the disk ...'</span></span><br><span class="line">    new_size=$(get_available_size <span class="variable">$disk</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"  the new size is <span class="variable">$&#123;new_size&#125;</span>MB"</span></span><br><span class="line">    pool=$(rbd showmapped | grep <span class="variable">$disk</span> | awk <span class="string">'&#123;print $2&#125;'</span>)</span><br><span class="line">    image=$(rbd showmapped | grep <span class="variable">$disk</span> | awk <span class="string">'&#123;print $3&#125;'</span>)</span><br><span class="line">    rbd resize --size <span class="variable">$new_size</span> -p <span class="variable">$pool</span> <span class="variable">$image</span></span><br><span class="line">    sleep 3</span><br><span class="line">    resize2fs /dev/<span class="variable">$&#123;disk&#125;</span> <span class="string">"<span class="variable">$&#123;new_size&#125;</span>M"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Done"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">disks=$(lsblk | grep rbd | awk <span class="string">'&#123;print $1&#125;'</span>)</span><br><span class="line"><span class="keyword">for</span> disk <span class="keyword">in</span> <span class="variable">$disks</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"=============================================="</span></span><br><span class="line">check_and_enlarge_disk <span class="string">"<span class="variable">$disk</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"=============================================="</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>这边我们采用<code>ceph</code>提供的原生<code>python</code>的接口，完成<code>RBD</code>的定时快照的创建和删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> rados</span><br><span class="line"><span class="keyword">import</span> rbd</span><br><span class="line"><span class="keyword">from</span> folder <span class="keyword">import</span> get_all_folder_info</span><br><span class="line"><span class="keyword">from</span> vip <span class="keyword">import</span> get_ip_folder_map</span><br><span class="line"></span><br><span class="line">CEPH_CONF = <span class="string">'/etc/ceph/ceph.conf'</span></span><br><span class="line">MAX_SNAP_COUNT = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_snap</span><span class="params">(pool, rbd_image)</span>:</span></span><br><span class="line">    now = time.localtime()</span><br><span class="line">    snap = time.strftime(<span class="string">"%Y_%m_%d_%H_%M_%S"</span>, now)</span><br><span class="line">    <span class="keyword">with</span> rados.Rados(conffile=CEPH_CONF) <span class="keyword">as</span> cluster:</span><br><span class="line">        <span class="keyword">with</span> cluster.open_ioctx(str(pool)) <span class="keyword">as</span> ioctx:</span><br><span class="line">            <span class="keyword">with</span> rbd.Image(ioctx, rbd_image) <span class="keyword">as</span> image:</span><br><span class="line">                image.create_snap(snap)</span><br><span class="line">                </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_images</span><span class="params">()</span>:</span></span><br><span class="line">    pubif = get_public_interface()</span><br><span class="line">    pub_ips = do_cmd(<span class="string">"ip addr show &#123;&#125; | awk '/inet/ &#123;&#123;print $2&#125;&#125;'"</span>.format(pubif)).split()</span><br><span class="line">    vip_folders = get_ip_folder_map(gwgroup)</span><br><span class="line">    my_folders = []</span><br><span class="line">    <span class="keyword">for</span> pip <span class="keyword">in</span> pub_ips:</span><br><span class="line">        <span class="keyword">if</span> pip <span class="keyword">in</span> vip_folders <span class="keyword">and</span> pip != vip_folders[pip]:</span><br><span class="line">            my_folders.append(os.path.basename(vip_folders[pip]))</span><br><span class="line">    folders = get_all_folder_info()</span><br><span class="line">    images = []</span><br><span class="line">    <span class="keyword">for</span> folder <span class="keyword">in</span> folders:</span><br><span class="line">        <span class="keyword">if</span> folder <span class="keyword">in</span> my_folders:</span><br><span class="line">            images.append(&#123;</span><br><span class="line">                <span class="string">'image'</span>: <span class="string">'image_&#123;&#125;'</span>.format(folder),</span><br><span class="line">                <span class="string">'pool'</span>: folders[folder][<span class="string">'pool'</span>]</span><br><span class="line">            &#125;)</span><br><span class="line">    <span class="keyword">return</span> images</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_old_snap</span><span class="params">(pool, rbd_image)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> rados.Rados(conffile=CEPH_CONF) <span class="keyword">as</span> cluster:</span><br><span class="line">        <span class="keyword">with</span> cluster.open_ioctx(str(pool)) <span class="keyword">as</span> ioctx:</span><br><span class="line">            <span class="keyword">with</span> rbd.Image(ioctx, rbd_image) <span class="keyword">as</span> image:</span><br><span class="line">                snaps = sorted(image.list_snaps(), key=<span class="keyword">lambda</span> snap: snap[<span class="string">'name'</span>])</span><br><span class="line">                <span class="keyword">if</span> len(snaps) &gt; MAX_SNAP_COUNT:</span><br><span class="line">                    <span class="keyword">for</span> snap <span class="keyword">in</span> snaps[<span class="number">0</span>:len(snaps)-MAX_SNAP_COUNT]:</span><br><span class="line">                        image.remove_snap(snap[<span class="string">'name'</span>])</span><br><span class="line">                        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    images = get_images()</span><br><span class="line">    <span class="keyword">for</span> image <span class="keyword">in</span> images:</span><br><span class="line">        create_snap(image[<span class="string">'pool'</span>], image[<span class="string">'image'</span>])</span><br><span class="line">        remove_old_snap(image[<span class="string">'pool'</span>], image[<span class="string">'image'</span>])</span><br><span class="line">        device = do_shell(<span class="string">"rbd showmapped | awk '/&#123;&#125;[ \t]*&#123;&#125;/ &#123;&#123;print $5&#125;&#125;'"</span>.format(image[<span class="string">'pool'</span>], image[<span class="string">'image'</span>]))</span><br><span class="line">        do_shell(<span class="string">'/usr/local/bin/monitor_rbd.sh &#123;&#125;'</span>.format(os.path.basename(device)))</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>内容和代码都比较多，其实每一个技术点都可以单独拿出来写一篇，但是我觉得这是一个完整<code>feature</code>，想让大家能够代入，了解到完成这样一个<code>feature</code>周边需要支持的各种技术点和注意点，一个<code>feature</code>往往是经过不断迭代和维护，很多实现方法也随着时间和应用场景不断发生变化。</p><p>完成这样一个<code>feature</code>，我也是反复修改，就比如异步实现<code>RBD image</code>的创建和删除，很多场景在生产环境和测试环境中的 情况是完全不一样的，比如我开发的时候创建的<code>image</code>都是<code>1G</code>的，当然很快，也不能存在什么阻塞的问题，也遇到很多问题和想不通的地方，感谢我的同事和前辈提供的帮助和启发。</p><p>最后，衷心希望<code>ceph</code>能够早日将<code>CephFS</code>完善，保证其在生产环境中的稳定性和性能。这样我们也就不用绞尽脑汁这般曲线救国了，哈哈。</p><p>最后的最后，贴上部分代码地址，由于项目保密性等原因，我只能贴出比较关键的代码，大家请见谅，我觉得这些代码应该足够了，足够给大家提供一个思路了，其实往往思路比代码更重要，相信很多人的实现方式要比我更加优秀呢！</p><blockquote><p>代码地址：<a href="https://github.com/tony-yin/Multi_RBD_HA" target="_blank" rel="noopener">https://github.com/tony-yin/Multi_RBD_HA</a></p></blockquote><p>如果大家觉得有帮助的话，欢迎<code>Star</code>哦 ~(≧▽≦)/~</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/rbd2-600x450.jpg&quot; alt=&quot;RBD-HA-2&quot;&gt;&lt;/center&gt;

&lt;p&gt;之前分享过一篇&lt;a href=&quot;http://www.tony-yin.top/2017/12/07/RBD-HA/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【通过 Keepalived 实现 Ceph RBD 的高可用】&lt;/a&gt;，主要讲解了将&lt;code&gt;RBD&lt;/code&gt;导出为&lt;code&gt;NFS&lt;/code&gt;，然后通过&lt;code&gt;keepalived&lt;/code&gt;实现高可用，保证当提供虚拟&lt;code&gt;IP&lt;/code&gt;节点发生故障时，可以自动切换节点，使得业务不发生中断。&lt;/p&gt;
&lt;p&gt;这样可以基本使用&lt;code&gt;RBD&lt;/code&gt;代替&lt;code&gt;CephFS&lt;/code&gt;对外提供&lt;code&gt;Ceph&lt;/code&gt;服务，至于为什么不用&lt;code&gt;CephFS&lt;/code&gt;就不多说了，不清楚的可以去看上一篇。虽然说这样可以保证无单点故障，但是有一点还是不如&lt;code&gt;CephFS&lt;/code&gt;，那就是&lt;code&gt;CephFS&lt;/code&gt;可以实现多节点同时提供服务，而&lt;code&gt;RBD&lt;/code&gt;说白了其实同时只有一个节点能提供服务，当客户端流量高的时候，&lt;code&gt;RBD&lt;/code&gt;方式的带宽并不能满足需求。就比如都是三个节点，&lt;code&gt;CephFS&lt;/code&gt;可以将客户端流量分流到三个节点，而&lt;code&gt;RBD&lt;/code&gt;只能用一个节点，而带宽上限又取决与网卡、磁盘和&lt;code&gt;IO&lt;/code&gt;等等原因，所以同样的硬件设施&lt;code&gt;RBD&lt;/code&gt;的带宽性能是跟不上的，本文就多虚拟&lt;code&gt;IP&lt;/code&gt;暴露访问方式进行分享。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="NFS" scheme="https://tony-yin.github.io/tags/NFS/"/>
    
      <category term="HA" scheme="https://tony-yin.github.io/tags/HA/"/>
    
      <category term="RBD" scheme="https://tony-yin.github.io/tags/RBD/"/>
    
      <category term="Keepalived" scheme="https://tony-yin.github.io/tags/Keepalived/"/>
    
  </entry>
  
  <entry>
    <title>scp 免交互式和 ssh 免交互式脚本</title>
    <link href="https://tony-yin.github.io/2018/01/10/scp-and-ssh/"/>
    <id>https://tony-yin.github.io/2018/01/10/scp-and-ssh/</id>
    <published>2018-01-10T15:40:46.000Z</published>
    <updated>2018-11-03T17:07:41.151Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/open_ssh-600x450.png" alt="Scp-And-Ssh"></center><p>简单实现了<code>scp</code>的免交互式脚本和<code>ssh</code>免交互式脚本。</p><a id="more"></a><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><p>场景：</p><p>需要将以下源主机上的三个文件拷贝到以下目的主机的对应目录下</p><blockquote><p><code>src host</code>: 192.168.1.1<br><code>dist host</code>: 192.168.1.2<br><code>files</code>: <code>/root/1/1.txt</code>, <code>/root/2/2.txt</code>, <code>/root/3/3.txt</code></p></blockquote><p>这时候如果手动做的话，将会很繁琐，所以这时候需要一个脚本能够实现文件的自动复制，并且脚本需要自动把密码验证的步骤也覆盖。</p><p>这里的关键就是如何实现<code>shell</code>交互式命令行的自动化，这边可以用分界符<code>EOF</code>，<code>EOF</code>范围中的字符将会被作为命令输入到交互式命令行中，具体脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SOURCEHOST=192.168.1.1</span><br><span class="line">DISTHOST=$1</span><br><span class="line">FILE1=/root/1/1.txt</span><br><span class="line">FILE2=/root/2/2.txt</span><br><span class="line">FILE3=/root/3/3.txt</span><br><span class="line">FOLDER1=/root/1/</span><br><span class="line">FOLDER2=/root/2/</span><br><span class="line">FOLDER3=/root/3/</span><br><span class="line">PASSWORD=123456</span><br><span class="line">scp FILE1 $&#123;DISTHOST&#125;$&#123;Folder1&#125; &lt;&lt; EOF</span><br><span class="line"><span class="meta">$</span><span class="bash">PASSWORD</span></span><br><span class="line">EOF</span><br><span class="line">scp FILE2 $&#123;DISTHOST&#125;$&#123;Folder2&#125; &lt;&lt; EOF</span><br><span class="line"><span class="meta">$</span><span class="bash">PASSWORD</span></span><br><span class="line">EOF</span><br><span class="line">scp FILE3 $&#123;DISTHOST&#125;$&#123;Folder3&#125; &lt;&lt; EOF</span><br><span class="line"><span class="meta">$</span><span class="bash">PASSWORD</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>调用方式：<code>sh scp.sh 192.168.1.2</code></p><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><p>场景：</p><p>上面的场景是建立在登陆<code>192.168.1</code>主机的基础上，现在我想我在任意主机上都可以实现上面将<code>192.168.1.1</code>的上述文件拷贝到<code>192.168.1.2</code>的对应目录下</p><p>这里的关键是实现<code>ssh</code>的免密登陆，这时我们需要用到<code>sshpass</code>，具体介绍可以自行搜索下，用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">SOURCEHOST=192.168.1.1</span><br><span class="line">DISTHOST=$1</span><br><span class="line">FILE1=/root/1/1.txt</span><br><span class="line">FILE2=/root/2/2.txt</span><br><span class="line">FILE3=/root/3/3.txt</span><br><span class="line">FOLDER1=/root/1/</span><br><span class="line">FOLDER2=/root/2/</span><br><span class="line">FOLDER3=/root/3/</span><br><span class="line">PASSWORD=123456</span><br><span class="line"></span><br><span class="line">sshpass -p $PASSWORD ssh $SOURCEHOST \</span><br><span class="line">    sshpass -p $PASSWORD scp $&#123;FILE1&#125; $&#123;DISTHOST&#125;$&#123;FOLDER1&#125; &amp;&amp; \</span><br><span class="line">    sshpass -p $PASSWORD scp $&#123;FILE2&#125; $&#123;DISTHOST&#125;$&#123;FOLDER2&#125; &amp;&amp; \</span><br><span class="line">    sshpass -p $PASSWORD scp $&#123;FILE3&#125; $&#123;DISTHOST&#125;$&#123;FOLDER3&#125;</span><br></pre></td></tr></table></figure><p>调用方式：<code>sh scp.sh 192.168.1.2</code></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/open_ssh-600x450.png&quot; alt=&quot;Scp-And-Ssh&quot;&gt;&lt;/center&gt;

&lt;p&gt;简单实现了&lt;code&gt;scp&lt;/code&gt;的免交互式脚本和&lt;code&gt;ssh&lt;/code&gt;免交互式脚本。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Script" scheme="https://tony-yin.github.io/tags/Script/"/>
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>利用Raid卡工具获取逻辑盘是否为SSD</title>
    <link href="https://tony-yin.github.io/2018/01/05/RaidCardToolUtils/"/>
    <id>https://tony-yin.github.io/2018/01/05/RaidCardToolUtils/</id>
    <published>2018-01-05T05:07:06.000Z</published>
    <updated>2018-11-03T17:07:41.150Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/raid-600x450.png" alt="RaidCardToolUtils"></center><p>网上很多获取一块盘是否为<code>SSD</code>的方式都是不靠谱的，不能覆盖到所有情况。一般我们在操作系统上的硬盘都是虚拟出来的逻辑盘，比如<code>/dev/sda</code>这种，它可能对应一块单独的物理硬盘，也有可能对应的是几块盘组成的<code>raid</code>。我们有时候想获取一块盘的具体信息，比如磁盘类型、插槽号、序列号等等，这时候我们就得借助对应的<code>raid</code>卡工具了，最常见的如<code>Megacli</code>，通过逻辑盘找到对应的物理盘，然后读取信息。</p><a id="more"></a><h2 id="Raid卡简介"><a href="#Raid卡简介" class="headerlink" title="Raid卡简介"></a>Raid卡简介</h2><p>所谓<code>raid</code>卡，就是为了更好的统一管理物理硬盘而存在的，在出现单独的<code>raid</code>卡之前，对硬盘做<code>raid</code>操作，需要<code>cpu</code>完成其中的计算操作，这个会很影响其他依赖<code>cpu</code>的应用或进程的性能，后来就将<code>raid</code>卡单独提取出来，并且在其之上存在一个小型<code>cpu</code>供来完成<code>raid</code>相关操作的计算，这其中最常见的<code>raid</code>工具应该非<code>Megacli</code>莫属了。</p><p>为什么说最常见的呢？因为<code>raid</code>卡工具对应不同型号的<code>raid</code>卡是不一样，<code>LSI</code>只是一个半导体厂商，负责提供<code>raid</code>芯片，最后还需要集成到服务器厂商的机器上，所以最后的工具还是由厂商决定和提供，也可以理解为特定型号的<code>raid</code>对应各自的工具。</p><h2 id="HBA卡简介"><a href="#HBA卡简介" class="headerlink" title="HBA卡简介"></a>HBA卡简介</h2><p>近来，又出现了一种<code>HBA</code>卡，只从<code>HBA</code>的英文解释<code>HOST BUS ADAPTER</code>（主机总线适配器）就能看出来，他肯定是给主机用的，一般<code>HBA</code>就是给主机插上后，给主机扩展出更多的接口，来连接外部的设备。大多数讲到<code>HBA</code>卡都是指光纤的<code>HBA</code>卡，给主机提供光纤接口的。也有<code>ISCSI</code>的<code>HBA</code>卡，链接<code>ISCSI</code>设备的，从这种功能上说，我们也可以把独立网卡称为<code>HBA</code>卡，通过独立网卡扩展出网口来连接外部网络设备或主机。不过习惯上大部分<code>HBA</code>只是称光纤卡或者<code>iscsi</code>卡。</p><p>简而言之，这种<code>HBA</code>卡本身是为了扩展外部连接设备而存在的，但是它具有部分<code>raid</code>功能，与<code>raid</code>卡相比它的优势在于它价格便宜，性价比高；劣势在于虽然具有<code>raid</code>功能，但是都是基础的功能，没有<code>raid</code>卡那么完善。</p><blockquote><p>这篇文章讲<code>raid</code>卡和<code>HBA</code>卡讲的挺好的：<a href="http://www.cnblogs.com/weikunzz/p/6707395.html" target="_blank" rel="noopener">HBA卡 和 RAID卡</a></p></blockquote><h2 id="需求和背景"><a href="#需求和背景" class="headerlink" title="需求和背景"></a>需求和背景</h2><p>据我所知，这类工具往往是运维人员用的居多，但是往往开发中也会需要用到。本文通过获取逻辑盘对应盘的类型展开描述，并借此讲解获取逻辑盘的一类信息或通过逻辑盘操作对应物理盘。因为这其中的关键就是找到逻辑盘和物理盘之间的对应关系。无论是<code>raid</code>卡工具还是<code>HBA</code>卡工具都是罗列所有硬盘的信息，所以你要从中找到你选择的逻辑盘所对应的便是重中之重。</p><p>逻辑盘对应的物理盘可能为单独的硬盘，也可能是<code>raid</code>，单独的可以直接读取硬盘类型，<code>raid</code>的话我们认为只会将同样类型的盘做<code>raid</code>，混合的情况不考虑。</p><p><code>raid</code>卡工具的话，我只对<code>Megacli</code>和<code>Sas3ircu</code>进行讲解，所以阅读本文前最好有使用以上两个工具的相关经验。首先我会根据目前存在的<code>raid</code>卡类型建立一个<code>map</code>关系，然后通过<code>raid</code>卡类型自动获取对应<code>raid</code>卡工具，每个<code>raid</code>卡都是一个类，然后里面的方法都是为该工具定制化的操作。</p><h2 id="获取raid卡工具"><a href="#获取raid卡工具" class="headerlink" title="获取raid卡工具"></a>获取raid卡工具</h2><p>目前就考虑两种型号的<code>raid</code>卡，以后有新的再往<code>map</code>里面填充就好了。<code>NotSupport</code>指的是其他不支持型号的<code>raid</code>卡和虚拟机。</p><blockquote><p><code>do_shell</code>是本人封装的一个在<code>python</code>中执行<code>shell</code>命令的方法，大家可以根据自己的情况对该方法进行转换</p></blockquote><p>通过获取的<code>card mode</code>，根据<code>map</code>找到对应的<code>tool</code>，然后实例化对应的工具类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RaidCardToolFactory</span><span class="params">()</span>:</span></span><br><span class="line">    RaidCardMap = &#123;</span><br><span class="line">        <span class="string">'SAS2208'</span>: MegaraidTool,</span><br><span class="line">        <span class="string">'SAS3008'</span>: HBATool,</span><br><span class="line">        <span class="string">'NotSupport'</span>: NotSupport</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getTool</span><span class="params">(self)</span>:</span></span><br><span class="line">        card_model = self.get_raidcard_model()</span><br><span class="line">        tool = self.RaidCardMap[card_model]()</span><br><span class="line">        <span class="keyword">return</span> tool</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_raidcard_model</span><span class="params">(self)</span>:</span></span><br><span class="line">        card_model = <span class="string">'NotSupport'</span></span><br><span class="line">        card_info = do_shell(<span class="string">"lspci | grep 'LSI Logic'"</span>)</span><br><span class="line">        <span class="keyword">if</span> card_info == <span class="string">''</span>:</span><br><span class="line">            <span class="keyword">return</span> card_model</span><br><span class="line">        card = card_info.strip().splitlines()[<span class="number">0</span>].split()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'RAID bus controller'</span> <span class="keyword">in</span> card_info:</span><br><span class="line">            card_model = card[<span class="number">10</span>] + card[<span class="number">11</span>]</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">'Attached SCSI controller'</span> <span class="keyword">in</span> card_info:</span><br><span class="line">            card_model = card[<span class="number">10</span>]</span><br><span class="line">        <span class="keyword">return</span> card_model</span><br></pre></td></tr></table></figure><h2 id="Megaraid工具类"><a href="#Megaraid工具类" class="headerlink" title="Megaraid工具类"></a>Megaraid工具类</h2><ol><li>先通过<code>lsscsi</code>命令获取逻辑盘是否为<code>raid</code>；</li><li>如果是<code>raid</code>，那么直接根据<code>lsscsi</code>获取当前逻辑盘的<code>target id</code>，也就是第三个号，然后通过<code>megacli cfgdsply -aALL</code>获取所有<code>raid</code>信息，根据逻辑盘的<code>target id</code>对应物理盘中的<code>Target Id</code>找到对应<code>raid</code>，然后只要获取<code>raid</code>中第一块物理盘的硬盘类型即可，也就是<code>Media Type</code>，具体参见下方<code>API</code>: <code>get_ld_type</code></li><li>如果不是<code>raid</code>，那么直接根据<code>lsscsi</code>获取当前逻辑盘的<code>target id</code>，也就是第三个号，这边的<code>target id</code>直接对应<code>megacli</code>中每一块单盘中的<code>Device Id</code>字段，所以根据<code>target id</code>匹配<code>megacli pdlist aAll</code>获取磁盘列表的每一项的<code>Device Id</code>便可以找到对应的物理盘，具体参见下方<code>API</code>: <code>get_pd_type</code>。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MegaraidTool</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_disk_type</span><span class="params">(self, disk_name)</span>:</span></span><br><span class="line">        scsi_info = do_shell(<span class="string">"lsscsi | grep &#123;&#125; -w"</span>.format(disk_name))</span><br><span class="line">        target_id = scsi_info.split()[<span class="number">0</span>].split(<span class="string">":"</span>)[<span class="number">2</span>]</span><br><span class="line">        serial_nu = scsi_info.split()[<span class="number">3</span>].strip()[<span class="number">2</span>:]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"LSI"</span> <span class="keyword">in</span> scsi_info:</span><br><span class="line">            disk_type = self.get_ld_type(target_id, serial_nu)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            disk_type = self.get_pd_type(target_id)</span><br><span class="line">        <span class="keyword">return</span> disk_type</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_ld_type</span><span class="params">(self, target_id, serial_nu)</span>:</span></span><br><span class="line">        disk_type = <span class="string">''</span></span><br><span class="line">        cmd = MEGACLI + <span class="string">' cfgdsply -aALL -NoLog|grep -E "Product Name|Target Id|Media Type"'</span></span><br><span class="line">        output = do_shell(cmd)</span><br><span class="line">        adapters = output.split(<span class="string">'Product Name'</span>)</span><br><span class="line">        <span class="keyword">for</span> adapter <span class="keyword">in</span> adapters:</span><br><span class="line">            <span class="keyword">if</span> serial_nu <span class="keyword">not</span> <span class="keyword">in</span> adapter:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            lines = adapter.split(<span class="string">'\n'</span>)</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">                <span class="keyword">if</span> <span class="string">"Target Id: &#123;&#125;"</span>.format(target_id) <span class="keyword">in</span> line:</span><br><span class="line">                    index = lines.index(line)</span><br><span class="line">                    <span class="keyword">if</span> <span class="string">'Solid State Device'</span> <span class="keyword">in</span> lines[index + <span class="number">1</span>]:</span><br><span class="line">                        disk_type = <span class="string">"SSD"</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        disk_type = <span class="string">"HDD"</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> disk_type != <span class="string">''</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> disk_type</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_pd_type</span><span class="params">(self, target_id)</span>:</span></span><br><span class="line">        disk_type = <span class="string">''</span></span><br><span class="line">        cmd = MEGACLI + <span class="string">' pdlist aAll | grep -E "Device Id|Media Type"'</span></span><br><span class="line">        output = do_shell(cmd)</span><br><span class="line">        lines = output.split(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'Device Id: &#123;&#125;'</span>.format(target_id) <span class="keyword">not</span> <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        index = lines.index(<span class="string">'Device Id: &#123;&#125;'</span>.format(target_id))</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'Solid State Device'</span> <span class="keyword">in</span> lines[index + <span class="number">1</span>]:</span><br><span class="line">            disk_type = <span class="string">"SSD"</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            disk_type = <span class="string">"HDD"</span></span><br><span class="line">        <span class="keyword">return</span> disk_type</span><br></pre></td></tr></table></figure><h2 id="HBA工具类"><a href="#HBA工具类" class="headerlink" title="HBA工具类"></a>HBA工具类</h2><ol><li><code>HBA</code>类用的工具是<code>sas3ircu</code>，首先我们需要根据命令<code>sas3ircu list</code>获取所有的<code>controller</code>，然后每次获取信息都需要遍历所有<code>controller</code>；</li><li>第一步依旧是判断逻辑盘是否为<code>raid</code>；</li><li>如果是<code>raid</code>，获取逻辑盘的<code>target id</code>，与之匹配的是<code>sas3ircu</code>中的<code>Initiator at ID</code>字段，找到对应的<code>raid</code>，然后通过获取其下第一个物理盘的类型，这边类型字段变成了<code>Drive Type</code>，具体参考下方<code>API</code>: <code>get_ld_type</code>；</li><li>如果非<code>raid</code>，我匹配的是<code>sas3ircu</code>中的<code>Sas Address</code>字段，那么逻辑盘的<code>Sas Address</code>如何获取呢？这边我用的方式是通过<code>udev</code>获取逻辑盘的<code>symlink</code>，这里面有很多<code>address</code>，而我们需要的是<code>by-path</code>，我这边就简单做了，看<code>sas3ircu</code>每个盘的<code>Sas Address</code>是否被<code>udev</code>获取的<code>symlink</code>包含，如果包含了，那么也就匹配到了，然后直接获取<code>Drive Type</code>字段就可以得到磁盘类型类；具体参考下方<code>API</code>: <code>get_pd_type</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HBATool</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_disk_type</span><span class="params">(self, disk_name)</span>:</span></span><br><span class="line">        scsi_info = do_shell(<span class="string">"lsscsi | grep &#123;&#125; -w"</span>.format(disk_name))</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"LSI"</span> <span class="keyword">in</span> scsi_info:</span><br><span class="line">            target_id = scsi_info.split()[<span class="number">0</span>].split(<span class="string">":"</span>)[<span class="number">2</span>]</span><br><span class="line">            disk_type = self.get_ld_type(target_id)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sas_address = do_cmd(<span class="string">'udevadm info --query=symlink --name=&#123;&#125;'</span>.format(disk_name))</span><br><span class="line">            disk_type = self.get_pd_type(sas_address)</span><br><span class="line">        <span class="keyword">return</span> disk_type</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_ld_type</span><span class="params">(self, target_id)</span>:</span></span><br><span class="line">        disk_type = <span class="string">''</span></span><br><span class="line">        controllers = self.get_controllers()</span><br><span class="line">        <span class="keyword">for</span> controller <span class="keyword">in</span> controllers:</span><br><span class="line">            cmd = <span class="string">'sas3ircu &#123;&#125; display|grep -E "Initiator at ID|Drive Type"'</span>.format(controller)</span><br><span class="line">            output = do_shell(cmd)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'Initiator at ID #&#123;&#125;'</span>.format(target_id) <span class="keyword">in</span> output:</span><br><span class="line">                lines = output.splitlines()</span><br><span class="line">                index = lines.index(<span class="string">'Initiator at ID #&#123;&#125;'</span>.format(target_id))</span><br><span class="line">                <span class="keyword">if</span> <span class="string">'HDD'</span> <span class="keyword">in</span> lines[index + <span class="number">1</span>]:</span><br><span class="line">                    disk_type = <span class="string">'HDD'</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    disk_type = <span class="string">'SSD'</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> disk_type</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_pd_type</span><span class="params">(self, sas_address)</span>:</span></span><br><span class="line">        disk_type = <span class="string">''</span></span><br><span class="line">        controllers = self.get_controllers()</span><br><span class="line">        <span class="keyword">for</span> controller <span class="keyword">in</span> controllers:</span><br><span class="line">            cmd = <span class="string">'sas3ircu &#123;&#125; display|grep -E "SAS Address|Drive Type"'</span>.format(controller)</span><br><span class="line">            output = do_shell(cmd)</span><br><span class="line">            lines = output.splitlines()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, len(lines), <span class="number">2</span>):</span><br><span class="line">                address = lines[i].split()[<span class="number">-1</span>].replace(<span class="string">'-'</span>, <span class="string">''</span>)</span><br><span class="line">                <span class="keyword">if</span> address <span class="keyword">in</span> sas_address:</span><br><span class="line">                    <span class="keyword">if</span> <span class="string">'HDD'</span> <span class="keyword">in</span> lines[i + <span class="number">1</span>]:</span><br><span class="line">                        disk_type = <span class="string">'HDD'</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        disk_type = <span class="string">'SSD'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> disk_type != <span class="string">''</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> disk_type</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_controllers</span><span class="params">(self)</span>:</span></span><br><span class="line">        cmd = <span class="string">'sas3ircu list | awk \'&#123;print $1&#125;\''</span></span><br><span class="line">        list = do_shell(cmd).splitlines()</span><br><span class="line">        index = list.index(<span class="string">'Index'</span>) + <span class="number">2</span></span><br><span class="line">        controllers = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(index, len(list) - <span class="number">1</span>):</span><br><span class="line">            controllers.append(list[i])</span><br><span class="line">        <span class="keyword">return</span> controllers</span><br></pre></td></tr></table></figure><h2 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mcs3.raidcardutils <span class="keyword">import</span> RaidCardToolFactory</span><br><span class="line"></span><br><span class="line">tool = RaidCardToolFactory().getTool()</span><br><span class="line">disk_type = tool.get_disk_type(disk_name)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这其中的关键就是先找到每一块物理盘的唯一标识，然后我们根据工具获取列表中的唯一标识字段，获取逻辑盘对应的信息，就比如上面的<code>Device Id</code>，对应的是逻辑盘的<code>target id</code>。</p><blockquote><p>完整代码地址：<a href="https://github.com/tony-yin/RaidCardTool/" target="_blank" rel="noopener">https://github.com/tony-yin/RaidCardTool/</a><br>如果有所帮助的话，帮忙<code>star</code>一下哦 ^_^</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/raid-600x450.png&quot; alt=&quot;RaidCardToolUtils&quot;&gt;&lt;/center&gt;

&lt;p&gt;网上很多获取一块盘是否为&lt;code&gt;SSD&lt;/code&gt;的方式都是不靠谱的，不能覆盖到所有情况。一般我们在操作系统上的硬盘都是虚拟出来的逻辑盘，比如&lt;code&gt;/dev/sda&lt;/code&gt;这种，它可能对应一块单独的物理硬盘，也有可能对应的是几块盘组成的&lt;code&gt;raid&lt;/code&gt;。我们有时候想获取一块盘的具体信息，比如磁盘类型、插槽号、序列号等等，这时候我们就得借助对应的&lt;code&gt;raid&lt;/code&gt;卡工具了，最常见的如&lt;code&gt;Megacli&lt;/code&gt;，通过逻辑盘找到对应的物理盘，然后读取信息。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Raidcard" scheme="https://tony-yin.github.io/tags/Raidcard/"/>
    
  </entry>
  
  <entry>
    <title>Daily Article Vol 1 - (2017/11/1 ~ 2017/12/31)</title>
    <link href="https://tony-yin.github.io/2018/01/01/Daily-Article-2017/"/>
    <id>https://tony-yin.github.io/2018/01/01/Daily-Article-2017/</id>
    <published>2018-01-01T02:13:25.000Z</published>
    <updated>2018-11-03T17:07:41.150Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/2018-1b.png" alt="Daily Article 2"></center><p>书籍可以系统的学习一些知识，并且需要比较长的时间集中注意力学习。而现在网络越来越发达，各种社区的流行，还有开源分享精神的传播，导致现在互联网上很多优秀文章、博客、微信公众号等出现，这些文章贴近热点，往往都很新，并且篇幅有长有短，我们可以利用一些碎片时间来吸收这些知识。优秀文章很多，所以每天读个一两篇文章可以作为一个习惯养成，这样日积月累相信会获益良多。</p><p><code>Daily Article</code>系列就是为了记录我每天的阅读历程，以月为单位，每个月出一篇大的总结，一是为了约束自己每天按时按量阅读，也给自己打气，二是给自己每个月的阅读内容做一个总结，用于回头阅读，三是将其中有质量的内容分享给有需要的人。由于我是从<code>2017</code>九月才可以记录，所以趁着年底索性把十一和十二月的记录一次性发出来。</p><p>目前我采取星星的方式给文章评级，最高三颗星，最低没有星星，一般我放上来的都不会是太水的文章，所以如果是一般的工具类或者没有很大特色的文章我不会进行标记。一颗星表示<code>good</code>，即这篇文章有特色，对自己有帮助；两颗星表示<code>verygood</code>，说明这篇文章内容很好，有深度有广度，是一篇很有质量的文章；三颗星表示<code>excellent</code>，说明这篇文章不仅内容技术讲的很到位，文章文笔也很出色，实践结合理论，让人很容易理解，看完后收获很大或者是顿悟，总而言之是一片很优秀的文章。当然我还会在这三个等级中结合半个星星进行调节，反正就是对文章的一个个人看法而已，仁者见仁，智者见智吧。</p><a id="more"></a><h2 id="十一月"><a href="#十一月" class="headerlink" title="十一月"></a>十一月</h2><ol><li><a href="http://www.xuxiaopang.com/08/23/easy-ceph-CephX/" target="_blank" rel="noopener">大话 Ceph – CephX 那点事儿</a>(11/15-11/17) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://mp.weixin.qq.com/s/UiDd-1zwrqIsk3-KEcAQaA" target="_blank" rel="noopener">互联网架构为什么要做服务化？</a>(11/18) <i class="fa fa-star"></i></li><li><a href="http://blog.csdn.net/liuaigui/article/details/7163482" target="_blank" rel="noopener">基于开源软件构建高性能集群NAS系统</a>(11/20)</li><li><a href="http://blog.csdn.net/whycold/article/details/11898249" target="_blank" rel="noopener">虚拟IP原理</a>(11/21)</li><li><a href="http://mp.weixin.qq.com/s/8aI9jS0SXJl5NdcM3TPYuQ" target="_blank" rel="noopener">究竟为什么要引入数据库中间件</a>(11/27) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://time.geekbang.org/column/article/183" target="_blank" rel="noopener">程序员如何用技术变现（上）</a>(11/28)</li><li><a href="https://time.geekbang.org/column/article/294" target="_blank" rel="noopener">Go语言，Docker和新技术</a>(11/28)</li><li><a href="https://h5.ele.me/hongbao/#hardware_id=&amp;is_lucky_group=True&amp;lucky_number=10&amp;track_id=&amp;platform=0&amp;sn=29dad164ef30a0c9&amp;theme_id=1745&amp;device_id=" target="_blank" rel="noopener">秒杀系统架构优化思路</a>(11/29) <i class="fa fa-star"></i></li></ol><h2 id="十二月"><a href="#十二月" class="headerlink" title="十二月"></a>十二月</h2><ol><li><a href="https://time.geekbang.org/column/article/294" target="_blank" rel="noopener">Ceph开发每周谈首发</a>(12/1)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-1/" target="_blank" rel="noopener">Ceph开发每周谈Vol2</a>(12/4)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-1/" target="_blank" rel="noopener">Ceph开发每周谈Vol3</a>(12/5)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-1/" target="_blank" rel="noopener">Ceph开发每周谈Vol4</a>(12/5)</li><li><a href="https://www.thomas-krenn.com/en/wiki/Ext4_Filesystem" target="_blank" rel="noopener">Ext4 Filesystem</a>(12/11)</li><li><a href="https://www.hecticgeek.com/2015/01/ext4-external-hard-disk-busy-at-idle-fix/" target="_blank" rel="noopener">Formatted ‘Ext4’ External Hard Disk is Busy</a>(12/12)</li><li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=bfff68738f1cb5c93dab1114634cea02aae9e7ba" target="_blank" rel="noopener">Ext4lazyinit detail</a>(12/12)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-5/" target="_blank" rel="noopener">Ceph开发每周谈Vol5</a>(12/13)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-6/" target="_blank" rel="noopener">Ceph开发每周谈Vol6</a>(12/13)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-7/" target="_blank" rel="noopener">Ceph开发每周谈Vol7</a>(12/13)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-8/" target="_blank" rel="noopener">Ceph开发每周谈Vol8—社区加快开发节奏, CDS 变更为 CDM, Firefly 结束版本支持</a>(12/13)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-9/" target="_blank" rel="noopener">Ceph开发每周谈Vol9—Ceph开发每周谈 Vol 9—加密、压缩、EC 全场景支持</a>(12/13)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-10/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 10—NFS 已经被 RadosGW 支持|用户态</a>(12/13)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-11/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 11—RadosGW 支持 KeyStone V3, AWS v4, 多站点多活</a>(12/13)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-12/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 12—Scrub 增强，Jewel 小结</a>(12/13)</li><li><a href="http://link.zhihu.com/?target=https%3A//opensource.com/life/16/10/introduction-linux-filesystems" target="_blank" rel="noopener">An introduction to Linux filesystems</a>(12/15 ~ 12/17) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316599.html" target="_blank" rel="noopener">linux lsof命令详解</a>(12/18)</li><li><a href="http://blog.csdn.net/stpeace/article/details/47069215" target="_blank" rel="noopener">linux中的ldd命令简介</a>(12/18)</li><li><a href="http://blog.csdn.net/qq_26819733/article/details/50610129" target="_blank" rel="noopener">linux–&gt;ldd命令的介绍</a>(12/18)</li><li><a href="http://www.cnblogs.com/lyongde/p/4190588.html" target="_blank" rel="noopener">【Linux笔记】ldconfig、ldd</a>(12/18)</li><li><a href="https://zhuanlan.zhihu.com/p/27875337" target="_blank" rel="noopener">Linux 的 EXT4 文件系统的历史、特性以及最佳实践</a>(12/18) <i class="fa fa-star"></i><i class="fa fa-star"></i> </li><li><a href="http://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="noopener">理解inode</a>(12/18)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-13/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 13 — Cache on SPDK / bufferlist</a>(12/19)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-14/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 14 — LDAP/ BlueStore SMR</a>(12/19)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-15/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 15—Unix Socket / BlueStore 压缩和 Checksum</a>(12/19)</li><li><a href="https://opensource.com/life/15/9/everything-is-a-file" target="_blank" rel="noopener">Everything is a file</a>(12/21) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://www.tldp.org/LDP/sag/html/dev-fs.html" target="_blank" rel="noopener">Overview of the Directory Tree</a>(12/21)</li><li><a href="https://www.xsky.com/news/20171218/" target="_blank" rel="noopener">没错，它就是存储界的“大胃王”</a>(12/22)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-16/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 16—Jewel RC Release!</a>(12/22)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-17/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 17 — ARM Status | RBD 一致性组合 | 内核模块 转至元数据结尾</a>(12/22)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-18/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 18 — EXT4 废弃论战? | 去重支持</a>(12/22)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-19/" target="_blank" rel="noopener">Ceph开发每周谈Vol19 | Ceph Next 2016 闭门会议资讯独家大放送</a>(12/26)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-20/" target="_blank" rel="noopener">Ceph开发每周谈Vol 20 | NVMe Over Fabric/Kernel Multi Queue</a>(12/26)</li><li><a href="http://mp.weixin.qq.com/s/h9mz5gWN8tKRz8by2-Sn6w" target="_blank" rel="noopener">Ceph开发每周谈Vol 104 | NFS Ganesha VS Kernel Client</a>(12/27)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-21/" target="_blank" rel="noopener">Ceph开发每周谈Vol 21 | ZetaScale | CMP/WriteSame</a>(12/27)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-22/" target="_blank" rel="noopener">Ceph开发每周谈Vol 22 | 全球最大Ceph集群到底有多大？</a>(12/28)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-23/" target="_blank" rel="noopener">Ceph开发每周谈vol23｜BlueStore新动向</a>(12/28)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-24/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 24｜Jewel 10.2.1 第一个 Bug 修复版本释出</a>(12/28)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-24-2/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 25 | Ceph &amp; DPDK 网络插件开源</a>(12/29)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-27/" target="_blank" rel="noopener">Ceph开发每周谈Vol 27｜主线分支默认启用 AsyncMessenger</a>(12/29)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-28/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 28 | OSD 心跳 | Jewel RBD 测试</a>(12/30)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-29/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 29 — RBD Cache 警告: 数据不一致风险</a>(12/30)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-30/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 30 — ISA-L 和 BlueStore 性能有哪些进展？</a>(12/30)</li><li><a href="http://blog.csdn.net/haoel/article/details/2879" target="_blank" rel="noopener">用GDB调试程序（一）</a>(12/31) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://blog.csdn.net/haoel/article/details/2880" target="_blank" rel="noopener">用GDB调试程序（二）</a>(12/31) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://blog.csdn.net/haoel/article/details/2881" target="_blank" rel="noopener">用GDB调试程序（三）</a>(12/31) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://blog.csdn.net/haoel/article/details/2882" target="_blank" rel="noopener">用GDB调试程序（四）</a>(12/31) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://blog.csdn.net/haoel/article/details/2883" target="_blank" rel="noopener">用GDB调试程序（五）</a>(12/31) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://blog.csdn.net/haoel/article/details/2884" target="_blank" rel="noopener">用GDB调试程序（六）</a>(12/31) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://blog.csdn.net/haoel/article/details/2885" target="_blank" rel="noopener">用GDB调试程序（七）</a>(12/31) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://www.zphj1987.com/2017/04/26/rados-put-strip-debug/" target="_blank" rel="noopener">rados put striper功能的调试</a>(12/31) <i class="fa fa-star"></i></li><li><a href="https://ivanjobs.github.io/2016/05/11/prepare-ceph-dev-env.html" target="_blank" rel="noopener">准备Ceph开发环境</a>(12/31) <i class="fa fa-star"></i></li><li><a href="https://my.oschina.net/u/2460844/blog/515353" target="_blank" rel="noopener">ceph编译源码、单机搭建调试环境</a>(12/31) <i class="fa fa-star"></i></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/2018-1b.png&quot; alt=&quot;Daily Article 2&quot;&gt;&lt;/center&gt;

&lt;p&gt;书籍可以系统的学习一些知识，并且需要比较长的时间集中注意力学习。而现在网络越来越发达，各种社区的流行，还有开源分享精神的传播，导致现在互联网上很多优秀文章、博客、微信公众号等出现，这些文章贴近热点，往往都很新，并且篇幅有长有短，我们可以利用一些碎片时间来吸收这些知识。优秀文章很多，所以每天读个一两篇文章可以作为一个习惯养成，这样日积月累相信会获益良多。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Daily Article&lt;/code&gt;系列就是为了记录我每天的阅读历程，以月为单位，每个月出一篇大的总结，一是为了约束自己每天按时按量阅读，也给自己打气，二是给自己每个月的阅读内容做一个总结，用于回头阅读，三是将其中有质量的内容分享给有需要的人。由于我是从&lt;code&gt;2017&lt;/code&gt;九月才可以记录，所以趁着年底索性把十一和十二月的记录一次性发出来。&lt;/p&gt;
&lt;p&gt;目前我采取星星的方式给文章评级，最高三颗星，最低没有星星，一般我放上来的都不会是太水的文章，所以如果是一般的工具类或者没有很大特色的文章我不会进行标记。一颗星表示&lt;code&gt;good&lt;/code&gt;，即这篇文章有特色，对自己有帮助；两颗星表示&lt;code&gt;very
good&lt;/code&gt;，说明这篇文章内容很好，有深度有广度，是一篇很有质量的文章；三颗星表示&lt;code&gt;excellent&lt;/code&gt;，说明这篇文章不仅内容技术讲的很到位，文章文笔也很出色，实践结合理论，让人很容易理解，看完后收获很大或者是顿悟，总而言之是一片很优秀的文章。当然我还会在这三个等级中结合半个星星进行调节，反正就是对文章的一个个人看法而已，仁者见仁，智者见智吧。&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
      <category term="Daily-Article" scheme="https://tony-yin.github.io/tags/Daily-Article/"/>
    
  </entry>
  
  <entry>
    <title>译：一切皆文件</title>
    <link href="https://tony-yin.github.io/2017/12/21/Everything-is-a-file/"/>
    <id>https://tony-yin.github.io/2017/12/21/Everything-is-a-file/</id>
    <published>2017-12-21T07:34:32.000Z</published>
    <updated>2018-11-03T17:07:41.150Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/file-600x450.png" alt="Everything is a file"></center><p>这里先提一个技巧性的问题:以下哪一个是文件?</p><ul><li>目录</li><li><code>Shell</code>脚本</li><li><code>Office</code>文档</li><li>串行端口（<code>Serial ports</code>）</li><li>内核数据结构</li><li>内核调优参数</li><li>硬盘驱动器</li><li>分区</li><li>逻辑卷（<code>LVM</code>）</li><li>打印机</li><li>套接字（<code>Sockets</code>）</li></ul><p>也许你不会相信，但是对于<code>Unix</code>和<code>Linux</code>，它们都是文件。这是最令人惊奇的概念之一——这样做使得许多管理任务可以被一些非常简单但功能强大的方法执行，否则这些任务实现起来可能非常困难甚至不可能。</p><a id="more"></a><h2 id="备份主引导记录"><a href="#备份主引导记录" class="headerlink" title="备份主引导记录"></a>备份主引导记录</h2><p>举个简单任务的例子，考虑一下为你的硬盘驱动器地主引导记录（<code>MBR</code>）做一个备份工作。有时候我需要恢复或重新创建我的<code>MBR</code>，尤其是分区表。从头开始重新创建它是非常困难的。但是从保存好的文件中恢复出来这是非常容易的。<code>Linux</code>有一个很强大的<code>GNU</code>工具 — <code>dd</code>，它可以实现这个和其他很多功能。</p><p><code>dd</code>表示<code>disk dump</code>的缩写，意为“磁盘转储”，但是我们很多资深管理员一直认为它是<code>disk destroyer</code>的缩写，因为如果你不是很小心的话，这个工具会准确无误地执行你告诉它要做的事情，包括将硬盘上或者分区上所有的数据都破坏掉。</p><p>以下命令将会备份你的<code>MBR</code>，它必须要是<code>root</code>用户执行，因为非<code>root</code>用户没有访问<code>/dev</code>目录下硬盘驱动器<a href="https://en.wikipedia.org/wiki/Device_file" target="_blank" rel="noopener">设备文件</a>的权限。<code>BS</code>是<code>Block Size</code>缩写，表示块大小，<code>count</code>表示从源文件读取的块的个数。这个命令将在<code>/tmp</code>目录创建一个<code>myMBR.bak</code>的文件。这个文件的大小将为<code>512</code>字节，包含了<code>MBR</code>的内容，包括引导代码和分区表等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/sda of=/tmp/myMBR.bak bs=512 count=1</span><br></pre></td></tr></table></figure><p>如果<code>MBR</code>被损坏了，就需要引导到一个修复盘并执行下面的命令，这个命令本质上就是上面的反向操作。值得注意的是这条命令没有必要指定块大小和块个数这两个参数，因为<code>dd</code>命令将会把备份文件简单地拷贝到硬盘的第一个扇区，并且当它执行到源文件末尾后停止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/tmp/myMBR.bak of=/dev/sda</span><br></pre></td></tr></table></figure><h2 id="都是文件系统的一部分"><a href="#都是文件系统的一部分" class="headerlink" title="都是文件系统的一部分"></a>都是文件系统的一部分</h2><p><code>Linux</code>计算机上的所有内容都可以作为文件系统空间的文件被访问。这是非常重要的，这使得我们 可以<a href="http://yarchive.net/comp/linux/everything_is_file.html" target="_blank" rel="noopener">使用通用的工具访问不同的东西</a>。</p><p><code>dd</code>命令可用于将硬盘的整个分区拷贝到一个文件或者如下所示的其他硬盘。在这里<code>dd</code>命令再次将数据拷贝到输入设备的末尾并停止。请确保输出设备的容量要大于输入设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/sdf2 of=/dev/sdg3</span><br><span class="line"></span><br><span class="line">dd if=/dev/sda of=/dev/sdg</span><br></pre></td></tr></table></figure><p>此外文件系统还有其他工具可以达到此作用。比如，<code>cat</code>命令可以用来将任意文件的内容发送到标准输出，这包括分区和整个硬盘。然后，输出还可以被重定向到一个文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/sda1 &gt; partition1.backup</span><br></pre></td></tr></table></figure><p>但是，<code>cat</code>命令没有<code>dd</code>命令的控制功能。例如，不能指定从源设备或者源文件读取的数据量。</p><p>下面是一个有趣的实验，它将正面一切皆文件的事实。大多数<code>Linux</code>发行版都有多个虚拟控制台，其中<code>1</code>到<code>7</code>可以用来登录到一个带有<code>shell</code>接口的本地控制台会话。可以通过一些组合键访问它们，比如<code>Ctrl-Alt-F1</code>是控制台<code>1</code>，<code>Ctrl-Alt-F2</code>是控制台2，以此类推。</p><p>按<code>Ctrl-Alt-F2</code>切换到控制台2。在一些发行版中，登录信息包括与此控制台相关的<code>tty</code>（<code>Teletype</code>）设备，但是也有很多发行版不包括。页面应该显示<code>tty2</code>的信息，因为你当前在控制台<code>2</code>。</p><p>用一个非<code>root</code>登录，你可以通过<code>who am i</code>这个命令来确定哪一个<code>tty</code>设备连接到当前控制台。</p><p>在我们实际执行这个实验之前，请看一下<code>/dev</code>目录下的<code>tty2</code>和<code>tty3</code>设备的列表清单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /dev tty[23]</span><br></pre></td></tr></table></figure><p>有大量的定义过的<code>tty</code>设备，但是它们其中的大多数我们并不关心，我们只关系<code>tty2</code>和<code>tty3</code>设备。作为设备文件，它们没有什么特殊之处；它们只是简单的字符类型的设备。我们将用这些设备做这个实验。<code>tty2</code>设备连接到虚拟控制台<code>2</code>，<code>tty3</code>设备连接到虚拟控制台<code>3</code>。</p><p>按<code>Ctrl-Alt-F3</code>组合键切换到控制台<code>3</code>，再次以同样的非<code>root</code>用户登录。</p><p>现在在控制台<code>3</code>输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Hello world&quot; &gt; /dev/tty2</span><br></pre></td></tr></table></figure><p>按<code>Ctrl-Alt-F2</code>组合键返回控制台<code>2</code>。字符串“Hello world”（没有引号）将显示在控制台<code>2</code>上。</p><p>这个实验也可以在<code>GUI</code>桌面的终端模拟器上进行。桌面上的终端会话在<code>/dev</code>树中使用伪终端设备，比如<code>/dev/pts/1</code>。通过<code>Konsole</code>或者<code>Xterm</code>开启两个终端会话，确定它们连接到哪个伪终端后，使用其中一个发送消息给另一个。</p><p>现在继续试验，使用<code>cat</code>命令在不同的终端显示<code>/etc/fstab</code>文件。</p><p>另一个有趣的实验是使用<code>cat</code>命令直接将文件打印到打印机上。假设你的打印机设备是<code>/dev/usb/lp0</code>，并且你的打印机可以直接打印<code>PDF</code>文件，下面的命令将会在你的打印机上打印一个<code>PDF</code>文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test.pdf &gt; /dev/usb/lp0</span><br></pre></td></tr></table></figure><p><code>dd</code>命令也可以用来打印一个准备打印的文件。不过，我认为<code>cat</code>命令实际上更适合这个任务。</p><h2 id="“一切皆文件”的含义"><a href="#“一切皆文件”的含义" class="headerlink" title="“一切皆文件”的含义"></a>“一切皆文件”的含义</h2><p>“一切都是文件”的含义是深远的，远远超过了像这篇文章所列举的那样。你们已经在前面的实验中看到过一些例子，但这里有一个包含这些和更多的简短列表。</p><ol><li>克隆硬盘。</li><li>备份分区。</li><li>备份主引导记录(<code>MBR</code>)。</li><li>在<code>u</code>盘上安装<code>ISO</code>镜像。</li><li>与其他终端用户沟通。</li><li>将文件打印到打印机。</li><li>更改<code>/proc pseudo</code>文件系统中的某些文件的内容，以修改运行内核的配置参数。</li><li>用随机数据或零覆盖文件、分区或整个硬盘驱动器。</li><li>将不需要的输出重定向到<code>/dev/null</code>设备，它将永远不会显示。</li><li>等等，等等，等等。。。</li></ol><p>这里有太多的例子，任何一个列表都只是表面的一部分。我相信，你肯定会想出或指出许多比我这里提到更有创造性的方式，来使用<code>Linux</code>的这个特性。我很乐意看到你对如何使用“一切都是文件”的评论。</p><h2 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h2><p>有关<code>/dev/</code>目录和你可能在那里找到的设备的更多信息，请参阅<code>Linux Journal</code>上的<a href="http://www.linuxjournal.com/article/2597" target="_blank" rel="noopener">这篇文章</a>。有关单个设备的更详细信息，<a href="http://www.tldp.org/" target="_blank" rel="noopener">Linux文档项目</a>中的<a href="http://www.tldp.org/LDP/sag/html/dev-fs.html" target="_blank" rel="noopener">这篇文章</a>和<a href="http://www.tldp.org/LDP/Linux-Filesystem-Hierarchy/html/dev.html" target="_blank" rel="noopener">这篇文章</a>会有所帮助。</p><blockquote><p>原文地址：<a href="https://opensource.com/life/15/9/everything-is-a-file" target="_blank" rel="noopener">https://opensource.com/life/15/9/everything-is-a-file</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/file-600x450.png&quot; alt=&quot;Everything is a file&quot;&gt;&lt;/center&gt;

&lt;p&gt;这里先提一个技巧性的问题:以下哪一个是文件?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Shell&lt;/code&gt;脚本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Office&lt;/code&gt;文档&lt;/li&gt;
&lt;li&gt;串行端口（&lt;code&gt;Serial ports&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;内核数据结构&lt;/li&gt;
&lt;li&gt;内核调优参数&lt;/li&gt;
&lt;li&gt;硬盘驱动器&lt;/li&gt;
&lt;li&gt;分区&lt;/li&gt;
&lt;li&gt;逻辑卷（&lt;code&gt;LVM&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;打印机&lt;/li&gt;
&lt;li&gt;套接字（&lt;code&gt;Sockets&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也许你不会相信，但是对于&lt;code&gt;Unix&lt;/code&gt;和&lt;code&gt;Linux&lt;/code&gt;，它们都是文件。这是最令人惊奇的概念之一——这样做使得许多管理任务可以被一些非常简单但功能强大的方法执行，否则这些任务实现起来可能非常困难甚至不可能。&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
      <category term="Filesystem" scheme="https://tony-yin.github.io/tags/Filesystem/"/>
    
  </entry>
  
</feed>
