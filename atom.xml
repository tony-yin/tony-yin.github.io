<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tony&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tony-yin.github.io/"/>
  <updated>2019-05-04T16:52:03.344Z</updated>
  <id>https://tony-yin.github.io/</id>
  
  <author>
    <name>Tony</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用软 RAID 实现系统盘高可用</title>
    <link href="https://tony-yin.github.io/2019/03/10/ssd_ha/"/>
    <id>https://tony-yin.github.io/2019/03/10/ssd_ha/</id>
    <published>2019-03-10T05:07:06.000Z</published>
    <updated>2019-05-04T16:52:03.344Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/ssd_ha.png" alt="HA RAID"></center><p>一套完善的系统理论上是不应该存在任何的单点故障，但是系统盘往往被人所忽略，而系统盘又恰恰是最重要的一个点。本文主要讲解如何利用软<code>RAID</code>实现系统盘高可用，并且实现自动换盘、自动告警和自动恢复。</p><a id="more"></a><h2 id="系统盘组成"><a href="#系统盘组成" class="headerlink" title="系统盘组成"></a>系统盘组成</h2><p>所有挂载点全部采用<code>RAID1</code>方式保证数据冗余，即使其中一块盘损坏，也不会影响操作系统的正常运行，只需要替换一块新盘，即可重新进行数据同步。</p><table><br>    <tr><br>        <th>Mount point</th><th>Raid</th><th>容量</th><br>    </tr><br>    <tr><br>        <td><br>        /<br>        </td><br>        <td><br>        Raid1<br>        </td><br>        <td><br>        100 GB<br>        </td><br>    </tr><br>    <br>    <tr><br>        <td><br>        /boot<br>        </td><br>        <td><br>        Raid1<br>        </td><br>        <td><br>        512 MB<br>        </td><br>    </tr><br>    <tr><br>        <td><br>        /boot/efi<br>        </td><br>        <td><br>        Raid1<br>        </td><br>        <td><br>        200 MB<br>        </td><br>    </tr><br>        <tr><br>        <td><br>        swap<br>        </td><br>        <td><br>        Raid1<br>        </td><br>        <td><br>        50 GB<br>        </td><br>    </tr><br>        <br>        <tr><br>        <td><br>        /var/log<br>        </td><br>        <td><br>        Raid1<br>        </td><br>        <td><br>        50 GB<br>        </td><br>    </tr><br></table><h2 id="系统盘软-RAID-配置"><a href="#系统盘软-RAID-配置" class="headerlink" title="系统盘软 RAID 配置"></a>系统盘软 RAID 配置</h2><p>进入引导页面，选择<code>UEFI</code>安装方式，因为传统的<code>BIOS</code>方式在容量和分区上都存在限制，具体请阅读<a href="https://tecadmin.net/copy-a-gpt-partition-table-to-new-disk/" target="_blank" rel="noopener">【聊聊 BIOS、UEFI、MBR、GPT、GRUB……】</a>。</p><center><img src="https://raw.githubusercontent.com/tony-yin/Picture-Lib/master/lib/load_uefi.png" alt="load uefi"></center><p>配置软<code>raid</code>阶段，<code>UEFI</code>存在一个<code>ESP</code>（<code>EFI system partition</code>）， 即<code>/boot/efi</code>分区，<code>RAID</code>等级设置为<code>raid1</code>。</p><center><img src="https://raw.githubusercontent.com/tony-yin/Picture-Lib/master/lib/uefi_partition.png" alt="uefi partition"></center><p>其他的挂载点也都选择<code>RAID1</code>即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sda             8:0    0 447.1G  0 disk</span><br><span class="line">├─sda4          8:4    0   201M  0 part</span><br><span class="line">│ └─md123       9:123  0   201M  0 raid1 /boot/efi</span><br><span class="line">├─sda2          8:2    0  50.1G  0 part</span><br><span class="line">│ └─md127       9:127  0  50.1G  0 raid1 [SWAP]</span><br><span class="line">├─sda5          8:5    0    50G  0 part</span><br><span class="line">│ └─md124       9:124  0    50G  0 raid1 /var/log</span><br><span class="line">├─sda3          8:3    0   513M  0 part</span><br><span class="line">│ └─md126       9:126  0 512.4M  0 raid1 /boot</span><br><span class="line">├─sda1          8:1    0  100.1G  0 part</span><br><span class="line">  └─md125       9:125  0    100G  0 raid1 /</span><br><span class="line">sdb             8:0    0 447.1G  0 disk</span><br><span class="line">├─sdb4          8:4    0   201M  0 part</span><br><span class="line">│ └─md123       9:123  0   201M  0 raid1 /boot/efi</span><br><span class="line">├─sdb2          8:2    0  50.1G  0 part</span><br><span class="line">│ └─md127       9:127  0  50.1G  0 raid1 [SWAP]</span><br><span class="line">├─sdb5          8:5    0    50G  0 part</span><br><span class="line">│ └─md124       9:124  0    50G  0 raid1 /var/log</span><br><span class="line">├─sdb3          8:3    0   513M  0 part</span><br><span class="line">│ └─md126       9:126  0 512.4M  0 raid1 /boot</span><br><span class="line">├─sdb1          8:1    0  100.1G  0 part</span><br><span class="line">  └─md125       9:125  0    100G  0 raid1 /</span><br></pre></td></tr></table></figure><h2 id="换盘流程"><a href="#换盘流程" class="headerlink" title="换盘流程"></a>换盘流程</h2><p>以系统盘为<code>sda</code>和<code>sdb</code>，并且<code>sdb</code>为更换的硬盘为例。</p><h3 id="拔盘-amp-插盘"><a href="#拔盘-amp-插盘" class="headerlink" title="拔盘 &amp; 插盘"></a>拔盘 &amp; 插盘</h3><p>因为所有挂载点都是<code>RAID1</code>，软<code>RAID</code>中拥有数据冗余的阵列是允许其中一块盘丢失的，所以不会存在磁盘占用的问题，进而不会导致磁盘乱序的问题。所以可以直接热插拔换盘。</p><h3 id="克隆磁盘分区表信息"><a href="#克隆磁盘分区表信息" class="headerlink" title="克隆磁盘分区表信息"></a>克隆磁盘分区表信息</h3><p>新插入的<code>sdb</code>理论上是没有分区的，需要将<code>sda</code>上面的分区完完全全的克隆过来。<code>gpt</code>磁盘分区表的磁盘应该采用<code>parted</code>或<code>sgdisk</code>工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 将sda的分区信息克隆到sdb上</span><br><span class="line">sgdisk -R /dev/sdb /dev/sda</span><br><span class="line">sleep 5</span><br></pre></td></tr></table></figure><p>最好<code>sleep</code>几秒，因为它克隆后底层同步工作并没有立即完成。</p><h3 id="生成新的GUID"><a href="#生成新的GUID" class="headerlink" title="生成新的GUID"></a>生成新的GUID</h3><p>克隆分区信息后，为<code>sdb</code>生成新的<code>GUID</code>，否则会因为克隆分区表导致<code>sdb</code>和<code>sda</code>的<code>GUID</code>一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sgdisk -G /dev/sdb</span><br></pre></td></tr></table></figure><h3 id="内核重新加载分区表"><a href="#内核重新加载分区表" class="headerlink" title="内核重新加载分区表"></a>内核重新加载分区表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">partprobe /dev/sdb</span><br></pre></td></tr></table></figure><h3 id="复制引导程序"><a href="#复制引导程序" class="headerlink" title="复制引导程序"></a>复制引导程序</h3><p><strong>注意：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这一步非常关键，可以说这是所有流程中最关键并且最容易忽略的一个步骤。因为软RAID数据冗余，并不会对操作系统引导程序有效，即RAID1不会对BIOS中的MBR做冗余，也不会对UEFI中的ESP分区做冗余。这里说的不冗余是指软RAID不会对其做数据冗余，需要另外做冗余。</span><br></pre></td></tr></table></figure><p>如果引导方式是传统的<code>bios</code>，则需要复制<code>MBR</code>，即硬盘的前<code>512</code>字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ ~]# dd if=/dev/sda of=/dev/sdb bs=512 count=1</span><br></pre></td></tr></table></figure><p>需要注意的是，我们这里采用了<code>UEFI</code>的引导方式，跟<code>BIOS</code>是完全不一样的，所以如果同样拷贝硬盘的前<code>512</code>字节是不会生效的。<code>UEFI</code>的引导程序在<code>ESP</code>中，需要复制整个<code>ESP</code>分区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ ~]# dd if=/dev/sda of=/dev/sdb</span><br></pre></td></tr></table></figure><p>你以为这就结束了吗？</p><p><code>UEFI</code>引导方式仅仅复制<code>ESP</code>分区还不够，还需要将系统盘添加到启动项中。因为当一块磁盘拔了再插上后，<strong>原先这块盘就会从启动项中移除</strong>，插盘后需要将新盘再添加到启动项中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ ~]# efibootmgr -c -g -d /dev/sdb -p 1 -L &quot;Centos #2&quot; -l &apos;\EFI\centos\grubx64.efi&apos;</span><br></pre></td></tr></table></figure><p>想对<code>efibootmgr</code>有更深入了解，可以阅读：</p><ul><li><a href="https://wiki.gentoo.org/wiki/Efibootmgr" target="_blank" rel="noopener">Efibootmgr wiki</a></li><li><a href="https://www.cnblogs.com/pipci/p/8862292.html" target="_blank" rel="noopener">用efibootmgr管理UEFI启动项，添加丢失的启动项</a></li></ul><h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p>将替换的磁盘的分区对应加入<code>RAID1</code>中，这样就可以将<code>sda</code>中的数据同步至<code>sdb</code>中，同步完成后，所有阵列又将拥有数据冗余的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ ~]# mdadm /dev/md123 -a /dev/sdb4</span><br><span class="line">[root@ ~]# mdadm /dev/md124 -a /dev/sdb5</span><br><span class="line">[root@ ~]# mdadm /dev/md125 -a /dev/sdb1</span><br><span class="line">[root@ ~]# mdadm /dev/md126 -a /dev/sdb3</span><br><span class="line">[root@ ~]# mdadm /dev/md127 -a /dev/sdb2</span><br></pre></td></tr></table></figure><h3 id="同步配置文件"><a href="#同步配置文件" class="headerlink" title="同步配置文件"></a>同步配置文件</h3><p>每次修改软<code>RAID</code>后，都要实时更新配置文件，方便查看<code>RAID</code>配置或利用配置文件重新组装阵列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ ~]# mdadm -Ds &gt; /etc/mdadm.conf</span><br></pre></td></tr></table></figure><h3 id="获取进度值"><a href="#获取进度值" class="headerlink" title="获取进度值"></a>获取进度值</h3><p>通过查看<code>/proc/mdstat</code>查看<code>RAID</code>当前信息，如果存在数据同步，会有<code>recovery</code>的字样，并且<code>[1/2]</code>表示还未同步，<code>[_U]</code>表示前面一个设备不是活跃状态，后一个设备为活跃状态。所以<code>recovery</code>同行的进度值并不是整体<code>RAID</code>同步进度值，只是当前的<code>RAID</code>的进度，所有阵列的同步进度值可以通过 <code>Finish Blocks / All Blocks</code>来计算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@ ~]# cat /proc/mdstat</span><br><span class="line">Personalities : [raid0] [raid1]</span><br><span class="line">md123 : active raid1 sdb4[1] sda4[0]</span><br><span class="line">      205760 blocks super 1.0 [1/2] [_U]</span><br><span class="line">      bitmap: 0/1 pages [0KB], 65536KB chunk</span><br><span class="line"></span><br><span class="line">md124 : active raid1 sda5[0] sdb5[1]</span><br><span class="line">      20971520 blocks super 1.2 [1/2] [_U]</span><br><span class="line">      bitmap: 1/1 pages [4KB], 65536KB chunk</span><br><span class="line"></span><br><span class="line">md125 : active raid1 sda1[0] sdb1[1]</span><br><span class="line">      83886080 blocks 64K chunks 2 near-copies [1/2] [_U] [=======&gt;........]  recovery = 35.6% (29863444/83886080) finish=0.1min speed=93472K/sec</span><br><span class="line">      bitmap: 1/1 pages [4KB], 65536KB chunk</span><br><span class="line"></span><br><span class="line">md126 : active raid1 sdb3[1] sda3[0]</span><br><span class="line">      524736 blocks super 1.2 [1/2] [_U]</span><br><span class="line">      bitmap: 0/1 pages [0KB], 65536KB chunk</span><br><span class="line"></span><br><span class="line">md127 : active raid1 sda2[0] sdb2[1]</span><br><span class="line">      104923136 blocks super 1.2 [1/2] [_U]</span><br><span class="line">      bitmap: 1/1 pages [4KB], 65536KB chunk</span><br><span class="line"></span><br><span class="line">unused devices: &lt;none&gt;</span><br></pre></td></tr></table></figure><h2 id="监控-amp-告警"><a href="#监控-amp-告警" class="headerlink" title="监控 &amp; 告警"></a>监控 &amp; 告警</h2><p>要达到对系统盘更好的维护，监控和告警是必不可少的。</p><h3 id="磁盘健康告警"><a href="#磁盘健康告警" class="headerlink" title="磁盘健康告警"></a>磁盘健康告警</h3><p>可以通过<code>smartctl</code>工具获取磁盘健康状态，不同型号的磁盘获取到的健康信息可能会不一致，如果磁盘状态健康，一般会返回<code>PASSED</code>或<code>OK</code>，如果状态不健康，直接调用邮件接口即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@ ~]# smartctl -H /dev/sda</span><br><span class="line">smartctl 6.2 2017-02-27 r4394 [x86_64-linux-4.14.78-201.1.el7.x86_64] (local build)</span><br><span class="line">Copyright (C) 2002-13, Bruce Allen, Christian Franke, www.smartmontools.org</span><br><span class="line"></span><br><span class="line">=== START OF READ SMART DATA SECTION ===</span><br><span class="line">SMART STATUS RETURN: incomplete response, ATA output registers missing</span><br><span class="line">SMART overall-health self-assessment test result: PASSED</span><br><span class="line">Warning: This result is based on an Attribute check.</span><br></pre></td></tr></table></figure><h3 id="磁盘拔插告警"><a href="#磁盘拔插告警" class="headerlink" title="磁盘拔插告警"></a>磁盘拔插告警</h3><p>通过<code>udev</code>的机制，编写<code>add</code>和<code>remove</code>两个<code>action</code>的<code>rules</code>文件即可监听磁盘拔出或插入的事件，然后调用告警接口即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ ~]# cat /etc/udev/rules.d/50-ssd-monitor.rules</span><br><span class="line">KERNEL==&quot;sd[a-z]+$&quot;, ACTION==&quot;remove&quot;, SUBSYSTEM==&quot;block&quot;, RUN+=&quot;/usr/bin/python /usr/lib/python2.7/site-packages/disk_watcher/os_disk.py %k pullout&quot;</span><br><span class="line">KERNEL==&quot;sd[a-z]+$&quot;, ACTION==&quot;add&quot;, SUBSYSTEM==&quot;block&quot;, RUN+=&quot;/usr/bin/python /usr/lib/python2.7/site-packages/disk_watcher/os_disk.py %k insert&quot;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了如何利用软<code>RAID</code>实现系统盘高可用，在其中一块系统盘损坏后如何换盘并数据同步做了详细描述，同时也对监控告警做了讲解。总体来说，整个流水线基本上覆盖到了，具体细节部分还需多实践。</p><h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ol><li><a href="https://tecadmin.net/copy-a-gpt-partition-table-to-new-disk/" target="_blank" rel="noopener">How To Copy a GPT Partition Table to Another Disk using sgdisk</a></li><li><a href="https://support.huawei.com/enterprise/zh/knowledge/EKB1000033953" target="_blank" rel="noopener">SuSE的软Raid中一块硬盘坏掉后的修复方法</a></li><li><a href="https://askubuntu.com/questions/660023/how-to-install-ubuntu-14-04-16-04-64-bit-with-a-dual-boot-raid-1-partition-on-an" target="_blank" rel="noopener">How to install Ubuntu 14.04/16.04 64-bit with a dual-boot RAID 1 partition on an UEFI/GPT system?</a></li><li><a href="http://dev.bizo.com/2012/07/mdadm-device-or-resource-busy.html" target="_blank" rel="noopener">mdadm: device or resource busy</a></li><li><a href="http://ilinuxkernel.com/?p=958#comment-76766" target="_blank" rel="noopener">Linux硬盘盘符分配</a></li><li><a href="https://implement.pt/2018/08/uefi-via-software-raid-with-mdadm-ubuntu-16-04/" target="_blank" rel="noopener">UEFI via software RAID with mdadm in Ubuntu 16.04</a></li><li><a href="https://unix.stackexchange.com/questions/320103/whats-the-difference-between-creating-mdadm-array-using-partitions-or-the-whole" target="_blank" rel="noopener">What’s the difference between creating mdadm array using partitions or the whole disks directly</a></li><li><a href="https://djlab.com/2014/03/xenserver-6-2-with-software-raid/#comments" target="_blank" rel="noopener">XenServer 6.2 with Software RAID</a></li><li><a href="https://askubuntu.com/questions/380447/uefi-boot-fails-when-cloning-image-to-new-machine" target="_blank" rel="noopener">UEFI boot fails when cloning image to new machine</a></li><li><a href="https://unix.stackexchange.com/questions/230349/how-to-correctly-install-grub-on-a-soft-raid-1" target="_blank" rel="noopener">How to correctly install GRUB on a soft RAID 1?</a></li><li><a href="https://unix.stackexchange.com/questions/83787/how-to-boot-after-raid-failure-software-raid" target="_blank" rel="noopener">How to boot after RAID failure (software RAID)?</a></li><li><a href="https://serverfault.com/questions/483141/mdadm-raid-1-grub-only-on-sda" target="_blank" rel="noopener">mdadm raid 1 grub only on sda</a></li><li><a href="https://askubuntu.com/questions/66637/can-the-efi-system-partition-be-raided" target="_blank" rel="noopener">Can the EFI system partition be RAIDed?</a></li><li><a href="https://unix.stackexchange.com/questions/69214/partitioning-efi-machine-with-two-ssd-disks-in-mirror" target="_blank" rel="noopener">Partitioning EFI machine with two SSD disks in mirror</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/ssd_ha.png&quot; alt=&quot;HA RAID&quot;&gt;&lt;/center&gt;

&lt;p&gt;一套完善的系统理论上是不应该存在任何的单点故障，但是系统盘往往被人所忽略，而系统盘又恰恰是最重要的一个点。本文主要讲解如何利用软&lt;code&gt;RAID&lt;/code&gt;实现系统盘高可用，并且实现自动换盘、自动告警和自动恢复。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Disk" scheme="https://tony-yin.github.io/tags/Disk/"/>
    
      <category term="HA" scheme="https://tony-yin.github.io/tags/HA/"/>
    
      <category term="RAID" scheme="https://tony-yin.github.io/tags/RAID/"/>
    
  </entry>
  
  <entry>
    <title>软 RAID 详解</title>
    <link href="https://tony-yin.github.io/2019/02/10/software_raid/"/>
    <id>https://tony-yin.github.io/2019/02/10/software_raid/</id>
    <published>2019-02-10T05:07:06.000Z</published>
    <updated>2019-05-04T16:51:54.324Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/raid.png" alt="RAID"></center><p>这篇文章聊聊软<code>RAID</code>。</p><a id="more"></a><h2 id="RAID-amp-软-RAID"><a href="#RAID-amp-软-RAID" class="headerlink" title="RAID &amp; 软 RAID"></a>RAID &amp; 软 RAID</h2><h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h3><p>随着数据日益增长，单块硬盘往往因为容量小而不能满足大部分人的需求，于是<code>RAID</code>就应运而生。<code>RAID</code>（ <code>Redundant Array of Independent Disks</code>）即独立磁盘冗余阵列，简称磁盘阵列。简单地说，<code>RAID</code>是由多个独立的高性能磁盘驱动器组成的磁盘组，从而提供比单个磁盘更高的存储性能和数据冗余的技术。</p><h4 id="Tips：JBOD"><a href="#Tips：JBOD" class="headerlink" title="Tips：JBOD"></a>Tips：JBOD</h4><p>这里要提一下<code>JBOD</code>（<code>Just a Bunch of Disks</code>）。<code>JBOD</code>将多个物理磁盘串联起来，提供一个巨大的逻辑磁盘。<code>JBOD</code>的数据存放机制是由第一块磁盘开始按顺序往后存储，当前磁盘存储空间用完后，再依次往后面的磁盘存储数据。<code>JBOD</code>存储性能完全等同于单块磁盘，而且也不提供数据冗余。它只是简单提供一种扩展存储空间的机制，<code>JBOD</code>可用存储容量等于所有成员磁盘的存储空间之和，即拥有容量叠加的作用。目前<code>JBOD</code>常指磁盘柜，而不论其是否提供<code>RAID</code>功能。</p><h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><p><code>RAID</code>中主要有三个关键概念和技术：镜像（<code>Mirroring</code>）、数据条带（<code>Data Stripping</code>）和数据校验（<code>Data parity</code>）。</p><ul><li><strong>镜像</strong>，将数据复制到多个磁盘，一方面可以提高可靠性，另一方面可并发从两个或多个副本读取数据来提高读性能。显而易见，镜像的写性能要稍低，确保数据正确地写到多个磁盘需要更多的时间消耗。</li><li><strong>数据条带</strong>，将数据分片保存在多个不同的磁盘，多个数据分片共同组成一个完整数据副本，这与镜像的多个副本是不同的，它通常用于性能考虑。数据条带具有更高的并发粒度，当访问数据时，可以同时对位于不同磁盘上数据进行读写操作，从而获得非常可观的<code>I/O</code>性能提升。</li><li><strong>数据校验</strong>，利用冗余数据进行数据错误检测和修复，冗余数据通常采用海明码、异或操作等算法来计算获得。利用校验功能，可以很大程度上提高磁盘阵列的可靠性、鲁棒性和容错能力。不过，数据校验需要从多处读取数据并进行计算和对比，会影响系统性能。</li></ul><p>不同等级的<code>RAID</code>采用一个或多个以上的三种技术，来获得不同的数据可靠性、可用性和<code>I/O</code>性能。至于采用何种模式的<code>RAID</code>，需要在深入理解系统需求的前提下进行合理选择，综合评估可靠性、性能和成本来进行折中的选择。</p><center><img src="http://cdn.tony-yin.site/raid_models.jpg" alt="raid models"></center><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>随着处理器、内存、计算机接口等技术的不断发展，<code>RAID</code>不断地发展和革新，在计算机存储领域得到了广泛的应用，从高端系统逐渐延伸到普通的中低端系统。<code>RAID</code>技术如此流行，源于其具有显著的特征和优势，基本可以满足大部分的数据存储需求。总体说来，<code>RAID</code>主要优势有如下几点</p><ol><li><strong>大容量</strong>，<code>RAID</code>扩大了磁盘的容量，由多个磁盘组成的<code>RAID</code>系统具有海量的存储空间。现在单个磁盘的容量就可以到<code>10TB</code>以上，这样<code>RAID</code>的存储容量就可以达到<code>PB</code>级，大多数的存储需求都可以满足。一般来说，<code>RAID</code>可用容量要小于所有成员磁盘的总容量。不同等级的<code>RAID</code>算法需要一定的冗余开销，具体容量开销与采用算法相关。如果已知<code>RAID</code>算法和容量，可以计算出<code>RAID</code>的可用容量。通常，<code>RAID</code>容量利用率在<code>50%</code> ~ <code>90%</code>之间。</li><li><strong>高性能</strong>，<code>RAID</code>的高性能受益于数据条带化技术。单个磁盘的<code>I/O</code>性能受到接口、带宽等计算机技术的限制，性能往往很有 限，容易成为系统性能的瓶颈。通过数据条带化，<code>RAID</code>将数据<code>I/O</code>分散到各个成员磁盘上，从而获得比单个磁盘成倍增长的聚合<code>I/O</code>性能。</li><li><strong>可靠性</strong>，可用性和可靠性是<code>RAID</code>的另一个重要特征。从理论上讲，由多个磁盘组成的<code>RAID</code>系统在可靠性方面应该比单个磁盘要差。这里有个隐含假定：单个磁盘故障将导致整个<code>RAID</code>不可用。<code>RAID</code>采用镜像和数据校验等数据冗余技术，打破了这个假定。镜像是最为原始的冗余技术，把某组磁盘驱动器上的数据完全复制到另一组磁盘驱动器上，保证总有数据副本可用。 比起镜像<code>50%</code>的冗余开销，数据校验要小很多，它利用校验冗余信息对数据进行校验和纠错。<code>RAID</code>冗余技术大幅提升数据可用性和可靠性，保证了若干磁盘出错时，不会导致数据的丢失，不影响系统的连续运行。</li><li><strong>可管理性</strong>，实际上，<code>RAID</code>是一种虚拟化技术，它对多个物理磁盘驱动器虚拟成一个大容量的逻辑驱动器。对于外部主机系统来说，<code>RAID</code>是一个单一的、快速可靠的大容量磁盘驱动器。这样，用户就可以在这个虚拟驱动器上来组织和存储应用系统数据。从用户应用角度看，可使存储系统简单易用，管理也很便利。由于<code>RAID</code>内部完成了大量的存储管理工作，管理员只需要管理单个虚拟驱动器，可以节省大量的管理工作。<code>RAID</code>可以动态增减磁盘驱动器，可自动进行数据校验和数据重建，这些都可以大大简化管理工作。</li></ol><center><img src="http://cdn.tony-yin.site/raid_advantages.png" alt="raid advantages"></center><p>由于本篇文章主要讲解的是软<code>RAID</code>，所以就不展开赘述，对<code>RAID</code>想要深入了解或对<code>RAID</code>各种模式感兴趣的，可以阅读以下链接：</p><ul><li><a href="https://www.zhihu.com/question/20131784" target="_blank" rel="noopener">RAID 有哪几种？有什么区别？</a></li><li><a href="https://www.cnblogs.com/efforeffor/p/6767161.html" target="_blank" rel="noopener">RAID 技术详解</a></li><li><a href="https://www.jianshu.com/p/acf495b6a21a" target="_blank" rel="noopener">RAID 及 mdadm 命令</a></li></ul><h3 id="软-RAID"><a href="#软-RAID" class="headerlink" title="软 RAID"></a>软 RAID</h3><p><code>RAID</code>分为软件<code>RAID</code>和硬件<code>RAID</code>。</p><h3 id="硬-RAID"><a href="#硬-RAID" class="headerlink" title="硬 RAID"></a>硬 RAID</h3><p>硬件磁盘阵列（<code>hardwareRAID</code>）是通过<strong>磁盘阵列卡</strong>（<code>RAID</code>卡）来创建磁盘阵列的。在<code>RAID</code>卡上会有一个专门的芯片来处理<code>RAID</code>任务，可以大大减轻原来系统的计算压力和<code>I/O</code>压力，效率也会得到很好的提升；同时现在大部分的<code>RAID</code>卡都支持热拔插，所以在更换损坏磁盘时是非常方便的。但是不好的一点是<code>RAID</code>卡<strong>比较贵</strong>，特别是那些好一点的<code>RAID</code>卡就会特别贵，而且功能还不能保证特别齐全，所以在这种情况下就出现了软件<code>RAID</code>，来模拟硬件<code>RAID</code>。</p><h3 id="软-RAID-1"><a href="#软-RAID-1" class="headerlink" title="软 RAID"></a>软 RAID</h3><p>软件<code>RAID</code>是一种模拟硬件<code>RAID</code>的产物，运行在操作系统上面，所有任务的处理都由<code>CPU</code>来完成，所以需要占用一定的系统资源，特别是计算和<code>I/O</code>资源，所以性能不如硬<code>RAID</code>，但软<code>RAID</code>实现简单，不需要额外的硬件设备。。虽然说现在的机器计算速度都非常快了，但是对于一些要求较高的场景或企业，一般最好还是尽量不要选择软件<code>RAID</code>的，毕竟在总的使用成本上来说硬件<code>RAID</code>性价比还是蛮高的（硬<code>RAID</code>通过<code>RAID</code>卡解决了很多管理问题，大大地降低了后期运维成本）。</p><h3 id="硬软-RAID-优劣比较"><a href="#硬软-RAID-优劣比较" class="headerlink" title="硬软 RAID 优劣比较"></a>硬软 RAID 优劣比较</h3><p>硬<code>RAID</code>优势：</p><ul><li><strong>性能</strong>，所有<code>RAID</code>操作都由<code>RAID</code>控制芯片完成，不占用任何<code>CPU</code>和内存资源，而且<code>RAID</code>卡上一般还有额外的<code>cache</code>进一步提升性能，同时拥有独立的电池对缓存进行供电保护，系统重启/电源恢复的时候可以把缓存中未写入硬盘的数据写入硬盘。</li><li><strong>功能强大</strong>，硬<code>RAID</code>可以支持所有与<code>RAID</code>相关的功能和所有<code>RAID</code>级别，而软<code>RAID</code>只能支持几种基础的<code>RAID</code>级别，并且不具有硬<code>RAID</code>的许多高级功能，比如点灯、缓存、热插拔等等。</li><li><strong>兼容性</strong>，硬<code>RAID</code>独立于系统，例如<code>windows/linux</code>都可以用，本身拥有<code>CPU</code>、内存、电池等。软<code>RAID</code>依赖于操作系统，如果操作系统出问题，软<code>RAID</code>就挂了。硬<code>RAID</code>的兼容性要好很多，万一系统出了问题，也可以很方便地做系统维护和数据恢复。</li></ul><p>软<code>RAID</code>优势：</p><ul><li><strong>免费！</strong></li><li><strong>免费！</strong></li><li><strong>免费！</strong></li></ul><p>重要的事情说三遍，软<code>RAID</code>最大的优势就是便宜！！！</p><p>总的来说，硬<code>RAID</code>功能上是完爆软<code>RAID</code>的，但是硬<code>RAID</code>比较昂贵，一般的<code>RAID</code>都需要几千元。企业级的核心应用推荐采用硬<code>RAID</code>的方案，花钱解决一切烦恼。而一些不是特别核心的应用或者个人推荐采用软<code>RAID</code>，软<code>RAID</code>目前大部分操作系统都支持，并且对基础的<code>RAID</code>的功能支持的也不错，能够满足大部分需求，最关键的还是不要钱！！！</p><h2 id="mdadm"><a href="#mdadm" class="headerlink" title="mdadm"></a>mdadm</h2><p><code>mdadm</code>是<code>Linux</code>操作系统上开源的软<code>RAID</code>用户层管理工具，允许用户创建和管理软<code>RAID</code>磁盘阵列。</p><p>目前，<code>mdadm</code>支持大部分常见的阵列类型，如<code>JBOD</code>、<code>RAID0</code>、<code>RAID1</code>、<code>RAID4</code>、<code>RAID5</code>、<code>RAID6</code>、<code>MULTIPATH</code>、<code>RAID10</code>等，创建和管理<code>RAID</code>也十分的方便，同时，<code>mdadm</code>使用非常灵活，磁盘或者分区都可以作为<code>RAID</code>的成员盘来创建软<code>RAID</code>。主要有<code>7</code>种使用模式：</p><table><br>    <tr><br>        <th>模式名字</th><th>主要功能</th><th><br>    </th></tr><br>    <tr><br>        <td><br>        Create<br>        </td><br>        <td><br>        使用空闲的设备创建一个新的阵列，每个设备具有元数据块<br>        </td><br>    </tr><br>        <tr><br>        <td><br>        Assemble<br>        </td><br>        <td><br>        将原来属于一个阵列的每个块设备组装为阵列<br>        </td><br>    </tr><br>        <tr><br>        <td><br>        Build<br>        </td><br>        <td><br>        创建或组装不需要元数据的阵列，每个设备没有元数据块<br>        </td><br>    </tr><br>        <tr><br>        <td><br>        Manage<br>        </td><br>        <td><br>        管理已经存储阵列中的设备，比如增加热备磁盘或者设置某个磁盘失效，然后从阵列中删除这个磁盘<br>        </td><br>    </tr><br>        <tr><br>        <td><br>        Misc<br>        </td><br>        <td><br>        报告或者修改阵列中相关设备的信息，比如查询阵列或者设备的状态信息<br>        </td><br>    </tr><br>        <tr><br>        <td><br>        Grow<br>        </td><br>        <td><br>        改变阵列中每个设备被使用的容量或阵列中的设备的数目<br>        </td><br>    </tr><br>        <tr><br>        <td><br>        Create<br>        </td><br>        <td><br>        使用空闲的设备创建一个新的阵列，每个设备具有元数据块<br>        </td><br>    </tr><br>        <tr><br>        <td><br>        Monitor<br>        </td><br>        <td><br>        监控一个或多个阵列，上报指定的事件<br>        </td><br>    </tr><br></table><h3 id="创建阵列"><a href="#创建阵列" class="headerlink" title="创建阵列"></a>创建阵列</h3><p><code>mdadm</code>使用<code>--create</code>(或其缩写<code>-C</code>)参数来创建新的阵列，并且将一些重要阵列的标识信息作为元数据可以写在每一个底层设备的指定区间。<code>--level</code>(或者其缩写<code>-l</code>)表示阵列的<code>RAID</code>级别，<code>--chunk</code>(或者其缩写<code>-c</code>)表示每个条带单元的大小，以<code>KB</code>为单位，默认为<code>64KB</code>，条带单元的大小配置对不同负载下的阵列读写性能有很大影响。<code>--raid-devices</code>(或者其缩写<code>-n</code>)表示阵列中活跃的设备个数，而<code>--spare-devices</code>(或者其缩写<code>-x</code>)表示阵列中热备盘的个数，一旦阵列中的某个磁盘失效，<code>MD</code>内核驱动程序自动用将热备磁盘加入到阵列，然后重构丢失磁盘上的数据到热备磁盘上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">创建RAID0：</span><br><span class="line">mdadm --create /dev/md0 --level=0 --chunk=32 --raid-devices=3 /dev/sd[i-k]1</span><br><span class="line">创建RAID1：</span><br><span class="line">mdadm -C /dev/md0 -l1 -c128 -n2 -x1 /dev/sd[i-k]1</span><br><span class="line">创建RAID5：</span><br><span class="line">mdadm -C /dev/md0 -l5 -n5 /dev/sd[c-g] -x1 /dev/sdb </span><br><span class="line">创建RAID6：</span><br><span class="line">mdadm -C /dev/md0 -l6 -n5 /dev/sd[c-g] -x2 /dev/sdb /dev/sdh</span><br><span class="line">创建RAID10：</span><br><span class="line">mdadm -C /dev/md0 -l10 -n6 /dev/sd[b-g] -x1 /dev/sdh</span><br></pre></td></tr></table></figure><p>如果一个块设备元数据中含有其他旧阵列信息，这时候会需要交互式命令确认<code>yes/no</code>，如果想自动化，通过管道符的方式即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">采用missing作为其中一个设备，相当于创建单盘raid1</span><br><span class="line">yes|mdadm --create /dev/md0 --level=1 --raid-devices=2 /dev/sdb1 missing</span><br></pre></td></tr></table></figure><p><code>Build</code>模式可以用来创建没有元数据（即没有<code>superblock</code>）的<code>RAID0/1</code>设备，不能创建<code>RAID4/5/6/10</code>等设备。由于不存在元数据块，很多区分和检查工作无法进行，需要对使用设备特别清楚，这种模式不常用，常用的还是<code>Create</code>模式，毕竟元数据块还是拥有很大的作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# ./mdadm -BR /dev/md0 -l0 -n6 /dev/sd[b-g]</span><br><span class="line">mdadm: array /dev/md0 built and started. </span><br><span class="line">[root@test ~]# ./mdadm -BR /dev/md0 -l1 -n2 /dev/sd[b-c]</span><br><span class="line">mdadm: array /dev/md0 built and started.</span><br><span class="line">[root@test ~]# ./mdadm -BR /dev/md0 -l5 -n6 /dev/sd[b-g]</span><br><span class="line">mdadm: Raid level 5 not permitted with --build.</span><br><span class="line">[root@test ~]# ./mdadm -BR /dev/md0 –l6 -n6 /dev/sd[b-g]</span><br><span class="line">mdadm: Raid level 5 not permitted with --build.</span><br><span class="line">[root@test ~]# ./mdadm -BR /dev/md0 –l10 -n6 /dev/sd[b-g]</span><br><span class="line">mdadm: Raid level 10 not permitted with --build.</span><br></pre></td></tr></table></figure><h3 id="查询阵列"><a href="#查询阵列" class="headerlink" title="查询阵列"></a>查询阵列</h3><h4 id="通过命令查询阵列信息"><a href="#通过命令查询阵列信息" class="headerlink" title="通过命令查询阵列信息"></a>通过命令查询阵列信息</h4><p>通过<code>mdadm</code>命令查看指定阵列的<strong>简要</strong>信息(使用<code>--query</code>或者其缩写<code>-Q</code>)和<strong>详细</strong>信息(使用<code>--detail</code>或者其缩写<code>-D</code>) 详细信息包括<code>RAID</code>的版本、创建的时间、<code>RAID</code>级别、阵列容量、可用空间、设备数量、超级块状态、更新时间、<code>UUID</code>信息、各个设备的状态、<code>RAID</code>算法级别类型和布局方式以及块大小等信息。设备状态信息分为<code>active</code>，<code>sync</code>，<code>spare</code>，<code>faulty</code>，<code>rebuilding</code>，<code>removing</code>等等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">查询简要信息</span><br><span class="line">[root@test ~]# mdadm --query /dev/md0</span><br><span class="line">/dev/md0: 2.100GiB raid10 6 devices, 1 spare. Use mdadm --detail for more detail.</span><br><span class="line">查询详细信息</span><br><span class="line">[root@test ~]# ./mdadm --detail /dev/md0</span><br><span class="line">/dev/md0:</span><br><span class="line">        Version : 00.90.03</span><br><span class="line">  Creation Time : Sun Aug 22 17:49:53 2018</span><br><span class="line">     Raid Level : raid10</span><br><span class="line">     Array Size : 3145536 (3.00 GiB 3.22 GB)</span><br><span class="line">  Used Dev Size : 1048512 (1024.11 MiB 1073.68 MB)</span><br><span class="line">   Raid Devices : 6</span><br><span class="line">  Total Devices : 7</span><br><span class="line">Preferred Minor : 0</span><br><span class="line">    Persistence : Superblock is persistent</span><br><span class="line"> </span><br><span class="line">    Update Time : Sun Aug 22 21:55:02 1999</span><br><span class="line">          State : clean</span><br><span class="line"> Active Devices : 6</span><br><span class="line">Working Devices : 7</span><br><span class="line"> Failed Devices : 0</span><br><span class="line">  Spare Devices : 1</span><br><span class="line"> </span><br><span class="line">         Layout : near=2, far=1</span><br><span class="line">     Chunk Size : 64K</span><br><span class="line"> </span><br><span class="line">           UUID : 0cabc5e5:842d4baa:e3f6261b:a17a477a</span><br><span class="line">         Events : 0.122</span><br><span class="line"> </span><br><span class="line">    Number   Major   Minor   RaidDevice State</span><br><span class="line">       0       8       16        0      active sync   /dev/sdb</span><br><span class="line">       1       8       32        1      active sync   /dev/sdc</span><br><span class="line">       2       8       48        2      active sync   /dev/sdd</span><br><span class="line">       3       8       64        3      active sync   /dev/sde</span><br><span class="line">       4       8       80        4      active sync   /dev/sdf</span><br><span class="line">       5       8       96        5      active sync   /dev/sdg</span><br><span class="line"> </span><br><span class="line">       6       8      112        -      spare   /dev/sdh</span><br></pre></td></tr></table></figure><h4 id="通过命令查询阵列中设备信息"><a href="#通过命令查询阵列中设备信息" class="headerlink" title="通过命令查询阵列中设备信息"></a>通过命令查询阵列中设备信息</h4><p>上面是查询阵列里面的详细信息，我们也可以查询阵列中具体设备的详细信息，使用命令<code>--examine</code>(或者其缩写<code>-E</code>)来检测当前的块设备上是否有阵列的元数据信息，包括设备<code>RAID</code>级别，设备<code>UUID</code>，阵列<code>UUID</code>等等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# mdadm -E /dev/sdb1</span><br><span class="line">/dev/sdb1:</span><br><span class="line">          Magic : a92b4efc</span><br><span class="line">        Version : 1.2</span><br><span class="line">    Feature Map : 0x1</span><br><span class="line">     Array UUID : df3ceb66:95a8c503:9c6c41b2:db583c57</span><br><span class="line">           Name : host244:root</span><br><span class="line">  Creation Time : Wed Apr 17 18:33:11 2019</span><br><span class="line">     Raid Level : raid1</span><br><span class="line">   Raid Devices : 2</span><br><span class="line"></span><br><span class="line"> Avail Dev Size : 167772160 (80.00 GiB 85.90 GB)</span><br><span class="line">     Array Size : 83886080 (80.00 GiB 85.90 GB)</span><br><span class="line">    Data Offset : 131072 sectors</span><br><span class="line">   Super Offset : 8 sectors</span><br><span class="line">   Unused Space : before=130992 sectors, after=0 sectors</span><br><span class="line">          State : clean</span><br><span class="line">    Device UUID : 8054a66a:962c52e8:be0c8425:db207be4</span><br><span class="line"></span><br><span class="line">Internal Bitmap : 8 sectors from superblock</span><br><span class="line">    Update Time : Sat May  4 16:13:56 2019</span><br><span class="line">  Bad Block Log : 512 entries available at offset 16 sectors</span><br><span class="line">       Checksum : 6af807c8 - correct</span><br><span class="line">         Events : 207</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   Device Role : Active device 1</span><br><span class="line">   Array State : AA (&apos;A&apos; == active, &apos;.&apos; == missing, &apos;R&apos; == replacing)</span><br></pre></td></tr></table></figure><h4 id="通过文件查询阵列信息"><a href="#通过文件查询阵列信息" class="headerlink" title="通过文件查询阵列信息"></a>通过文件查询阵列信息</h4><p>我们还可以通过<code>cat /proc/mdstat</code>查看所有运行的<code>RAID</code>阵列的状态，在第一行中首先是<code>MD</code>的设备名，<code>active</code>和<code>inactive</code>选项表示阵列是否能读写，接着是阵列的<code>RAID</code>级别，后面是属于阵列的块设备，方括号<code>[]</code>里的数字表示设备在阵列中的序号，<code>(S)</code>表示其是热备盘，<code>(F)</code>表示这个磁盘是<code>faulty</code>状态。在第二行中首先是阵列的大小，单位是<code>KB</code>，接着是<code>chunk-size</code>的大小，然后是<code>layout</code>类型，不同<code>RAID</code>级别的<code>layout</code>类型不同，<code>[6/6]</code>和<code>[UUUUUU]</code>表示阵列有<code>6</code>个磁盘并且<code>6</code>个磁盘都是正常运行的，而<code>[5/6]</code>和<code>[_UUUUU]</code>表示阵列有<code>6</code>个磁盘中<code>5</code>个都是正常运行的，下划线对应的那个位置的磁盘是<code>faulty</code>状态的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# cat /proc/mdstat</span><br><span class="line">Personalities : [raid6] [raid5] [raid4] [raid1]</span><br><span class="line">md0 : active raid5 sdh[6](S) sdg[5] sdf[4] sde[3] sdd[2] sdc[1] sdb[0]</span><br><span class="line">      5242560 blocks level 5, 64k chunk, algorithm 2 [6/6] [UUUUUU]</span><br><span class="line"> </span><br><span class="line">unused devices: &lt;none&gt;</span><br><span class="line">[root@test ~]# mdadm /dev/md0 -f /dev/sdh /dev/sdb</span><br><span class="line">mdadm: set /dev/sdh faulty in /dev/md0</span><br><span class="line">mdadm: set /dev/sdb faulty in /dev/md0</span><br><span class="line">[root@test ~]# cat /proc/mdstat</span><br><span class="line">Personalities : [raid6] [raid5] [raid4] [raid1]</span><br><span class="line">md0 : active raid10 sdh[6] sdb[7](F) sdc[0] sdg[5] sdf[4] sde[3] sdd[2]</span><br><span class="line">      3145536 blocks 64K chunks 2 near-copies [6/5] [U_UUUU]</span><br><span class="line">      [=======&gt;........]  recovery = 35.6% (373888/1048512) finish=0.1min speed=93472K/sec</span><br><span class="line">unused devices: &lt;none&gt;</span><br></pre></td></tr></table></figure><p>并且还会展示阵列中一些状态，比如<code>recvoery</code>，<code>resync</code>等等，并且还有详细包括进度值、速度、完成块大小等。</p><h4 id="通过文件系统查询"><a href="#通过文件系统查询" class="headerlink" title="通过文件系统查询"></a>通过文件系统查询</h4><p><code>Linux</code>系统目前支持<code>sysfs</code>也可以访问<code>/sys/block/md0</code>目录查询阵列信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# ls -l /sys/block/md0/</span><br><span class="line">capability  holders  range      size    stat       uevent</span><br><span class="line">dev         md       removable  slaves  subsystem</span><br><span class="line">[root@test ~]# ls /sys/block/md0/md/</span><br><span class="line">array_state      dev-sdg           rd1               suspend_lo</span><br><span class="line">bitmap_set_bits  dev-sdh           rd2               sync_action</span><br><span class="line">chunk_size       layout            rd3               sync_completed</span><br><span class="line">component_size   level             rd4               sync_speed</span><br><span class="line">dev-sdb          metadata_version  rd5               sync_speed_max</span><br><span class="line">dev-sdc          mismatch_cnt      reshape_position  sync_speed_min</span><br><span class="line">dev-sdd          new_dev           resync_start</span><br><span class="line">dev-sde          raid_disks        safe_mode_delay</span><br><span class="line">dev-sdf          rd0               suspend_hi</span><br><span class="line">[root@test ~]# ls /sys/block/md0/slaves/</span><br><span class="line">sdb  sdc  sdd  sde  sdf  sdg  sdh</span><br></pre></td></tr></table></figure><h3 id="停止-amp-删除阵列"><a href="#停止-amp-删除阵列" class="headerlink" title="停止 &amp; 删除阵列"></a>停止 &amp; 删除阵列</h3><p>当阵列没有文件系统或者其他存储应用以及高级设备使用的话，可以使用<code>--stop</code>(或者其缩写<code>-S</code>)停止阵列；如果命令返回设备或者资源忙类型的错误，说明<code>/dev/md0</code>正在被上层应用使用，暂时不能停止，必须要首先停止上层的应用，这样也能保证阵列上数据的一致性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# mdadm --stop /dev/md0</span><br><span class="line">mdadm: fail to stop array /dev/md0: Device or resource busy</span><br><span class="line">[root@test ~]# umount /dev/md0</span><br><span class="line">[root@test ~]# mdadm --stop /dev/md0 </span><br><span class="line">mdadm: stopped /dev/md0</span><br></pre></td></tr></table></figure><p>上面只是停止阵列，阵列其中的设备还存在着阵列元数据信息，如果需要彻底删除阵列，还需要<code>--zero-superblock</code>将阵列中所有设备的元数据块删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# mdadm --zero-superblock /dev/sdb</span><br></pre></td></tr></table></figure><h3 id="组装阵列"><a href="#组装阵列" class="headerlink" title="组装阵列"></a>组装阵列</h3><p>模式<code>--assemble</code>或者其缩写(<code>-A</code>)主要是检查底层设备的元数据信息，然后再组装为活跃的阵列。如果我们已经知道阵列由那些设备组成，可以指定使用那些设备来启动阵列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# mdadm -A /dev/md0 /dev/sd[b-h]</span><br><span class="line">mdadm: /dev/md0 has been started with 6 drives and 1 spare.</span><br></pre></td></tr></table></figure><p>可以通过配置文件<code>/etc/mdadm.conf</code>重新组装，<code>mdadm</code>先检<code>查mdadm.conf</code>中的<code>DEVICE</code>信息，然后从每个设备上读取元数据信息，并检查是否和<code>ARRAY</code>信息一致，如果信息一致则启动阵列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -As /dev/md0</span><br></pre></td></tr></table></figure><p>如果没有配置<code>/etc/mdadm.conf</code>文件，而且又不知道阵列由那些磁盘组成，则可以使用上面提到的查询命令<code>--examine</code>(或者其缩写<code>-E</code>)来检测当前的块设备上是否有阵列的元数据信息，找到阵列的唯一标识<code>UUID</code>和阵列包含的设备名字，然后再使用上面的命令来组装阵列，也可以使用<code>UUID</code>标识来组装阵列。没有一致的元数据的信息设备(例如<code>/dev/sda</code>和<code>/dev/sda1</code>等)<code>mdadm</code>程序会自动跳过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# ./mdadm -Av --uuid=0cabc5e5:842d4baa:e3f6261b:a17a477a /dev/md0 /dev/sd*</span><br><span class="line">mdadm: looking for devices for /dev/md0</span><br><span class="line">mdadm: no recogniseable superblock on /dev/sda</span><br><span class="line">mdadm: /dev/sda has wrong uuid.</span><br><span class="line">mdadm: no recogniseable superblock on /dev/sda1</span><br><span class="line">mdadm: /dev/sda1 has wrong uuid.</span><br><span class="line">mdadm: no RAID superblock on /dev/sdi</span><br><span class="line">mdadm: /dev/sdi has wrong uuid.</span><br><span class="line">mdadm: /dev/sdi1 has wrong uuid.</span><br><span class="line">mdadm: no RAID superblock on /dev/sdj</span><br><span class="line">mdadm: /dev/sdj has wrong uuid.</span><br><span class="line">mdadm: /dev/sdj1 has wrong uuid.</span><br><span class="line">mdadm: no RAID superblock on /dev/sdk</span><br><span class="line">mdadm: /dev/sdk has wrong uuid.</span><br><span class="line">mdadm: /dev/sdk1 has wrong uuid.</span><br><span class="line">mdadm: /dev/sdb is identified as a member of /dev/md0, slot 0.</span><br><span class="line">mdadm: /dev/sdc is identified as a member of /dev/md0, slot 1.</span><br><span class="line">mdadm: /dev/sdd is identified as a member of /dev/md0, slot 2.</span><br><span class="line">mdadm: /dev/sde is identified as a member of /dev/md0, slot 3.</span><br><span class="line">mdadm: /dev/sdf is identified as a member of /dev/md0, slot 4.</span><br><span class="line">mdadm: /dev/sdg is identified as a member of /dev/md0, slot 5.</span><br><span class="line">mdadm: /dev/sdh is identified as a member of /dev/md0, slot 6.</span><br><span class="line">mdadm: added /dev/sdc to /dev/md0 as 1</span><br><span class="line">mdadm: added /dev/sdd to /dev/md0 as 2</span><br><span class="line">mdadm: added /dev/sde to /dev/md0 as 3</span><br><span class="line">mdadm: added /dev/sdf to /dev/md0 as 4</span><br><span class="line">mdadm: added /dev/sdg to /dev/md0 as 5</span><br><span class="line">mdadm: added /dev/sdh to /dev/md0 as 6</span><br><span class="line">mdadm: added /dev/sdb to /dev/md0 as 0</span><br><span class="line">mdadm: /dev/md0 has been started with 6 drives and 1 spare.</span><br></pre></td></tr></table></figure><h4 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h4><p><code>/etc/mdadm.conf</code>作为默认的配置文件，主要作用是方便跟踪软<code>RAID</code>的配置，尤其是可以配置监视和事件上报选项。<code>Assemble</code>命令也可以使用<code>--config</code>(或者其缩写<code>-c</code>)来指定配置文件。我们通常可以如下命令来建立配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# mdadm -Ds &gt; /etc/mdadm.conf</span><br><span class="line">[root@test ~]# cat /etc/mdadm.conf</span><br><span class="line"># mdadm.conf written out by anaconda</span><br><span class="line">MAILADDR root</span><br><span class="line">AUTO +imsm +1.x -all</span><br><span class="line">ARRAY /dev/md/1 level=raid1 num-devices=2 UUID=fe796549:cdbe506c:51e5404e:fa40fee6</span><br><span class="line">ARRAY /dev/md/2 level=raid1 num-devices=2 UUID=60cecdc1:f115d9e5:f9ddfb52:c3c035ab</span><br><span class="line">ARRAY /dev/md/3 level=raid1 num-devices=2 UUID=df3ceb66:95a8c503:9c6c41b2:db583c57</span><br><span class="line">ARRAY /dev/md/4 level=raid0 num-devices=2 UUID=7c5f42c1:9b013ec0:b17b7337:33df22ca</span><br><span class="line">ARRAY /dev/md/5 level=raid1 num-devices=2 UUID=4cbb3226:c5acf9e3:fb156e23:9aa56a48</span><br></pre></td></tr></table></figure><p>使用配置文件启动阵列时，<code>mdadm</code>会查询配置文件中的设备和阵列内容，然后启动运行所有能运行<code>RAID</code>阵列。如果指定阵列的设备名字，则只启动对应的阵列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# mdadm -As</span><br><span class="line">mdadm: /dev/md1 has been started with 3 drives.</span><br><span class="line">mdadm: /dev/md0 has been started with 6 drives and 1 spare.</span><br><span class="line">[root@test ~]# cat /proc/mdstat</span><br><span class="line">Personalities : [raid0] [raid10]</span><br><span class="line">md0 : active raid10 sdb[0] sdh[6](S) sdg[5] sdf[4] sde[3] sdd[2] sdc[1]</span><br><span class="line">      3145536 blocks 64K chunks 2 near-copies [6/6] [UUUUUU]</span><br><span class="line"> </span><br><span class="line">md1 : active raid0 sdi1[0] sdk1[2] sdj1[1]</span><br><span class="line">      7337664 blocks 32k chunks</span><br><span class="line"> </span><br><span class="line">unused devices: &lt;none&gt;</span><br><span class="line">[root@test ~]# mdadm -S /dev/md0 /dev/md1</span><br><span class="line">mdadm: stopped /dev/md0</span><br><span class="line">mdadm: stopped /dev/md1</span><br><span class="line">[root@test ~]# mdadm -As /dev/md0</span><br><span class="line">mdadm: /dev/md0 has been started with 6 drives and 1 spare.</span><br><span class="line">[root@test ~]# cat /proc/mdstat</span><br><span class="line">Personalities : [raid0] [raid10]</span><br><span class="line">md0 : active raid10 sdb[0] sdh[6](S) sdg[5] sdf[4] sde[3] sdd[2] sdc[1]</span><br><span class="line">      3145536 blocks 64K chunks 2 near-copies [6/6] [UUUUUU]</span><br><span class="line"> </span><br><span class="line">unused devices: &lt;none&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>这个配置文件不是随着阵列信息随时变化的，而是可以手动修改的。所以根据配置文件组装未必百分百成功，因为之前可能阵列被手动修改过，所以建议在每一次改变阵列信息后，最好同步一下当前的阵列信息到配置文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# mdadm -Ds &gt; /etc/mdadm.conf</span><br></pre></td></tr></table></figure><h3 id="管理阵列"><a href="#管理阵列" class="headerlink" title="管理阵列"></a>管理阵列</h3><p><code>mdadm</code>可以在<code>Manage</code>模式下，对运行中的阵列进行添加及删除磁盘。常用于标识<code>failed</code>磁盘，增加<code>spare</code>(热备)磁盘，以及从阵列中移走已经失效的磁盘等等。 使用<code>--fail</code>(或者其缩写<code>-f</code>)指定磁盘损坏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# mdadm /dev/md0 --fail /dev/sdb</span><br><span class="line">mdadm: set /dev/sdb faulty in /dev/md0</span><br></pre></td></tr></table></figure><p>当磁盘已经损坏时，使用<code>--remove</code>(或者其缩写<code>-f</code>)参数将这个磁盘从磁盘阵列中移走；但如果设备还正在被阵列使用（即不处于失效状态），则不能从阵列中移走。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# mdadm /dev/md0 --remove /dev/sdb</span><br><span class="line">mdadm: hot removed /dev/sdb</span><br><span class="line">[root@test ~]# mdadm /dev/md0 --remove /dev/sde</span><br><span class="line">mdadm: hot remove failed for /dev/sde: Device or resource busy</span><br></pre></td></tr></table></figure><p>如果阵列带有<code>spare</code>磁盘，那么自动将损坏磁盘上的数据重构到新的<code>spare</code>磁盘上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# mdadm -f /dev/md0 /dev/sdb ; cat /proc/mdstat</span><br><span class="line">mdadm: set /dev/sdb faulty in /dev/md0</span><br><span class="line">Personalities : [raid0] [raid10]</span><br><span class="line">md0 : active raid10 sdh[6] sdb[7](F) sdc[0] sdg[5] sdf[4] sde[3] sdd[2]</span><br><span class="line">      3145536 blocks 64K chunks 2 near-copies [6/5] [U_UUUU]</span><br><span class="line">      [=======&gt;........]  recovery = 35.6% (373888/1048512) finish=0.1min speed=93472K/sec</span><br><span class="line"> </span><br><span class="line">unused devices: &lt;none&gt;</span><br></pre></td></tr></table></figure><p>还可以使用<code>--add</code>(或者其缩写<code>-a</code>)参数增加磁盘：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# mdadm /dev/md0 --add /dev/sdh</span><br><span class="line">mdadm: added /dev/sdh</span><br></pre></td></tr></table></figure><h3 id="扩展阵列"><a href="#扩展阵列" class="headerlink" title="扩展阵列"></a>扩展阵列</h3><p>如果在创建阵列时不想使用整个块设备，可以指定用于创建<code>RAID</code>阵列每个块设备使用的设备大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# mdadm -CR /dev/md0 -l5 -n6 /dev/sd[b-g] -x1 /dev/sdh --size=102400</span><br></pre></td></tr></table></figure><p>然后在阵列需要扩展大小时，使用模式<code>--grow</code>(或者其缩写<code>-G</code>)以及<code>--size</code>参数(或者其缩写<code>-z</code>)再加上合适的大小数值就能分别扩展阵列所使用每个块设备的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# mdadm -Q /dev/md0</span><br><span class="line">/dev/md0: 500.00MiB raid5 6 devices, 1 spare. Use mdadm --detail for more detail. </span><br><span class="line">[root@test ~]# mdadm --grow /dev/md0 --size=204800</span><br><span class="line">[root@test ~]# cat /proc/mdstat</span><br><span class="line">Personalities : [raid0] [raid10] [raid6] [raid5] [raid4]</span><br><span class="line">md0 : active raid5 sdh[6](S) sdg[5] sdf[4] sde[3] sdd[2] sdc[1] sdb[0]</span><br><span class="line">      1024000 blocks level 5, 64k chunk, algorithm 2 [6/6] [UUUUUU]</span><br><span class="line">      [============&gt;......]  resync = 69.6% (144188/204800) finish=0.0min speed=10447K/sec</span><br><span class="line"> </span><br><span class="line">unused devices: &lt;none&gt;</span><br><span class="line">[root@test ~]# mdadm -Q /dev/md0</span><br><span class="line">/dev/md0: 1000.00MiB raid5 6 devices, 1 spare. Use mdadm --detail for more detail.</span><br></pre></td></tr></table></figure><p>如果上面是文件系统，在设备大小扩展后，文件系统也要同时扩展。</p><p><code>mdadm</code>还提供增加或减少阵列中设备个数的功能(<code>reshape</code>)，使用模式<code>—grow</code>和<code>--raid-disks</code>(或者其缩写<code>-n</code>)参数再加上合适的设备个数。扩展后阵列中原来的热备盘变为活跃磁盘，所以阵列的设备个数增加，阵列的大小也相应增加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# ./mdadm -D /dev/md0</span><br><span class="line">/dev/md0:</span><br><span class="line">        Version : 00.90.03</span><br><span class="line">  Creation Time : Sun Aug 22 22:16:19 1999</span><br><span class="line">     Raid Level : raid5</span><br><span class="line">     Array Size : 1024000 (1000.17 MiB 1048.58 MB)</span><br><span class="line">  Used Dev Size : 204800 (200.03 MiB 209.72 MB)</span><br><span class="line">   Raid Devices : 6</span><br><span class="line">  Total Devices : 7</span><br><span class="line">Preferred Minor : 0</span><br><span class="line">    Persistence : Superblock is persistent</span><br><span class="line"> </span><br><span class="line">    Update Time : Sun Aug 22 22:23:46 1999</span><br><span class="line">          State : clean</span><br><span class="line"> Active Devices : 6</span><br><span class="line">Working Devices : 7</span><br><span class="line"> Failed Devices : 0</span><br><span class="line">  Spare Devices : 1</span><br><span class="line"> </span><br><span class="line">         Layout : left-symmetric</span><br><span class="line">     Chunk Size : 64K</span><br><span class="line"> </span><br><span class="line">           UUID : 53e6395c:1af16258:087cb2a0:b66b087f</span><br><span class="line">         Events : 0.12</span><br><span class="line"> </span><br><span class="line">    Number   Major   Minor   RaidDevice State</span><br><span class="line">       0       8       16        0      active sync   /dev/sdb</span><br><span class="line">       1       8       32        1      active sync   /dev/sdc</span><br><span class="line">       2       8       48        2      active sync   /dev/sdd</span><br><span class="line">       3       8       64        3      active sync   /dev/sde</span><br><span class="line">       4       8       80        4      active sync   /dev/sdf</span><br><span class="line">       5       8       96        5      active sync   /dev/sdg</span><br><span class="line"> </span><br><span class="line">       6       8      112        -      spare   /dev/sdh</span><br><span class="line">[root@test ~]# ./mdadm --grow /dev/md0 --raid-disks=7</span><br><span class="line">mdadm: Need to backup 1920K of critical section..</span><br><span class="line">mdadm: ... critical section passed.</span><br><span class="line">[root@test ~]# cat /proc/mdstat</span><br><span class="line">Personalities : [raid0] [raid10] [raid6] [raid5] [raid4]</span><br><span class="line">md0 : active raid5 sdh[6] sdg[5] sdf[4] sde[3] sdd[2] sdc[1] sdb[0]</span><br><span class="line">      1024000 blocks super 0.91 level 5, 64k chunk, algorithm 2 [7/7] [UUUUUUU]</span><br><span class="line">      [===&gt;.............]  reshape = 19.4% (40256/204800) finish=0.7min speed=3659K/sec</span><br><span class="line"> </span><br><span class="line">unused devices: &lt;none&gt;</span><br></pre></td></tr></table></figure><h3 id="监控阵列"><a href="#监控阵列" class="headerlink" title="监控阵列"></a>监控阵列</h3><p><code>mdadm</code>还可以对<code>RAID</code>阵列进行监控，监控程序定时查询指定的事件是否发生，然后根据配置来妥善处理。例如当阵列中的磁盘设备出现问题的时候，可以发送邮件给管理员；或者当磁盘出现问题的时候由回调程序来进行自动的磁盘替换，所有监控事件都可以记录到系统日志中。目前<code>mdadm</code>支持的事件有：</p><ul><li><code>RebuildStarted</code></li><li><code>RebuildNN</code>(<code>NN is 20, 40, 60, or 80</code>)</li><li><code>RebuildFinished</code></li><li><code>Fail</code></li><li><code>FailSpare</code></li><li><code>SpareActive</code></li><li><code>NewArray</code></li><li><code>DegradedArray</code></li><li><code>MoveSpare</code></li><li><code>SparesMissing</code></li><li><code>TestMessage</code></li></ul><p>如果配置每<code>300</code>秒<code>mdadm</code>监控进程查询<code>MD</code>设备一次，当阵列出现错误，会发送邮件给指定的用户，执行事件处理的程序并且记录上报的事件到系统的日志文件。使用<code>--daemonise</code>参数(或者其缩写<code>-f</code>)使程序持续在后台运行。如果要发送邮件需要<code>sendmail</code>程序运行，当邮件地址被配置为外网地址应先测试是否能发送出去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# mdadm --monitor --mail=root@localhost --program=/root/md.sh --syslog --delay=300 /dev/md0 --daemonise</span><br></pre></td></tr></table></figure><p>查看系统日志信息，可以看到哪个阵列或者阵列中的哪个设备发生过的哪些事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# mdadm -f /dev/md0 /dev/sdb</span><br><span class="line">mdadm: set /dev/sdb faulty in /dev/md0</span><br><span class="line">[root@test ~]# tail –f /var/log/messages</span><br><span class="line">Aug 22 22:04:12 fc5 mdadm: RebuildStarted event detected on md device /dev/md0</span><br><span class="line">Aug 22 22:04:12 fc5 kernel: md: using maximum available idle IO bandwidth (but not more than 200000 KB/sec) for recovery.</span><br><span class="line">Aug 22 22:04:12 fc5 kernel: md: using 128k window, over a total of 1048512 blocks.</span><br><span class="line">Aug 22 22:04:14 fc5 mdadm: Fail event detected on md device /dev/md0, component device /dev/sdb</span><br><span class="line">Aug 22 22:04:14 fc5 mdadm: Rebuild80 event detected on md device /dev/md0</span><br><span class="line">Aug 22 22:04:16 fc5 mdadm: RebuildFinished event detected on md device /dev/md0</span><br><span class="line">Aug 22 22:04:16 fc5 mdadm: SpareActive event detected on md device /dev/md0, component device /dev/sdh</span><br><span class="line">Aug 22 22:04:16 fc5 kernel: md: md0: recovery done.</span><br></pre></td></tr></table></figure><p>回调程序从<code>mdadm</code>程序接受两个或者三个参数：事件名字，监控阵列的名字和特殊事件可能使用到的底层块设备名字。上面的事件返回的信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Eventname: RebuildStarted  Device: /dev/md0  next:</span><br><span class="line">Eventname: Fail  Device: /dev/md0  next: /dev/sdb</span><br><span class="line">Eventname: Rebuild80  Device: /dev/md0  next:</span><br><span class="line">Eventname: RebuildFinished  Device: /dev/md0  next:</span><br><span class="line">Eventname:SpareActive  Device: /dev/md0  next: /dev/sdh</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文讲述了<code>RAID</code>的特点和优势，然后引入硬<code>RAID</code>和软<code>RAID</code>，并分析这两者的优劣势；最后着重对软<code>RAID</code>的创建，删除，停止和扩展等操作进行了介绍和实践。</p><h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ol><li><a href="https://www.zhihu.com/question/20131784" target="_blank" rel="noopener">RAID 有哪几种？有什么区别？</a></li><li><a href="https://www.cnblogs.com/efforeffor/p/6767161.html" target="_blank" rel="noopener">RAID 技术详解</a></li><li><a href="https://www.jianshu.com/p/e8e4c768de97" target="_blank" rel="noopener">磁盘阵列（RAID）的原理与搭建</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-raid/index.html" target="_blank" rel="noopener">Linux 中软件 RAID 的使用</a></li><li><a href="https://www.jianshu.com/p/acf495b6a21a" target="_blank" rel="noopener">RAID 及 mdadm 命令</a></li><li><a href="https://blog.csdn.net/lcy4599/article/details/51870809" target="_blank" rel="noopener">RAID 方案总结</a></li><li><a href="https://blog.csdn.net/AhhSong/article/details/77898687" target="_blank" rel="noopener">软件磁盘阵列（Software RAID）介绍</a></li><li><a href="https://www.zhihu.com/question/19613331" target="_blank" rel="noopener">软 RAID 和硬 RAID 各有什么优劣？</a></li><li><a href="http://www.ha97.com/4753.html" target="_blank" rel="noopener">硬RAID、软RAID的区别详解</a></li><li><a href="http://www.jinbuguo.com/storage/raid_types.html" target="_blank" rel="noopener">三种 Linux RAID 简要说明</a></li><li><a href="https://djlab.com/2014/03/xenserver-6-2-with-software-raid" target="_blank" rel="noopener">XenServer 6.2 with Software RAID</a></li><li><a href="http://fibrevillage.com/storage/676-how-to-fix-linux-mdadm-inactive-array" target="_blank" rel="noopener">How to fix linux mdadm inactive array</a></li><li><a href="http://www.cnblogs.com/felix-zp/p/9738724.html" target="_blank" rel="noopener">针对mdadm的RAID1失效测试</a></li><li><a href="http://www.cnblogs.com/baiyw/p/3470211.html" target="_blank" rel="noopener">mdadm wiki</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/raid.png&quot; alt=&quot;RAID&quot;&gt;&lt;/center&gt;

&lt;p&gt;这篇文章聊聊软&lt;code&gt;RAID&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Disk" scheme="https://tony-yin.github.io/tags/Disk/"/>
    
      <category term="RAID" scheme="https://tony-yin.github.io/tags/RAID/"/>
    
  </entry>
  
  <entry>
    <title>聊聊 BIOS、UEFI、MBR、GPT、GRUB……</title>
    <link href="https://tony-yin.github.io/2019/01/10/Talk_BIOS_UEFI_MBR_GPT_GRUB/"/>
    <id>https://tony-yin.github.io/2019/01/10/Talk_BIOS_UEFI_MBR_GPT_GRUB/</id>
    <published>2019-01-10T05:07:06.000Z</published>
    <updated>2019-04-29T08:38:44.638Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/bios_article.jpg" alt="bios"></center><p>最近一直在搞<code>Linux</code>系统启动方面的事情，频繁地接触到<code>BIOS</code>、<code>UEFI</code>、<code>MBR</code>、<code>GPT</code>、<code>GRUB</code>等诸多概念，一下子有些混淆不清，本文就这些概念进行总结，尽量通过容易理解的表达进行讲解，对这些概念有一个清楚的认识。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>BIOS</code>（<code>Basic Input/Output System</code>）和<code>UEFI</code>（<code>Unified Extensible Firmware Interface</code>）是不同的计算机启动固件（<code>Fireware</code>），需要硬件（通常为主板）支持，相互代替的，其中<code>UEFI</code> 是比较新的方式。可以通过下面图片对这两个概念先有个直观了解：</p><p><code>BIOS</code>:</p><center><img src="http://cdn.tony-yin.site/bios.png" alt="bios"></center><p><code>UEFI</code>:</p><center><img src="http://cdn.tony-yin.site/uefi.jpg" alt="uefi"></center><h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><p><code>BIOS（Basic Input/Output System）</code>：在<code>IBM PC</code>兼容系统上使用，是一种业界标准的固件接口。这种主板类型大家应该比较熟悉，老一点的机器都是使用<code>BIOS</code>主板。对于支持<code>BIOS</code>的主板来讲，<code>BIOS</code>只能完成非常基本的硬件检测和初始化，之后的事情就都由<code>bootloader</code>来接手。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一句话概括：BIOS只认识设备，不认识分区、不认识文件。</span><br></pre></td></tr></table></figure><p><code>BIOS</code>启动的时候，会按照<code>CMOS</code>设置里的顺序，挨个查看存储设备的前<code>512</code>字节是不是以<code>0x55 0xAA</code>结尾，如果不是，那就跳过找下一个设备；如果是的话，则表示这个磁盘可以启动，加载这<code>512</code>字节里的代码，执行之后，后面的事，几乎就跟<code>BIOS</code>没啥关系了。</p><p>至于加载引导代码后面启动什么系统，取决于这<code>512B</code>（字节）里存了什么系统的代码。这个代码是各家系统安装程序写进去的，目的是启动自家系统。比如安装<code>Windows</code>，这里面就变成了<code>Windows</code>的启动代码；<br>安装了<code>Linux</code>，这里面就会变成<code>Grub</code>的启动代码。</p><h2 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h2><p>那么这<code>512</code>字节里面到底什么东西呢，看起来如此重要？这就是<code>MBR</code>（<code>Master Boot Record</code>），主分区引导记录。</p><h3 id="硬盘分区表-DPT（Disk-Partition-Table）"><a href="#硬盘分区表-DPT（Disk-Partition-Table）" class="headerlink" title="硬盘分区表 DPT（Disk Partition Table）"></a>硬盘分区表 DPT（Disk Partition Table）</h3><p>一个磁盘抛开物理组成部分的话，它就是一个地址序列，这个序列从<code>0~n-1</code>，每个地址包含<code>512B</code>（字节）的空间。一般我们将这些地址称作逻辑块地址（<code>LBA</code>），每块由<code>512B</code>组成。分区表告诉操作系统，磁盘的分区有几个，从哪里开始到哪里结束。当将一个磁盘插入已经含有操作系统的机器上时，操作系统会检索这个磁盘的分区表，并正确认识它的分区结构。一个磁盘是先有分区表，后有分区，然后才有文件系统，有了文件系统才能被操作系统读写删。磁盘分区表格式目前主要有两种，分别是<code>MBR</code>分区表和<code>GPT</code>分区表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这边有个概念需要注意下，避免混淆：MBR有两个意思，一个表示主引导记录，一个表示分区表类型，具体区别请看下文。</span><br></pre></td></tr></table></figure><ul><li><code>MBR</code>：主引导记录位置在磁盘的第一个逻辑扇区，即<code>LBA0</code>的位置。一个逻辑扇区仅有<code>512B</code>（字节） ，<code>MBR</code>引导代码占<code>446B</code>，<code>MBR</code>分区表占<code>64B</code>，最后的<code>magic number</code>占<code>2B</code>（即上述以<code>0x55 0xAA</code>结尾的标识符）。因为每个分区只有<code>16B</code>大小的分区表记录，所以寻址最大只能到<code>2.2TB</code>，并且由于分区表总共只占<code>64B</code>，所以<code>MBR</code>分区表最多<code>4</code>个分区。下图的绿色部分。</li><li><code>PBR</code>：即<code>Partition Boot Record</code>，对应主引导记录，每个分区都存在引导记录，位置在每个磁盘分区的开始部分，占用扇区不定。这个扇区一般保存着操作系统引导程序的所在位置。下图的红色部分。</li><li><code>File System</code>：操作系统对磁盘的所有操作都需要经过文件系统，删除文件指的是在文件系统里删除文件的索引条目，创建文件就是在在文件系统里添加索引条目并将具体数据写入磁盘。常见的文件系统格式有：<code>FAT</code>、<code>ext4</code>、<code>NTFS</code>。文件系统位置一般在<code>PBR</code>之后。下图黄色部分。</li></ul><center><img src="http://cdn.tony-yin.site/mbr.png" alt="mbr"></center><h2 id="BIOS-引导流程"><a href="#BIOS-引导流程" class="headerlink" title="BIOS 引导流程"></a>BIOS 引导流程</h2><p>开机后，固化在<code>ROM</code>里的<code>BIOS</code>就会被加载到内存运行，<code>BIOS</code>自检完毕以后加载<code>COMS</code>的参数，通过<code>COMS</code>的参数，<code>BIOS</code>程序加载启动磁盘的<code>MBR</code>到内存里运行，运行<code>MBR</code>的引导代码，这段代码会查找活动分区（<code>BIOS</code>不认识活动分区，但这段代码认识活动分区）的位置，加载并执行活动分区的<code>PBR</code>（另一段引导程序），与<code>MBR</code>类似，<code>PBR</code>在运行后加载操作系统的引导程序到内存运行，例如<code>Windows</code>的<code>bootmgr</code>或<code>Linux</code>的<code>grub</code>。当引导程序运行后，操作系统内核就被加载运行，完成从<code>BIOS</code>程序中接手的引导流程，整体流程如下图：</p><center><img src="http://cdn.tony-yin.site/bios_loader.png" alt="bios loader"></center><p><code>Windows</code>的<code>PBR</code>认识<code>FAT32</code>和<code>NTFS</code>两种分区，找到分区根目录的<code>bootmgr</code>文件，加载、执行<code>bootmgr</code>。<br><code>bootmgr</code>没了<code>MBR</code>和<code>PBR</code>的大小限制，<strong>可以做更多的事</strong>。它会加载并分析<code>BCD</code>启动项存储。而且<code>bootmgr</code>可以跨越磁盘读取文件了。所以无论你有几个磁盘，你在多少块磁盘上装了<code>Windows</code>，一个电脑只需要一个<code>bootmgr</code>就行了。<code>bootmgr</code>会去加载某磁盘某<code>NTFS</code>分区的<code>\Windows\System32\WinLoad.exe</code>，后面启动<code>Windows</code>的事就由<code>WinLoad.exe</code>来完成了。</p><center><img src="http://cdn.tony-yin.site/bios_partition.jpg" alt="bios loader partition"></center><p><strong>为什么图中有两组虚线？</strong></p><p>因为“启动磁盘”和“装系统的磁盘”可以是同一个磁盘，也可以不是同一个。“启动分区”和“系统分区”可以是不同磁盘的不同分区，也可以是相同磁盘的不同分区，也可以是同一个分区。</p><p>这就解释了，为什么有的时候，<code>Windows</code>装在磁盘<code>2</code>上，却要在<code>BIOS</code>里选磁盘<code>1</code>启动了。因为<code>bootmgr</code>可能在磁盘<code>1</code>上。</p><h2 id="UEFI"><a href="#UEFI" class="headerlink" title="UEFI"></a>UEFI</h2><p><code>UEFI</code>，全称<code>Unified Extensible Firmware Interface</code>，即“统一的可扩展固件接口”，是一种详细描述全新类型接口的标准，是适用于电脑的标准固件接口，旨在代替<code>BIOS</code>。此标准由<code>intel</code>公司带头组织<code>UEFI</code>联盟中的<code>140</code>多个技术公司共同创建，其中包括微软公司。<code>UEFI</code>旨在提高软件互操作性和解决<code>BIOS</code>的局限性。作为传统<code>BIOS</code>的继任者，<code>UEFI</code>拥有前辈所不具备的诸多功能，比如图形化界面、多种多样的操作方式、允许植入硬件驱动等等。这些特性让<code>UEFI</code>相比于传统<code>BIOS</code>更加易用、更加多功能、更加方便。而<code>Windows 8</code>在发布之初就对外宣布全面支持<code>UEFI</code>，这也促使了众多主板厂商纷纷转投<code>UEFI</code>，并将此作为主板的标准配置之一。<code>Intel</code>更是宣布在<code>2020</code>之前实现在芯片上将<code>BIOS</code><a href="https://www.anandtech.com/show/12068/intel-to-remove-bios-support-from-uefi-by-2020" target="_blank" rel="noopener">全部替换</a>为<code>UEFI</code>。对<code>UEFI</code>的由来感兴趣的可以阅读一下<a href="https://zhuanlan.zhihu.com/p/25281151" target="_blank" rel="noopener">【UEFI背后的历史】</a>。<br>　　<br><code>BIOS</code>只能在<code>16</code>位模式下运行，而<code>UEFI</code>可以在<code>32</code>位或<code>64</code>位模式下运行，并且具有比<code>BIOS</code>更多的可寻址地址空间，这意味着引导过程更快。这也意味着<code>UEFI</code>设置屏幕可以比<code>BIOS</code>设置屏幕更光滑，包括图形和鼠标光标支持。但是这不是强制性的，许多<code>pc</code>机仍然带有文本模式的<code>UEFI</code>设置界面，这些界面看起来和工作起来都像一个旧的<code>BIOS</code>设置屏幕。老一点的机器都是使用<code>BIOS</code>主板，现在大部分新机器都是采用<code>UEFI</code>主板，<code>UEFI</code>采用了向后兼容，所以<code>BIOS</code>切换为<code>UEFI</code>不可以，而<code>UEFI</code>切换为<code>BIOS</code>是可以的。</p><p>UEFI还包含了其他功能，它支持安全引导，这意味着可以检查操作系统的有效性，以确保没有恶意软件篡改引导过程。它可以在<code>UEFI</code>固件本身中支持联网特性，这有助于远程故障排除和配置。对于传统<code>BIOS</code>，必须坐在物理计算机前才能配置它。虽然目前<a href="http://www.ruanyifeng.com/blog/2013/01/secure_boot.html" target="_blank" rel="noopener">有厂商利用这一特性尝试垄断市场</a>，但这不意味着这不是一个很好的功能。</p><p>它也不仅仅是<code>BIOS</code>替换。<code>UEFI</code>本质上是一个运行在<code>PC</code>固件之上的微型操作系统，它可以做的比<code>BIOS</code>多得多。它可以存储在主板的闪存中，也可以在启动时从硬盘或网络共享加载。一般的<code>UEFI</code>系统仅能识别<code>FAT32</code>，不同于<code>BIOS</code>只能识别固定位置的磁盘引导块。这意味着只要将引导程序放到<code>FAT32</code>分区里，<code>UEFI</code>系统就能通过分区表的指引找到这个保存着引导程序的<code>FAT32</code>分区。<code>UEFI</code>系统是由模块化的<code>C</code>语言程序写出来的，所以通过添加或修改程序模块就能获得更多的功能。例如支持更多的文件系统，图形界面，甚至能使用浏览器浏览网页。</p><p>上面提到<code>BIOS</code>分区表类型为<code>MBR</code>，只能管理最大<code>2.2T</code>的硬盘，并且分区数上限最大为<code>4</code>个，尽管后来为了支持更多的分区，引入了扩展分区及逻辑分区的概念，但是换汤不换药，满足不了硬盘容量和分区数目急速增长的需求。而<code>UEFI</code>采用<code>GPT</code>分区表的方式后，硬盘容量和分区数目几乎没有上限（目前<code>windows</code>支持最大<code>128</code>个分区）。</p><p>对<code>UEFI</code>架构感兴趣的可以关注<a href="https://zhuanlan.zhihu.com/p/25941528" target="_blank" rel="noopener">UEFI架构详解</a></p><h2 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h2><p><code>GPT</code>，即<code>Globally Unique Identifier Partition Table</code>，全局唯一标识码分区表，简称<code>GPT</code>或<code>GUID</code>分区表，它是<code>UEFI</code>规范的一部分。由于<code>MBR</code>分区表 的局限性（还有<code>BIOS</code>的），而<code>UEFI BIOS</code>的推广也为<code>GPT</code>的实现打下了坚实的技术基础，<code>GPT</code>应运而生。<code>GPT</code>由<code>GPT</code>头和<code>GPT</code>主体，<code>GPT</code>备份组成。起始于磁盘<code>LBA1</code>的位置，相对的<code>LBA0</code>仍然为<code>MBR</code>，但是这个<code>MBR</code>是被保护的，没有引导代码，仅仅有一个被标识为未知的分区，当支持<code>GPT</code>分区表的操作系统检索到这个<code>MBR</code>后就会自动忽略并跳到<code>LBA1</code>读取<code>GPT</code>分区表。如下图，由于篇幅的关系，表的长度比例不等同与实际在磁盘地址里的实际比例。</p><center><img src="http://cdn.tony-yin.site/gpt.png" alt="gpt"></center><p><code>PMBR</code>存在的意义是当不支持<code>GPT</code>的分区工具试图对硬盘进行操作时（例如<code>MS-DOS</code>和Linux的<code>fdisk</code>程序），它可以根据这份<code>PMBR</code>以传统方式启动，过程和<code>MBR+BIOS</code>完全一致，极大地提高了兼容性。而支持<code>GPT</code>的系统在检测<code>PMBR</code>后会直接跳到GPT表头读取分区表。和<code>MBR</code>类似，分区表中存储了某个分区的起始和结束位置及其文件系统属性信息，而分区才是实际存在的物理磁盘的一部分。</p><p><code>GPT</code>表头，主要定义了分区表中分区数及每个分区大小，还包含硬盘的容量信息。分区表头还记录了这块硬盘的<code>GUID</code>，分区表头位置（总是<code>LBA1</code>）和大小，也包含了备份分区表头和分区表的位置和大小信息（<code>LBA-1~LBA-34</code>）。同时还储存着它本身和分区表的<code>CRC32</code>校验。固件、引导程序和操作系统在启动时可以根据这个校验值来判断分区表是否出错，如果出错，可以使用软件从硬盘最后的备份<code>GPT</code>中恢复整个分区表，如果备份<code>GPT</code>也校验错误，硬盘将不可使用。</p><p>分区表包含分区的类型<code>GUID</code>（如：<code>EFI</code>系统分区的<code>GUID</code>类型是<code>{C12A7328-F81F-11D2-BA4B-00A0C93EC93B}</code>），名称，起始终止位置，该分区的<code>GUID</code>以及分区属性。</p><p>相较于<code>MBR</code>，<code>GPT</code>具有以下优点：</p><ul><li><p>得益于<code>LBA</code>提升至<code>64</code>位，以及分区表中每项<code>128</code>位设定，<code>GPT</code>可管理的空间近乎无限大，假设一个扇区大小仍为<code>512</code>字节，可表示扇区数为，算下来，可管理的硬盘容量=<code>18EB</code>(<code>1EB</code>=<code>1024PB</code>=<code>1,048,576TB</code>)，<code>2.2T</code>在它面前完全不在话下。按目前的硬盘技术来看，确实近乎无限。</p></li><li><p>分区数量几乎没有限制，由于可在表头中设置分区数量的大小，如果愿意，设置分区也可以（有人愿意管理这么多分区吗），不过，目前<code>windows</code>仅支持最大<code>128</code>个分区。</p></li><li><p>自带保险，由于在磁盘的首尾部分各带一个<code>GPT</code>表头，任何一个受到破坏后都可以通过另一份恢复，极大地提高了磁盘的抗性。</p></li><li><p>循环冗余检验值针对关键数据结构而计算，提高了数据崩溃的检测几率。</p></li><li><p>尽管目前分区类型不超过百数，<code>GPT</code>仍提供了<code>16</code>字节的<code>GUID</code>来标识分区类型，使其更不容易产生冲突。</p></li><li><p>每个分区都可以拥有一个特别的名字，最长<code>72</code>字节，足够满足种奇葩命名需求。</p></li><li><p>完美支持<code>UEFI</code>，毕竟它就是<code>UEFI</code>规范的衍生品。在将来全行业<code>UEFI</code>的情境下，<code>GPT</code>必将更快淘汰<code>MBR</code>。</p></li></ul><h2 id="UEFI-引导流程"><a href="#UEFI-引导流程" class="headerlink" title="UEFI 引导流程"></a>UEFI 引导流程</h2><p>整个<code>UEFI</code>的启动详细流程描述如下：</p><ul><li>开机后，固化在<code>ROM</code>里的<code>UEFI BIOS</code>就会被加载到内存运行。</li><li><code>UEFI BIOS</code>将引导<code>EFI</code>系统进行运行。</li><li>在<code>EFI</code>系统启动后，<code>GUID</code>分区表就会被识别，之后<code>EFI</code>系统就会通过<code>.efi</code>文件启动<code>Boot Loader</code>程序加载操作系统内核。</li></ul><p>如下图：</p><center><img src="http://cdn.tony-yin.site/efi_loader.png" alt="uefi loader"></center><p>对于分区表格式为<code>MBR</code>分区表的磁盘，<code>UEFI</code>系统会 先启动<code>CSM</code>兼容模式后按传统<code>BIOS</code>的步骤加载操作系统的内核。如下图：</p><center><img src="http://cdn.tony-yin.site/uefi_mbr_loader.png" alt="uefi mbr loader"></center><h2 id="如何使用-GPT-方式安装系统"><a href="#如何使用-GPT-方式安装系统" class="headerlink" title="如何使用 GPT 方式安装系统"></a>如何使用 GPT 方式安装系统</h2><p>由于<code>MBR</code>方式限制重重，所以大部分情况下我们都会选择使用<code>GPT</code>分区方式安装系统。通过上面的讲解，我们应该知道<code>UEFI</code>方式安装的系统是肯定是使用<code>GPT</code>分区方式；而<code>BIOS</code>方式安装的系统默认使用<code>MBR</code>分区方式。</p><p>看下图，这是一个主板支持<code>UEFI</code>的机器，最下面有一个启动设备是<code>UEFI:</code>开头的，即表示通过<code>UEFI</code>方式安装系统，这样安装默认支持使用<code>GPT</code>分区方式：</p><center><img src="http://cdn.tony-yin.site/uefi_support.png" alt="uefi support"></center><p>再看下图，这是一个主板不支持<code>UEFI</code>的机器，最下面没有启动设备是<code>UEFI:</code>开头的，只有<code>ATEN</code>开头的，<code>ATEN</code>就是默认地通过<code>BIOS</code>方式安装系统：</p><center><img src="http://cdn.tony-yin.site/uefi_no_support.png" alt="uefi no support"></center><p>这样安装默认不支持使用<code>GPT</code>分区方式，不过我们可以通过一些手段强制以<code>GPT</code>分区方式安装系统，</p><p>在安装开机后第一个界面，按<code>tab</code>键，在行末尾，空格，输入<code>inst.gpt</code>，如下图所示:</p><center><img src="http://cdn.tony-yin.site/bios_force_uefi.png" alt="force gpt"></center><p>以<code>GPT</code>方式安装系统具体方案可以参考之前一篇文章：<a href="https://www.tony-yin.site/2018/12/10/Centos7-GPT/" target="_blank" rel="noopener">Centos7系统安装设置gpt分区</a></p><h2 id="GRUB"><a href="#GRUB" class="headerlink" title="GRUB"></a>GRUB</h2><h3 id="GRUB-是什么"><a href="#GRUB-是什么" class="headerlink" title="GRUB 是什么"></a>GRUB 是什么</h3><p><code>GRUB</code>（<code>Grand Unified Boot loader</code>）是硬盘中的软件，引导器（<code>loader</code>）的一种。目前主流版本是 <code>GRUB2</code>，可以看<a href="https://my.oschina.net/guol/blog/37373" target="_blank" rel="noopener">GRUB2</a>中文介绍。</p><p><code>Wikipedia</code>这样介绍<code>GURB</code>：</p><p><code>GNU GRUB</code>（简称<code>GRUB</code>）是一个来自<code>GNU</code>项目的启动引导程序。<code>GRUB</code>是多启动规范的实现，它允许用户可以在计算机内同时拥有多个操作系统，并在计算机启动时选择希望运行的操作系统。<code>GRUB</code>可用于选择操作系统分区上的不同内核，也可用于向这些内核传递启动参数。</p><center><img src="http://cdn.tony-yin.site/grub-loader.jpg" alt="grub loader"></center><p>对于只支持<code>BIOS</code>的主板，可以使用<code>grub</code>进入<code>grub</code>命令行，然后<code>为grub</code>添加第三方的<code>EFI shell</code>模块，然后就可以启动那些使用<code>EFI</code>启动的<code>OS</code>了。对于只有<code>EFI</code>的主板，当然可以写个<code>.efi</code>文件，然后转去读取<code>MBR</code>传统引导。</p><p><code>GRUB</code>用于从多操作系统的计算机中选择一个系统来启动，或从系统分区中选择特殊的内核配置。</p><p>如图：第一个选项和最后一个选项是选择不同的操作系统；第一个选项和第二个选项是选择不同的内核配置。</p><h3 id="GRUB位置"><a href="#GRUB位置" class="headerlink" title="GRUB位置"></a>GRUB位置</h3><p>其启动代码（<code>boot.img</code>）直接安装在<code>MBR</code>中，然后执行<code>GRUB</code>内核镜像（<code>core.img</code>），最后从<code>/boot/grub</code>中读取配置和其他功能代码。</p><p><code>BIOS</code>引导方式中，<code>MBR</code>分区表和<code>GPT</code>分区表的<a href="https://en.wikipedia.org/wiki/BIOS_boot_partition" target="_blank" rel="noopener">GRUB引导文件所放分区不同</a>：</p><center><img src="http://cdn.tony-yin.site/grub_location.png" alt="grub location"></center><p>如图，<code>GRUB</code>的执行顺序为<code>boot.img</code> –&gt; <code>core.img</code> –&gt; <code>/boot/grub/</code>。</p><ul><li>在<code>MBR</code>分区表中，<code>boot.img</code>和<code>core.img</code>都在<code>MBR</code>中。<code>MBR</code>虽然只占用一个扇区(<code>512Byte</code>)，但是其所在的磁道是空闲的，不会用于分区，可以放下<code>core.img</code>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Some MBR code loads additional code for a boot manager from the first track of the disk, which it assumes to be “free” space that is not allocated to any disk partition, and executes it. – MBR</span><br></pre></td></tr></table></figure><ul><li>在<code>GPT</code>分区表中，<code>MBR</code>为<code>protected MBR</code>（为兼容<code>MBR</code>，在硬盘起始位置保留的空间），后面并没有空间放<code>core.img</code>，需要建一个专门的分区来放，称为<code>BIOS boot partition</code>，该分区的文件类型为<code>unformatted</code>，<code>flag</code>为<code>BOIS_grub</code>，该<code>flag</code>用于标识<code>core.img</code>所要安装到的分区。若果使用<code>UEFI</code>引导，<code>GRUB</code>读取的是<code>ESP</code>分区中的数据，不需要<code>flag</code>为<code>BIOS_grub</code>的分区。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文依次对<code>BIOS</code>、<code>UEFI</code>、<code>MBR</code>、<code>GPT</code>、<code>GRUB</code>等概念进行了介绍和讲解，相信看完本文后，应该对<code>BIOS</code> + <code>MBR</code>和<code>UEFI</code> + <code>GPT</code>这两种方式有了充分的了解。本文做了一个比较详细的总结，旨在让读者对这些概念有一个入门的认识，当你不断研究，深入下去之后会发现这些概念只是冰山一角，还有很多知识等我们去探索，比如<code>boot loader</code>、<code>boot manager</code>、<code>FAT</code>等等。</p><h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ol><li><a href="https://www.howtogeek.com/56958/htg-explains-how-uefi-will-replace-the-bios/" target="_blank" rel="noopener">What Is UEFI, and How Is It Different from BIOS?</a></li><li><a href="https://www.anandtech.com/show/12068/intel-to-remove-bios-support-from-uefi-by-2020" target="_blank" rel="noopener">Intel to Remove Legacy BIOS Support from UEFI by 2020</a></li><li><a href="https://www.hack520.com/uefi.html" target="_blank" rel="noopener">UEFI是什么？与BIOS的区别在哪里？</a></li><li><a href="https://cntchen.github.io/2017/02/11/Ubuntu16-10-%E8%BF%81%E7%A7%BB%E5%88%B0-SSD/" target="_blank" rel="noopener">Ubuntu16.10 迁移到 SSD</a></li><li><a href="https://zhuanlan.zhihu.com/p/33438994" target="_blank" rel="noopener">现代计算机 Boot 相关知识</a></li><li><a href="https://zhuanlan.zhihu.com/p/31365115" target="_blank" rel="noopener">科普贴：BIOS和UEFI的启动项</a></li><li><a href="https://bbs.feng.com/read-htm-tid-6890655.html" target="_blank" rel="noopener">Mac 系统引导过程概述 &amp; BootCamp 的秘密</a></li><li><a href="https://zhuanlan.zhihu.com/p/25281151" target="_blank" rel="noopener">UEFI背后的历史</a></li><li><a href="https://zhuanlan.zhihu.com/p/25941528" target="_blank" rel="noopener">UEFI架构</a></li><li><a href="https://zhuanlan.zhihu.com/p/26098509" target="_blank" rel="noopener">MBR与GPT</a></li><li><a href="https://zhuanlan.zhihu.com/p/37977078" target="_blank" rel="noopener">关于UEFI启动+GPT分区的一些经验</a></li><li><a href="https://blog.51cto.com/isenknows/2053969" target="_blank" rel="noopener">CentOS 7 安装强制使用GPT分区</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/01/secure_boot.html" target="_blank" rel="noopener">反Secure Boot垄断：兼谈如何在Windows 8电脑上安装Linux</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/bios_article.jpg&quot; alt=&quot;bios&quot;&gt;&lt;/center&gt;

&lt;p&gt;最近一直在搞&lt;code&gt;Linux&lt;/code&gt;系统启动方面的事情，频繁地接触到&lt;code&gt;BIOS&lt;/code&gt;、&lt;code&gt;UEFI&lt;/code&gt;、&lt;code&gt;MBR&lt;/code&gt;、&lt;code&gt;GPT&lt;/code&gt;、&lt;code&gt;GRUB&lt;/code&gt;等诸多概念，一下子有些混淆不清，本文就这些概念进行总结，尽量通过容易理解的表达进行讲解，对这些概念有一个清楚的认识。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
      <category term="BIOS" scheme="https://tony-yin.github.io/tags/BIOS/"/>
    
      <category term="UEFI" scheme="https://tony-yin.github.io/tags/UEFI/"/>
    
      <category term="MBR" scheme="https://tony-yin.github.io/tags/MBR/"/>
    
      <category term="GPT" scheme="https://tony-yin.github.io/tags/GPT/"/>
    
      <category term="GRUB" scheme="https://tony-yin.github.io/tags/GRUB/"/>
    
  </entry>
  
  <entry>
    <title>Centos7系统安装设置gpt分区</title>
    <link href="https://tony-yin.github.io/2018/12/10/Centos7-GPT/"/>
    <id>https://tony-yin.github.io/2018/12/10/Centos7-GPT/</id>
    <published>2018-12-10T05:07:06.000Z</published>
    <updated>2018-12-17T04:35:36.549Z</updated>
    
    <content type="html"><![CDATA[<p>硬盘分区最常见的类型为<code>msdos</code>和<code>gpt</code>，前者表示<code>MBR</code>分区，而后者表示<code>GPT</code>分区。系统安装默认分区方式为<code>MBR</code>，本文讲解如何设置<code>GPT</code>分区方式安装系统，这个看起来没什么技术含量，但是笔者实践过程中还是遇到了不少阻力，并且发现相关文章甚少，故做此记录。</p><center><img src="http://cdn.tony-yin.site/lazycat.png" alt="centos7 gpt"></center><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>MBR</code>分区表(即主引导记录) 最大只支持<code>2TB</code>的分区，最多只支持<code>4</code>个主分区或<code>3</code>个主分区加一个扩展分区，信息只存储在一个区域；<code>GPT</code>（即<code>GUID</code>分区表），是源自<code>EFI</code>标准的一种较新的磁盘分区表结构的标准，是未来磁盘分区的主要形式，与<code>MBR</code>分区方式相比，突破<code>4</code>个主分区限制，每个磁盘最多支持<code>128</code>个分区，支持大于<code>2T</code>的分区，最大卷可达 <code>18EB</code>，信息存储在多个区域，当一部分受损后可修复。</p><p>设置<code>GPT</code>方式有<code>UEFI</code>和<code>BIOS</code>两种方式，<code>UEFI</code>启动是一种新的主板引导项，与传统的<code>Bios</code>方式相比可以提高开机后操作系统的启动速度。如今很多主板已经直接支持<code>UEFI</code>，这种场景下可以直接通过<code>UEFI</code>的方式设置<code>GPT</code>方式，如若主板不支持，那么还得通过传统的<code>Bios</code>方式强制设置<code>GPT</code>方式。</p><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">操作系统： centos7</span><br><span class="line">软raid配置：/分区为raid1，boot分区为raid1</span><br></pre></td></tr></table></figure><h2 id="UEFI方式"><a href="#UEFI方式" class="headerlink" title="UEFI方式"></a>UEFI方式</h2><h3 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h3><p>进入引导页面，如果存在<code>UEFI</code>安装方式，则选择<code>UEFI</code>方式安装</p><center><img src="https://raw.githubusercontent.com/tony-yin/Picture-Lib/master/lib/load_uefi.png" alt="load uefi"></center><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>配置软<code>raid</code>阶段，<code>UEFI</code>安装方式的必须存在一个<code>UEFI</code>分区，分区方式为 <code>raid1</code>，<code>/boot/efi</code>分区必须也设置为<code>raid1</code>，否则会有报错。</p><center><img src="https://raw.githubusercontent.com/tony-yin/Picture-Lib/master/lib/uefi_partition.png" alt="uefi partition"></center><h2 id="BIOS-Boot方式"><a href="#BIOS-Boot方式" class="headerlink" title="BIOS Boot方式"></a>BIOS Boot方式</h2><h3 id="引导-1"><a href="#引导-1" class="headerlink" title="引导"></a>引导</h3><p>进入引导页面，如果不存在<code>UEFI</code>安装方式，如果存在则选择默认的<code>BIOS Boot</code>方式安装</p><center><img src="https://raw.githubusercontent.com/tony-yin/Picture-Lib/master/lib/load_biosboot.png" alt="load bios boot"></center><p>进入系统安装页面，强制设置GPT方式安装：</p><center><img src="https://raw.githubusercontent.com/tony-yin/Picture-Lib/master/lib/centos7_install.png" alt="centos7 install"></center><p>点击<code>tab</code>键，在末尾输入<code>inst.gpt</code></p><center><img src="https://raw.githubusercontent.com/tony-yin/Picture-Lib/master/lib/centos7_inst_gpt.png" alt="centos7 inst gpt"></center><h3 id="分区-1"><a href="#分区-1" class="headerlink" title="分区"></a>分区</h3><p>配置软raid阶段，<code>BIOS Boot</code>安装方式的必须存在一个<code>bios</code>分区，分区方式设置为<code>raid1</code>会报错如下：</p><center><img src="https://raw.githubusercontent.com/tony-yin/Picture-Lib/master/lib/biosboot_partition_error.png" alt="bios boot raid1 partition error"></center><p>然后系统也不能继续安装下去：</p><center><img src="https://raw.githubusercontent.com/tony-yin/Picture-Lib/master/lib/biosboot_cannot_install.png" alt="Can not continue to install"></center><p>需要将分区方式改成<code>standard</code>：</p><center><img src="https://raw.githubusercontent.com/tony-yin/Picture-Lib/master/lib/biosboot_standard_partition.png" alt="BIOS Boot Standard partition"></center><p>可以继续安装系统，但是过程中会出现<code>boot loader install failed</code>的报错，直接忽略即可</p><center><img src="https://raw.githubusercontent.com/tony-yin/Picture-Lib/master/lib/boot_loader_install_error.png" alt="Boot loader install failed"></center><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体看来<code>GPT</code>分区俨然成为<code>MBR</code>的替代者，<code>fdisk</code>只能操作<code>MBR</code>方式的磁盘，而<code>parted</code>工具能够操作<code>GPT</code>或<code>MBR</code>中任意方式的磁盘。</p><h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ol><li><a href="https://my.oschina.net/guol/blog/61424" target="_blank" rel="noopener">使用parted划分GPT分区</a></li><li><a href="https://www.xncoding.com/2017/03/14/ceph/disk-partition.html" target="_blank" rel="noopener">Linux磁盘分区总结</a></li><li><a href="http://blog.51cto.com/isenknows/2053969" target="_blank" rel="noopener">CentOS 7 安装强制使用GPT分区</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;硬盘分区最常见的类型为&lt;code&gt;msdos&lt;/code&gt;和&lt;code&gt;gpt&lt;/code&gt;，前者表示&lt;code&gt;MBR&lt;/code&gt;分区，而后者表示&lt;code&gt;GPT&lt;/code&gt;分区。系统安装默认分区方式为&lt;code&gt;MBR&lt;/code&gt;，本文讲解如何设置&lt;code&gt;GPT&lt;/code&gt;分区方式安装系统，这个看起来没什么技术含量，但是笔者实践过程中还是遇到了不少阻力，并且发现相关文章甚少，故做此记录。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/lazycat.png&quot; alt=&quot;centos7 gpt&quot;&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Disk" scheme="https://tony-yin.github.io/tags/Disk/"/>
    
      <category term="Partition" scheme="https://tony-yin.github.io/tags/Partition/"/>
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ES告警详解之Sentinl</title>
    <link href="https://tony-yin.github.io/2018/12/01/ES-Sentinl/"/>
    <id>https://tony-yin.github.io/2018/12/01/ES-Sentinl/</id>
    <published>2018-12-01T05:07:06.000Z</published>
    <updated>2018-12-17T04:26:43.105Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/sentinl.png" alt="sentinl"></center><p>上一篇文章详细讲解了<code>ElastAlert</code>这款告警组件，今天我们聊聊另一个<code>ES</code>开源告警组件<code>Sentinl</code>。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>sentinl</code>是基于<code>javascript</code>开发的<code>kibana</code>插件，拥有告警和报表两大功能，分别作为<code>X-Pack</code> 的<code>Alert</code>和<code>Reporting</code>的替代品，即插即用，它将前端<code>UI</code>、<code>webserver</code>和告警逻辑代码都集成在一个项目中，这一点要比上篇文章提到同为<code>kibana</code>插件的<code>elastalert-kibana-plugin</code>要强大不少，并且可以说<code>sentinl</code>的<code>UI</code>无论是美观程度还是操作友好程度都完全秒杀<code>elastalert-kibana-plugin</code>。说了这么多是不是<code>sentinl</code>就很完美呢？请看下文慢慢讲述。</p><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch: 6.4.2</span><br><span class="line">kibana: 6.4.2</span><br><span class="line">sentinl: 6.4.2</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装环节很简单，只需要进行通用的<code>kibana</code>安装插件的方式安装即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /usr/share/kibana/bin/kibana-plugin install https://github.com/sirensolutions/sentinl/releases/download/tag-6.4.2-0/sentinl-v6.4.2.zip</span></span><br></pre></td></tr></table></figure><p>安装完成以后，重启<code>kibana</code>服务即可在<code>kibana</code>页面上看到<code>sentinl</code>。</p><h2 id="Alert配置"><a href="#Alert配置" class="headerlink" title="Alert配置"></a>Alert配置</h2><p>告警配置环节其实也很简单，因为<code>sentinl</code>大部分配置都是通过<code>UI</code>创建告警的时候配置的，需要手动配置的地方并不多，只有告警方式相关的。</p><p>和上节一样，众多告警方式我们就选择最普遍的邮件告警进行讲解</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/kibana/kibana.yml</span></span><br></pre></td></tr></table></figure><p>在文件最下方添加以下配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sentinl:</span><br><span class="line">  settings:</span><br><span class="line">    email:</span><br><span class="line">      active: true          // 开启email方式</span><br><span class="line">      host: 'smtp.163.com'  // smtp server</span><br><span class="line">      user: 'xxx@163.com'   // 发送邮箱账号</span><br><span class="line">      password: 'xxx'       //发送邮箱客户端授权码或密码</span><br><span class="line">      timeout: 10000        // 连接smtp server的最大timeout</span><br></pre></td></tr></table></figure><p>配置完成需要重启<code>kibana</code>服务才可以生效。这里需要注意的是<code>host</code>、<code>user</code>和<code>password</code>三个选项，<code>host</code>表示<code>smtp</code>主机地址，<code>user</code>表示发送邮箱的账号，<code>password</code>表示客户端授权码，如果没有授权码才是密码。</p><p>如果这样配置了，还是无法发送邮件成功，可以通过查看<code>kibana</code>的日志定位原因，大部分情况都是由于<code>smtp server</code>连接失败导致，可以通过本地邮件客户端进行测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mailx -S smtp=&lt;smtp-server-address&gt; -r &lt;from-address&gt; -s &lt;subject&gt; -v &lt;to-address&gt; &lt; body.txt</span></span><br></pre></td></tr></table></figure><h2 id="Report配置"><a href="#Report配置" class="headerlink" title="Report配置"></a>Report配置</h2><p><code>sentinl</code>除了提供告警功能，还提供了一个类似<code>X-Pack Reporting</code>的报表功能。</p><p>同样这个功能需要开启和配置，不得不说这个功能和相关文档还是存在着不少的问题，比如尽管文档声称默认<code>engine</code>是<code>horseman</code>，但是现在默认的是<code>puppeteer</code>。 </p><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>官方文档提供的<a href="https://sentinl.readthedocs.io/en/latest/Config-Example/" target="_blank" rel="noopener">配置例子</a>是这样的:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sentinl:</span><br><span class="line">  settings:</span><br><span class="line">    report:</span><br><span class="line">      active: true</span><br><span class="line">      executable_path: '/usr/bin/chromium' # path to Chrome v59+ or Chromium v59+</span><br></pre></td></tr></table></figure><p><code>chromium</code>环境中不存在的话，手动下载后同步配置中对应的路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sentinl:</span><br><span class="line">  settings:</span><br><span class="line">    active: true</span><br><span class="line">      engine: 'puppeteer'</span><br><span class="line">      executable_path: '/usr/bin/chromium-browser'</span><br></pre></td></tr></table></figure><p>运用上述配置会有以下报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Option &quot;report.executable_path&quot; was deprecated. The path is handled automatically!</span><br></pre></td></tr></table></figure><p>报错中显示<code>executable_path</code>这个选项已经被弃用，这个路径会被自动解析，一脸懵逼，文档中丝毫没提及。。。</p><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p>当时笔者也很奇怪，如何自动解析？如何知晓<code>chromium</code>的路径呢？这个下面再讲，然后就先注释掉该选项配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sentinl:</span><br><span class="line">  settings:</span><br><span class="line">    active: true</span><br><span class="line">      engine: &apos;puppeteer&apos;</span><br><span class="line">      # executable_path: &apos;/usr/bin/chromium-browser&apos;</span><br></pre></td></tr></table></figure><p>页面换了个报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActionError: report action: execute: run &apos;puppeteer&apos; report: puppeteer work</span><br></pre></td></tr></table></figure><p>如下图所示：</p><center><img src="http://cdn.tony-yin.site/puppeteer_execute.png" alt="error1"></center><p>这个时候笔者就通过关键字谷歌搜索，发现<code>sentinl</code>里面有一个<a href="https://github.com/sirensolutions/sentinl/issues/535" target="_blank" rel="noopener">issue 535</a>，里面提到查看日志里面是否存在类似下面信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">server    log   [07:52:27.332] [info][Sentinl][init] Chrome bin found at: /media/trex/safe1/Development/siren/kibi-internal/plugins/sentinl/node_modules/puppeteer/.local-chromium/linux-564778/chrome-linux/chrome</span><br><span class="line">...</span><br><span class="line">server    log   [07:52:27.428] [info][Sentinl][init] PhantomJS bin found at: /media/trex/safe1/Development/siren/kibi-internal/plugins/sentinl/phantomjs/phantomjs-2.1.1-linux-x86_64/bin/phantomjs</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>笔者去日志里面查了查，还真发现类似信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;type&quot;:&quot;log&quot;,&quot;@timestamp&quot;:&quot;2018-11-23T10:27:44Z&quot;,&quot;tags&quot;:[&quot;error&quot;,&quot;Sentinl&quot;,&quot;init&quot;],&quot;pid&quot;:8219,&quot;message&quot;:&quot;setting puppeteer report engine: Error: user has no permissions to make file executable: /usr/share/kibana/plugins/sentinl/node_modules/puppeteer/.local-chromium/linux-564778/chrome-linux/chrome&quot;&#125;</span><br></pre></td></tr></table></figure><p>如下图所示</p><p><img src="http://cdn.tony-yin.site/puppeteer_permission.PNG" alt="puppeteer permission"></p><p>这就是为什么可以自动解析<code>chrome</code>路径了，因为<code>sentinl</code>内置了<code>chrome</code>，所以<code>sentinl</code>默认解析的是其内置<code>chrome</code>路径而非其他第三方下载的，所以文档中的<code>/usr/bin/chromium</code>也有点误导的感觉。</p><p>这一段日志提示<code>chrome</code>没有执行权限，于是查看权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ll /usr/share/kibana/plugins/sentinl/node_modules/puppeteer/.<span class="built_in">local</span>-chromium/linux-564778/chrome-linux/chrome</span></span><br><span class="line">-rw-r--r-- 1 root root 206915904 Nov 22 10:16 /usr/share/kibana/plugins/sentinl/node_modules/puppeteer/.local-chromium/linux-564778/chrome-linux/chrome</span><br></pre></td></tr></table></figure><p>果然是不存在执行权限，然后手动添加权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x /usr/share/kibana/plugins/sentinl/node_modules/puppeteer/.local-chromium/linux-564778/chrome-linux/chrome</span><br></pre></td></tr></table></figure><h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><p>更改之后这个报错没有了，但是又有了新的报错（真是醉了）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to load url</span><br></pre></td></tr></table></figure><p>如下图所示</p><p><img src="http://cdn.tony-yin.site/load_url_error.PNG" alt="load url error"></p><p>然后继续谷歌大法，在 <a href="https://github.com/sirensolutions/sentinl/issues/495" target="_blank" rel="noopener">issue 495</a> 中看到了相关信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for the error &quot;Failed to load url&quot; I just replaced the action&apos;s url with a valide link from a chosen dashboard</span><br></pre></td></tr></table></figure><p>于是返回告警配置界面，发现有一个<code>url</code>选项，笔者也没填（因为当时也不知道这个<code>url</code>是干嘛的）。结合上面这哥们描述的，该<code>url</code>应该是<code>kibana</code>上面<code>dashbord</code>模块中某个已经存在的<code>dashbord</code>的链接，然后根据该<code>dashbord</code>生成报表。</p><p>于是手动创建了一个<code>dashbord</code>，然后将该<code>dashbord</code>的<code>url</code>更新至配置中的<code>url</code>。</p><h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h3><p>这次没报错了，<code>report</code>也发送到了指定邮箱，但是<code>report</code>是空的，这是因为新创建的<code>dashbord</code>并没有导入任何可视化图表，所以将<code>url</code>切换成了已经存在可视化图表的<code>dashbord</code>的<code>url</code>，这下可以发现发送的<code>report</code>是存在图表的。</p><p>结合之前<code>monitoring</code>的了解，突然想到这个<code>url</code>可能不是<code>dashbord</code>直接显示的<code>url</code>，而应该是通过<code>share</code>功能提供的<code>link</code>。</p><h3 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h3><p>上面<code>engine</code>选择<code>puppeteer</code>，笔者又尝试将<code>engine</code>切换成<code>horseman</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sentinl:</span><br><span class="line">  settings:</span><br><span class="line">    report:</span><br><span class="line">      active: true</span><br><span class="line">      engine: &apos;horseman&apos;</span><br></pre></td></tr></table></figure><p>换了<code>engine</code>，依然报错不停：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActionError: report action: execute: run &apos;horseman&apos; report: spawn EACCES</span><br></pre></td></tr></table></figure><p>如下图所示</p><p><img src="http://cdn.tony-yin.site/eacces_error.PNG" alt="eacces error"></p><p>其实这个问题，上文提到的 <a href="https://github.com/sirensolutions/sentinl/issues/535" target="_blank" rel="noopener">issue 535</a> 中也给出了答案，<code>horseman engine</code>依赖的是<code>phantomjs</code>库，<code>puppeteer</code>依赖的是<code>chrome</code>库，问题<code>2</code>是<code>chrome</code>缺少可执行权限，而<code>spawn EACCES</code>这样的关键字则表示<code>phantomjs</code>库无法使用，根据上文<code>chrome</code>的路径笔者找到<code>phantomjs</code>的路径并检查权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ll /usr/share/kibana/plugins/sentinl/node_modules/phantomjs-prebuilt/bin/phantomjs </span></span><br><span class="line">-rw-r--r-- 1 root root 1050 Nov 22 10:15 /usr/share/kibana/plugins/sentinl/node_modules/phantomjs-prebuilt/bin/phantomjs</span><br></pre></td></tr></table></figure><p>发现<code>phantomjs</code>也缺少可执行权限，添加权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x /usr/share/kibana/plugins/sentinl/node_modules/phantomjs-prebuilt/bin/phantomjs</span></span><br></pre></td></tr></table></figure><p>但是<code>UI</code>上还是有相同的报错，只能继续查看日志，发现报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"type":"log","@timestamp":"2018-11-22T02:27:28Z","tags":["info","Sentinl","init"],"pid":21134,"message":"PhantomJS bin found at: /usr/share/kibana/plugins/sentinl/phantomjs/phantomjs-2.1.1-linux-x86_64/bin/phantomjs"&#125;</span><br></pre></td></tr></table></figure><p>原来<code>sentinl</code>解析库不是上面<code>node_modules</code>目录的那个路径，而是在<code>phantomjs</code>这个目录下，查看权限情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -lh /usr/share/kibana/plugins/sentinl/phantomjs/phantomjs-2.1.1-linux-x86_64/bin/phantomjs</span></span><br><span class="line">-rw-r--r-- 1 root root 65M Nov 22 10:15 /usr/share/kibana/plugins/sentinl/phantomjs/phantomjs-2.1.1-linux-x86_64/bin/phantomjs</span><br></pre></td></tr></table></figure><p>果然还是缺少执行权限，添加权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x /usr/share/kibana/plugins/sentinl/phantomjs/phantomjs-2.1.1-linux-x86_64/bin/phantomjs</span></span><br></pre></td></tr></table></figure><p>终于不报错了。。。</p><h3 id="官方回应"><a href="#官方回应" class="headerlink" title="官方回应"></a>官方回应</h3><p>这一系列问题，笔者也给<code>sentinl</code>提了 <a href="https://github.com/sirensolutions/sentinl/issues/619" target="_blank" rel="noopener">issue</a>，作者也表示了这个权限问题之后会通过脚本等方式自动处理，然后表示<a href="https://sentinl.readthedocs.io/en/docs/Config-Example/" target="_blank" rel="noopener">这个文档</a>没有同步更新，可以看<a href="https://sentinl.readthedocs.io/en/latest/" target="_blank" rel="noopener">最新同步文档</a>。</p><h2 id="Sentinl-amp-ElastAlert"><a href="#Sentinl-amp-ElastAlert" class="headerlink" title="Sentinl &amp; ElastAlert"></a>Sentinl &amp; ElastAlert</h2><p>与<code>elastalert</code>相比较，就告警功能而言的话，如果要求不高，推荐使用<code>sentinl</code>，因为安装容易并且配置简单；但如果有复杂的告警场景或独立的告警方式，那推荐选择<code>elastalert</code>。</p><p>整理一个对比表格，想必这样看起来更直观：</p><table><thead><tr><th style="text-align:center">比较</th><th style="text-align:center">Sentinl</th><th style="text-align:center">ElastAlert</th></tr></thead><tbody><tr><td style="text-align:center">安装</td><td style="text-align:center">简单</td><td style="text-align:center">一般复杂</td></tr><tr><td style="text-align:center">配置</td><td style="text-align:center">简单</td><td style="text-align:center">一般复杂</td></tr><tr><td style="text-align:center">UI</td><td style="text-align:center">简单美观</td><td style="text-align:center">不友好</td></tr><tr><td style="text-align:center">告警规则数量</td><td style="text-align:center">1个</td><td style="text-align:center">11个</td></tr><tr><td style="text-align:center">告警方式数量</td><td style="text-align:center">6个</td><td style="text-align:center">11个</td></tr><tr><td style="text-align:center">告警方式隔离</td><td style="text-align:center">不独立</td><td style="text-align:center">独立</td></tr><tr><td style="text-align:center">开发语言</td><td style="text-align:center">javascript</td><td style="text-align:center">python</td></tr><tr><td style="text-align:center">后端配置透明度</td><td style="text-align:center">不透明</td><td style="text-align:center">透明</td></tr><tr><td style="text-align:center">成熟度</td><td style="text-align:center">700+ star</td><td style="text-align:center">5000+ start</td></tr><tr><td style="text-align:center">开发者数量</td><td style="text-align:center">28</td><td style="text-align:center">160</td></tr><tr><td style="text-align:center">commit数</td><td style="text-align:center">1500+</td><td style="text-align:center">1800+</td></tr><tr><td style="text-align:center">开发周期</td><td style="text-align:center">2016/08</td><td style="text-align:center">2015/11</td></tr></tbody></table><p>根据上述表格，我们可以看出各有各的优势，<code>sentinl</code>更加偏向于集成进<code>kibana</code>的一种页面展示插件，而<code>elastalert</code>则是更偏向与后端告警功能的打磨。单从告警功能来看，<code>elastalert</code>看起来更强大一些，但是<code>sentinl</code>也有它的优势，<code>UI</code>非常地棒，其次还支持<code>report</code>功能，虽然现在还存在很多问题，但相信之后肯定越来越好，而且目前通过开发者数量和代码提交量可以看出有后来居上的感觉。就笔者而言，喜爱<code>sentinl</code>的<code>UI</code>,喜爱<code>elastalert</code>的告警<code>rule</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>sentinl</code>作为一个开源组件，提供了<code>X-Pack</code>两款收费组件：<code>Alert</code>和<code>Reporting</code>的替代功能，着实不错，告警功能配置简单、页面美观、操作友好；但是<code>Report</code>功能就显得问题较多，并且生成的报表也有很多瑕疵。希望之后可以不断优化和强大吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/sentinl.png&quot; alt=&quot;sentinl&quot;&gt;&lt;/center&gt;

&lt;p&gt;上一篇文章详细讲解了&lt;code&gt;ElastAlert&lt;/code&gt;这款告警组件，今天我们聊聊另一个&lt;code&gt;ES&lt;/code&gt;开源告警组件&lt;code&gt;Sentinl&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Elasticsearch" scheme="https://tony-yin.github.io/tags/Elasticsearch/"/>
    
      <category term="Monitor" scheme="https://tony-yin.github.io/tags/Monitor/"/>
    
  </entry>
  
  <entry>
    <title>ES告警详解之ElastAlert</title>
    <link href="https://tony-yin.github.io/2018/11/15/ES-ElastAlert/"/>
    <id>https://tony-yin.github.io/2018/11/15/ES-ElastAlert/</id>
    <published>2018-11-15T05:07:06.000Z</published>
    <updated>2018-12-17T05:54:12.579Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/alert.png" alt="alert"></center><p>今天聊聊<code>ES</code>的告警，<code>X-Pack</code>提供了报警组件<code>Alert</code>，但是这个功能是需要付费，在寻求其他方案的时候，发现了<code>ElastAlert</code>，可以说这是一款为<code>ES</code>量身定制的告警组件，能够完美替代<code>Alert</code>提供的所有功能。今天就<code>ElastAlert</code>强大的告警功能和笔者实践过程中遇到的一些问题进行分享。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>ElastAlert</code>是基于<code>python2</code>开发的一个告警框架，它主要有以下特点：</p><ul><li>成熟，<a href="https://github.com/Yelp/elastalert" target="_blank" rel="noopener">Github</a>上已有<code>5k+ star</code></li><li>开源，<a href="https://elastalert.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">文档</a>很全面</li><li>开发语言为<code>python</code>，研究和扩展源码较为容易</li><li>告警规则丰富</li><li>告警方式丰富</li><li><code>SMTP</code>以每个告警为单位，相对独立</li></ul><p>网上已经有了相当多的基础介绍文章，但是笔者发现大多数文章的内容都是过时的，甚至官方文档经常还会展示一些弃用配置；还有虎头蛇尾的通病，往往不全面，经常对一些关键性的细节不提及；再者一些地方解释地不够清晰，导致歧义。笔者在搭建和测试过程中同时借鉴多篇文章，然后在反复尝试中最后才成功，这其中失败了很多次，浪费了很多时间，所以这篇文章借鉴了上面提到的种种问题，保证本文的全面性、细节性以及具体性。</p><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Centos7</span><br><span class="line">Elasticsearch 6.4.2</span><br><span class="line">Kibana 6.4.2</span><br></pre></td></tr></table></figure><h2 id="ElastAlert安装"><a href="#ElastAlert安装" class="headerlink" title="ElastAlert安装"></a>ElastAlert安装</h2><p>安装较为简单，但为了不虎头蛇尾还是做一个完整的步骤介绍：</p><h3 id="克隆代码"><a href="#克隆代码" class="headerlink" title="克隆代码"></a>克隆代码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/Yelp/elastalert.git</span></span><br></pre></td></tr></table></figure><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> elastalert</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python setup.py install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip install -r requirements.txt</span></span><br></pre></td></tr></table></figure><h3 id="整体配置"><a href="#整体配置" class="headerlink" title="整体配置"></a>整体配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cp config.yaml.example config.yaml    // 根据模板生成配置文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim config.yaml   // 修改配置</span></span><br></pre></td></tr></table></figure><p>主要修改几个必需的选项，比如<code>rules_folder</code>、<code>es_host</code>、<code>es_port</code>等，那些非必需没有特殊需求就不用更改了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 用来加载rule的目录，默认是example_rules</span></span><br><span class="line">rules_folder: example_rules</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用来设置定时向elasticsearch发送请求</span></span><br><span class="line">run_every:</span><br><span class="line">  minutes: 1</span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 用来设置请求里时间字段的范围</span></span><br><span class="line">buffer_time:</span><br><span class="line">  minutes: 15</span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> elasticsearch的host地址</span></span><br><span class="line">es_host: 192.168.232.191</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> elasticsearch 对应的端口号</span></span><br><span class="line">es_port: 9200</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可选的，es url前缀</span></span><br><span class="line"><span class="meta">#</span><span class="bash">es_url_prefix：elasticsearch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可选的，查询es的方式，默认是GET</span></span><br><span class="line"><span class="meta">#</span><span class="bash">es_send_get_body_as：GET</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可选的，选择是否用SSL连接es，<span class="literal">true</span>或者<span class="literal">false</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">use_ssl: True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">可选的，是否验证TLS证书，设置为<span class="literal">true</span>或者<span class="literal">false</span>，默认为- <span class="literal">true</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">verify_certs: True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> es认证的username和password</span></span><br><span class="line"><span class="meta">#</span><span class="bash">es_username: someusername</span></span><br><span class="line"><span class="meta">#</span><span class="bash">es_password: somepassword</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> elastalert产生的日志在elasticsearch中的创建的索引</span></span><br><span class="line">writeback_index: elastalert_status</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 失败重试的时间限制</span></span><br><span class="line">alert_time_limit:</span><br><span class="line">  days: 2</span><br></pre></td></tr></table></figure><p>详情请参考文档：<a href="http://elastalert.readthedocs.io/en/latest/ruletypes.html#rule-configuration-cheat-sheet" target="_blank" rel="noopener">http://elastalert.readthedocs.io/en/latest/ruletypes.html#rule-configuration-cheat-sheet</a></p><h3 id="创建ElastAlert索引"><a href="#创建ElastAlert索引" class="headerlink" title="创建ElastAlert索引"></a>创建ElastAlert索引</h3><p>可以在<code>/usr/bin/</code>目录下看到以下四个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ll /usr/bin/elastalert*</span></span><br><span class="line">-rwxr-xr-x 1 root root 399 Nov 20 16:39 /usr/bin/elastalert</span><br><span class="line">-rwxr-xr-x 1 root root 425 Nov 20 16:39 /usr/bin/elastalert-create-index</span><br><span class="line">-rwxr-xr-x 1 root root 433 Nov 20 16:39 /usr/bin/elastalert-rule-from-kibana</span><br><span class="line">-rwxr-xr-x 1 root root 419 Nov 20 16:39 /usr/bin/elastalert-test-rule</span><br></pre></td></tr></table></figure><ul><li><code>elastalert-create-index</code>会创建一个索引，<code>ElastAlert</code> 会把执行记录存放到这个索引中，默认情况下，索引名叫 <code>elastalert_status</code>。其中有<code>4</code>个<code>_type</code>，都有自己的<code>@timestamp</code> 字段，所以同样也可以用<code>kibana</code>来查看这个索引的日志记录情况。</li><li><code>elastalert-rule-from-kibana</code>从<code>Kibana3</code>已保存的仪表盘中读取<code>Filtering</code> 设置，帮助生成<code>config.yaml</code>里的配置。不过注意，它只会读取 <code>filtering</code>，不包括<code>queries</code>。</li><li><code>elastalert-test-rule</code>测试自定义配置中的<code>rule</code>设置。</li></ul><p>执行<code>elastalert-create-index</code>命令在<code>ES</code>创建索引，这不是必须的步骤，但是强烈建议创建。因为对于审计和测试很有用，并且重启<code>ES</code>不影响计数和发送<code>alert</code>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> elastalert-create-index</span></span><br></pre></td></tr></table></figure><p>具体参见文档： <a href="http://elastalert.readthedocs.io/en/latest/running_elastalert.html#setting-up-elasticsearch" target="_blank" rel="noopener">setting-up-elasticsearch</a></p><h2 id="Rule配置"><a href="#Rule配置" class="headerlink" title="Rule配置"></a>Rule配置</h2><p><code>rule</code>配置算是<code>ElastAlert</code>最核心的功能了，支持<code>11</code>种告警规则，就不一一介绍了，选用一个最为普遍使用的告警规则<code>frequency</code>，告警方式也选用最普遍的<code>email</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># Alert when the rate of events exceeds a threshold</span><br><span class="line"></span><br><span class="line"># (Optional)</span><br><span class="line"># Elasticsearch host</span><br><span class="line">es_host: 192.168.232.191</span><br><span class="line"></span><br><span class="line"># (Optional)</span><br><span class="line"># Elasticsearch port</span><br><span class="line">es_port: 9200</span><br><span class="line"></span><br><span class="line"># (OptionaL) Connect with SSL to Elasticsearch</span><br><span class="line">#use_ssl: True</span><br><span class="line"></span><br><span class="line"># (Optional) basic-auth username and password for Elasticsearch</span><br><span class="line">#es_username: someusername</span><br><span class="line">#es_password: somepassword</span><br><span class="line"></span><br><span class="line"># (Required)</span><br><span class="line"># Rule name, must be unique</span><br><span class="line">name: Example frequency rule</span><br><span class="line"></span><br><span class="line"># (Required)</span><br><span class="line"># Type of alert.</span><br><span class="line"># the frequency rule type alerts when num_events events occur with timeframe time</span><br><span class="line">type: frequency</span><br><span class="line"></span><br><span class="line"># (Required)</span><br><span class="line"># Index to search, wildcard supported</span><br><span class="line">index: metricbeat-*</span><br><span class="line"></span><br><span class="line"># (Required, frequency specific)</span><br><span class="line"># Alert when this many documents matching the query occur within a timeframe</span><br><span class="line">num_events: 5</span><br><span class="line"></span><br><span class="line"># (Required, frequency specific)</span><br><span class="line"># num_events must occur within this amount of time to trigger an alert</span><br><span class="line">timeframe:</span><br><span class="line">  hours: 4</span><br><span class="line"></span><br><span class="line"># (Required)</span><br><span class="line"># A list of Elasticsearch filters used for find events</span><br><span class="line"># These filters are joined with AND and nested in a filtered query</span><br><span class="line"># For more info: http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl.html</span><br><span class="line">filter:</span><br><span class="line">- query_string:</span><br><span class="line">    query: &quot;system.process.cpu.total.pct: &gt;10%&quot;     // field支持嵌套</span><br><span class="line"></span><br><span class="line">smtp_host: smtp.163.com</span><br><span class="line">smtp_port: 25</span><br><span class="line">smtp_auth_file: /opt/elastalert/smtp_auth.yaml</span><br><span class="line">#回复给那个邮箱</span><br><span class="line">email_reply_to: xxx@163.com</span><br><span class="line">##从哪个邮箱发送</span><br><span class="line">from_addr: xxx@163.com</span><br><span class="line"># (Required)</span><br><span class="line"># The alert is use when a match is found</span><br><span class="line">alert:</span><br><span class="line">- &quot;email&quot;</span><br><span class="line"></span><br><span class="line"># (required, email specific)</span><br><span class="line"># a list of email addresses to send alerts to</span><br><span class="line">email:</span><br><span class="line">- &quot;yyy@qq.com&quot;</span><br></pre></td></tr></table></figure><p>上述配置表示选择<code>metricbeat</code>作为告警索引，在<code>4</code>小时内将匹配过滤条件，当<code>CPU</code>使用百分比的值为<code>10%</code>超过<code>5</code>次后，即满足告警条件，然后发送邮件。</p><h2 id="邮件配置"><a href="#邮件配置" class="headerlink" title="邮件配置"></a>邮件配置</h2><p>上述配置中已经展示了一部分邮件配置，主要有<code>smtp host</code>、<code>smtp port</code>、<code>from addr</code>和<code>to_addr</code>等。这里笔者选择一个网易<code>163</code>的邮箱作为发送邮箱，一个<code>QQ</code>邮箱作为接收邮件进行测试，所以<code>smpt host</code>应该为<code>smtp.163.com</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">smtp_host: smtp.163.com</span><br><span class="line">smtp_port: 25</span><br><span class="line">smtp_auth_file: /opt/elastalert/smtp_auth.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash">回复给那个邮箱</span></span><br><span class="line">email_reply_to: xxx@163.com</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#从哪个邮箱发送</span></span></span><br><span class="line">from_addr: xxx@163.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> (Required)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The alert is use when a match is found</span></span><br><span class="line">alert:</span><br><span class="line">- "email"</span><br><span class="line"><span class="meta">#</span><span class="bash"> (required, email specific)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a list of email addresses to send alerts to</span></span><br><span class="line">email:</span><br><span class="line">- "yyy@qq.com"</span><br></pre></td></tr></table></figure><p>还有一个<code>smtp_auth.yaml</code>文件，这个里面记录了发送邮箱的账号和密码，<code>163</code>邮箱有授权码机制，所以密码处应该填写授权码（没有的话则需要开启）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">发送邮件的邮箱</span></span><br><span class="line">user: xxx@163.com</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#不是邮箱密码，是设置的POP3密码</span></span></span><br><span class="line">password: xxx</span><br></pre></td></tr></table></figure><p>网易授权码设置如下图：</p><center><img src="http://cdn.tony-yin.site/163_pwd.png" alt="163 client password"></center><h2 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h2><h3 id="避免重复告警"><a href="#避免重复告警" class="headerlink" title="避免重复告警"></a>避免重复告警</h3><p>避免一定时间段中重复告警，可以配置<code>realert</code>和<code>exponential_realert</code>这两个选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 5分钟内相同的报警不会重复发送</span><br><span class="line">realert:</span><br><span class="line">  minutes: 5</span><br><span class="line"></span><br><span class="line"># 指数级扩大 realert 时间，中间如果有报警，</span><br><span class="line"># 则按照5-&gt;10-&gt;20-&gt;40-&gt;60不断增大报警时间到制定的最大时间，</span><br><span class="line"># 如果之后报警减少，则会慢慢恢复原始realert时间</span><br><span class="line">exponential_realert:</span><br><span class="line">  hours: 1</span><br></pre></td></tr></table></figure><h3 id="聚合相同告警"><a href="#聚合相同告警" class="headerlink" title="聚合相同告警"></a>聚合相同告警</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 根据报警的内，将相同的报警安装 name 来聚合</span><br><span class="line">aggregation_key: name</span><br><span class="line"></span><br><span class="line"># 聚合报警的内容，只展示 name 与 message</span><br><span class="line">summary_table_fields:</span><br><span class="line">  - name</span><br><span class="line">  - message</span><br></pre></td></tr></table></figure><h3 id="告警内容格式化"><a href="#告警内容格式化" class="headerlink" title="告警内容格式化"></a>告警内容格式化</h3><p>可以自定义告警内容，内部是使用<code>Python</code>的<code>format</code>来实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">alert_subject: &quot;Error &#123;&#125; @&#123;&#125;&quot;</span><br><span class="line">alert_subject_args:</span><br><span class="line">  - name</span><br><span class="line">  - &quot;@timestamp&quot;</span><br><span class="line"></span><br><span class="line">alert_text_type: alert_text_only</span><br><span class="line">alert_text: |</span><br><span class="line">  ### Error frequency exceeds</span><br><span class="line">  &gt; Name: &#123;&#125;</span><br><span class="line">  &gt; Message: &#123;&#125;</span><br><span class="line">  &gt; Host: &#123;&#125; (&#123;&#125;)</span><br><span class="line">alert_text_args:</span><br><span class="line">  - name</span><br><span class="line">  - message</span><br><span class="line">  - hostname</span><br><span class="line">  - host</span><br></pre></td></tr></table></figure><p>当然还有更多高级配置，详情请参考文档。</p><h2 id="测试Rule"><a href="#测试Rule" class="headerlink" title="测试Rule"></a>测试Rule</h2><p>可以在运行<code>rule</code>之前先通过<code>elastalert-test-rule</code>命令来测试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ elastalert-test-rule ~/elastalert/example_rules/example_frequency.yaml</span><br></pre></td></tr></table></figure><p>详情参考文档：<a href="http://elastalert.readthedocs.io/en/latest/running_elastalert.html#testing-your-rule" target="_blank" rel="noopener">http://elastalert.readthedocs.io/en/latest/running_elastalert.html#testing-your-rule</a></p><h2 id="运行Rule"><a href="#运行Rule" class="headerlink" title="运行Rule"></a>运行Rule</h2><p>启动<code>elastalert</code>服务，监听<code>es</code>，这里加了<code>--rule example_frequency.yaml</code>表示只运行<code>example_frequency.yaml</code>这一个<code>rule</code>文件，如果不加该选项则会运行<code>rules_folder</code>下所有<code>rule</code>文件，上面配置中的<code>rules_folder</code>为默认的<code>example_rules</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m elastalert.elastalert --verbose --rule example_frequency.yaml</span><br></pre></td></tr></table></figure><p>为了让服务后台运行并且可以达到守护进程的效果，在生产环境中笔者建议使用<code>supervisor</code>管理。</p><p>邮件效果图如下：</p><center><img src="http://cdn.tony-yin.site/elastalert_email.png" alt="elastalert email"></center><h2 id="其他Rule"><a href="#其他Rule" class="headerlink" title="其他Rule"></a>其他Rule</h2><ul><li><code>any</code>：只要有匹配就报警；</li><li><code>blacklist</code>：<code>compare_key</code>字段的内容匹配上<code>blacklist</code>数组里任意内容；</li><li><code>whitelist</code>：<code>compare_key</code>字段的内容一个都没能匹配上<code>whitelist</code>数组里内容；</li><li><code>change</code>：在相同<code>query_key</code>条件下，<code>compare_key</code>字段的内容，在 <code>timeframe</code>范围内 发送变化；</li><li><code>frequency</code>：在相同<code>query_key</code>条件下，<code>timeframe</code> 范围内有<code>num_events</code>个被过滤出 来的异常；</li><li><code>spike</code>：在相同<code>query_key</code>条件下，前后两个<code>timeframe</code>范围内数据量相差比例超过<code>spike_height</code>。其中可以通过<code>spike_type</code>设置具体涨跌方向是- <code>up</code>、<code>down</code>、<code>both</code>。还可以通过<code>threshold_ref</code>设置要求上一个周期数据量的下限，<code>threshold_cur</code>设置要求当前周期数据量的下限，如果数据量不到下限，也不触发；</li><li><code>flatline</code>：<code>timeframe</code>范围内，数据量小于<code>threshold</code>阈值；</li><li><code>new_term</code>：fields字段新出现之前<code>terms_window_size</code>(默认<code>30</code>天)范围内最多的<code>terms_size</code>(默认<code>50</code>)个结果以外的数据；</li><li><code>cardinality</code>：在相同 <code>query_key</code>条件下，<code>timeframe</code>范围内<code>cardinality_field</code>的值超过 <code>max_cardinality</code>或者低于<code>min_cardinality</code></li></ul><p>摘自：<a href="https://segmentfault.com/a/1190000008227486" target="_blank" rel="noopener">ElastAlert介绍和安装－1</a><br>详细请参考文档：<a href="https://elastalert.readthedocs.io/en/latest/ruletypes.html#rule-types" target="_blank" rel="noopener">https://elastalert.readthedocs.io/en/latest/ruletypes.html#rule-types</a></p><h2 id="其他告警方式"><a href="#其他告警方式" class="headerlink" title="其他告警方式"></a>其他告警方式</h2><p>除了<code>email</code>，还有<code>jira</code>、<code>webhook</code>等内置告警方式，由于笔者没有实践，就不一一赘述了。</p><p>第三方的微信和钉钉：</p><ul><li>微信：<a href="https://github.com/anjia0532/elastalert-wechat-plugin" target="_blank" rel="noopener">https://github.com/anjia0532/elastalert-wechat-plugin</a></li><li>钉钉：<a href="https://github.com/xuyaoqiang/elastalert-dingtalk-plugin" target="_blank" rel="noopener">https://github.com/xuyaoqiang/elastalert-dingtalk-plugin</a></li></ul><p>也可以根据文档自己实现：<a href="https://elastalert.readthedocs.io/en/latest/recipes/adding_alerts.html" target="_blank" rel="noopener">https://elastalert.readthedocs.io/en/latest/recipes/adding_alerts.html</a></p><h2 id="elastalert-kibana-plugin"><a href="#elastalert-kibana-plugin" class="headerlink" title="elastalert-kibana-plugin"></a>elastalert-kibana-plugin</h2><p><code>elastalert-kibana-plugin</code>是围绕<code>elastalert</code>做的一个<code>kibana</code>展示插件，可以在<code>kibana</code>上创建、编辑和删除告警，但是说实话这个插件还不是很好用，首先配置就有点麻烦，其次展示效果并不友好，提供配置<code>rule</code>的方式太专业化了，对小白或者一般用户来说要求稍高。</p><h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><p>下载<code>6.4.2</code>的<code>release</code>安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://github.com/bitsensor/elastalert-kibana-plugin/releases/download/1.0.1/elastalert-kibana-plugin-1.0.1-6.4.2.zip</span></span><br></pre></td></tr></table></figure><h3 id="本地安装插件"><a href="#本地安装插件" class="headerlink" title="本地安装插件"></a>本地安装插件</h3><p><code>Kibana</code>插件本地安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /usr/share/kibana/bin/kibana-plugin install file:///root/elastalert-kibana-plugin-1.0.1-6.4.2.zip</span></span><br></pre></td></tr></table></figure><p>本地安装前面需要加上<code>file://</code>，否则会默认为在线资源去解析<code>url</code>并下载</p><p><strong>Unix：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo bin/elasticsearch-plugin install file:///path/to/plugin.zip</span><br></pre></td></tr></table></figure><p><strong>Windows：</strong></p><p>假定需要安装的插件本地地址为<code>C:\path\to\plugin.zip</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin\elasticsearch-plugin install file:///C:/path/to/plugin.zip</span><br></pre></td></tr></table></figure><h3 id="安装Server"><a href="#安装Server" class="headerlink" title="安装Server"></a>安装Server</h3><p>上面安装的只是<code>kibana</code>的一个展示插件，插件内部并没有集成<code>server</code>，所以还需要再安装一个<code>server</code>，笔者之前因为没有做这一步，一直卡着，页面显示报错<code>502 Bad Gateway</code>，关键是官方文档也没说清楚一定要装这个。。</p><h4 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/bitsensor/elastalert.git elastalert-server</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> elastalert-server</span></span><br></pre></td></tr></table></figure><p>这边我们先不用官网说的<code>docker</code>运行的方式，先用本地<code>npm</code>起服务的方式运行。</p><h4 id="下载指定版本的npm"><a href="#下载指定版本的npm" class="headerlink" title="下载指定版本的npm"></a>下载指定版本的<code>npm</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install &quot;$(cat .nvmrc)&quot;</span><br></pre></td></tr></table></figure><h4 id="安装依赖-1"><a href="#安装依赖-1" class="headerlink" title="安装依赖"></a>安装依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><p>这一步很重要，因为很多地方没有说的很清楚，包括<code>docker</code>运行方式在这一块也没说清楚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim config/config.json</span><br></pre></td></tr></table></figure><p>默认的配置需要修改，尤其是<code>elastalertPath</code>和<code>rulesPath</code>中的<code>path</code>选项</p><p><code>elastalertPath</code>表示的是我们最初安装的<code>elastalert</code>仓库的目录，也就是说<code>elastalert-kibana-plugin</code>运行需要三个仓库，分别是<code>elastalert</code>、<code>elastalert-kibana-plugin</code>、和<code>elastalert-server</code>，分别对应的是后端代码、前端代码、<code>webserver</code>，这也就是笔者之前提到的安装提到的安装麻烦所在了；</p><p>其次<code>rulesPath</code>中<code>path</code>选项表示运用<code>elastalert-kibana-plugin</code>插件创建告警后<code>rule</code>文件存放的目录，上面笔者在<code>elastalert</code>配置的<code>rules_folder</code>为<code>example_rules</code>，这里配置的<code>path</code>为<code>rules</code>，主要是因为<code>elastalert-server</code>目录下用的是这个，笔者也在<code>elastalert</code>项目中创建了个<code>rules</code>的目录，并将<code>rules_folder</code>配置进行同步，这个看个人喜好自定义即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;appName&quot;: &quot;elastalert-server&quot;,</span><br><span class="line">  &quot;port&quot;: 3030,</span><br><span class="line">  &quot;elastalertPath&quot;: &quot;/root/elastalert&quot;,</span><br><span class="line">  &quot;verbose&quot;: false,</span><br><span class="line">  &quot;es_debug&quot;: false,</span><br><span class="line">  &quot;debug&quot;: false,</span><br><span class="line">  &quot;rulesPath&quot;: &#123;</span><br><span class="line">    &quot;relative&quot;: true,</span><br><span class="line">    &quot;path&quot;: &quot;/rules&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;templatesPath&quot;: &#123;</span><br><span class="line">    &quot;relative&quot;: true,</span><br><span class="line">    &quot;path&quot;: &quot;/rule_templates&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;es_host&quot;: &quot;192.168.232.191&quot;,</span><br><span class="line">  &quot;es_port&quot;: 9200,</span><br><span class="line">  &quot;writeback_index&quot;: &quot;elastalert_status&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="起服务"><a href="#起服务" class="headerlink" title="起服务"></a>起服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><h4 id="容器方式"><a href="#容器方式" class="headerlink" title="容器方式"></a>容器方式</h4><p>官网提供的命令依旧是很模糊，很多同学直接运行了，也没报错，但是也没正常运行，这是因为跟上面一样，下面这些目录都要对应修改，具体参考上面配置文件即可，最重要的还是要明白整体架构，三个项目各自的作用，知道原理就一目了然了，但不得不说如果官方文档描述地详细一点，大家也许会更容易地搞成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3030:3030 \</span><br><span class="line">    -v `pwd`/config/elastalert.yaml:/opt/elastalert/config.yaml \</span><br><span class="line">    -v `pwd`/config/config.json:/opt/elastalert-server/config/config.json \</span><br><span class="line">    -v `pwd`/rules:/opt/elastalert/rules \</span><br><span class="line">    -v `pwd`/rule_templates:/opt/elastalert/rule_templates \</span><br><span class="line">    --net=&quot;host&quot; \</span><br><span class="line">    --name elastalert bitsensor/elastalert:latest</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从<code>elastalert</code>的安装讲起，接着涉猎<code>rule</code>配置、<code>email</code>配置等环节，然后通过测试和运行来对<code>rule</code>文件进行验证，最后再详细介绍了<code>elastalert-kibana-plugin</code>的安装和用法。</p><p>总的来说，<code>elastalert</code>围绕<code>es</code>所提供的告警功能是很强大的，文中提供的案例只是冰山一角，大家感兴趣的可以多看看官方文档，<code>elastalert</code>的官方文档还是很全的。</p><p>至于<code>elastalert-kibana-plugin</code>这个插件，笔者认为一般般，配置过程稍显麻烦，其次功能很弱，跟后端手动修改配置文件没什么两样，也没有同名校验这些机制，相比而言，<code>sentinl</code>的<code>UI</code>就显得简单美观了，请听下回分解。</p><h2 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h2><ol><li><a href="https://www.freebuf.com/articles/web/160254.html" target="_blank" rel="noopener">ElastAlert监控日志告警Web攻击行为</a></li><li><a href="https://blog.xizhibei.me/2017/11/19/alerting-with-elastalert/" target="_blank" rel="noopener">ElastAlert：『Hi，咱服务挂了』</a></li><li><a href="https://segmentfault.com/a/1190000008227486" target="_blank" rel="noopener">ElastAlert介绍和安装－1</a></li><li><a href="https://www.jianshu.com/p/f82812e0a743" target="_blank" rel="noopener">elastalert的简单运用</a></li><li><a href="https://anjia0532.github.io/2017/02/14/elasticsearch-elastalert/#&amp;gid=1&amp;pid=1" target="_blank" rel="noopener">ElastAlert 基于Elasticsearch的监控告警</a></li><li><a href="https://my.oschina.net/qixiaobo025/blog/1932752" target="_blank" rel="noopener">elastAlert之kibana的插件使用</a></li><li><a href="https://www.elastic.co/guide/cn/kibana/current/installing_plugins.html" target="_blank" rel="noopener">Install plugins</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/plugins/current/plugin-management-custom-url.html" target="_blank" rel="noopener">plugin management custom url</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/alert.png&quot; alt=&quot;alert&quot;&gt;&lt;/center&gt;

&lt;p&gt;今天聊聊&lt;code&gt;ES&lt;/code&gt;的告警，&lt;code&gt;X-Pack&lt;/code&gt;提供了报警组件&lt;code&gt;Alert&lt;/code&gt;，但是这个功能是需要付费，在寻求其他方案的时候，发现了&lt;code&gt;ElastAlert&lt;/code&gt;，可以说这是一款为&lt;code&gt;ES&lt;/code&gt;量身定制的告警组件，能够完美替代&lt;code&gt;Alert&lt;/code&gt;提供的所有功能。今天就&lt;code&gt;ElastAlert&lt;/code&gt;强大的告警功能和笔者实践过程中遇到的一些问题进行分享。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Elasticsearch" scheme="https://tony-yin.github.io/tags/Elasticsearch/"/>
    
      <category term="Monitor" scheme="https://tony-yin.github.io/tags/Monitor/"/>
    
  </entry>
  
  <entry>
    <title>如何避免 Cronjob 重复运行</title>
    <link href="https://tony-yin.github.io/2018/11/05/How-To-Avoid-Cronjob-Duplicate-Running/"/>
    <id>https://tony-yin.github.io/2018/11/05/How-To-Avoid-Cronjob-Duplicate-Running/</id>
    <published>2018-11-05T05:07:06.000Z</published>
    <updated>2018-12-13T16:40:24.434Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/cronjob.png" alt="cronjob"></center><p><code>Cronjob</code>使用中有很多问题需要注意，前段时间写了一篇文章<a href="https://www.tony-yin.site/2018/10/29/Why-Crontab-Not-Work/" target="_blank" rel="noopener">《为什么 Cronjob 不执行》</a>，里面谈到了各种会导致<code>cronjob</code>不执行的因素和解决方案，而本文就<code>cronjob</code>重复运行的场景，对技术手段、技术方案、具体代码和相互优劣展开详细讲解。</p><a id="more"></a><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>之前写过一篇文章<a href="https://www.tony-yin.site/2018/05/20/Ctdb-Rados-2/" target="_blank" rel="noopener">《Ctdb Rados（二）：多场景断网高可用》</a>，文中提到支持秒级的定时任务的方法，因为<code>cronjob</code>本身最小只支持分钟级别的定时任务，所以笔者在<code>cronjob</code>定时脚本中通过<code>for</code>循环来达到秒级定时的目的。</p><p>然而这种定时间隔很短的任务是很容易出现重复运行的问题的。正常情况下脚本执行时间是很短的，但是一旦遇到<code>IO</code>阻塞等问题，会出现多个任务同时运行的情况，这种情况往往不是我们所期望的，可能会导致意想不到的问题。</p><p>即使不是秒级的定时任务，只要任务执行时间超过定时间隔都会出现重复运行的问题，比如每分钟运行的定时任务，而其执行时间需要三分钟等等</p><p>例子如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -elf | grep forever</span></span><br><span class="line">4 S vagrant   4095  4094  0  80   0 -  1111 wait   21:59 ?        00:00:00 /bin/sh -c /var/tmp/forever.sh</span><br><span class="line">0 S vagrant   4096  4095  0  80   0 -  2779 wait   21:59 ?        00:00:00 /bin/bash /var/tmp/forever.sh</span><br><span class="line">4 S vagrant   4100  4099  0  80   0 -  1111 wait   22:00 ?        00:00:00 /bin/sh -c /var/tmp/forever.sh</span><br><span class="line">0 S vagrant   4101  4100  0  80   0 -  2779 wait   22:00 ?        00:00:00 /bin/bash /var/tmp/forever.sh</span><br><span class="line">4 S vagrant   4130  4129  0  80   0 -  1111 wait   22:01 ?        00:00:00 /bin/sh -c /var/tmp/forever.sh</span><br><span class="line">0 S vagrant   4131  4130  0  80   0 -  2779 wait   22:01 ?        00:00:00 /bin/bash /var/tmp/forever.sh</span><br><span class="line">4 S vagrant   4135  4134  0  80   0 -  1111 wait   22:02 ?        00:00:00 /bin/sh -c /var/tmp/forever.sh</span><br><span class="line">0 S vagrant   4136  4135  0  80   0 -  2779 wait   22:02 ?        00:00:00 /bin/bash /var/tmp/forever.sh</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案1：进程数"><a href="#方案1：进程数" class="headerlink" title="方案1：进程数"></a>方案1：进程数</h3><p>这是笔者第一时间自己想的方式，通过进程数来判断当前定时脚本同时执行的数量，比如执行的脚本名为<code>/opt/test.sh</code>，当有一个任务在运行的时候：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# ps -ef | grep /opt/test.sh</span><br><span class="line">root      1107 25880  0 23:26 pts/0    00:00:00 /usr/bin/bash /opt/test.sh</span><br><span class="line">root      1305  1175  0 23:27 pts/5    00:00:00 grep --color=auto /opt/test.sh</span><br></pre></td></tr></table></figure><p>此时通过<code>ps -ef | grep /opt/test.sh | wc -l</code>得到的数量应该是<code>2</code>，如果定时间隔完毕后又刷新了一轮，总进程数则会变成<code>3</code>。</p><p>所以我们可以在<code>/opt/test.sh</code>中加入进程数的判断，如果进程数大于<code>2</code>，就说明存在已有任务在运行，此时应该退出执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count=$(ps -ef | grep /opt/test.sh | wc -l)</span><br><span class="line">if [ $count -gt 2 ]; then</span><br><span class="line">    echo "Exist job running!"</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line">do something</span><br></pre></td></tr></table></figure><p>但是事与愿违，当我们在<code>/opt/test.sh</code>中通过<code>ps</code>命令获取定时任务运行数量的时候发现，如果只存在当前的任务运行时，得到的进程数是<code>3</code>，如果有其他一个已在运行，则进程数是<code>4</code>，以此类推。这是为什么呢？</p><p>经过一番研究发现，当只存在当前任务运行时，如果脚本里面是直接运行<code>ps</code>命令，得到的进程数是<code>2</code>，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep /opt/test.sh | wc -l</span><br></pre></td></tr></table></figure><p>不难看出这是<code>$()</code>的原因，它在<code>shell</code>中起了一个子<code>shell</code>，所以在子<code>shell</code>执行<code>ps</code>的同时多了一个当前脚本任务运行的进程，所以比正常进程数多<code>1</code>，所以上面代码我们需要改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count=$(ps -ef | grep /opt/test.sh | wc -l)</span><br><span class="line">if [ $count -gt 3 ]; then</span><br><span class="line">    echo "Exist job running!"</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line">do something</span><br></pre></td></tr></table></figure><h3 id="方案2：普通文件锁"><a href="#方案2：普通文件锁" class="headerlink" title="方案2：普通文件锁"></a>方案2：普通文件锁</h3><p>可以通过一个文件来标识当前是否存在任务在运行，具体做法为当运行任务时，先检查是否存在文件锁，如果存在则表示上个任务还没有运行结束，则退出；如果不存在文件锁，则新创建一个文件锁，然后执行任务，最后执行完毕后删除文件锁。</p><p>具体代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">file_lock=/opt/test.lock</span><br><span class="line">if [ -f file_lock ]; then</span><br><span class="line">    echo "Exist job running!"</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line">touch file_lock</span><br><span class="line">do something</span><br><span class="line">rm -f file_lock</span><br></pre></td></tr></table></figure><h3 id="方案3：进程号文件锁"><a href="#方案3：进程号文件锁" class="headerlink" title="方案3：进程号文件锁"></a>方案3：进程号文件锁</h3><p>所谓进程号文件锁，相比于方案<code>2</code>的普通文件锁不同的地方就是会把当前运行任务对应的进程号写入锁文件中，其优势在于除了可以通过检查文件是否存在来判断是否存在已经运行的任务，还可以再通过锁文件里面的进程号来做第二次确认。</p><p>也许有人会问这个二次确认有啥用？你还别说，这个还真有用，很多时候进程意外终止或者被手动杀掉后，文件锁依然存在，那么使用普通文件锁的结果就是其实并没有正在运行的任务，但是由于存在文件锁，之后所有的任务都不会再运行。而进程号文件锁则可以在文件锁判断之外，再对锁文件中的进程号进行判断是否还在运行，具体代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PIDFILE=/opt/test.pid</span><br><span class="line">if [ -f $PIDFILE ]</span><br><span class="line">then</span><br><span class="line">  PID=$(cat $PIDFILE)</span><br><span class="line">  ps -p $PID &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">  if [ $? -eq 0 ]</span><br><span class="line">  then</span><br><span class="line">    echo "Exist job running!"</span><br><span class="line">    exit 1</span><br><span class="line">  else</span><br><span class="line">    echo $$ &gt; $PIDFILE</span><br><span class="line">    if [ $? -ne 0 ]</span><br><span class="line">    then</span><br><span class="line">      echo "Could not create PID file!"</span><br><span class="line">      exit 1</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">else</span><br><span class="line">  echo $$ &gt; $PIDFILE</span><br><span class="line">  if [ $? -ne 0 ]</span><br><span class="line">  then</span><br><span class="line">    echo "Could not create PID file!"</span><br><span class="line">    exit 1</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">do something</span><br><span class="line">rm $PIDFILE</span><br></pre></td></tr></table></figure><p>虽然此方案看起来很完美，但是还是有一个场景没有考虑到，那就是如果正在运行任务的进程被<code>kill</code>掉，然后另一个进程使用了和被<code>kill</code>进程相同的<code>pid</code>，这样也会导致其实任务并没有在运行，由于存在锁文件和对应进程号的进程在运行，之后所有的任务不再运行。虽然这种场景很极端，但是也是有可能出现的，不过没关系，下面的方案会帮你解决这个问题。</p><h3 id="方案4：flock-锁"><a href="#方案4：flock-锁" class="headerlink" title="方案4：flock 锁"></a>方案4：flock 锁</h3><p><code>linux flock</code>锁有区别于一般的锁，它不仅仅是检查文件是否存在，它会一直存在直到进程结束，所以可以直接地知道进程是否真的执行结束了。</p><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flock [-sxun][-w #] fd#</span><br><span class="line">flock [-sxon][-w #] file [-c] command</span><br></pre></td></tr></table></figure><p>选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-s, --shared:    获得一个共享锁 </span><br><span class="line">-x, --exclusive: 获得一个独占锁 </span><br><span class="line">-u, --unlock:    移除一个锁，脚本执行完会自动丢弃锁 </span><br><span class="line">-n, --nonblock:  如果没有立即获得锁，直接失败而不是等待 </span><br><span class="line">-w, --timeout:   如果没有立即获得锁，等待指定时间 </span><br><span class="line">-o, --close:     在运行命令前关闭文件的描述符号。用于如果命令产生子进程时会不受锁的管控 </span><br><span class="line">-c, --command:   在shell中运行一个单独的命令 </span><br><span class="line">-h, --help       显示帮助 </span><br><span class="line">-V, --version:   显示版本</span><br></pre></td></tr></table></figure><p>锁类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">共享锁：多个进程可以使用同一把锁，常被用作读共享锁</span><br><span class="line">独占锁：同时只允许一个进程使用，又称排他锁，写锁。</span><br></pre></td></tr></table></figure><p>这里由于我们只允许同时存在一个任务运行，所以选择独占锁，然后需要在脚本执行完丢弃锁：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * *  flock -xn /opt/test.lock -c /opt/test.sh</span><br></pre></td></tr></table></figure><h3 id="方案5：solo-程序"><a href="#方案5：solo-程序" class="headerlink" title="方案5：solo 程序"></a>方案5：solo 程序</h3><p><a href="http://timkay.com/solo/" target="_blank" rel="noopener">Solo</a>是一个<code>Perl</code>脚本，它的工作原理与<code>flock</code>类似，但它并不依赖于锁文件，因为<code>Solo</code>程序是通过绑定端口来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./solo -port=6000 /opt/test.sh &amp;</span></span><br><span class="line">[1] 7503</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./solo -port=6000 /opt/test.sh</span></span><br><span class="line">solo(6000): Address already in use</span><br></pre></td></tr></table></figure><p>执行<code>solo</code>时，将绑定指定的端口并执行后面指定的命令。一旦命令完成，就会释放端口，允许任务的下一个调用正常执行。</p><p><code>solo</code>的优势在于没有人能够通过删除一个文件并意外地导致任务重复运行。即使使用<code>flock</code>命令，如果锁文件被删除，也可以启动第二个作业。由于<code>solo</code>绑定了一个端口，所以不可能出现这种情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面提到了五种方案，第一种方案略显粗糙，但是缺陷相对来说较少；第二种方案存在锁文件被意外删除或者进程被<code>kill</code>的风险；第三种方案存在锁文件被意外删除和新进程占用相同进程号的问题；第四种方案还是存在意外删除锁文件的问题；第五种方案则不需要担心锁文件被删除导致任务重复运行的问题。</p><p>目前看起来第五种方案是最优的，不存在缺陷。不过还是得看具体场景，笔者认为第三种、第四种、第五种方案都是有可取之处的，大家还是根据各自的场景选择最适合自己的方案吧。</p><h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ul><li><a href="https://blog.csdn.net/phachon/article/details/52106409" target="_blank" rel="noopener">https://blog.csdn.net/phachon/article/details/52106409</a></li><li><a href="http://bencane.com/2015/09/22/preventing-duplicate-cron-job-executions/" target="_blank" rel="noopener">http://bencane.com/2015/09/22/preventing-duplicate-cron-job-executions/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/cronjob.png&quot; alt=&quot;cronjob&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;code&gt;Cronjob&lt;/code&gt;使用中有很多问题需要注意，前段时间写了一篇文章&lt;a href=&quot;https://www.tony-yin.site/2018/10/29/Why-Crontab-Not-Work/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《为什么 Cronjob 不执行》&lt;/a&gt;，里面谈到了各种会导致&lt;code&gt;cronjob&lt;/code&gt;不执行的因素和解决方案，而本文就&lt;code&gt;cronjob&lt;/code&gt;重复运行的场景，对技术手段、技术方案、具体代码和相互优劣展开详细讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
      <category term="Cronjob" scheme="https://tony-yin.github.io/tags/Cronjob/"/>
    
  </entry>
  
  <entry>
    <title>为什么 crontab 不执行</title>
    <link href="https://tony-yin.github.io/2018/10/29/Why-Crontab-Not-Work/"/>
    <id>https://tony-yin.github.io/2018/10/29/Why-Crontab-Not-Work/</id>
    <published>2018-10-29T06:50:26.000Z</published>
    <updated>2018-12-13T16:40:24.465Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/Why-Crontab-Not_Work.png" alt="Why Crontab Not Work"></center><p>作为<code>linux</code>中的定时任务工具，<code>crontab</code>被广大开发者所热爱和使用。该技术由来已久，相当成熟，但是在真正使用的时候会时不时地发现为什么<code>crontab</code>脚本没有按照预期那样执行？本文以本周笔者遇到一个<code>crontab</code>不能运行的问题为引子，详细地介绍为什么<code>crontab</code>不运行的各种原因。</p><a id="more"></a><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>本周遇到一个<code>crontab</code>不能执行的问题，发现原因后觉得甚是有趣。</p><p>笔者通过一个<code>python</code>脚本向<code>/etc/cron.d</code>目录下的一个文件写入定时任务命令，每分钟调用一个脚本，调用的这个脚本是个<code>python</code>文件，然后发现<code>cron</code>并没有按照预期每分钟执行一次。然后笔者就将原定时任务脚本<code>aaa</code>拷贝了一份，并重新命名为<code>bbb</code>，然后将定时任务中调用脚本改成了执行一个简单的<code>echo</code>命令，然后保存退出，发现<code>bbb</code>是可以正常定时运行的，这时候，笔者就通过<code>file</code>命令想比较一下这两个文件有何不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@tony cron.d]# file *</span><br><span class="line">aaa:     ASCII text, with no line terminators</span><br><span class="line">bbb:     ASCII text</span><br></pre></td></tr></table></figure><p>这个时候我们可以发现<code>aaa</code>文件出现了比较奇怪的标识：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">with no line terminators</span><br></pre></td></tr></table></figure><p>显而易见，这是在说<code>cron</code>脚本中定时命令没有行终止符，导致这个问题是因为该<code>cron</code>脚本由<code>python</code>代码生成时没有添加换行符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;/etc/cron.d/aaa&apos;, &apos;w&apos;) as f:</span><br><span class="line">    f.write(&apos;xxx&apos;)</span><br></pre></td></tr></table></figure><p>然后笔者尝试性地在<code>aaa</code>文件中在定时命令下新增一行后，发现定时任务可以正常运行了。不得不说，这是一个很有意思的问题，<code>crontab</code>居然会因为一个换行符导致定时任务的不运行，后来<code>google</code>了一下发现，<code>crontab</code>的确存在这个机制，具体解释下面会提到。</p><p>在<code>google</code>的同时，在<code>ask unbuntu</code>上发现了这篇文章：<a href="https://askubuntu.com/questions/23009/why-crontab-scripts-are-not-working?page=1&amp;tab=votes#tab-top" target="_blank" rel="noopener">《Why crontab scripts are not working?》</a>，里面很多开发者罗列了他们遇到<code>cron</code>不能正常运行的各种因素，笔者大致浏览了下，发现有遇到过，也有很多并不知道的，所以想把这些因素和解决方案一一罗列下来。</p><h2 id="因素"><a href="#因素" class="headerlink" title="因素"></a>因素</h2><h3 id="因素1：环境变量"><a href="#因素1：环境变量" class="headerlink" title="因素1：环境变量"></a>因素1：环境变量</h3><h4 id="场景及原因"><a href="#场景及原因" class="headerlink" title="场景及原因"></a>场景及原因</h4><p><code>cron</code>中的环境变量和系统的环境变量是不一样的，我们可以通过设置定时脚本将<code>cron</code>中的环境变量打印出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * env &gt; /tmp/env.output</span><br></pre></td></tr></table></figure><p>可以看到<code>cron</code>中的环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">XDG_SESSION_ID=12952</span><br><span class="line">SHELL=/bin/sh</span><br><span class="line">USER=root</span><br><span class="line">PATH=/usr/bin:/bin</span><br><span class="line">PWD=/root</span><br><span class="line">LANG=en_US.UTF-8</span><br><span class="line">SHLVL=1</span><br><span class="line">HOME=/root</span><br><span class="line">LOGNAME=root</span><br><span class="line">XDG_RUNTIME_DIR=/run/user/0</span><br><span class="line">_=/usr/bin/env</span><br></pre></td></tr></table></figure><p>查看系统的环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@tony cron.d]# env</span><br><span class="line">XDG_SESSION_ID=1140</span><br><span class="line">HOSTNAME=tony</span><br><span class="line">TERM=xterm-256color</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">HISTSIZE=1000</span><br><span class="line">USER=root</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/root/bin</span><br><span class="line">MAIL=/var/spool/mail/root</span><br><span class="line">PWD=/etc/cron.d</span><br><span class="line">LANG=en_US.UTF-8</span><br><span class="line">TMUX_PANE=%18</span><br><span class="line">HISTCONTROL=ignoredups</span><br><span class="line">SHLVL=2</span><br><span class="line">HOME=/root</span><br><span class="line">LOGNAME=root</span><br><span class="line">_=/usr/bin/env</span><br><span class="line">OLDPWD=/root</span><br></pre></td></tr></table></figure><p>我们可以看到<code>cron</code>中的环境变量很多都和系统环境变量不一样（<code>cron</code>会忽略<code>/etc/environment</code>文件），尤其是<code>PATH</code>，只有<code>/usr/bin:/bin</code>，也就是说在<code>cron</code>中运行<code>shell</code>命令，如果不是全路径，只能运行<code>/usr/bin</code>或<code>/bin</code>这两个目录中的标准命令，而像<code>/usr/sbin</code>、<code>/usr/local/bin</code>等目录中的非标准命令是不能运行的。</p><p>这个问题笔者也遇到很多次，所以很多非标准命令都选择了全路径，但是这个方法也有问题，因为不同环境的命令所存在的目录是不一样的。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><strong>方案1：</strong></p><p>在<code>cron</code>脚本文件头部声明<code>PATH</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">PATH=/opt/someApp/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line"></span><br><span class="line"># rest of script follows</span><br></pre></td></tr></table></figure><p><strong>方案2：</strong></p><p>在定时脚本调用的脚本头部声明<code>PATH</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PATH=/opt/someApp/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line"></span><br><span class="line">15 1 * * * backupscript --incremental /home /root</span><br></pre></td></tr></table></figure><h3 id="因素2：换行符"><a href="#因素2：换行符" class="headerlink" title="因素2：换行符"></a>因素2：换行符</h3><h4 id="场景及原因-1"><a href="#场景及原因-1" class="headerlink" title="场景及原因"></a>场景及原因</h4><p>这个因素就是笔者引子中提到的，官方解释（<code>man crontab</code>）如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Although cron requires that each entry in a crontab end in a newline character, neither the crontab command nor the cron daemon will detect this error. Instead, the crontab will appear to load normally. However, the command will never run. The best choice is to ensure that your crontab has a blank line at the end.</span><br><span class="line"></span><br><span class="line">4th Berkeley Distribution      29 December 1993     CRONTAB(1)</span><br></pre></td></tr></table></figure><p>简单翻译一下就是：</p><p>尽管<code>crontab</code>要求<code>cron</code>中的每个条目都要以换行符结尾，但<code>crontab</code>命令和<code>cron</code>守护进程都不会检测到这个错误。相反，<code>crontab</code>将正常加载。然而，命令永远不会运行。最好的选择是确保您的<code>crontab</code>在末尾有一个空白行。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>给<code>cron</code>中每个条目下面添加一个空行</p><p><strong>注意：</strong></p><p>除了没了换行符会导致<code>cron</code>中的命令不会运行，即引子中所标识：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">with no line terminators</span><br></pre></td></tr></table></figure><p>但是因为非<code>linux</code>操作系统导致的非<code>\n</code>换行符同样会导致该问题，比如<code>windows</code>的<code>^M</code>、<code>mac</code>的<code>\r</code>等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">with CR line terminators</span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong></p><p><code>windows</code>的话就通过<code>dos2unix</code>命令转换；而<code>mac</code>则可以通过<code>mac2unix</code>来转换，<code>mac2unix</code>也是<code>dos2unix</code>软件中的一部分</p><h4 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h4><ul><li><a href="https://stackoverflow.com/questions/14080306/remove-cr-line-terminators" target="_blank" rel="noopener">remove CR line terminators</a></li></ul><h3 id="因素3：crond-服务"><a href="#因素3：crond-服务" class="headerlink" title="因素3：crond 服务"></a>因素3：crond 服务</h3><h4 id="场景及原因-2"><a href="#场景及原因-2" class="headerlink" title="场景及原因"></a>场景及原因</h4><p>很多时候<code>crond</code>服务未开启，也会导致定时任务不会正常执行。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>查看服务是否运行，如果未运行，启动<code>crond</code>服务即可。</p><p>查看方式有两种：</p><p>1.通过进程查看</p><p><code>pgrep</code>相当于<code>ps -ef | grep</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgrep cron</span><br></pre></td></tr></table></figure><p>2.通过<code>service</code>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service crond status</span><br></pre></td></tr></table></figure><p>启动服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service crond start</span><br></pre></td></tr></table></figure><h3 id="因素4：shell-解释器"><a href="#因素4：shell-解释器" class="headerlink" title="因素4：shell 解释器"></a>因素4：shell 解释器</h3><h4 id="场景及原因-3"><a href="#场景及原因-3" class="headerlink" title="场景及原因"></a>场景及原因</h4><p>从因素<code>1</code>就知道<code>cron</code>环境变量中的<code>SHELL</code>是<code>sh</code>而不是<code>bash</code>，我们知道很多<code>shell</code>命令是可以在<code>bash</code>中正常运行，但是不能在<code>sh</code>中运行的，所以这个因素也会影响定时任务的正常运行。</p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p><strong>方案1：</strong></p><p>将<code>cron</code>中需要执行的命令在<code>sh</code>中执行确认</p><p><strong>方案2：</strong></p><p>将<code>cron</code>中需要执行的命令外面加一个<code>bash shell</code>的封装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c &quot;mybashcommand&quot;</span><br></pre></td></tr></table></figure><p><strong>方案3：</strong></p><p>修改<code>cron</code>中的<code>SHELL</code>环境变量的值，让所有命令都用<code>bash</code>解释器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHELL=/bin/bash</span><br></pre></td></tr></table></figure><p><strong>方案4：</strong></p><p>如果定时任务执行的命令是<code>shell</code>脚本，只要在脚本内添加<code>bash</code>解释器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br></pre></td></tr></table></figure><h3 id="因素5：时区"><a href="#因素5：时区" class="headerlink" title="因素5：时区"></a>因素5：时区</h3><h4 id="场景及原因-4"><a href="#场景及原因-4" class="headerlink" title="场景及原因"></a>场景及原因</h4><p>当修改系统时区后，无论是之前已经存在的<code>cron</code>还是之后新创建的<code>cron</code>，脚本中设置的定时时间都以旧时区为准，比如原来时区是<code>Asia/Shanghai</code>，时间为<code>10:00</code>，然后修改时区为<code>Europe/Paris</code>，时间变为<code>3:00</code>，此时你设置<code>11:00</code>的定时时间，<code>cron</code>会在<code>Asia/Shanghai</code>时区的<code>11:00</code>执行。</p><h4 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h4><p><strong>方案1：</strong></p><p>重启<code>crond</code>服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service crond restart</span><br></pre></td></tr></table></figure><p><strong>方案2：</strong></p><p><code>kill crond</code>进程，因为<code>crond</code>进程是可重生的</p><h3 id="因素6：百分号"><a href="#因素6：百分号" class="headerlink" title="因素6：百分号%"></a>因素6：百分号%</h3><h4 id="场景及原因-5"><a href="#场景及原因-5" class="headerlink" title="场景及原因"></a>场景及原因</h4><p>当<code>cron</code>定时执行命令中，有百分号并且没有转义的时候，<code>cron</code>执行会出错，比如执行以下<code>cron</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 * * * * echo hello &gt;&gt; ~/cron-logs/hourly/test`date &quot;+%d&quot;`.log</span><br></pre></td></tr></table></figure><p>会有如下报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh: -c: line 0: unexpected EOF while looking for matching ``&apos;</span><br><span class="line">/bin/sh: -c: line 1: syntax error: unexpected end of file</span><br></pre></td></tr></table></figure><p>有的日志也会有如下报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(echo) ERROR (getpwnam() failed)</span><br></pre></td></tr></table></figure><p><code>crontab manpage</code>中解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The &quot;sixth&quot; field (the rest of the line) specifies the command to be run. The entire command portion of the line, up to a newline or % character, will be executed by /bin/sh or by the shell specified in the SHELL variable of the cronfile. Percent-signs (%) in the command, unless escaped with backslash (\), will be changed into newline characters, and all data after the first % will be sent to the command as standard input.</span><br></pre></td></tr></table></figure><p>即<code>cron</code>中换行符或<code>%</code>前的命令会被<code>shell</code>解释器执行，但是<code>%</code>会被认为新一行的字符，并且<code>%</code>后所有的数据都会以标准输出的形式发送给命令。</p><h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><p>为百分号做转义，即在<code>%</code>前添加反斜杠<code>\</code></p><h4 id="Refer-1"><a href="#Refer-1" class="headerlink" title="Refer"></a>Refer</h4><ul><li><a href="http://www.pantz.org/software/cron/croninfo.html" target="_blank" rel="noopener">Cron and Crontab usage and examples</a></li><li><a href="https://unix.stackexchange.com/questions/29578/how-can-i-execute-date-inside-of-a-cron-tab-job" target="_blank" rel="noopener">How can I execute date inside of a cron tab job?</a></li></ul><h3 id="因素7：密码过期"><a href="#因素7：密码过期" class="headerlink" title="因素7：密码过期"></a>因素7：密码过期</h3><h4 id="场景及原因-6"><a href="#场景及原因-6" class="headerlink" title="场景及原因"></a>场景及原因</h4><p><code>Linux</code>下新建用户密码过期时间是从<code>/etc/login.defs</code>文件中<code>PASS_MAX_DAYS</code>提取的，普通系统默认就是<code>99999</code>，而有些安全操作系统是<code>90</code>。更改此处，只是让新建的用户默认密码过期时间变化，已有用户密码过期时间仍然不变。</p><p>当用户密码过期也会导致<code>cron</code>脚本执行失败。</p><h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><p>将用户密码有效期设置成永久有效期或者延长有效期</p><p><strong>方案1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chage -M &lt;expire&gt; &lt;username&gt;</span><br></pre></td></tr></table></figure><p><strong>方案2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd -x -1 &lt;username&gt;</span><br></pre></td></tr></table></figure><p><strong>方案3：</strong></p><p>手动修改<code>/etc/login.defs</code>文件中<code>PASS_MAX_DAYS</code>的值</p><h3 id="因素8：权限"><a href="#因素8：权限" class="headerlink" title="因素8：权限"></a>因素8：权限</h3><h4 id="场景及原因-7"><a href="#场景及原因-7" class="headerlink" title="场景及原因"></a>场景及原因</h4><p>很多时候解决方案都是采用<code>root</code>用户执行<code>cron</code>，但是有时候这并不是一个很好的方式。如果采用非<code>root</code>用户执行<code>cron</code>，需要注意很多权限问题，比如<code>cron</code>用户对操作的文件或目录是否存在权限等。</p><p>如果权限不够，<code>cron</code>会拒绝执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service cron restart</span><br><span class="line">grep -i cron /var/log/syslog|tail -2</span><br><span class="line">2013-02-05T03:47:49.283841+01:00 ubuntu cron[49906]: (user) INSECURE MODE (mode 0600 expected) (crontabs/user)</span><br></pre></td></tr></table></figure><h4 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># correct permission</span><br><span class="line">sudo chmod 600 /var/spool/cron/crontabs/user</span><br><span class="line"># signal crond to reload the file</span><br><span class="line">sudo touch /var/spool/cron/crontabs</span><br></pre></td></tr></table></figure><h3 id="因素9：不同平台"><a href="#因素9：不同平台" class="headerlink" title="因素9：不同平台"></a>因素9：不同平台</h3><h4 id="场景及原因-8"><a href="#场景及原因-8" class="headerlink" title="场景及原因"></a>场景及原因</h4><p>一些特殊选项各个平台支持不一样，有的支持，有的不支持，例如<code>2/3</code>、<code>1-5</code>、<code>1,3,5</code></p><h4 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h4><p>需要针对不同平台做兼容性测试</p><h3 id="因素10：不同-cron"><a href="#因素10：不同-cron" class="headerlink" title="因素10：不同 cron"></a>因素10：不同 cron</h3><h4 id="场景及原因-9"><a href="#场景及原因-9" class="headerlink" title="场景及原因"></a>场景及原因</h4><p>将之前运行的<code>Crontab Spec</code>在从一个<code>Crontab</code>文件移动到另一个<code>Crontab</code>文件时可能会崩溃。有时候，原因是你已经将<code>Spec</code>从系统<code>crontab</code>文件转移到用户<code>crontab</code>文件，反之亦然。</p><p><code>cron</code>分为系统<code>cron</code>和用户<code>cron</code>，用户<code>cron</code>指<code>/var/spool/cron/username</code>或<code>/var/spool/crontabs/crontabs/username</code>，系统<code>cron</code>指<br><code>/etc/crontab</code>以及<code>/etc/crontab</code>，这两者是存在部分差异的。</p><p>系统<code>crontab</code>在命令行运行之前有一个额外的字段<code>user</code>。这会导致一些错误，比如你将<code>/etc/crontab</code>中的命令或者<code>/etc/cron.d</code>中的文件移动至用户<code>crontab</code>会报错如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">george; command not found</span><br></pre></td></tr></table></figure></p><p>相反，当发生相反的情况时，<code>cron</code>将显示<code>/usr/bin/restartxyz is not a valid username</code>之类的错误。</p><h4 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a>解决方案</h4><p>当共享系统<code>cron</code>或用户<code>cron</code>时，注意用户的添加和删除。</p><h3 id="因素11：crontable-变量"><a href="#因素11：crontable-变量" class="headerlink" title="因素11：crontable 变量"></a>因素11：crontable 变量</h3><h4 id="场景及原因-10"><a href="#场景及原因-10" class="headerlink" title="场景及原因"></a>场景及原因</h4><p>虽然你可以在<code>crontable</code>里面声明环境变量，但是在下面这种情况定时任务是不会执行的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SOME_DIR=/var/log</span><br><span class="line">MY_LOG_FILE=$&#123;SOME_LOG&#125;/some_file.log</span><br><span class="line"></span><br><span class="line">BIN_DIR=/usr/local/bin</span><br><span class="line">MY_EXE=$&#123;BIN_DIR&#125;/some_executable_file</span><br><span class="line"></span><br><span class="line">0 10 * * * $&#123;MY_EXE&#125; some_param &gt;&gt; $&#123;MY_LOG_FILE&#125;</span><br></pre></td></tr></table></figure><p>这是因为在<code>crontable</code>里面只能声明变量，不能对变量进行操作或者执行其他任何<code>shell</code>命令的，所以上述的<code>shell</code>字符串拼接是不会成功的，所以只能声明变量，然后在命令中引用变量。</p><h4 id="解决方案：-2"><a href="#解决方案：-2" class="headerlink" title="解决方案："></a>解决方案：</h4><p><strong>方案1：</strong> </p><p>直接声明变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SOME_DIR=/var/log</span><br><span class="line">MY_LOG_FILE=/var/log/some_file.log</span><br><span class="line"></span><br><span class="line">BIN_DIR=/usr/local/bin</span><br><span class="line">MY_EXE=/usr/local/bin/some_executable_file</span><br><span class="line"></span><br><span class="line">0 10 * * * $&#123;MY_EXE&#125; some_param &gt;&gt; $&#123;MY_LOG_FILE&#125;</span><br></pre></td></tr></table></figure><p><strong>方案2：</strong></p><p>声明多个变量，在命令中引用拼接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SOME_DIR=/var/log</span><br><span class="line">MY_LOG_FILE=some_file.log</span><br><span class="line"></span><br><span class="line">BIN_DIR=/usr/local/bin</span><br><span class="line">MY_EXE=some_executable_file</span><br><span class="line"></span><br><span class="line">0 10 * * * $&#123;BIN_DIR&#125;/$&#123;MY_EXE&#125; some_param &gt;&gt; $&#123;SOME_DIR&#125;/$&#123;MY_LOG_FILE&#125;</span><br></pre></td></tr></table></figure><h3 id="因素12：GUI"><a href="#因素12：GUI" class="headerlink" title="因素12：GUI"></a>因素12：GUI</h3><h4 id="场景及原因-11"><a href="#场景及原因-11" class="headerlink" title="场景及原因"></a>场景及原因</h4><p>如果你的<code>cronjob</code>调用了相关<code>GUI</code>应用时，你需要告诉它们应该使用什么<code>DISPLAY</code>环境变量，从因素<code>1</code>我们可以知道<code>cron</code>中的环境变量是和系统环境变量不一样的，<code>DISPLAY</code>同样如此，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Firefox launch with cron.</span><br></pre></td></tr></table></figure><h4 id="解决方案-8"><a href="#解决方案-8" class="headerlink" title="解决方案"></a>解决方案</h4><p>声明<code>DISPLAY=:0</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * export DISPLAY=:0 &amp;&amp; &lt;command&gt;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前主要总结了影响<code>cron</code>运行的<code>12</code>种因素，当然肯定还存在其他影响因素，本文将持续更新，希望这些坑能够被广大开发者所熟知。</p><p>大家如果有上述以外导致<code>cron</code>不能正常运行的因素可以在博客下方留言，或者在<code>Github</code>上面提<code>pr</code>，笔者已经将本文在<code>Github</code>上面创建了一个仓库，让我们一起不断完善吧 -。-</p><p><code>Github</code>仓库地址：<a href="https://github.com/tony-yin/Why-Cronjob-Not-Work" target="_blank" rel="noopener">https://github.com/tony-yin/Why-Cronjob-Not-Work</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/Why-Crontab-Not_Work.png&quot; alt=&quot;Why Crontab Not Work&quot;&gt;&lt;/center&gt;

&lt;p&gt;作为&lt;code&gt;linux&lt;/code&gt;中的定时任务工具，&lt;code&gt;crontab&lt;/code&gt;被广大开发者所热爱和使用。该技术由来已久，相当成熟，但是在真正使用的时候会时不时地发现为什么&lt;code&gt;crontab&lt;/code&gt;脚本没有按照预期那样执行？本文以本周笔者遇到一个&lt;code&gt;crontab&lt;/code&gt;不能运行的问题为引子，详细地介绍为什么&lt;code&gt;crontab&lt;/code&gt;不运行的各种原因。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
      <category term="Crontab" scheme="https://tony-yin.github.io/tags/Crontab/"/>
    
  </entry>
  
  <entry>
    <title>Daily Article Vol7(2018/6/1 ~ 2018/6/30)</title>
    <link href="https://tony-yin.github.io/2018/07/01/Daily-Article-Vol7/"/>
    <id>https://tony-yin.github.io/2018/07/01/Daily-Article-Vol7/</id>
    <published>2018-07-01T05:07:06.000Z</published>
    <updated>2018-12-13T16:40:24.424Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/6.png" alt="6"></center><p>这是<code>Daily Article</code>系列文章的第七篇，主要记录了<code>2018/6/1 ~ 2018/6/30</code>之间的阅读记录。</p><a id="more"></a><p>六月份主要做了几件事，一个是基于<code>python</code>实现一个守护进程，从<code>unix</code>实现守护进程的底层原理撸了一遍，加深了对<code>linux</code>底层进程一些概念的了解，正好也接触了“骑着企鹅采树莓”系列文章，讲的很不错，通俗易懂；然后把之前基于<code>pci path</code>寻找逻辑磁盘的物理位置整理了下，研究了一波块设备持久化命名；然后学习了下<code>kvm</code>虚拟化技术，并在此之上研究了下虚拟机迁移技术，这其中包括虚拟机到虚拟机的迁移，<code>kvm</code>虚拟机到<code>vmware</code>虚拟机的迁移，虚拟机到物理机的迁移，物理机到物理机的迁移等等；最后研究了下多路径设备，概念有点混乱，不断地啃资料终于有点明白了。不得不说，这些底层的知识真是又多又复杂，只能慢慢啃，加油咯。</p><ol><li><a href="https://unix.stackexchange.com/questions/86764/understanding-dev-disk-by-folders" target="_blank" rel="noopener">understanding /dev/disk/by- folders</a>(6/1) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/online_storage_reconfiguration_guide/persistent_naming" target="_blank" rel="noopener">PERSISTENT NAMING</a>(6/2) <i class="fa fa-star"></i></li><li><a href="http://fibrevillage.com/storage/578-understanding-device-names-managed-by-the-udev-mechanism" target="_blank" rel="noopener">Understanding Device Names Managed by the udev mechanism</a>(6/3) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">Persistent block device naming</a>(6/4) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://wiki.archlinux.org/index.php/Udev_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E8.AE.BE.E7.BD.AE.E9.9D.99.E6.80.81.E8.AE.BE.E5.A4.87.E5.90.8D" target="_blank" rel="noopener">udev (简体中文)</a>(6/9) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://www.linuxquestions.org/questions/linux-server-73/how-to-find-wwn-for-dev-sdc-917269/" target="_blank" rel="noopener">How to find WWN for /dev/sdc</a>(6/9)</li><li><a href="http://www.cnblogs.com/songyaqi/p/4553069.html9.html/l-anaconda/index.html" target="_blank" rel="noopener">SSO单点登录的实现原理是怎样的</a>(6/10)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/sdk/python/python-6/index.html" target="_blank" rel="noopener">可爱的 Python：Curses 编程</a>(6/10)</li><li><a href="http://blog.51cto.com/830909/1751106" target="_blank" rel="noopener">Django cookie和session</a>(6/10)</li><li><a href="https://www.jianshu.com/p/40ec55c6e614?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">这也许是你看到过的最通俗易懂的ElasticSearch文章了（理论篇）</a>(6/10) <i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="https://elasticsearch.cn/slides/109#page=21" target="_blank" rel="noopener">饿了么在ELasticsearch自动化运维平台和监控平台的应用实践</a>(6/10)</li><li><a href="https://humansky.com/2011/12/accidentally-adding-a-git-submodule/" target="_blank" rel="noopener">ACCIDENTALLY ADDING A GIT SUBMODULE</a>(6/11)</li><li><a href="https://www.jianshu.com/p/4e412f48e820?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">聊聊MySQL、HBase、ES的特点和区别</a>(6/12) <i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="http://www.cnblogs.com/qiaoyihang/p/6262806.html" target="_blank" rel="noopener">行存储和列存储</a>(6/13)</li><li><a href="https://time.geekbang.org/column/article/1610" target="_blank" rel="noopener">【极客时间：左耳听风】洞悉PaaS平台的本质</a>(6/13) <i class="fa fa-star"></i></li><li><a href="https://coolshell.cn/articles/17459.html" target="_blank" rel="noopener">【CoolShell】关于高可用的系统</a>(6/13) <i class="fa fa-star"></i></li><li><a href="https://time.geekbang.org/column/article/301" target="_blank" rel="noopener">【极客时间：左耳听风】编程范式游记（1）- 起源</a>(6/14)<i class="fa fa-star"></i></li><li><a href="https://blog.csdn.net/asware/article/details/4159366" target="_blank" rel="noopener">python fork</a>(6/15)</li><li><a href="https://blog.csdn.net/taiyang1987912/article/details/44850999" target="_blank" rel="noopener">Python实例浅谈之五Python守护进程和脚本单例运行</a>(6/16) <i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="https://www.jianshu.com/p/e3f3d49093ca" target="_blank" rel="noopener">Python实现守护进程</a>(6/18) <i class="fa fa-star"></i></li><li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p14_launching_daemon_process_on_unix.html#id1" target="_blank" rel="noopener">在Unix系统上面启动守护进程</a>(6/19) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://yq.aliyun.com/articles/41477?spm=5176.100240.searchblog.39.HyGU9I" target="_blank" rel="noopener">《APUE》读书笔记—第十三章守护进程</a>(6/19) <i class="fa fa-star"></i><i class="fa fa-star"></i> </li><li><a href="http://www.cnblogs.com/vamei/archive/2012/09/20/2694466.html" target="_blank" rel="noopener">【骑着企鹅采树莓】Linux进程基础</a>(6/20) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="http://www.cnblogs.com/vamei/archive/2012/10/07/2713023.html" target="_blank" rel="noopener">【骑着企鹅采树莓】Linux进程关系</a>(6/20) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://www.cnblogs.com/vamei/p/6415434.html" target="_blank" rel="noopener">【骑着企鹅采树莓】树莓派：一个关于教育的故事</a>(6/21)</li><li><a href="http://www.cnblogs.com/vamei/p/6424666.html" target="_blank" rel="noopener">【骑着企鹅采树莓】树莓派心脏：ARM的逆袭</a>(6/21)  <i class="fa fa-star"></i></li><li><a href="http://www.cnblogs.com/vamei/p/6718942.html" target="_blank" rel="noopener">【骑着企鹅采树莓】树莓派的大脑：Linux</a>(6/22)</li><li><a href="https://my.oschina.net/guol/blog/156607" target="_blank" rel="noopener">Linux策略路由</a>(6/22)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-linux-br1/index.html" target="_blank" rel="noopener">【迁移Linux系统1】如何迁移备份和裸机恢复Linux系统</a>(6/24)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-linux-br2/index.html" target="_blank" rel="noopener">【迁移Linux系统2】利用 KIWI Imaging System 定制裸机恢复光盘）</a>(6/26)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-mgrtvm1/index.html" target="_blank" rel="noopener">【虚拟机迁移技术漫谈1】如何在虚拟机和物理机以及虚拟机和虚拟机之间的迁移系统</a>(6/24)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-mgrtvm2/index.html" target="_blank" rel="noopener">【虚拟机迁移技术漫谈2】KVM虚拟机在物理主机之间迁移的实现</a>(6/24) <i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-mgrtvm3/index.html" target="_blank" rel="noopener">【虚拟机迁移技术漫谈3】迁移 VMware 虚拟机到 KVM</a>(6/25) <i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-kvm/" target="_blank" rel="noopener">【虚拟机迁移技术漫谈4】KVM 虚拟机在 IBM System x 上应用</a>(6/25) <i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="https://www.ibm.com/developerworks/cn/aix/library/0808_shenlf_ivm/" target="_blank" rel="noopener">【虚拟机迁移技术漫谈5】在IBM集成虚拟化管理器上进行动态分区迁移</a>(6/26)</li><li><a href="http://www.cnblogs.com/biangbiang/p/3222458.html" target="_blank" rel="noopener">利用Qemu Guest Agent (Qemu-ga) 实现 Openstack 监控平台</a>(6/26)</li><li><a href="http://www.zoues.com/2015/10/13/qemu-guest-agent/" target="_blank" rel="noopener">利用qemu-guest-agent冻结文件系统</a>(6/26)</li><li><a href="http://blog.51cto.com/aishangwei/2124944" target="_blank" rel="noopener">kvm 快照</a>(6/26)</li><li><a href="https://access.redhat.com/solutions/732773" target="_blank" rel="noopener">How to enable QEMU guest agent in KVM</a>(6/26)</li><li><a href="http://www.ruanyifeng.com/blog/2018/06/ddos.html" target="_blank" rel="noopener">DDOS 攻击的防范教程</a>(6/27)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-libvirt/index.html" target="_blank" rel="noopener">Libvirt 虚拟化库剖析</a>(6/27) <i class="fa fa-star"></i></li><li><a href="https://www.ibm.com/developerworks/cn/aix/redbooks/live-mobility/" target="_blank" rel="noopener">IBM 动态分区迁移(Live Partition Mobility)技术-概述</a>(6/27)</li><li><a href="http://www.cnblogs.com/vamei/archive/2012/10/04/2711818.html" target="_blank" rel="noopener">【骑着企鹅采树莓】Linux信号基础</a>(6/27) <i class="fa fa-star"></i></li><li><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/6/html/dm_multipath/mpio_description" target="_blank" rel="noopener">DM-MULTIPATH 概述</a>(6/28)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-devmapper/index.html" target="_blank" rel="noopener">Linux 内核中的 Device Mapper 机制</a>(6/28) <i class="fa fa-star"></i></li><li><a href="https://wsgzao.github.io/post/multipath/" target="_blank" rel="noopener">Multipath 多路径配置实践心得</a>(6/28)</li><li><a href="http://www.cnblogs.com/jyzhao/p/7200585.html" target="_blank" rel="noopener">multipath多路径实验01-构建iSCSI模拟环境</a>(6/30) <i class="fa fa-star"></i></li><li><a href="http://www.cnblogs.com/jyzhao/p/7208620.html" target="_blank" rel="noopener">multipath多路径实验02-配置多路径软件</a>(6/30)</li><li><a href="https://blog.csdn.net/jiaping0424/article/details/51591257" target="_blank" rel="noopener">multipath 路径切换</a>(6/30) <i class="fa fa-star"></i></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/6.png&quot; alt=&quot;6&quot;&gt;&lt;/center&gt;

&lt;p&gt;这是&lt;code&gt;Daily Article&lt;/code&gt;系列文章的第七篇，主要记录了&lt;code&gt;2018/6/1 ~ 2018/6/30&lt;/code&gt;之间的阅读记录。&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
      <category term="Daily-Article" scheme="https://tony-yin.github.io/tags/Daily-Article/"/>
    
  </entry>
  
  <entry>
    <title>块设备持久化命名和多路径</title>
    <link href="https://tony-yin.github.io/2018/06/20/Block-device-persistent-name-and-multipath/"/>
    <id>https://tony-yin.github.io/2018/06/20/Block-device-persistent-name-and-multipath/</id>
    <published>2018-06-20T15:15:26.000Z</published>
    <updated>2018-12-13T16:40:24.408Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/fork-in-the-road.png" alt="persistent name"></center><p>众所周知，我们看到的磁盘通常是<code>/dev/sda</code>，<code>/dev/sdb</code>这样的名称，我们可以通过这些磁盘名称对磁盘进行各种操作，例如挂载，分区和格式化等等。但是，如果你的机器上有不止一个<code>SATA</code>，<code>SCSI</code>或<code>IDE</code>磁盘控制器，那么它们所对应的设备节点将会依随机次序添加。这样就可能导致每次引导时设备的名字如<code>/dev/sda</code>与<code>/dev/sdb</code>互换了，再比如硬盘拔插导致磁盘乱序等等，最终导致系统不可引导、<code>kernel panic</code>、或者设备不可见。持久化命名可以解决这些问题。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>持久化命名，顾名思义即一次性或者是短暂的命名，它是一种长久的并且稳定靠谱的命名方案。与之形成鲜明对比的就是<code>/dev/sda</code>这种非持久化命名，这两种命名方案各有各的用处，本文着重对持久化命名进行介绍。持久化命名方案有四种：<code>by-label</code>、<code>by-uuid</code>、<code>by-id</code>和<code>by-path</code>。对于那些使用<code>GUID</code>分区表（<code>GPT</code>）的磁盘，还有额外的两种方案：<code>by-partlabel</code>和<code>by-partuuid</code>。你也可以使用<code>Udev</code>静态设备名方案，这个我们就不作详细解释。下面我将对每种持久化命名方案进行详细的介绍和讲解，不难发现上面所提到的命名方式在<code>/dev</code>目录下都存在一个与之名字对应的文件夹：</p><h2 id="by-label"><a href="#by-label" class="headerlink" title="by-label"></a>by-label</h2><p><code>label</code>表示标签的意思，几乎每一个文件系统都有一个标签。所有有标签的分区都在<code>/dev/disk/by-label</code>目录中列出。这个目录随着分区标签的变动而被动态地创建和销毁。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /dev/disk/by-label</span><br><span class="line"> </span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 10 May 27 23:31 DATA -&gt; ../../sda3</span><br><span class="line">lrwxrwxrwx 1 root root 10 May 27 23:31 SYSTEM -&gt; ../../sda2</span><br></pre></td></tr></table></figure><p>标签必须是唯一的，标签是文件系统的一个属性，所以无法持久地表示单一磁盘阵列设备。</p><p><strong>注意：</strong><code>label</code>是通过从设备中的内容（即数据）获取，所以如果将该内容拷贝至另一个设备中，我们也可以通过<code>blkid</code>来获取磁盘的<code>label</code>。</p><h2 id="by-uuid"><a href="#by-uuid" class="headerlink" title="by-uuid"></a>by-uuid</h2><p><code>UUID</code>是给每个文件系统唯一标识的一种机制，这个标识是在分区格式化时通过文件系统工具生成，比如<code>mkfs</code>，这个唯一标识可以起到解决冲突的作用。所有<code>GNU/Linux</code>文件系统（包括<code>swap</code>和原始加密设备的<code>LUKS</code>头）都支持<code>UUID</code>。<code>FAT</code>和<code>NTFS</code>文件系统并不支持<code>UUID</code>，但是在<code>/dev/disk/by-uuid</code>目录下还是存在着一个更为简单的<code>UID</code>（唯一标识）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /dev/disk/by-uuid/</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 10 May 27 23:31 0a3407de-014b-458b-b5c1-848e92a327a3 -&gt; ../../sda2</span><br><span class="line">lrwxrwxrwx 1 root root 10 May 27 23:31 b411dc99-f0a0-4c87-9e05-184977be8539 -&gt; ../../sda3</span><br><span class="line">lrwxrwxrwx 1 root root 10 May 27 23:31 CBB6-24F2 -&gt; ../../sda1</span><br><span class="line">lrwxrwxrwx 1 root root 10 May 27 23:31 f9fe0b69-a280-415d-a03a-a32752370dee -&gt; ../../sda4</span><br></pre></td></tr></table></figure><p>使用<code>UUID</code>方法的优点是，名称冲突发生的可能性大大低于使用<code>Label</code>的方式。更深层次地讲，它是在创建文件系统时自动生成的。例如，即使设备插入到另一个系统(可能有一个标签相同的设备)，它仍然是唯一的。</p><p>缺点是<code>uuid</code>使得许多配置文件(例如<code>fstab</code>或<code>crypttab</code>)中的长代码行难以读取和破坏格式。此外，每当一个分区被调整大小或重新格式化时，都会生成一个新的UUID，并且必须(手动)调整配置。</p><h2 id="by-path"><a href="#by-path" class="headerlink" title="by-path"></a>by-path</h2><p>该目录中的条目提供一个符号名称，该符号名称通过用于访问设备的<strong>硬件路径</strong>引用存储设备，首先引用<code>PCI hierachy</code>中的存储控制器，并包括<code>SCSI host</code>、<code>channel</code>、<code>target</code>和<code>LUN</code>号，以及可选的分区号。虽然这些名字比使用<code>major</code>和<code>minor</code>号或<code>sd</code>名字更容易，但必须使用谨慎以确保<code>target</code>号不改变在光纤通道<code>SAN</code>环境中(例如，通过使用持久绑定)，如果一个主机适配器切换到到一个不同的<code>PCI</code>插槽的话这个路径也会随之改变。此外，如果<code>HBA</code>无法探测，或者如果驱动程序以不同的顺序加载，或者系统上安装了新的<code>HBA</code>，那么<code>SCSI</code>主机号都有可能会发生变化。附带路径清单的一个例子是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/disk/by-path/pci-0000:03:00.0-scsi-0:1:0:0</span><br></pre></td></tr></table></figure><p>也许还会带着分区号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/disk/by-path/pci-0000:03:00.0-scsi-0:1:0:0-part1</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 上面说了很多种情况都会导致<code>by-path</code>的值可能发生变化，但是在同一时间来说，<code>by-path</code>的值是和物理设备是唯一对应的，也就是说不管怎么说<code>by-path</code>是对应物理机器上面的某个位置的，根据<code>by-path</code>可以获取对应物理位置的设备。（此前<code>megaraid</code>通过逻辑磁盘获取物理磁盘位置就是根据这个原理）</p><p>对于<code>iSCSI</code>设备，路径/名称映射从目标名称和门户信息映射到<code>sd</code>名称。<br>应用程序通常不适合使用这些基于路径的名称。这是因为这些路径引用可能会更改存储设备，从而可能导致将不正确的数据写入设备。基于路径的名称也不适用于多路径设备，因为基于路径的名称可能被误认为是单独的存储设备，导致不协调的访问和数据的意外修改。</p><p>此外，基于路径的名称是特定于系统的。当设备被多个系统访问时，例如在集群中，这会导致意外的数据更改。</p><h2 id="by-id"><a href="#by-id" class="headerlink" title="by-id"></a>by-id</h2><p>此目录中的条目提供一个符号名称，该符号名称通过唯一标识符(与所有其他存储设备不同)引用存储设备。标识符是设备的属性，但不存储在设备的内容(即数据)中。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dev/disk/by-id/scsi-3600508e000000000ce506dc50ab0ad05</span><br><span class="line">/dev/disk/by-id/wwn-0x600508e000000000ce506dc50ab0ad05</span><br></pre></td></tr></table></figure><p>该<code>id</code>从设备的全局<code>ID</code>（<code>WWID</code>）或设备序列号中获取。<code>/dev/disk/by-id</code>条目也可能包含一个分区号。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dev/disk/by-id/scsi-3600508e000000000ce506dc50ab0ad05-part1</span><br><span class="line">/dev/disk/by-id/wwn-0x600508e000000000ce506dc50ab0ad05-part1</span><br></pre></td></tr></table></figure><p><code>World Wide Identifier</code>（<code>WWID</code>）可用于可靠的识别设备。<code>SCSI</code>标准要求所有<code>SCSI</code>设备提供一个持久的、系统无关的<code>ID</code>。<code>WWID</code>标识符保证对每个存储设备都是唯一的，并且独立于用于访问设备的路径。</p><p>这个标识符可以通过发出<code>SCSI</code>查询来获取设备标识重要厂商数据(第<code>0x83</code>页)或单位序列号(第<code>0x80</code>页)。从这些<code>wwid</code>到当前<code>/dev/sd</code>名称的映射可以在<code>/dev/disk/by-id/</code>目录中维护的符号链接中看到。<br>例如，具有页<code>0x83</code>标识符的设备将具有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scsi-3600508b400105e210000900000490000 -&gt; ../../sda</span><br></pre></td></tr></table></figure><p>或者，具有页<code>0x80</code>标识符的设备将具有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scsi-SSEAGATE_ST373453LW_3HW1RHM6 -&gt; ../../sda</span><br></pre></td></tr></table></figure><p><code>Red Hat Enterprise Linux 5</code>自动维护从基于<code>wwid</code>的设备名称到系统上当前<code>/dev/sd</code>名称的正确映射。应用程序可以使用<code>/dev/ disk/by-id/</code>的链接引用磁盘上的数据，即使设备的路径改变，甚至当从不同系统访问该设备时都是如此。</p><p>但是当设备被插入到硬件控制器的端口时，而这个端口又受另一个子系统控制（即多路径），<code>by-id</code>的值也会改变。多路径设备会在下面详细讲解。</p><h2 id="by-partlabel-amp-amp-by-partuuid"><a href="#by-partlabel-amp-amp-by-partuuid" class="headerlink" title="by-partlabel &amp;&amp; by-partuuid"></a>by-partlabel &amp;&amp; by-partuuid</h2><p>这两个和上面提到的<code>by-label</code>和<code>by-uuid</code>类似，只不过是在<code>GPT</code>磁盘上。</p><h2 id="多路径设备"><a href="#多路径设备" class="headerlink" title="多路径设备"></a>多路径设备</h2><p>所谓多路径设备指的是从一个系统到一个设备存在多个路径，这种现象主要出现在光纤网络的<code>SAN</code>下，主要是做数据链路冗余以达到高可用的效果，<strong>即对应底层一个物理设备，可能存在多个路径表示它</strong>，具体参考<code>refer</code>下面有关文章。</p><p>如果从一个系统到一个设备有多个路径，那么<code>device-mapper-multipath</code>使用<code>WWID</code>来检测它。然后在<code>/dev/mapper/wwid</code>中显示一个“伪设备”，例如<code>/dev/ mapper/3600508b400105df70000000ac0000</code>。</p><p><code>Device-mapper-multipath</code>显示映射到非持久标识符：<code>Host:Channel:Target:LUN</code>， <code>/dev/sd</code>名称，以及<code>major:minor</code>号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3600508b400105df70000e00000ac0000 dm-2 vendor,product </span><br><span class="line">[size=20G][features=1 queue_if_no_path][hwhandler=0][rw] </span><br><span class="line">\_ round-robin 0 [prio=0][active] </span><br><span class="line"> \_ 5:0:1:1 sdc 8:32  [active][undef] </span><br><span class="line"> \_ 6:0:1:1 sdg 8:96  [active][undef]</span><br><span class="line">\_ round-robin 0 [prio=0][enabled] </span><br><span class="line"> \_ 5:0:0:1 sdb 8:16  [active][undef] </span><br><span class="line"> \_ 6:0:0:1 sdf 8:80  [active][undef]</span><br></pre></td></tr></table></figure><p><code>Device-mapper-multipath</code>在系统上自动维护每个基于<code>wwid</code>的设备名称和其对应的<code>/dev/sd</code>名称的正确映射。这些名称即使是在路径发生改变时也是持久的，并且当从不同的系统访问设备时它们仍然是一致的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了方便管理和使用设备，<code>linux</code>操作系统给我们提供了上面这么多持久化命名方式。它们各自有各自的优势和使用场景。<code>by-label</code>和<code>by-uuid</code>都和文件系统相关，<code>by-label</code>是通过读取设备中的内容获取，<code>by-uuid</code>则是随着每次文件系统的创建而创建，所以<code>by-uuid</code>的持久化程度更高一些；持久化程度最高的要属<code>by-path</code>和<code>by-id</code>了，因为它们都是根据物理设备的位置或者信息而和链接做对应的，<code>by-path</code>会因为路径的变化而变化；而<code>by-id</code>则不会因为路径或者系统的改变而改变，它只会在多路径的情况下发生改变。这两个在通过虚拟设备名称寻找物理设备的场景下都十分有用。</p><p>多路径设备则帮助我们在<code>SAN</code>等场景下提高了数据传输的可用性，目前由于网络带宽的发展，它在<code>iscsi</code>场景下也频繁亮相。</p><h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ul><li><a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_%28简体中文%29" target="_blank" rel="noopener">Persistent block device naming</a></li><li><a href="http://fibrevillage.com/storage/578-understanding-device-names-managed-by-the-udev-mechanism" target="_blank" rel="noopener">Understanding Device Names Managed by the udev mechanism</a></li><li><a href="https://wiki.archlinux.org/index.php/Udev_%28简体中文%29#.E8.AE.BE.E7.BD.AE.E9.9D.99.E6.80.81.E8.AE.BE.E5.A4.87.E5.90.8D" target="_blank" rel="noopener">Udev</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/online_storage_reconfiguration_guide/persistent_naming" target="_blank" rel="noopener">PERSISTENT NAMING</a></li><li><a href="https://www.linuxquestions.org/questions/linux-server-73/how-to-find-wwn-for-dev-sdc-917269/" target="_blank" rel="noopener">How to find WWN for /dev/sdc</a></li><li><a href="https://unix.stackexchange.com/questions/86764/understanding-dev-disk-by-folders" target="_blank" rel="noopener">understanding /dev/disk/by- folders</a></li><li><a href="https://blog.csdn.net/jiaping0424/article/details/51591257" target="_blank" rel="noopener">multipath 路径切换</a></li><li><a href="http://www.cnblogs.com/jyzhao/p/7200585.html" target="_blank" rel="noopener">multipath多路径实验01-构建iSCSI模拟环境</a></li><li><a href="http://www.cnblogs.com/jyzhao/p/7208620.html" target="_blank" rel="noopener">multipath多路径实验02-配置多路径软件</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-devmapper/index.html" target="_blank" rel="noopener">Linux 内核中的 Device Mapper 机制</a></li><li><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/6/html/dm_multipath/mpio_description" target="_blank" rel="noopener">DM-MULTIPATH 概述</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/fork-in-the-road.png&quot; alt=&quot;persistent name&quot;&gt;&lt;/center&gt;

&lt;p&gt;众所周知，我们看到的磁盘通常是&lt;code&gt;/dev/sda&lt;/code&gt;，&lt;code&gt;/dev/sdb&lt;/code&gt;这样的名称，我们可以通过这些磁盘名称对磁盘进行各种操作，例如挂载，分区和格式化等等。但是，如果你的机器上有不止一个&lt;code&gt;SATA&lt;/code&gt;，&lt;code&gt;SCSI&lt;/code&gt;或&lt;code&gt;IDE&lt;/code&gt;磁盘控制器，那么它们所对应的设备节点将会依随机次序添加。这样就可能导致每次引导时设备的名字如&lt;code&gt;/dev/sda&lt;/code&gt;与&lt;code&gt;/dev/sdb&lt;/code&gt;互换了，再比如硬盘拔插导致磁盘乱序等等，最终导致系统不可引导、&lt;code&gt;kernel panic&lt;/code&gt;、或者设备不可见。持久化命名可以解决这些问题。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Disk" scheme="https://tony-yin.github.io/tags/Disk/"/>
    
  </entry>
  
  <entry>
    <title>Python Snack 最佳实践</title>
    <link href="https://tony-yin.github.io/2018/06/03/Python-Snack-Best-Practice/"/>
    <id>https://tony-yin.github.io/2018/06/03/Python-Snack-Best-Practice/</id>
    <published>2018-06-03T05:07:06.000Z</published>
    <updated>2018-12-13T16:40:24.453Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/python_snack.jpg" alt="python snack"></center><p>  了解<code>linux</code>的人应该听说过<code>Newt</code>，<code>Newt</code>是一个为<code>RedHat</code>安装程序而设计的基于文本的窗口开发工具，它是由<code>c</code>语言编写并不依赖<code>X</code>包，<code>linux</code>下的<code>dialog</code>和<code>whiptail</code>都是基于它。而我们今天讨论的<code>snack</code>则是<code>Newt</code>提供的<code>python</code>接口，<code>redhat</code>的系统都自带这个模块，本文就如何使用<code>snack</code>制作伪终端页面展开讲解，并配合代码展示实现效果。</p><a id="more"></a><h2 id="用餐介绍"><a href="#用餐介绍" class="headerlink" title="用餐介绍"></a>用餐介绍</h2><p>为啥说是最佳实践呢？因为我使用<code>snack</code>的过程中，上网查阅相关资料，发现有关信息甚少。偶尔几篇文章都是处于<code>API</code>或者<code>Demo</code>的级别，并且讲的都不全，更别说高级扩展功能了。我正好工作需要给我们的一个系统做一个终端部署控制台<code>UI</code>，所以我就使用了<code>python snack</code>来实现，期间不断新需求，不断迭代，从基本页面到增删改查，再到校验、再到配置导入、再到进度条等等，不断的迭代开发让我对<code>snack</code>不断地加深认知，它支持的或不支持的我都想办法一一解决，所以在这把我这段时间的收货进行总结并分享给需要的人。</p><h2 id="上菜单"><a href="#上菜单" class="headerlink" title="上菜单"></a>上菜单</h2><p>本文实践的需求是做一个部署控制台工具，该工具主要分为三个阶段：基础配置、高级配置和部署进度。基础配置页面需要我们创建一些主机，填写一些主机的信息，比如<code>IP</code>、<code>Hostname</code>和<code>Password</code>，然后高级配置我们也需要创建一些主机，不过我们可以复用基础设置的主机，所以我们的工具要支持在高级配置中导入基础配置的功能，在高级配置中我们还有一个全局配置，也就是不限于单个主机的配置（其中具体部署原理和是非，我就不多展开赘述，这不是本文的重点）。最后就是进度条页面，我们可以展示部署的过程阶段和相关时间信息。</p><center><img src="http://cdn.tony-yin.site/deploy_console.gif" alt="deploy console"></center><blockquote><p>项目地址：<a href="https://github.com/tony-yin/Best-practice-of-python-snack" target="_blank" rel="noopener">https://github.com/tony-yin/Best-practice-of-python-snack</a></p></blockquote><h2 id="开胃凉菜"><a href="#开胃凉菜" class="headerlink" title="开胃凉菜"></a>开胃凉菜</h2><h3 id="远古时代"><a href="#远古时代" class="headerlink" title="远古时代"></a>远古时代</h3><p>先上几道凉菜，给大家开开胃。所谓的凉菜就是介绍一下<code>python snack</code>的基础组件，基础组件很多，类似<code>html</code>，主要有：</p><ul><li>Textbox</li><li>TextboxReflowed</li><li>Button</li><li>Compactbutton</li><li>Checkbox</li><li>Listbox</li><li>SingleRadioButton</li><li>Scale</li><li>Entry</li></ul><p>然后就是一些组合组件，也就是基于上述基础组件封装而得到，主要有：</p><ul><li>RadioBar</li><li>ButtonBar</li><li>CheckboxTree</li></ul><p>上面这些组件就是所有的基础组件（组合组件也算基础组件），这些组件最终呈现还需要<code>grid</code>和<code>form</code>这两个组件，<code>grid</code>表示“网格”的意思，跟<code>html</code>中的<code>table</code>类似，由行和列组成，我们的基础组件需要放在网格中来实现页面布局；而<code>form</code>也类似“表单”，我们需要把<code>grid</code>填充到<code>form</code>中，运行后，就可以看到图形化页面了。</p><h3 id="工业革命"><a href="#工业革命" class="headerlink" title="工业革命"></a>工业革命</h3><p>经过上面基础组件的介绍，想必你对<code>snack</code>的组件有了充分的了解，这时候你可以参考文末的<code>refer</code>做几个小<code>demo</code>，做了之后你会发现页面是出来了，emmm… 可是感觉好繁琐哦，很多重复性的代码，而且页面布局也怪怪的，如果要把布局搞好，又需要加很多代码。</p><p>我们把用基础组件的阶段称之为“远古时代”，每做一个<code>window</code>，都得一瓦一砖地慢慢堆砌，这样效率太低了，所以我们急需一波“工业革命”来提高生产力。</p><p><code>python snack</code>似乎考虑到了这个问题，它在上述基础组件之外还提供了<code>dialog</code>相关组件，<code>dialog</code>组件即集大成者，一个<code>dialog</code>组件就是一个<code>window</code>，也就是我们上面所说的<code>form</code>，并且该<code>form</code>中填充了必需的各种基础组件，<code>dialog</code>组件主要有：</p><ul><li>ListboxChoiceWindow</li><li>ButtonChoiceWindow</li><li>EntryWindow</li></ul><h3 id="返璞归真"><a href="#返璞归真" class="headerlink" title="返璞归真"></a>返璞归真</h3><p>当今社会，大家吃惯了大鱼大肉，反而更是想念农村的野味。同理，我们用惯了“工业革命”的产物，发现虽然可用，但是仅仅停留在基础可用级别上，想换换样式，加加自己的定制化需求，都是有限的，完全达不到新需求的技术实现要求。所以，我们不能只知道用别人实现的现成的产物，我们可以尝试着“返璞归真”一下，回归最初的“远古时代”，自己实现一把“工业革命”。所谓的“dialog”组件无非也就是基础组件的封装而已，我们也可以自己实现一套自己的组件库，这个在前端是非常流行的，例如<code>font-awesome</code>、<code>iview</code>、<code>ant-design</code>等等。这里我们自己实现了以下<code>dialog</code>：</p><ul><li>ExtButtonChoiceWindow</li><li>ExtAlert</li><li>ExtCheckboxWindow</li><li>ExtListboxChoiceWindow</li><li>ExtEntryWindow</li><li>ExtPwdEntryWindow</li><li>ExtProgressWindow</li><li>ExtTextWindow</li></ul><p>扩展的功能主要有：</p><ul><li>热键支持扩展</li><li>按钮样式扩展</li><li>布局大小自动化扩展</li><li>暗文输入框扩展</li><li>弹出窗口扩展</li><li>进度条窗口信息展示扩展</li><li>动态展示扩展</li></ul><blockquote><p>扩展组件库地址：<a href="https://github.com/tony-yin/Best-practice-of-python-snack/blob/master/widget_extlib.py" target="_blank" rel="noopener">widget extend library</a></p></blockquote><h2 id="管饱正菜"><a href="#管饱正菜" class="headerlink" title="管饱正菜"></a>管饱正菜</h2><p>凉菜不够，正菜来凑。上面就是把<code>python snack</code>的<code>API</code>罗列了一下，做个小<code>Demo</code>还行，但是距离产品化还很远，接下来我结合我做部署控制台工具的实践经历分享一下几个“正菜”，必须够硬，不接受反驳，不接受批评， O(∩_∩)O ~</p><h3 id="热键"><a href="#热键" class="headerlink" title="热键"></a>热键</h3><p><code>python snack</code>提供了两种帮助用户使用的途径，一种是窗口下方的操作提示栏，另一个就是热键了。热键就是快捷键，比如我们可以敲击键盘上面的<code>ESC</code>键实现页面的返回。我们可以通过调用<code>grid</code>的<code>runOnce</code>接口获取热键的输入，例如<code>hotkey = g.runOnce()</code>，然后我们根据<code>hotkey</code>的值进行判断并执行对应的操作。</p><h3 id="页面切换"><a href="#页面切换" class="headerlink" title="页面切换"></a>页面切换</h3><p>当我们存在多个页面的时候，我们需要页面切换的功能，翻阅文档，并没有发现提供类似的功能。在我们的工具中，页面切换主要有两种方式，一种是点击<code>button</code>，一种是热键，既然没有原生的页面切换接口，我们就根据触发方式手动切换页面。比如我们想实现页面<code>1</code>点击<code>next</code>按钮想跳转页面<code>2</code>，那我们只需要获取<code>button</code>的返回值，判断是否为<code>next</code>，如果是<code>next</code>，直接调用页面<code>2</code>的方法即可，热键同理，即判断热键内容是否为对应热键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ret, button, lb = ExtListboxChoiceWindow(</span><br><span class="line">    screen, </span><br><span class="line">    &apos;Distribute Storage Config&apos;,</span><br><span class="line">    &apos;Distribute Storage Config&apos;,</span><br><span class="line">    ips,</span><br><span class="line">    buttons=(&quot;prev&quot;, &quot;next&quot;, &quot;exit&quot;),</span><br><span class="line">    width=50,</span><br><span class="line">    height=5,</span><br><span class="line">)                                                                                                                                        </span><br><span class="line">if button == &quot;exit&quot; or ret == &quot;ESC&quot;:</span><br><span class="line">    screen.finish()</span><br><span class="line">elif button == &quot;prev&quot;:</span><br><span class="line">    Welcome_Deploy_Window()</span><br><span class="line">elif button == &quot;next&quot;:</span><br><span class="line">    Additional_Config_Window()</span><br><span class="line">elif lb is not None:</span><br><span class="line">    Basic_Host_Window(lb)</span><br></pre></td></tr></table></figure><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><p>增删改查永远是一个软件系统绕不开的基础功能。</p><p><strong>“查”：</strong></p><p>首先是整体查看，我们可以通过一个列表展示所有信息，这时候我们可以用<code>ExtListboxChoiceWindow</code>组件来实现；然后就是单个查看了，我们可能有多条信息，我们想查看单个信息的详细内容时，我们可以通过点击具体的<code>item</code>进入详细信息的<code>dialog</code>，如何实现呢？<code>listbox</code>中有一个<code>current</code>的概念，也就是<code>listbox</code>中每个<code>li</code>的唯一标识，我们可以用列表的<code>index</code>来填充，因为往往列表页面的信息也无非是数组或者是列表的方式，我们获取到当前的<code>current</code>，即获取到数组的索引，然后就是根据索引查值了，我们再调用新增页面，将查到的值赋值到<code>Textbox</code>即可，<code>Textbox</code>有一个<code>setText</code>就是做这个事情的。当然我们的<code>ExtEntryWindow</code>组件也可以做到赋值填充。请参考上述代码中的<code>lb</code>，其实就是<code>listbox</code>的<code>li.current()</code>接口。</p><p><strong>“增”：</strong></p><p>我们可以通过一个新增按钮或者<code>listbox</code>中的一个<code>li</code>作为新增按钮来触发新增操作，点击后出现一个<code>dialog</code>，<code>dialog</code>中有一些<code>Textbox</code>、<code>Radio</code>、<code>Checkbox</code>等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def Basic_Host_Window(current, data=None):</span><br><span class="line">    buttons = [ &apos;save&apos;, &apos;cancel&apos;, &apos;exit&apos;]</span><br><span class="line">    if not data:</span><br><span class="line">        data = [&apos;IP Address:&apos;, &apos;Hostname:&apos;, &apos;Password:&apos;]</span><br><span class="line">        if current != &apos;add&apos;:</span><br><span class="line">            data = get_format_data(Basic_Config[current], BASIC_TYPE)</span><br><span class="line">            buttons.insert(1, &apos;Delete&apos;)</span><br><span class="line"></span><br><span class="line">    host = ExtEntryWindow(</span><br><span class="line">        screen,</span><br><span class="line">        &apos;&#123;&#125; host&apos;.format(&apos;Add&apos; if current == &apos;add&apos; else &apos;Edit&apos;),</span><br><span class="line">        &apos;Please fill storage host info.&apos;,</span><br><span class="line">        data,</span><br><span class="line">        width = 40, </span><br><span class="line">        entryWidth = 40, </span><br><span class="line">        buttons = buttons</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p><strong>“改”：</strong></p><p>修改操作的方法是在<code>list</code>页面选中需要修改的项，然后进入详情页面，可以查看之前创建时填写的信息，也就是我们在“查”中查看单个信息提到的方式，我们所要做的就是在用户点击<code>save</code>按钮的时候，获取用户编辑后的数据，再进行一次修改即可，在我们工具中，此操作就是根据索引修改数组中对应索引的数据而已。</p><p><strong>“删”：</strong></p><p>有增就有删，这边我暂时还没实现批量删除的功能，一方面<code>python snack</code>的支持功能有限，一方面时间有限，所以我只实现了单个删除的功能，在新增和编辑的页面添加一个<code>delete</code>按钮即可，为了提醒用户错删，我们还要加上一个确认提示框。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if host[1] == &quot;delete&quot;:</span><br><span class="line">    button = ExtButtonChoiceWindow(</span><br><span class="line">        screen,</span><br><span class="line">        &apos;Delete host&apos;,</span><br><span class="line">        &apos;Are you sure to delete current host?&apos;</span><br><span class="line">    )</span><br><span class="line">    if button == &quot;ok&quot;:</span><br><span class="line">        del(Basic_Config[current])</span><br><span class="line">    else:</span><br><span class="line">        Basic_Host_Window(current)</span><br></pre></td></tr></table></figure><h3 id="组件扩展"><a href="#组件扩展" class="headerlink" title="组件扩展"></a>组件扩展</h3><p>构建自己的组件库真的很有必要，对于默认的<code>button</code>样式，我真是吐槽到不想再吐槽，它居然还认为自己的<code>border</code>很<code>nice</code>？！所以最终构建自己的组件库的初衷就是想把各个<code>dialog</code>中的<code>button</code>改为<code>compactbutton</code>，没办法，默认的<code>dialog</code>组件不给改呀，所以我们得自己返璞归真一下。</p><p>当然我们做扩展组件库，也不是仅仅因为一个<code>button</code>样式，还有很多新需求都要依赖自己扩展的组件。比如热键，原生<code>dialog</code>无法支持热键；还有进度条的进度时间和任务信息展示；还有<code>Gridform</code>的动态布局等等。具体就不一一介绍了，想深入了解的直接看代码，做个小<code>Demo</code>，一目了然。</p><h2 id="爽口甜菜"><a href="#爽口甜菜" class="headerlink" title="爽口甜菜"></a>爽口甜菜</h2><p>充实的正菜吃饱了，是时候来一波甜菜漱漱口，解解渴了。</p><p>在做进度条页面的时候，想除了显示进度任务完成信息之外，还想显示一下开始时间和花费时间。发现<code>python</code>的<code>time</code>模块比较坑爹，对于时间差的转换支持不行，查阅资料只发现<code>datetime</code>可以将时间差转换为微秒、秒和小时三个单位，但是我想实现时间差的自动转换，也就是<code>60s</code>自动转换为<code>1min</code>，<code>60min</code>转为<code>1h</code>，<code>24h</code>转为<code>1d</code>，超越天为单位的我就不进行转换了，逻辑不难，只是拿出来分享给有需要的人，不必重复造轮子罢了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def get_time_interval(start_time):</span><br><span class="line">    start_time = datetime.fromtimestamp(start_time)</span><br><span class="line">    now_time = datetime.fromtimestamp(time.time())</span><br><span class="line">    interval = (now_time - start_time).seconds</span><br><span class="line">    format_interval = get_format_interval(interval)                                                                                          </span><br><span class="line">    return format_interval</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_format_interval(interval):</span><br><span class="line">    if interval &lt; 60:</span><br><span class="line">        format_interval = &quot;&#123;&#125;s&quot;.format(str(interval))</span><br><span class="line">    elif 60 &lt;= interval &lt; 60*60:</span><br><span class="line">        format_interval = &quot;&#123;&#125;min &#123;&#125;s&quot;.format(</span><br><span class="line">            str(interval/60), str(interval%60))</span><br><span class="line">    elif 60*60 &lt;= interval &lt; 60*60*24:</span><br><span class="line">        format_interval = &quot;&#123;&#125;h &#123;&#125;min &#123;&#125;s&quot;.format(</span><br><span class="line">            str(interval/(60*60)),</span><br><span class="line">            str(interval%(60*60)/60),</span><br><span class="line">            str(interval%(60*60)%60)</span><br><span class="line">        )</span><br><span class="line">    elif 60*60*24 &lt;= interval:</span><br><span class="line">        format_interval = &quot;&#123;&#125;d &#123;&#125;h &#123;&#125;min &#123;&#125;s&quot;.format( </span><br><span class="line">str(interval/(60*60*24)),</span><br><span class="line">            str(interval%(60*60*24)/60*60),</span><br><span class="line">            str(interval%(60*60)/60),</span><br><span class="line">            str(interval%(60*60)%60)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    return format_interval</span><br></pre></td></tr></table></figure><h2 id="用餐总结"><a href="#用餐总结" class="headerlink" title="用餐总结"></a>用餐总结</h2><p>原本只是想做一个终端图形化的进度条页面，但是后续需求越来越多，导致做成了一个部署控制台工具，整个工程开发和优化花了大约两个星期的时间，项目中遇到的很多难点和问题很多都与<code>python snack</code>无关，所以没有做详细解释，就比如上述的甜菜，大家有兴趣的自行翻阅代码即可。</p><p><code>python snack</code>还有很多未知的我没有使用，比如<code>checkbox tree</code>等，但我相信万变不离其宗，有了这次实践，其他组件的使用和扩展应该不会花很多时间，其实做这个东西，我最深的感触就是前端发展的迅速，<code>python snack</code>是<code>2000</code>年初的产物了，很多页面逻辑跟<code>jQuery</code>比起来要弱的多，更别说现在的<code>angular</code>，<code>vue</code>等等了，但是领域不同，毕竟是伪终端页面，能做成这样已经不错了。如果是真正的桌面图形化界面（<code>GUI</code>），有<code>pyqt</code>这种神器，功能貌似很强大。</p><p>我在之前的一个项目中，就使用过<code>python snack</code>做的控制台，当然当时不知道是用这个技术做的，当时觉得蛮牛的，尝试过修改终端文字成汉子，后来没有成功，便不了了之。这次机缘巧合，工作需要做这么一个控制台，在工作中学习和使用自己感兴趣的技术的感觉真是爽呀。工作中运用技术和自己业余时间学习新技术并做个小<code>Demo</code>完全是不一样的，工作中运用会不断有新需求，不断精益求精，不断深入。所以以工作作为平台，实现自己的技术价值，会有很大的成就感，与大家共勉咯。(#^.^#)</p><blockquote><p>完整项目代码地址：<a href="https://github.com/tony-yin/Best-practice-of-python-snack" target="_blank" rel="noopener">https://github.com/tony-yin/Best-practice-of-python-snack</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/python_snack.jpg&quot; alt=&quot;python snack&quot;&gt;&lt;/center&gt;

&lt;p&gt;  了解&lt;code&gt;linux&lt;/code&gt;的人应该听说过&lt;code&gt;Newt&lt;/code&gt;，&lt;code&gt;Newt&lt;/code&gt;是一个为&lt;code&gt;RedHat&lt;/code&gt;安装程序而设计的基于文本的窗口开发工具，它是由&lt;code&gt;c&lt;/code&gt;语言编写并不依赖&lt;code&gt;X&lt;/code&gt;包，&lt;code&gt;linux&lt;/code&gt;下的&lt;code&gt;dialog&lt;/code&gt;和&lt;code&gt;whiptail&lt;/code&gt;都是基于它。而我们今天讨论的&lt;code&gt;snack&lt;/code&gt;则是&lt;code&gt;Newt&lt;/code&gt;提供的&lt;code&gt;python&lt;/code&gt;接口，&lt;code&gt;redhat&lt;/code&gt;的系统都自带这个模块，本文就如何使用&lt;code&gt;snack&lt;/code&gt;制作伪终端页面展开讲解，并配合代码展示实现效果。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
      <category term="Python" scheme="https://tony-yin.github.io/tags/Python/"/>
    
      <category term="Snack" scheme="https://tony-yin.github.io/tags/Snack/"/>
    
      <category term="Console" scheme="https://tony-yin.github.io/tags/Console/"/>
    
  </entry>
  
  <entry>
    <title>Daily Article Vol6(2018/5/1 ~ 2018/5/31)</title>
    <link href="https://tony-yin.github.io/2018/06/01/Daily-Article-Vol6/"/>
    <id>https://tony-yin.github.io/2018/06/01/Daily-Article-Vol6/</id>
    <published>2018-06-01T05:07:06.000Z</published>
    <updated>2018-12-13T16:40:24.423Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/5-2.png" alt="May"></center><p>五月份主要基于<code>python sna</code>实现了一个终端伪图形化界面的部署控制台，提供了填写配置信息、校验信息、导入信息和进度监控等功能，详情请见<a href="http://www.tony-yin.site/2018/06/03/Python-Snack-Best-Practice/" target="_blank" rel="noopener">【Python Snack 最佳实践】</a>。这是我之前一直感兴趣想做的事情，这次正好借助工作的契机对其有了深入的了解和学习，收获颇多。五月份假期多，团建，还有工作进度赶，导致自己的阅读时间受到了影响，大多数阅读都是围绕着工作内容，极客时间这些<code>APP</code>、技术博客和微信公众号的很多技术资源，自己都没有规律地学习。这些都不是借口啦，主要还是陷入吃鸡，不能自拔，哈哈哈。（已经卸了，我这个人容易上瘾然而又有点嫌麻烦，这对我来说是最简单有效的方式）</p><a id="more"></a><p>加入公司两个多月了，工作内容不断增多，难度也不断加大，由起初的合作工作到现在的独立负责某个<code>task</code>，也渐渐地忙了起来，总体来说还是游刃有余，能把自己的工作量<code>cover</code>住，希望自己继续加油。不过，这段时间大多数工作内容跟<code>ceph</code>关系不大，比如<code>ctdb rados</code>、<code>megaraid location</code>、<code>deploy console</code>等，毕竟是做产品，工作内容还是依赖产品需求，不过我还是不希望以后工作内容长期游离于<code>ceph</code>之外，因为今天的期望就是深入<code>ceph</code>，深入存储，如果工作上满足不了我的话，自己课余时间要挤一点时间做做研究了。不过好在现在项目上除了<code>ceph</code>也有很多东西是目前的我所不懂的，有学习的机会也不错，只要每天都能学习到不熟悉的东西便是极好的。除了存储，我们组也在往大数据和检索的方向靠，这两个我也都蛮感兴趣的，最近也稍微了解了下<code>elaticsearch</code>，目前好像很火的样子，六月底南京有一个<code>ES</code>线下沙龙，已经报名参加了，吼吼。</p><p>加油咯 ~</p><ol><li><a href="http://www.voidcn.com/article/p-yvycalqd-brm.html" target="_blank" rel="noopener">Django实现CAS+OAuth2</a>(5/5) <i class="fa fa-star"></i></li><li><a href="https://weibo.com/p/1001603934517592239583?mod=zwenzhang#_loginLayer_1525517479194" target="_blank" rel="noopener">NVMe over Fabric</a>(5/6) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://www.wzxue.com/ceph-librbd-block-library/" target="_blank" rel="noopener">解析Ceph: Librbd–块存储库</a>(5/7)</li><li><a href="https://draveness.me/docker" target="_blank" rel="noopener">Docker 核心技术与实现原理</a>(4)(5/11 ~ 5/13) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://blog.csdn.net/feng88724/article/details/7262514" target="_blank" rel="noopener">【Django】@login_required用法简介</a>(5/14)</li><li><a href="http://www.nowamagic.net/academy/detail/1318909" target="_blank" rel="noopener">request.META里包含了哪些数据？</a>(5/15)</li><li><a href="https://blog.csdn.net/naipeng/article/details/77162764" target="_blank" rel="noopener">CTDB代码流程简要梳理</a>(5/16) <i class="fa fa-star"></i></li><li><a href="https://blog.csdn.net/liuying_1001/article/details/77994642" target="_blank" rel="noopener">ctdb原理介绍</a>(5/17~5/18) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://opstrip.com/2017/06/14/howto-monitor-raidCard-status-with-commandline-MegaCli/" target="_blank" rel="noopener">MegaCli:如何使用命令行监控RAID卡状态</a>(5/18)</li><li><a href="http://www.cnblogs.com/lustralisk/p/pythonProgressBar.html" target="_blank" rel="noopener">Python实现控制台中的进度条</a>(5/21)</li><li><a href="https://coolshell.cn/articles/677.html" target="_blank" rel="noopener">用PYTHON写NCURSES UI</a>(5/22)</li><li><a href="https://blog.csdn.net/naipeng/article/details/77162764" target="_blank" rel="noopener">NEWT 程序设计指南</a>(5/23)</li><li><a href="http://www.wanware.com/tsgdocs/snack.html" target="_blank" rel="noopener">Quick Guide to Python’s Snack Module</a>(5/23)</li><li><a href="http://www.cnblogs.com/Xjng/p/3869869.html" target="_blank" rel="noopener">python在linux制作图形界面（snack）</a>(5/23)</li><li><a href="https://blog.csdn.net/taiyang1987912/article/details/49273601" target="_blank" rel="noopener">python在linux(anaconda)的图形界面（snack）</a>(5/24)</li><li><a href="https://npyscreen.readthedocs.io/introduction.html#example-code" target="_blank" rel="noopener">An introduction to npyscreen</a>(5/24)</li><li><a href="https://helloacm.com/creating-ui-controls-under-linux-shell-console-using-whiptail-utility/" target="_blank" rel="noopener">Creating UI Controls under Linux Shell Console using whiptail Utility</a>(5/25)</li><li><a href="https://www.linuxjournal.com/article/2807" target="_blank" rel="noopener">Dialog: An Introductory Tutorial</a>(5/25)</li><li><a href="https://askubuntu.com/questions/747143/create-a-progress-bar-in-bash" target="_blank" rel="noopener">Create a progress bar in bash</a>(5/25)</li><li><a href="https://www.tecmint.com/monitor-copy-backup-tar-progress-in-linux-using-pv-command/" target="_blank" rel="noopener">How to Monitor Progress of (Copy/Backup/Compress) Data using ‘pv’ Command</a>(5/25)</li><li><a href="http://blog.ihipop.info/2010/10/1736.html" target="_blank" rel="noopener">Python中如何写控制台进度条的整理</a>(5/26) <i class="fa fa-star"></i></li><li><a href="https://www.ibm.com/developerworks/cn/linux/sdk/python/python-6/index.html" target="_blank" rel="noopener">可爱的 Python：Curses 编程</a>(5/26)</li><li><a href="http://wklken.me/posts/2012/02/19/python-ini-configparser.html" target="_blank" rel="noopener">PYTHON读取修改INI配置文件[CONFIGPARSER]</a>(5/31)</li><li><a href="https://www.jianshu.com/p/4202a2051668" target="_blank" rel="noopener">Python 解析配置模块之ConfigParser详解</a>(5/31) <i class="fa fa-star"></i></li><li><a href="http://www.cnblogs.com/huey/p/4334152.html" target="_blank" rel="noopener">Python(2.7.6) ConfigParser - 读写配置文件</a>(5/31)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/5-2.png&quot; alt=&quot;May&quot;&gt;&lt;/center&gt;

&lt;p&gt;五月份主要基于&lt;code&gt;python sna&lt;/code&gt;实现了一个终端伪图形化界面的部署控制台，提供了填写配置信息、校验信息、导入信息和进度监控等功能，详情请见&lt;a href=&quot;http://www.tony-yin.site/2018/06/03/Python-Snack-Best-Practice/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【Python Snack 最佳实践】&lt;/a&gt;。这是我之前一直感兴趣想做的事情，这次正好借助工作的契机对其有了深入的了解和学习，收获颇多。五月份假期多，团建，还有工作进度赶，导致自己的阅读时间受到了影响，大多数阅读都是围绕着工作内容，极客时间这些&lt;code&gt;APP&lt;/code&gt;、技术博客和微信公众号的很多技术资源，自己都没有规律地学习。这些都不是借口啦，主要还是陷入吃鸡，不能自拔，哈哈哈。（已经卸了，我这个人容易上瘾然而又有点嫌麻烦，这对我来说是最简单有效的方式）&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
      <category term="Daily-Article" scheme="https://tony-yin.github.io/tags/Daily-Article/"/>
    
  </entry>
  
  <entry>
    <title>Ctdb Rados（二）：多场景断网高可用</title>
    <link href="https://tony-yin.github.io/2018/05/20/Ctdb-Rados-2/"/>
    <id>https://tony-yin.github.io/2018/05/20/Ctdb-Rados-2/</id>
    <published>2018-05-20T05:07:06.000Z</published>
    <updated>2018-12-13T16:40:24.415Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/ping-600x450.png" alt="ping"></center><p>之前写过一篇文章【<a href="http://www.tony-yin.site/2018/04/20/Ctdb-Rados-All-Banned/" target="_blank" rel="noopener">Ctdb Rados方式导致All Banned的问题</a>】，谈到了当<code>ctdb</code>将<code>recovery lock</code>设置成<code>rados</code>的方式后，断网<code>master</code>节点会造成所有<code>ctdb</code>节点<code>All Banned</code>，主要原因是<code>master</code>意外断网没有释放锁，其他节点无法获取到锁，当时的解决方案是每<code>5</code>分钟检查一次<code>ctdb</code>状态，如果连续两次发生了<code>All Banned</code>的情况，则手动删除<code>lock</code>，这种做法在最近的测试中遇到了一些问题，本文对这些问题进行剖析并对相应的解决方案进行分享。</p><a id="more"></a><blockquote><p>完整代码地址：<a href="https://github.com/tony-yin/Ctdb-Rados-Monitor" target="_blank" rel="noopener">https://github.com/tony-yin/Ctdb-Rados-Monitor</a></p></blockquote><h2 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h2><p>如果基于原来的做法，<code>ctdb</code>发生<code>All Banned</code>的情况，需要十分钟的监控时间加上两分钟左右的<code>recovery</code>时间，也就是说大概需要十二分钟才能恢复<code>ctdb</code>服务，这样看来高可用有点名实其副了，这个也会明显地影响存储业务的正常运行。后来，我们讨论出新的方案：每<code>5s</code>检查一次<code>ctdb</code>的状态，<code>All Banned</code>的次数累计到<code>5</code>次才确定为该故障场景，然后手动删除<code>lock</code>，最终要保证<code>ctdb</code>能够在<code>2min</code>内完成恢复。</p><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p><code>cron tab</code>最短周期只支持分钟级别，所以如何<code>5s</code>检查一次便是一个问题。</p><p>代码是死的，人是活的，虽然<code>cron tab</code>只支持分钟级别，但是我们可以每分钟调用一个脚本，然后在这个脚本中遍历<code>12</code>次，每次调用<code>ctdb monitor</code>脚本，然后<code>sleep 5s</code>，这样就可以达到每<code>5s</code>检查一次<code>ctdb</code>的效果了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ctdb_monitor</span></span><br><span class="line">* * * * * root /etc/ctdb/cron-seconds</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cron-seconds</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for((i=1;i&lt;=12;i++));do</span><br><span class="line">    ../monitor_ctdb</span><br><span class="line">sleep 5</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>这样检查到<code>ctdb</code>发生<code>All Banned</code>情况，只需要花费<code>25s</code>，剩下的就是<code>recovery</code>的时间了。</p><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p>当<code>ctdb master</code>节点的<code>network</code>服务断掉，其他两个节点（我的开发环境是三节点的虚拟机环境）便会选举一个为<code>master</code>节点，然后去获取<code>lock</code>，因为原<code>master</code>没有释放锁，导致所有节点<code>All Banned</code>，即使我们手动删除了锁，但是这时候其他两个节点仍然处于<code>Banned</code>的情况，需要等到<code>Ban Timeout</code>才会再次尝试获取锁并开始恢复过程，这个<code>timeout</code>的时间是<code>300s</code>，即<code>5min</code>，这显然是我们不能接受的，所以我们要在删除<code>lock</code>后，重启所有节点的<code>ctdb</code>服务。</p><p>不过该如何触发该重启操作呢？</p><p>我们在删除<code>lock</code>后将<code>ctdb</code>所有节点的<code>ip</code>作为对象存进<code>rados</code>中，然后在每<code>5s</code>监控的脚本中，查看<code>rados</code>中是否存在本节点的<code>ip</code>对象，如果有，则尝试重启<code>ctdb</code>操作，重启后便删除该对象。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function save_nodes_ip() &#123;</span><br><span class="line">    nodes=$(ctdb listnodes)</span><br><span class="line">    for node in $nodes; do</span><br><span class="line">        echo "$node" &gt; $node</span><br><span class="line">        rados -p rbd put $node $node</span><br><span class="line">        rm -f $node</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function get_current_node_ips() &#123;</span><br><span class="line">    ips=$(/usr/sbin/ip addr | grep "inet " | awk '&#123;print $2&#125;')</span><br><span class="line">    echo $ips</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function monitor_nodes_ip_in_rados() &#123;</span><br><span class="line">    ips=$(get_current_node_ips)</span><br><span class="line">    for ipinfo in $ips; do</span><br><span class="line">        ip=$&#123;ipinfo%/*&#125;</span><br><span class="line">        if $(timeout 10 rados -p rbd ls | grep "$ip" -qw); then</span><br><span class="line">            systemctl restart ctdb</span><br><span class="line">            rados -p rbd rm $ip</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么三个节点的<code>ip</code>都要存入<code>rados</code>，这个是因为原<code>master</code>节点恢复网络后，<code>ctdb</code>服务的状态为<code>failed</code>，同样需要重启<code>ctdb</code>服务才能正常恢复原<code>master</code>节点。 </p><p><strong>注意：</strong></p><p>这边有两个问题，当时浪费了我不少时间，问题不是多么深奥，但是不易发现。。。</p><p>第一个问题便是<code>ips=$(/usr/sbin/ip addr | grep &quot;inet &quot; | awk &#39;{print $2}&#39;)</code>这行代码，原来的写法是<code>ips=$(ip addr | grep &quot;inet &quot; | awk &#39;{print $2}&#39;)</code>，当时发现<code>ip</code>总是获取不到，然后无论是命令行还是脚本运行都可以正常获取到，后来还是同事提醒才发现在<code>crontab</code>脚本中，<code>shell</code>命令默认是<code>/usr/bin/</code>下的，而<code>ip</code>命令则是<code>/usr/sbin/</code>下，所以这里的命令我们需要全路径。（这个需要格外注意！！！被坑的不要不要的。。。）</p><p>第二个问题便是<code>rados -p rbd ls | grep &quot;$ip&quot; -qw</code>这行代码，当时没注意写成了<code>rados -p rbd ls | grep &quot;$ip&quot; -w</code>，发现<code>if</code>判断时常有问题，一开始还以为不能<code>grep</code>数字什么的，后来才发现没有加<code>q</code>，<code>q</code>表示安静模式，不打印任何标准输出，如果有匹配的内容则立即返回状态值0。</p><h2 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h2><p>“断网”这个词不够具体，在实际生产环境中，一个集群中，一般都会有多个网络，就拿本人的<code>ceph</code>集群环境来说（物理机环境，并非前文提及的虚拟机开发环境），<code>ceph</code>有个<code>public network</code>和<code>cluster network</code>，而<code>ctdb</code>也有它的<code>node network</code>和<code>public network</code>，<code>ceph</code>的<code>public</code>和<code>ctdb</code>的<code>public</code>是同一网段，<code>ceph</code>的<code>cluster</code>是单独网段，<code>ctdb</code>的<code>node</code>是单独的网段。所以<code>ctdb master</code>断网可以分为三种情况：</p><ul><li>拔掉<code>ctdb master node</code>网段网线</li><li>拔掉<code>ctdb master public</code>网段网线</li><li>断掉<code>ctdb master network</code>服务</li></ul><p>当拔掉<code>ctdb master public</code>网段网线，这没有什么好说的，<code>ctdb master</code>节点服务还存在，只是<code>master</code>节点上的<code>public address</code>不可用了，会漂移到其他节点上。</p><h3 id="问题1-1"><a href="#问题1-1" class="headerlink" title="问题1"></a>问题1</h3><p>当拔掉<code>ctdb master node</code>网段网线后，<code>master</code>节点仍然有<code>public</code>网卡，（<strong>这里注意</strong>）它仍然可以获取其他<code>ctdb</code>节点的状态，而其他节点却不可以获取它的状态，因为<code>master</code>的<code>node</code>节点<code>ip</code>不存在。所以造成的结果就是原<code>master</code>节点还默认自己是<code>master</code>节点，而其他的节点却又选举出了新的<code>master</code>，我们的脚本因为<code>All Banned</code>手动删除了<code>lock</code>，这时候其他节点可以正常恢复<code>ctdb</code>服务，但是当<code>ctdb master</code>节点断网再恢复后，它还以为自己是<code>master</code>，会不断去获取锁，而原来的锁已经被我们手动删除，这时候新的锁被新的<code>master</code>掌握，所以此时产生脑裂，我们要牺牲原<code>master</code>节点，也就是断网节点，所以需要重启它。这个重启触发机制我们是通过在每次删除<code>lock</code>之后在<code>rados</code>中存入<code>ctdb</code>所有节点的<code>ip</code>作为<code>object</code>（这就是为什么要存入所有节点的<code>ip</code>），然后只要发现有这个<code>object</code>便执行<code>ctdb</code>重启操作，然后便删除这个对象。至于为什么要存所有对象是因为除了原<code>master</code>需要重启之外，另外两个正常节点发生<code>All Banned</code>的情况，默认<code>timeout</code>时间是<code>300s</code>（这个上面也提到过），我们为了减少恢复时间，直接在删除<code>lock</code>后重启<code>ctdb</code>；</p><h2 id="问题2-1"><a href="#问题2-1" class="headerlink" title="问题2"></a>问题2</h2><p>由于现在<code>ctdb</code>的锁是放在<code>rados</code>中，而不是以前的<code>cephfs</code>的方式了。所以当<code>master</code>断网再恢复时，它会不断地去<code>rados</code>获取他原来的锁，这是获取锁的进程越来越多，会阻塞住<code>rados</code>服务，我们可以通过<code>ps -ef | grep rados_helper</code>看到进程不断变多，那么<code>rados</code>服务不能正常读写就影响到我们上一条的机制，不能读<code>rados</code>中是否含有本节点<code>ip</code>的对象，就没办法进行重启操作，那么这样它就会不断地继续获取<code>lock</code>，所以我们在这里又加了一个机制，如果<code>ps -ef | grep rados_helper</code>的数目超过<code>6</code>个，就默认启动重启<code>ctdb</code>服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function monitor_get_lock_timeout() &#123;</span><br><span class="line">    count=$(ps -ef | grep rados_helper | wc -l)</span><br><span class="line">    if [ $count -ge $RADOS_HELPER_PROCESS_MAX ]; then</span><br><span class="line">        systemctl restart ctdb</span><br><span class="line">        update_last_ctdb_restart_time</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h2><p><code>ctdb</code>目前重启的机制有点多，有自身自带的故障重启，也有我们监控脚本的异常情况，很容易发生重复重启，还有可能<code>rados_helper</code>堆积的进程很多，比如<code>20</code>个，我们的脚本是<code>5s</code>一次，也许<code>20</code>个的时候重启了，过<code>5s</code>，进程释放也需要时间，可能此时还有<code>10</code>个，那么大于我们规定的<code>6</code>个，就会继续重启，这种重复重启没有必要，所以我们要加上<code>ctdb</code>重启的周期限定<code>2min</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function get_ctdb_restart_interval() &#123;</span><br><span class="line">    last_time=$(get_ctdb_restart_last_time)</span><br><span class="line">    if [ -z "$last_time" ]; then</span><br><span class="line">        interval=$(expr $RESTART_CTDB_INTERVAL_MAX + 1)</span><br><span class="line">    else</span><br><span class="line">        current_time=$(date +%s)</span><br><span class="line">        interval=$(expr $current_time - $last_time)</span><br><span class="line">    fi</span><br><span class="line">    echo $interval</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑并解决以上提到的问题，基本上可以覆盖以上三种断网的场景了，在监控和管理<code>ctdb</code>的过程中，一定要小心，不能影响到业务正常运行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>生产环境网络结构错综复杂，往往在虚拟机上开发的功能当时好好的，到了物理机上面测试会发生各种问题，此时，我们首先要搞清楚网络拓扑结构，熟悉硬件配置，各网段的作用和相互之间的关联，这样遇到问题我们可以顺藤摸瓜，同样<code>ctdb</code>的原理也需要掌握才能了解它各种行为的触发机制，才能更好的定制化监控和管理。之后我会花点时间好好地研究一下<code>ctdb</code>，然后再单独做分享。</p><blockquote><p>完整代码地址：<a href="https://github.com/tony-yin/Ctdb-Rados-Monitor" target="_blank" rel="noopener">https://github.com/tony-yin/Ctdb-Rados-Monitor</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/ping-600x450.png&quot; alt=&quot;ping&quot;&gt;&lt;/center&gt;

&lt;p&gt;之前写过一篇文章【&lt;a href=&quot;http://www.tony-yin.site/2018/04/20/Ctdb-Rados-All-Banned/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ctdb Rados方式导致All Banned的问题&lt;/a&gt;】，谈到了当&lt;code&gt;ctdb&lt;/code&gt;将&lt;code&gt;recovery lock&lt;/code&gt;设置成&lt;code&gt;rados&lt;/code&gt;的方式后，断网&lt;code&gt;master&lt;/code&gt;节点会造成所有&lt;code&gt;ctdb&lt;/code&gt;节点&lt;code&gt;All Banned&lt;/code&gt;，主要原因是&lt;code&gt;master&lt;/code&gt;意外断网没有释放锁，其他节点无法获取到锁，当时的解决方案是每&lt;code&gt;5&lt;/code&gt;分钟检查一次&lt;code&gt;ctdb&lt;/code&gt;状态，如果连续两次发生了&lt;code&gt;All Banned&lt;/code&gt;的情况，则手动删除&lt;code&gt;lock&lt;/code&gt;，这种做法在最近的测试中遇到了一些问题，本文对这些问题进行剖析并对相应的解决方案进行分享。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Ctdb" scheme="https://tony-yin.github.io/tags/Ctdb/"/>
    
  </entry>
  
  <entry>
    <title>Megaraid 磁盘定位</title>
    <link href="https://tony-yin.github.io/2018/05/12/Megaraid_Location/"/>
    <id>https://tony-yin.github.io/2018/05/12/Megaraid_Location/</id>
    <published>2018-05-12T05:07:06.000Z</published>
    <updated>2018-12-13T16:40:24.442Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/mega_drive-600x450.png" alt="mega drive"></center><p>早前写过一篇【<a href="http://www.tony-yin.site/2018/01/05/RaidCardToolUtils/" target="_blank" rel="noopener">利用Raid卡工具获取逻辑盘是否为SSD</a>】的文章，大概讲述了如何通过<code>raid</code>卡工具判断一个逻辑磁盘对应物理磁盘是否为<code>SSD</code>，当时主要提到了<code>megacli</code>和<code>sas3ircu</code>这两种工具，核心是如何通过<code>raid</code>卡工具定位到逻辑磁盘对应的物理磁盘的位置，当时的方式现在看来在有些场景会存在缺陷。</p><a id="more"></a><p>当时的方案主要是先通过<code>lspci</code>获取<code>raid</code>卡型号，然后找到对应的<code>raid</code>卡型号，紧接着通过<code>lsscsi</code>命令获取逻辑磁盘的<code>targetid</code>，再通过<code>raid</code>卡工具根据<code>targetid</code>定位到对应的物理盘。当时的方案在多<code>controller</code>的场景下存在问题，可能会出现重复<code>target id</code>的情况，所以这时候只能再借助<code>controller id</code>来定位唯一的磁盘了。总而言之，想真正定位逻辑磁盘对应的物理磁盘，就必须要获取到磁盘的<code>controller id</code>，<code>enclosure id</code>和<code>slot number</code>，有了这三个参数，便可以获取该磁盘的信息，或者对该物理磁盘进行点灯、响音和做<code>raid</code>等操作。</p><p>那么，具体如何定位逻辑磁盘的物理位置呢？且看下文分析</p><h2 id="获取-raid-卡信息"><a href="#获取-raid-卡信息" class="headerlink" title="获取 raid 卡信息"></a>获取 raid 卡信息</h2><p>通过<code>lspci</code>命令可以获取到操作系统上所有<code>raid</code>卡信息，我们可以看到每个<code>raid</code>卡最前面都有一串数字，比如第一行是<code>02:00.0</code>，第二行是<code>03:00.0</code>，这里的<code>02</code>和<code>03</code>表示的是<code>raid</code>卡的<code>busid</code>，即<code>raid</code>卡控制器在<code>pci</code>总线上的<code>id</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# lspci | grep "LSI Logic"</span><br><span class="line">02:00.0 RAID bus controller: LSI Logic / Symbios Logic MegaRAID SAS-3 3008 [Fury] (rev 02)</span><br><span class="line">03:00.0 RAID bus controller: LSI Logic / Symbios Logic MegaRAID SAS-3 3108 [Invader] (rev 02)</span><br></pre></td></tr></table></figure><h2 id="获取磁盘-pcipath"><a href="#获取磁盘-pcipath" class="headerlink" title="获取磁盘 pcipath"></a>获取磁盘 pcipath</h2><p>在<code>linux</code>中，一切皆文件，每个文件都有自己的唯一标识，对于磁盘而言，<code>pcipath</code>就是它的唯一标识，<code>pci</code>总线上面有很多控制器，比如<code>scsi</code>控制器，而磁盘又存在于<code>scsi</code>控制器上，所以我们可以在<code>lsscsi</code>命令获取到的<code>scsi</code>设备列表中查看到操作系统上的磁盘信息。</p><p>以<code>sda</code>为例，我们可以在<code>/dev/disk/by-path</code>目录下查看到磁盘的<code>pcipath</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# ll /dev/disk/by-path/</span><br><span class="line">total 4</span><br><span class="line">lrwxrwxrwx 1 root root   9 May 11 10:30 pci-0000:02:00.0-scsi-0:2:0:0 -&gt; ../../sda</span><br><span class="line">lrwxrwxrwx 1 root root  10 May 11 10:30 pci-0000:02:00.0-scsi-0:2:0:0-part1 -&gt; ../../sda1</span><br><span class="line">lrwxrwxrwx 1 root root  10 May 11 10:30 pci-0000:02:00.0-scsi-0:2:0:0-part2 -&gt; ../../sda2</span><br><span class="line">lrwxrwxrwx 1 root root   9 May 11 16:22 pci-0000:02:00.0-scsi-0:2:1:0 -&gt; ../../sdb</span><br><span class="line">lrwxrwxrwx 1 root root   9 May 11 16:22 pci-0000:02:00.0-scsi-0:2:10:0 -&gt; ../../sdk</span><br></pre></td></tr></table></figure><p>由于在<code>linux</code>中，<code>udev</code>是用户态的设备管理，所以我们也可以通过<code>udev</code>获取。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# udevadm info --query=symlink --name=sda</span><br><span class="line">disk/by-id/scsi-36509a4c0ac86790022337b9105005435 disk/by-id/wwn-0x6509a4c0ac86790022337b9105005435 disk/by-path/pci-0000:02:00.0-scsi-0:2:0:0</span><br></pre></td></tr></table></figure><p>这边我们可以得到磁盘<code>sda</code>的<code>pcipath</code>为<code>pci-0000:02:00.0-scsi-0:2:0:0</code>，<code>02</code>就是磁盘的<code>raid</code>卡的<code>bus id</code>，后面的<code>00</code>表示<code>channel id</code>，再后面的<code>0:2:0:0</code>就和<code>lsscsi</code>获取的一样了，其中<code>2</code>就表示<code>target id</code>。</p><p>所以通过<code>bud id</code>，我们可以获取到磁盘对应的<code>raid</code>卡型号，根据对应的<code>raid</code>卡工具操作磁盘。这边我们只讨论<code>megaraid</code>，所以工具也就是<code>megacli</code>了。</p><h2 id="获取-controller-id"><a href="#获取-controller-id" class="headerlink" title="获取 controller id"></a>获取 controller id</h2><p>上面我们获取到了磁盘的<code>target id</code>和对应<code>raid</code>卡的<code>bus id</code>，而对于<code>megacli</code>工具而言，每个<code>raid</code>卡都有一个与之对应的<code>controller</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# /opt/MegaRAID/MegaCli/MegaCli64 -AdpGetPciInfo -aall -NoLog</span><br><span class="line"></span><br><span class="line">PCI information for Controller 0</span><br><span class="line">--------------------------------</span><br><span class="line">Bus Number      : 2</span><br><span class="line">Device Number   : 0</span><br><span class="line">Function Number : 0</span><br><span class="line"></span><br><span class="line">PCI information for Controller 1</span><br><span class="line">--------------------------------</span><br><span class="line">Bus Number      : 3</span><br><span class="line">Device Number   : 0</span><br><span class="line">Function Number : 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exit Code: 0x00</span><br></pre></td></tr></table></figure><p>这边我们可以看到<code>megacli</code>获取到了两个<code>controller</code>，也就对应上面<code>lspci</code>获取到的两张<code>raid</code>卡。细心的朋友可以发现这边有一个<code>Bus Number</code>，分别为<code>2</code>和<code>3</code>，而我们上面获取到了<code>raid</code>卡的<code>bus id</code>分别为<code>02</code>和<code>03</code>，没错，这边的<code>Bus Number</code>和<code>bus id</code>是对应的，只是<code>Bus number</code>没有自动填补成两位数，所以我们可以通过<code>bus id</code>得到<code>sda</code>所对应的<code>controller</code>为<code>0</code>。</p><blockquote><p><strong>注意：</strong><br>原本系统中版本<code>8.07.07</code>的<code>megacli</code>工具获取<code>raid</code>卡信息的时候会存在问题，每次<code>Bus Number</code>都会变化，我们只要升级<code>megacli</code>即可，我这边是把<code>megacli</code>升级到了<code>8.07.14</code>版本。</p><p>安装包地址：<a href="https://github.com/tony-yin/Megaraid_location/blob/master/MegaCli-8.07.14-1.noarch.rpm" target="_blank" rel="noopener">https://github.com/tony-yin/Megaraid_location/blob/master/MegaCli-8.07.14-1.noarch.rpm</a></p></blockquote><h2 id="获取磁盘组"><a href="#获取磁盘组" class="headerlink" title="获取磁盘组"></a>获取磁盘组</h2><p>此时，我们拥有了<code>controller id</code>，可以获取该<code>controller</code>下所有的磁盘组信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# /opt/MegaRAID_new/MegaCli/MegaCli64  -LdPdInfo -a0 -NoLog</span><br><span class="line">Adapter #0</span><br><span class="line"></span><br><span class="line">Number of Virtual Disks: 13</span><br><span class="line">Virtual Drive: 0 (Target Id: 0)</span><br><span class="line">Name                :</span><br><span class="line">RAID Level          : Primary-1, Secondary-0, RAID Level Qualifier-0</span><br><span class="line">Size                : 558.375 GB</span><br><span class="line">Sector Size         : 512</span><br><span class="line">Is VD emulated      : No</span><br><span class="line">Mirror Data         : 558.375 GB</span><br><span class="line">State               : Optimal</span><br><span class="line">Strip Size          : 64 KB</span><br><span class="line">Number Of Drives    : 2</span><br><span class="line">Span Depth          : 1</span><br><span class="line">Default Cache Policy: WriteThrough, ReadAheadNone, Direct, No Write Cache if Bad BBU</span><br><span class="line">Current Cache Policy: WriteThrough, ReadAheadNone, Direct, No Write Cache if Bad BBU</span><br><span class="line">Default Access Policy: Read/Write</span><br><span class="line">Current Access Policy: Read/Write</span><br><span class="line">Disk Cache Policy   : Disk's Default</span><br><span class="line">Encryption Type     : None</span><br><span class="line">Default Power Savings Policy: Controller Defined</span><br><span class="line">Current Power Savings Policy: None</span><br><span class="line">Can spin up in 1 minute: Yes</span><br><span class="line">LD has drives that support T10 power conditions: Yes</span><br><span class="line">LD's IO profile supports MAX power savings with cached writes: No</span><br><span class="line">Bad Blocks Exist: No</span><br><span class="line">Is VD Cached: No</span><br><span class="line">Number of Spans: 1</span><br><span class="line">Span: 0 - Number of PDs: 2</span><br><span class="line"></span><br><span class="line">PD: 0 Information</span><br><span class="line">Enclosure Device ID: 32</span><br><span class="line">Slot Number: 12</span><br><span class="line">Drive's position: DiskGroup: 0, Span: 0, Arm: 0</span><br><span class="line">Enclosure position: 1</span><br><span class="line">Device Id: 12</span><br><span class="line">WWN: 50000398181A974C</span><br><span class="line">Sequence Number: 2</span><br><span class="line">Media Error Count: 0</span><br><span class="line">Other Error Count: 0</span><br><span class="line">Predictive Failure Count: 0</span><br><span class="line">Last Predictive Failure Event Seq Number: 0</span><br><span class="line">PD Type: SAS</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后我们可以根据<code>target id</code>获取对应的磁盘组信息，<code>target id</code>与上面的<code>Target Id</code>所对应，这样我们可以过滤得到唯一的磁盘组信息。这边我们可以看到<code>sda</code>对应<code>Target Id</code>为<code>0</code>的磁盘组，该<code>raid</code>类型为<code>raid1</code>，虚拟磁盘组中有两块物理盘，然后我们可以获取这两块物理盘的<code>enclosure id</code>和<code>slot number</code>，这样再加上前文的<code>controller id</code>，我们就可以完完全全地定位到具体一块磁盘的物理位置。</p><h2 id="一键定位"><a href="#一键定位" class="headerlink" title="一键定位"></a>一键定位</h2><p>针对这种需求，本人根据以上逻辑写了一个简单的脚本可以一键获取磁盘的定位。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# ./get_disk_location.py sda</span><br><span class="line">['0:32:12', '0:32:13']</span><br></pre></td></tr></table></figure><p>这边<code>0:32:12</code>分别表示磁盘的<code>controller id</code>，<code>enclosure id</code>和<code>slot number</code>。</p><blockquote><p>完整代码地址：<a href="https://github.com/tony-yin/Megaraid_location/" target="_blank" rel="noopener">https://github.com/tony-yin/Megaraid_location/</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前的做法大部分场景可行，但是在一些场合偶尔会发现问题，总感觉还是不够靠谱，身边的人还有通过<code>sda</code>，<code>sdb</code>这种排列顺序来查找和<code>megacli</code>中显示磁盘的对应关系的，就更不靠谱了。<code>linux</code>操作系统是可以识别到具体硬件设备的，所以是肯定存在方法识别硬件对应的逻辑设备的，本文通过<code>pcipath</code>获取到设备的唯一标识，然后根据<code>pcipath</code>中的<code>bus id</code>和<code>megacli</code>中的<code>cobtroller</code>建立连接，最后通过<code>target id</code>锁定唯一磁盘组中的磁盘信息。</p><p>通过这种方式，我们不需要肉眼判断，也不需要顾虑部分场景方案不适用，这完全就是操作系统使用的方式，使用这种最基础，最底层的方式实现，真是让人豁然开朗。这跟看源码类似，了解一个功能的背后具体实现，你才知道最正确的姿势，不用去碰，去凑，这种感觉真好。</p><p>给大家推荐一本书《<code>Linux</code>设备驱动程序》，这本书详细讲解了<code>linux</code>中各种设备与驱动的细节，很底层也很枯燥，不过看完后应该会很有收获。希望大家在使用各种已有工具和框架的基础上，多去了解背后的实现机制，这样可以帮助我们更好地实现更深层次的需求。</p><h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ol><li><a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">Persistent block device naming</a></li><li><a href="https://github.com/eLvErDe/hwraid" target="_blank" rel="noopener">hwraid</a></li><li><a href="https://github.com/louwrentius/showtools" target="_blank" rel="noopener">showtools</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-scsi-subsystem/" target="_blank" rel="noopener">Linux SCSI 子系统剖析</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/mega_drive-600x450.png&quot; alt=&quot;mega drive&quot;&gt;&lt;/center&gt;

&lt;p&gt;早前写过一篇【&lt;a href=&quot;http://www.tony-yin.site/2018/01/05/RaidCardToolUtils/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;利用Raid卡工具获取逻辑盘是否为SSD&lt;/a&gt;】的文章，大概讲述了如何通过&lt;code&gt;raid&lt;/code&gt;卡工具判断一个逻辑磁盘对应物理磁盘是否为&lt;code&gt;SSD&lt;/code&gt;，当时主要提到了&lt;code&gt;megacli&lt;/code&gt;和&lt;code&gt;sas3ircu&lt;/code&gt;这两种工具，核心是如何通过&lt;code&gt;raid&lt;/code&gt;卡工具定位到逻辑磁盘对应的物理磁盘的位置，当时的方式现在看来在有些场景会存在缺陷。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Megaraid" scheme="https://tony-yin.github.io/tags/Megaraid/"/>
    
  </entry>
  
  <entry>
    <title>Django CAS Token 解决方案</title>
    <link href="https://tony-yin.github.io/2018/05/02/Django_CAS_Token_Solution/"/>
    <id>https://tony-yin.github.io/2018/05/02/Django_CAS_Token_Solution/</id>
    <published>2018-05-02T05:07:06.000Z</published>
    <updated>2018-12-17T04:37:27.341Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/bottle.png" alt="cas"></center><p><code>CAS</code>单点登录主要是为了解决主系统和子系统的统一登录问题，能够做到任意一个子系统登录成功后，再登录其他子系统后不再需要认证，让用户不用重复地进行登录认证。<code>CAS</code>单点登录的方案很多，并且大多数都是采用<code>session</code>的方式，而本文结合个人实践，着重讨论<code>django cas token</code>的解决方案。</p><a id="more"></a><p>本方案中，<code>cas</code>客户端和服务端都采用了开源项目，服务端是<a href="https://github.com/jbittel/django-mama-cas" target="_blank" rel="noopener">django-mama-cas</a>，而客户端是<a href="https://github.com/mingchen/django-cas-ng" target="_blank" rel="noopener">django-cas-ng</a>。</p><h2 id="CAS-Server"><a href="#CAS-Server" class="headerlink" title="CAS Server"></a>CAS Server</h2><p>服务端相比于客户端要简单地多，根据<code>github</code>步骤一步步下载和配置就好。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django-mama-cas</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">INSTALLED_APPS = (</span><br><span class="line">    <span class="string">'mama_cas'</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重要！，service是client的IP，是个数组，可以在后面添加SERVICE的HOST:PORT。</span></span><br><span class="line">MAMA_CAS_SERVICES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'SERVICE'</span>: <span class="string">'http://127.0.1.1:8000'</span>,</span><br><span class="line">        <span class="string">'CALLBACKS'</span>: [</span><br><span class="line">            <span class="string">'mama_cas.callbacks.user_model_attributes'</span>,     <span class="comment"># 返回除了password的所有Field</span></span><br><span class="line">            <span class="comment"># 'mama_cas.callbacks.user_name_attributes', # 只返回 username</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">'LOGOUT_ALLOW'</span>: <span class="keyword">True</span>,</span><br><span class="line">        <span class="string">'LOGOUT_URL'</span>: <span class="string">'http://127.0.1.1:8000/accounts/callback'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># urls.py</span></span><br><span class="line">url(<span class="string">r''</span>, include(<span class="string">'mama_cas.urls'</span>)),</span><br></pre></td></tr></table></figure><h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><p>首先是一些基本的客户端配置，比如<code>server ip</code>等，但是<code>django-cas-ng</code>默认是通过<code>session</code>的方式认证的，而我们需要通过<code>token</code>的方式认证，所以如果想继续用<code>django-cas-ng</code>来解决问题，那要么查看它是否有原生支持的接口，要么改源码。改源码可能不大友好，所以我优先研究了一下<code>django-cas-ng</code>的原生支持，无意中发现<a href="https://github.com/mingchen/django-cas-ng#view-wrappers-example" target="_blank" rel="noopener">view-wrappers-example</a>可以继承它原生的登录接口做一些封装，而我们完全通过继承原生的登录方法，然后加入我们的<code>token</code>相关代码。所以<code>urls.py</code>里面登录的方法我们写的是我们写在<code>view.py</code>中封装的登录方法，而并非默认的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">INSTALLED_APPS = (</span><br><span class="line">    <span class="comment"># ... other installed apps</span></span><br><span class="line">    <span class="string">'django_cas_ng'</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">AUTHENTICATION_BACKENDS = (</span><br><span class="line">    <span class="string">'django_cas_ng.backends.CASBackend'</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：这是cas server的地址</span></span><br><span class="line">CAS_SERVER_URL = <span class="string">'http://127.0.0.1:8000'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存入所有CAS 服务端返回的user数据。</span></span><br><span class="line">CAS_APPLY_ATTRIBUTES_TO_USER = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># urls.py</span></span><br><span class="line"><span class="keyword">import</span> view <span class="keyword">import</span> *</span><br><span class="line">url(<span class="string">r'^accounts/login$'</span>, cas_login, name=<span class="string">'cas_login'</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">#view.py</span></span><br><span class="line"><span class="keyword">from</span> django_cas_ng <span class="keyword">import</span> views <span class="keyword">as</span> baseviews</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cas_login</span><span class="params">(request, **kwargs)</span>:</span></span><br><span class="line">    r = baseviews.login(request, **kwargs)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.user.is_anonymous():</span><br><span class="line">        token = get_token(request)</span><br><span class="line">        <span class="keyword">if</span> token:</span><br><span class="line">            r.set_cookie(<span class="string">'token'</span>, token)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'Get token error'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'User is anonymous'</span>)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token</span><span class="params">(request, *args, **kwargs)</span>:</span></span><br><span class="line">    user = request.user</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        request_hash = AuthToken.get_request_hash(request)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            token = generate_token()    <span class="comment"># function used to geneate token, this place won't show more detail codes</span></span><br><span class="line">            token.refresh()</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">print</span> e</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> token.key</span><br></pre></td></tr></table></figure><p>生成<code>token</code>的方法我就不详细描述了，这边主要提供了一个思路，我们将<code>django-cas-ng</code>原生的登录方法进行了继承，然后生成<code>token</code>并放到了<code>session</code>当中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要为<code>CAS Token</code>方案提供一个思路，如果集成进已有项目中，肯定会遇到很多细节问题，不过万变不离其宗，我们首先要熟悉手中运用的工具，然后要善于在此基础之上根据自己的定制需求进行开发，多看看文档和源码，每一次可能都会有新的发现。</p><h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ol><li><a href="https://www.jianshu.com/p/d97a3d367037" target="_blank" rel="noopener">使用django-mama-cas快速搭建CAS服务</a></li><li><a href="http://www.voidcn.com/article/p-yvycalqd-brm.html" target="_blank" rel="noopener">Django实现CAS+OAuth2</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/bottle.png&quot; alt=&quot;cas&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;code&gt;CAS&lt;/code&gt;单点登录主要是为了解决主系统和子系统的统一登录问题，能够做到任意一个子系统登录成功后，再登录其他子系统后不再需要认证，让用户不用重复地进行登录认证。&lt;code&gt;CAS&lt;/code&gt;单点登录的方案很多，并且大多数都是采用&lt;code&gt;session&lt;/code&gt;的方式，而本文结合个人实践，着重讨论&lt;code&gt;django cas token&lt;/code&gt;的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Django" scheme="https://tony-yin.github.io/tags/Django/"/>
    
      <category term="CAS" scheme="https://tony-yin.github.io/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>Daily Article Vol 5 - (2018/4/1 ~ 2018/4/30)</title>
    <link href="https://tony-yin.github.io/2018/05/01/Daily-Article-Vol5/"/>
    <id>https://tony-yin.github.io/2018/05/01/Daily-Article-Vol5/</id>
    <published>2018-05-01T02:07:06.000Z</published>
    <updated>2018-12-13T16:40:24.422Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/hello_april_600x450.png" alt="April"></center><p>这是<code>Daily Article</code>系列的第五篇，罗列了<code>2018</code>年<code>4</code>月的阅读清单。</p><a id="more"></a><p>本月是在新公司工作的第一个月，主要做了利用<code>python</code>搭建<code>NAS</code>服务稳定性测试框架、<code>CTDB</code>使用<code>rados object</code>作为<code>lock file</code>、利用<code>django</code>做<code>CAS</code>单点登录。首先<code>python</code>搭建<code>NAS</code>服务稳定性测试框架的工作就是通过<code>python</code>对<code>NAS</code>服务进行连接，并进行读写操作，该框架不需要任何挂载操作便可以对<code>NAS</code>服务进行连接和读写操作，目前支持<code>NFS</code>、<code>CIFS</code>和<code>FTP</code>，具体请参考<a href="http://www.tony-yin.site/2018/04/08/python_nas_stable_test/" target="_blank" rel="noopener">基于Python的NAS稳定性测试框架</a>；然后就是<code>CTDB</code>使用<code>rados object</code>作为<code>lockfile</code>这种方案的实践，期间也遇到了<code>Nodes All Banned</code>这种问题并解决了；最后就是采用<code>django-mama-cas</code>作为服务端，<code>django-cas-ng</code>作为客户端，搭建了一套<code>CAS</code>环境，并对目前的项目进行集成。</p><p>个人课余时间的话，一方面关注的是<code>python</code>和<code>django</code>有关的知识，因为工作中要用到，其次就是围绕着<code>ceph</code>和存储相关知识的了解和学习了。上周在扫盲区的过程中，看到了很久之前了解的<code>nvme over fabric</code>这个概念，然后又去深入地了解了一下。这一了解又引申出了无数的盲区，比如<code>RDMA</code>、<code>nvme</code>、<code>nvme overip</code>、<code>FC</code>等等，而这些技术也很新，文档不多，并且大多数都是很枯燥的，只能逼着自己慢慢地啃下去。感慨技术变革真是日新月异的同时，也感慨扫盲区的速度远远赶不上盲区生成的速度，每天都会有好多自己不知道或者不是特别了解原理的概念，等待着自己去学习和深入。不过呢，也正如之前一位前辈讲过，很多人都觉得这个技术牛逼，那个技术牛逼，不是那么容易学会的，也正是因为这种心态，很多人都不去学习，而很多学习的人即使没有到达最顶峰，比不学的人多了解一点就强一些。所以人生苦短，没事多看看总没坏处。</p><p>碎片时间也会看极客时间上面的专栏，我已经买了两个专栏。从目前的观看效果来说，首先我觉得还是不错的，但是很多内容都是概念上面的东西，仿佛是为了写文章而写文章，缺少落地的东西，经常围绕着一个概念反复强调，我觉得还不如多讲讲具体的场景更容易让别人接受一些。对于我而言，分布式，服务治理，服务分发这些概念和场景我都有经历过，所以我还蛮能接受的，我想很多没有经历过这些开发的童鞋直接看也许会感觉到云里雾里的。但是还是那句话，多看一点总是有好处的，因为很多东西你看了，你没到一定层次是不会了解的，你提前看了，也许之后某一天就会有一种豁然开朗的感觉。但是我们还是要讲究方法的，时间是有限的，我们要在有限的时间学习更多的知识。我认为看这些文章，目的不是为了一步登天，获得什么实质效应，事实上他也不会给你这种回报，我们要做的就是从上面获取一些技术概念、原理和本质，由此作为一个引子，自己找项目，找场景去实践，去深入，光说不练假把式，只有实践了才能深入，然后最好的就是能够在产品中不断运用和学习相关技术了，这样才是最好的学习和掌握。因为很多时间如果固步自封，很多概念你都不知道，更别谈去学习了。最后我会专门整理一篇文章，把我看过的极客时间的文章分享出来，这样可以让一些童鞋免费了解和学习，我这边用的是极客时间提供的分享的功能，也不算违规，每次分享只有十个名额，所以大家先到先得。emmm，看很多同学买课很积极，很多同学却很消极，我觉得前者起码有学习的想法，后者就不谈了，但是针对前者我想说的是，不是花的钱越多就有用的，而是学到手，记到脑子里才属于自己的，希望大家都能不断学习，越变越好，happy everyday！</p><ol><li><a href="https://www.jianshu.com/p/6f67a4b9dad3" target="_blank" rel="noopener">django2.0入门教程第一节</a>(4/2) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://www.jianshu.com/p/b8d73d39f184" target="_blank" rel="noopener">django2.0入门教程第二节</a>(4/2) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://www.jianshu.com/p/2004b8dbebb4" target="_blank" rel="noopener">django2.0入门教程第三节</a>(4/2) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://www.jianshu.com/p/e2a09d2a4a2f" target="_blank" rel="noopener">django2.0入门教程第四节</a>(4/2) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://time.geekbang.org/column/article/ed937b37244d4db63f60e5f00be38fce/share" target="_blank" rel="noopener">【极客时间-左耳听风】：分布式系统关键技术：服务调度</a>(4/3)</li><li><a href="http://www.woshipm.com/data-analysis/872543.html" target="_blank" rel="noopener">数据分析入门：初识数据埋点（一）</a>(4/7) <i class="fa fa-star"></i></li><li><a href="https://www.jianshu.com/p/5b33bbd61c48" target="_blank" rel="noopener">docker初体验</a>(4/7)</li><li><a href="https://www.jianshu.com/p/f43659a58d71" target="_blank" rel="noopener">构建FTP文件传输服务器</a>(4/8)</li><li><a href="https://blog.csdn.net/bear_huangzhen/article/details/41806903?from=singlemessage" target="_blank" rel="noopener">FTP文件传输协议</a>(4/8)</li><li><a href="https://www.jianshu.com/p/05212313d0e2" target="_blank" rel="noopener">ftp实现原理以及抓包分析</a>(4/8)</li><li><a href="https://www.jianshu.com/p/e99519739b5e" target="_blank" rel="noopener">Linux下ftp服务搭建之小试牛刀</a>(4/8)</li><li><a href="https://blog.csdn.net/u014245412/article/details/72286348" target="_blank" rel="noopener">python 操作samba文件服务器</a>(4/10) <i class="fa fa-star"></i></li><li><a href="https://yq.aliyun.com/articles/578927?utm_content=m_45816" target="_blank" rel="noopener">佛系程序员的月薪五万指南</a>(4/12) <i class="fa fa-star"></i></li><li><a href="https://lingxiankong.github.io/2013-12-23-python-setup.html" target="_blank" rel="noopener">关于python中的setup.py</a>(4/13) <i class="fa fa-star"></i></li><li><a href="https://time.geekbang.org/column/article/b307919cc599a82c542ec39e7aa3ddc7/share" target="_blank" rel="noopener">【极客时间-左耳听风】：分布式系统关键技术：流量与数据调度</a>(4/16) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="http://blog.sina.com.cn/s/blog_8c243ea30102uxaw.html" target="_blank" rel="noopener">分布式高可用CTDB方案</a>(4/16)</li><li><a href="https://ceph.com/planet/ctdb使用rados-object作为lock-file/" target="_blank" rel="noopener">CTDB使用rados object作为lock file</a>(4/16) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://blog.csdn.net/naipeng/article/details/75045177" target="_blank" rel="noopener">关于CTDB</a>(4/17)</li><li><a href="http://www.zphj1987.com/2017/04/20/where-is-cephfs-data-store/" target="_blank" rel="noopener">Cephfs的文件存到哪里了</a>(4/21)</li><li><a href="http://blog.jobbole.com/56574/" target="_blank" rel="noopener">最佳日志实践</a>(4/22) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://zhuanlan.zhihu.com/p/27363484" target="_blank" rel="noopener">最佳日志实践（v2.0）</a>(4/23) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="http://www.zphj1987.com/2017/06/09/use-graylog-get-Ceph-status/" target="_blank" rel="noopener">使用日志系统graylog获取Ceph集群状态</a>(4/23) <i class="fa fa-star"></i></li><li><a href="http://www.zphj1987.com/2017/07/13/CEPHFS-op-to-graylog/" target="_blank" rel="noopener">Cephfs 操作输出到日志查询系统</a>(4/23) <i class="fa fa-star"></i></li><li><a href="https://blog.csdn.net/xiaqunfeng123/article/details/56675696?locationNum=1&amp;fps=1" target="_blank" rel="noopener">bluestore调研</a>(4/23) <i class="fa fa-star"></i></li><li><a href="https://zhuanlan.zhihu.com/p/24312755" target="_blank" rel="noopener">Python打包时添加非代码文件的坑</a>(4/24)</li><li><a href="https://www.jianshu.com/p/d910a70dfee7" target="_blank" rel="noopener">cephfs介绍和功能测试</a>(4/24)</li><li><a href="http://xiaqunfeng.cc/2017/01/20/%E5%9D%97%E5%AD%98%E5%82%A8%E7%9A%84%E4%B8%96%E7%95%8C/#more" target="_blank" rel="noopener">块存储的世界</a>(4/24) <i class="fa fa-star"></i></li><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432712108300322c61f256c74803b43bfd65c6f8d0d0000#0" target="_blank" rel="noopener">python virtualenv</a>(4/24) <i class="fa fa-star"></i></li><li><a href="http://stackeye.com/2014/08/rpmbuild-in-action/" target="_blank" rel="noopener">rpmbuild实战</a>(4/25) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://zhuanlan.zhihu.com/p/28492389" target="_blank" rel="noopener">使用RPM方式安装Linux软件</a>(4/25)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-rpm/index.html" target="_blank" rel="noopener">RPM 打包技术与典型 SPEC 文件分析</a>(4/25) <i class="fa fa-star"></i></li><li><a href="http://mp.weixin.qq.com/s?src=11&amp;timestamp=1524706491&amp;ver=839&amp;signature=nEMLgYwV4GI9Pd19glqGgJS6DR7sfrZesONMDXvpIWz34-KhzcYGK8h*WE7DjAFpXU9NYztsheG7Doy29A2zEC-V2bw*zFNgXbyy5VK2vRBR83sVVudSgxEsbAN0R8iW&amp;new=1" target="_blank" rel="noopener">RDMA(远程直接内存访问)技术浅析</a>(4/26) <i class="fa fa-star"></i></li><li><a href="https://blog.csdn.net/chenhaifeng2016/article/details/78072498?locationNum=4&amp;fps=1" target="_blank" rel="noopener">RDMA技术</a>(4/26) <i class="fa fa-star"></i></li><li><a href="https://www.csdn.net/article/1970-01-01/302809" target="_blank" rel="noopener">Fabric是否代表网络架构的未来？</a> <i class="fa fa-star-half-full"></i></li><li><a href="http://dy.163.com/v2/article/detail/CDG9CD7G05179LAH.html" target="_blank" rel="noopener">2017下一代数据中心网络研究报告</a>(4/27)</li><li><a href="http://book.51cto.com/art/201105/266135.htm" target="_blank" rel="noopener">统一Fabric和互联云</a>(4/27)</li><li><a href="http://net.zol.com.cn/459/4598330.html" target="_blank" rel="noopener">浅谈数据中心网络架构的发展</a>(4/27) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://blog.csdn.net/memblaze_2011/article/details/51820631" target="_blank" rel="noopener">为了部落：NVMe over Fabric诞生记</a> <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="http://www.cnblogs.com/rodenpark/p/6220519.html" target="_blank" rel="noopener">NVMe over Fabrics：概念、应用和实现</a>(4/28)</li><li><a href="https://blog.csdn.net/u010616442/article/details/70773956" target="_blank" rel="noopener">NVME概述</a>(4/28)</li><li><a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1524808998&amp;ver=841&amp;signature=56U4bzWNuWUqlDANFQNBFPkSc2dX-R*HeLL9y7vN*ha-Ph0PrOfhkEPUfB8R*Gy-SLlwFeMqCUKDneUkeDPfpgT-igBpw77SSCr6Hhl9Ul29OsEMtzY1B2-JPQbBd1vH&amp;new=1" target="_blank" rel="noopener">详谈NVMe over Fabric技术发展简史</a>(4/29) <i class="fa fa-star"></i></li><li><a href="http://www.voidcn.com/article/p-yvycalqd-brm.html" target="_blank" rel="noopener">Django实现CAS+OAuth2</a> <i class="fa fa-star"></i></li><li><a href="https://weibo.com/p/1001603934517592239583?mod=zwenzhang#_loginLayer_1525517479194" target="_blank" rel="noopener">NVMe over Fabric</a> <i class="fa fa-star"></i><i class="fa fa-star"></i></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/hello_april_600x450.png&quot; alt=&quot;April&quot;&gt;&lt;/center&gt;

&lt;p&gt;这是&lt;code&gt;Daily Article&lt;/code&gt;系列的第五篇，罗列了&lt;code&gt;2018&lt;/code&gt;年&lt;code&gt;4&lt;/code&gt;月的阅读清单。&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
      <category term="Daily-Article" scheme="https://tony-yin.github.io/tags/Daily-Article/"/>
    
  </entry>
  
  <entry>
    <title>Ctdb Rados方式导致All Banned的问题</title>
    <link href="https://tony-yin.github.io/2018/04/20/Ctdb-Rados-All-Banned/"/>
    <id>https://tony-yin.github.io/2018/04/20/Ctdb-Rados-All-Banned/</id>
    <published>2018-04-20T05:07:06.000Z</published>
    <updated>2018-12-13T16:40:24.416Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/lock.jpg" alt="lock object"></center><p><code>ctdb</code>最近专门为<code>ceph</code>提供了一种<code>raods object</code>作为文件锁的方式，<code>lock file</code>可以放在对象存储中，而不是<code>cephfs</code>，从而大大降低了系统宕机的延时。在此方案的实践中，我们发现<code>master</code>节点宕机会导致严重的<code>All Banned</code>的问题，本文则围绕该问题展开讨论和提供本人的解决方案。</p><a id="more"></a><p>很多系统都在用<code>ctdb</code>做<code>HA</code>，今天我们讨论的是基于<code>cephfs</code>的<code>ctdb HA</code>方案。<code>ctdb</code>的作用是在一个共享文件系统中，当所有节点都访问同一个文件时，<code>ctdb</code>会选举出一个<code>master</code>节点获得<code>lock</code>，我们之前的做法是把这个<code>lock file</code>放在<code>cephfs</code>的共享目录中，但是当其中某个节点<code>down</code>了之后，会导致<code>cephfs</code>这个目录卡死，进一步导致<code>lock file</code>在其他节点都获取不到，只有等到锁超时了之后才能获取到，而这个超时时间默认是<code>300s</code>，再加上<code>ctdb</code>的监控检测和恢复的时间，切换的时间少则十几分钟，多则几十分钟，这对于高可用场景来说无疑是灾难级的。</p><h2 id="具体场景"><a href="#具体场景" class="headerlink" title="具体场景"></a>具体场景</h2><p><code>ctdb</code>的编译和安装我就不说了，大家可以参考磨渣的文章：<a href="http://www.zphj1987.com/2018/01/06/CTDB-use-rados-object-as-lock-file/" target="_blank" rel="noopener">CTDB使用rados object作为lock file</a>。在<code>ceph</code>集群中所有节点安装好<code>ctdb</code>后，起服务后通过<code>systemctl status ctdb</code>可以发现<code>reclock</code>是通过<code>ctdb_mutex_ceph_rados_helper</code>的方式，就说明<code>ctdb rados</code>的方式配置成功了。</p><p>然后我们可以通过<code>rados -p rbd ls</code>也可以看到自己配置的锁存在于<code>rbd pool</code>中。这时我们断电一个<code>slave</code>节点，一分钟左右后可以实现节点切换。但是我们的测试发现当断网<code>master</code>节点的时候，就会造成长时间的卡住，且节点并不会切换。详细查看可以发现断网后，<code>master</code>节点没有释放<code>lock</code>，然后其他的集群节点选举出了<code>master</code>节点后，试图获取锁，但是由于之前的<code>master</code>节点一直没有释放，所以一直获取不到，然后就不停的去获取，<code>ctdb</code>的机制是如果有不断的这种行为，就会让所有节点<code>All Banned</code>。因为<code>slave</code>节点并不拥有锁，所以不存在之前的问题。</p><p>这个问题是比较严重的，因为不存在超时机制，拥有锁的节点断网或者断电，所以不会因为超时就释放锁。所以就会一直就卡着，并且一直实现不了切换节点。这就意味着一旦这种情况发生，客户的业务就会发生中断，这是无法接受的。并且我们也发现了如果使用原来将<code>lock file</code>放在<code>cephfs</code>目录的方式，断网或者断电主节点并不会发生这种情况，后来大概看了下源码大概是因为<code>cephfs</code>自己的机制会强制释放共享目录中文件的锁。</p><p>具体报错如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# ctdb status</span><br><span class="line">Warning: All nodes are banned.</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们的解决方案没有尝试着修改<code>ctdb</code>的源码，而是通过定时监控<code>ctdb</code>的状态。如果是主节点上面的<code>ctdb</code>，并且如果是<code>rados</code>方式的话，每<code>3</code>分钟查看一下<code>ctdb status</code>的状态，如果有连续两次的状态都是<code>All Banned</code>的话，我们就认为目前主节点发生了不释放锁的问题，我们就主动地删除<code>lock object</code>。部分代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">function check_if_master() &#123;</span><br><span class="line">    MASTER_PNN=$(ctdb recmaster)</span><br><span class="line">    CURRENT_PNN=$(ctdb pnn)</span><br><span class="line">    if [ $MASTER_PNN -eq $CURRENT_PNN ]; then</span><br><span class="line">        echo true</span><br><span class="line">    else</span><br><span class="line">        echo false</span><br><span class="line">    fi  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function get_lock_name() &#123;</span><br><span class="line">    LOCK_INFO=$(grep rados $CTDB_CONFIG_FILE | awk '&#123;print $5&#125;')</span><br><span class="line">    LOCK_NAME=$&#123;LOCK_INFO:0:-1&#125;</span><br><span class="line">    echo $LOCK_NAME</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function monitor_lock() &#123;</span><br><span class="line">    STATUS_FILE=/etc/ctdb/status.txt</span><br><span class="line">    CTDB_STATUS=$(ctdb status 2&gt;&amp;1)</span><br><span class="line">    ALL_BANNED="Warning: All nodes are banned."</span><br><span class="line"></span><br><span class="line">    if [ ! -f "$STATUS_FILE" ]; then</span><br><span class="line">        echo "$CTDB_STATUS" &gt; $STATUS_FILE</span><br><span class="line">    else</span><br><span class="line">        if [ "$CTDB_STATUS" = "$ALL_BANNED" ]; then</span><br><span class="line">            LAST_CTDB_STATUS=$(cat $STATUS_FILE)</span><br><span class="line">            if [ "$LAST_CTDB_STATUS" = "$ALL_BANNED" ]; then</span><br><span class="line">                LOCKNAME=$(get_lock_name)</span><br><span class="line">                echo $(date)" Ctdb all nodes banned: Second time" &gt;&gt; /var/log/monitor_ctdb.log</span><br><span class="line">                echo $(date)" Remove ctdb rados lock: "$LOCKNAME &gt;&gt; /var/log/monitor_ctdb.log</span><br><span class="line">                rados -p rbd rm $LOCKNAME </span><br><span class="line">                echo -n "" &gt; $STATUS_FILE</span><br><span class="line">            else</span><br><span class="line">                echo $(date)" Ctdb all nodes banned: First time" &gt;&gt; /var/log/monitor_ctdb.log</span><br><span class="line">                echo "$ALL_BANNED" &gt; $STATUS_FILE</span><br><span class="line">            fi</span><br><span class="line">        else</span><br><span class="line">            echo -n "" &gt; $STATUS_FILE</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTDB_CONFIG_FILE=/etc/sysconfig/ctdb</span><br><span class="line">if $(grep rados $CTDB_CONFIG_FILE -q); then</span><br><span class="line">    if $(check_if_master); then</span><br><span class="line">        monitor_lock</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><blockquote><p>完整代码地址：<code>https://github.com/tony-yin/Ctdb-Rados-Monitor</code></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>也许我的这种做法不是最优方案，希望遇到同样问题的同学可以一起讨论，拥有更好解决方案的可以一起分享。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/lock.jpg&quot; alt=&quot;lock object&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;code&gt;ctdb&lt;/code&gt;最近专门为&lt;code&gt;ceph&lt;/code&gt;提供了一种&lt;code&gt;raods object&lt;/code&gt;作为文件锁的方式，&lt;code&gt;lock file&lt;/code&gt;可以放在对象存储中，而不是&lt;code&gt;cephfs&lt;/code&gt;，从而大大降低了系统宕机的延时。在此方案的实践中，我们发现&lt;code&gt;master&lt;/code&gt;节点宕机会导致严重的&lt;code&gt;All Banned&lt;/code&gt;的问题，本文则围绕该问题展开讨论和提供本人的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Ctdb" scheme="https://tony-yin.github.io/tags/Ctdb/"/>
    
      <category term="Rados" scheme="https://tony-yin.github.io/tags/Rados/"/>
    
      <category term="HA" scheme="https://tony-yin.github.io/tags/HA/"/>
    
  </entry>
  
  <entry>
    <title>基于Python的NAS稳定性测试框架</title>
    <link href="https://tony-yin.github.io/2018/04/08/python_nas_stable_test/"/>
    <id>https://tony-yin.github.io/2018/04/08/python_nas_stable_test/</id>
    <published>2018-04-08T05:07:06.000Z</published>
    <updated>2018-12-13T16:40:24.449Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/nas.jpg" alt="NAS Stable Test"></center><p>最近公司有个集群一直在跑着，领导想要测测它上面<code>NAS</code>服务的稳定性，也就是看看正常持续的读写会不会导致<code>NAS</code>服务异常，这个其实通过<code>fio</code>或者<code>cosbench</code>这类的工具测试起来很容易，但是这样一是没有挑战性，二是比较机械，可扩展性低。比如并行测试、进程保护和异常通知等等这些是机械地运用工具测试所做不到的，所以我们尝试做了一套基于<code>NAS</code>稳定性测试的框架。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>整个测试框架打包和发布都是通过RPM的方式，方便测试人员一键部署。部署之后测试工作由<code>supervisor</code>管理，实时监控后台进程的运行状态，发生异常时可以进行重启等自动化操作。所有读写操作都是通过<code>python</code> 连接NAS服务，无需做任何挂载工作。主要测试工作是通过<code>celery</code>实现任务调度，支持并行多个NAS服务的读写测试，<code>broker</code>和<code>backend store</code>都采用了<code>rabbitmq</code>。后端注册了<code>register</code>、<code>nfs</code>、<code>cifs</code>和<code>ftp</code>四个<code>job</code>，定时每<code>10</code>分钟执行一次，设置最大开启<code>worker</code>数为<code>5</code>个。<code>Job</code>注册进消息队列中后，<code>celery worker</code>会自动去消费，针对服务器中不同的<code>NAS</code>服务进行读写操作，每个任务的执行结果最后都会记录在日志中，出了异常通过邮件通知管理员。</p><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>整个项目的框架图如下：</p><center><img src="http://cdn.tony-yin.site/NAS_Stable_Test%E6%A1%86%E6%9E%B6%E5%9B%BE.png" alt="Nas_Stable_Test架构图"></center><h2 id="NAS服务读写流程"><a href="#NAS服务读写流程" class="headerlink" title="NAS服务读写流程"></a>NAS服务读写流程</h2><p>由于每个<code>NAS</code>服务的测试方式是一致的，所以下面就以单个<code>NAS</code>服务的流程来介绍。首先<code>client</code>端向<code>server</code>的<code>NAS</code>服务端口发起连接，<code>server</code>端接收到<code>client</code>端的请求后建立连接。<code>Client</code>在<code>/tmp</code>目录下生成固定大小<code>1G</code>的文件，并且记录该文件的<code>MD5</code>值，然后将该文件上传至远端NAS服务目录（即对<code>NAS</code>服务进行写操作），上传完成后将该文件从本地删除。接着对之前上传至<code>NAS</code>服务目录的文件进行下载（即对<code>NAS</code>服务进行读操作），下载完成后再次记录文件<code>MD5</code>值，并删除掉远端<code>NAS</code>服务目录对应的文件。最后对两次记录的<code>MD5</code>值进行比较，判断上传和下载的文件是否一致，并将比较结果记录在日志中，再次删除本地下载的文件。<code>NAS</code>服务读写流程图如下：</p><center><img src="http://cdn.tony-yin.site/NAS_Stable_Test%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Nas_Stable_Test流程图"></center><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装libnfs"><a href="#安装libnfs" class="headerlink" title="安装libnfs"></a>安装libnfs</h3><p>通过<code>pip</code>安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install libnfs</span><br></pre></td></tr></table></figure><p>一般会报这个错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libnfs/libnfs_wrap.c:2969:25: fatal error: nfsc/libnfs.h: No such file or directory</span><br></pre></td></tr></table></figure><p>这个错看起来是缺少这个头文件的包，但是通过<code>yum search libnfs</code>是找不到相关的包的，所以我们只能去官网下载<code>rpm</code>包然后在安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 下载rpm</span><br><span class="line">wget http://li.nux.ro/download/nux/dextop/el7/x86_64//libnfs-1.9.8-1.el7.nux.x86_64.rpm</span><br><span class="line">wget http://li.nux.ro/download/nux/dextop/el7/x86_64//libnfs-devel-1.9.8-1.el7.nux.x86_64.rpm</span><br><span class="line">## 安装rpm</span><br><span class="line">yum localinstall libnfs-1.9.8-1.el7.nux.x86_64.rpm</span><br><span class="line">yum localinstall libnfs-devel-1.9.8-1.el7.nux.x86_64.rpm</span><br></pre></td></tr></table></figure><h3 id="安装pysmb"><a href="#安装pysmb" class="headerlink" title="安装pysmb"></a>安装pysmb</h3><p>这个比较简单，直接<code>pip</code>安装就可以了，也没遇到什么问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pysmb</span><br></pre></td></tr></table></figure><h2 id="NAS服务相关代码实现"><a href="#NAS服务相关代码实现" class="headerlink" title="NAS服务相关代码实现"></a>NAS服务相关代码实现</h2><p>这里只贴出部分<code>python</code>连接或者操作具体<code>Nas</code>服务的代码实现，如果想要了解或者贡献整个项目，请关注：<a href="https://github.com/tony-yin/python_nas" target="_blank" rel="noopener">Github python_nas项目</a></p><h3 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h3><h4 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def open(self):</span><br><span class="line">    self.nfs = libnfs.NFS(&apos;nfs://&#123;&#125;&apos;.format(self.mount_point))        </span><br><span class="line">    log.info(&apos;nfs connect successfully!&apos;)</span><br></pre></td></tr></table></figure><h4 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h4><p>这里有个关键点就是分段读写文件，避免内存溢出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def read(self):</span><br><span class="line">log.info(&apos;nfs read start...&apos;)</span><br><span class="line">a = self.nfs.open(&apos;/&#123;&#125;&apos;.format(self.filename), mode=&apos;r&apos;)          </span><br><span class="line">with open(self.download_path, &apos;a&apos;) as f:                          </span><br><span class="line">    while True: </span><br><span class="line">        content = a.read(1024*1024)                               </span><br><span class="line">        if content == &apos;&apos;:</span><br><span class="line">            break</span><br><span class="line">        f.write(content)                                          </span><br><span class="line">a.close()</span><br><span class="line">    log.info(&apos;nfs read end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def write(self, content):                                             </span><br><span class="line">log.info(&apos;nfs write start...&apos;)                                    </span><br><span class="line">a = self.nfs.open(&apos;/&#123;&#125;&apos;.format(self.filename), mode=&apos;w+&apos;)         </span><br><span class="line">a.seek(self.file_size)</span><br><span class="line">a.write(content)</span><br><span class="line">a.close()</span><br><span class="line">log.info(&apos;nfs write end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def delete(self):</span><br><span class="line">    log.info(&apos;nfs file delete start...&apos;)</span><br><span class="line">self.nfs.unlink(&apos;/&#123;&#125;&apos;.format(self.filename))</span><br><span class="line">log.info(&apos;nfs file delete end...&apos;)</span><br></pre></td></tr></table></figure><h3 id="CIFS"><a href="#CIFS" class="headerlink" title="CIFS"></a>CIFS</h3><h4 id="Connect-1"><a href="#Connect-1" class="headerlink" title="Connect"></a>Connect</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def open(self):</span><br><span class="line">    self.smb = SMBConnection(</span><br><span class="line">        self.username,</span><br><span class="line">        self.password,</span><br><span class="line">        self.my_name.encode(&apos;utf-8&apos;),</span><br><span class="line">        self.remote_name.encode(&apos;utf-8&apos;),</span><br><span class="line">        use_ntlm_v2=True</span><br><span class="line">    )</span><br><span class="line">    self.smb.connect(self.host, self.port)</span><br><span class="line">    log.info(&apos;cifs connect successfully!&apos;)</span><br></pre></td></tr></table></figure><h4 id="Read-1"><a href="#Read-1" class="headerlink" title="Read"></a>Read</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def read(self):</span><br><span class="line">    log.info(&apos;cifs read start...&apos;)</span><br><span class="line">    file_obj = open(self.download_path, &apos;wb&apos;)</span><br><span class="line">    self.smb.retrieveFile(</span><br><span class="line">        self.directory,</span><br><span class="line">        self.filename,</span><br><span class="line">        file_obj</span><br><span class="line">    )</span><br><span class="line">    file_obj.close()</span><br><span class="line">    log.info(&apos;cifs read end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Write-1"><a href="#Write-1" class="headerlink" title="Write"></a>Write</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def write(self):</span><br><span class="line">log.info(&apos;cifs write start...&apos;)</span><br><span class="line">file_obj = open(self.client_path, &apos;rb&apos;)</span><br><span class="line">self.smb.storeFile(</span><br><span class="line">    self.directory,</span><br><span class="line">    self.filename,</span><br><span class="line">    file_obj</span><br><span class="line"> )</span><br><span class="line">file_obj.close()</span><br><span class="line">log.info(&apos;cifs write end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Delete-1"><a href="#Delete-1" class="headerlink" title="Delete"></a>Delete</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def delete(self):</span><br><span class="line">log.info(&apos;cifs delete start...&apos;)</span><br><span class="line">self.smb.deleteFiles(&apos;path3&apos;, self.filename)</span><br><span class="line">log.info(&apos;cifs delete end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def close(self):</span><br><span class="line">    self.smb.close()</span><br></pre></td></tr></table></figure><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><h4 id="Connect-2"><a href="#Connect-2" class="headerlink" title="Connect"></a>Connect</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def open(self):</span><br><span class="line">    self.ftp = FTP()</span><br><span class="line">    self.ftp.connect(</span><br><span class="line">        host=self.host.encode(&apos;utf-8&apos;),</span><br><span class="line">        port=self.port.encode(&apos;utf-8&apos;)</span><br><span class="line">    )</span><br><span class="line">    self.ftp.login(self.username, self.password)</span><br><span class="line">    log.info(&apos;ftp connect successfully!&apos;)</span><br></pre></td></tr></table></figure><h4 id="Read-2"><a href="#Read-2" class="headerlink" title="Read"></a>Read</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def read(self):</span><br><span class="line">log.info(&apos;ftp read start...&apos;)                                     </span><br><span class="line">buff_size = 1024</span><br><span class="line">fp = open(self.download_path, &quot;wb&quot;)                               </span><br><span class="line">self.ftp.retrbinary(</span><br><span class="line">    &quot;RETR &#123;&#125;&quot;.format(self.filename),</span><br><span class="line">    fp.write,</span><br><span class="line">    buff_size                                                     </span><br><span class="line">)   </span><br><span class="line">fp.close()</span><br><span class="line">log.info(&apos;ftp read end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Write-2"><a href="#Write-2" class="headerlink" title="Write"></a>Write</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def write(self):</span><br><span class="line">log.info(&apos;ftp write start...&apos;)                                    </span><br><span class="line">buff_size = 1024</span><br><span class="line"> fp = open(self.client_path, &quot;rb&quot;)</span><br><span class="line">self.ftp.storbinary(</span><br><span class="line">    &quot;STOR &#123;&#125;&quot;.format(self.filename),</span><br><span class="line">    fp,</span><br><span class="line">   buff_size</span><br><span class="line">)</span><br><span class="line">fp.close()</span><br><span class="line">log.info(&apos;ftp write end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Delete-2"><a href="#Delete-2" class="headerlink" title="Delete"></a>Delete</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def delete(self):</span><br><span class="line">log.info(&apos;ftp delete start...&apos;)</span><br><span class="line">self.ftp.delete(self.filename)</span><br><span class="line">log.info(&apos;ftp delete end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Close-1"><a href="#Close-1" class="headerlink" title="Close"></a>Close</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def close(self):</span><br><span class="line">    self.ftp.quit(self.filename)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还有一些其他的<code>API</code>接口就不一一赘述了，具体实现细节大家可以查看<code>github</code>上面的项目代码，具体地址我会在文末贴出。整个项目的核心是通过<code>celery</code>实现任务的调度，还有全程通过<code>python</code>连接和操作<code>nas</code>服务，后续还会不断完善~~~</p><blockquote><p><strong>项目地址：</strong><a href="https://github.com/tony-yin/python_nas" target="_blank" rel="noopener">https://github.com/tony-yin/python_nas</a></p></blockquote><p><br></p><blockquote><p>参考列表：<br><a href="https://pypi.org/project/libnfs/" target="_blank" rel="noopener">python 操作samba文件服务器</a><br><a href="https://blog.csdn.net/u014245412/article/details/72286348" target="_blank" rel="noopener">python libnfs</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/nas.jpg&quot; alt=&quot;NAS Stable Test&quot;&gt;&lt;/center&gt;

&lt;p&gt;最近公司有个集群一直在跑着，领导想要测测它上面&lt;code&gt;NAS&lt;/code&gt;服务的稳定性，也就是看看正常持续的读写会不会导致&lt;code&gt;NAS&lt;/code&gt;服务异常，这个其实通过&lt;code&gt;fio&lt;/code&gt;或者&lt;code&gt;cosbench&lt;/code&gt;这类的工具测试起来很容易，但是这样一是没有挑战性，二是比较机械，可扩展性低。比如并行测试、进程保护和异常通知等等这些是机械地运用工具测试所做不到的，所以我们尝试做了一套基于&lt;code&gt;NAS&lt;/code&gt;稳定性测试的框架。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Python" scheme="https://tony-yin.github.io/tags/Python/"/>
    
      <category term="NAS" scheme="https://tony-yin.github.io/tags/NAS/"/>
    
  </entry>
  
  <entry>
    <title>Daily Article Vol 4 - (2018/3/1 ~ 2018/3/31)</title>
    <link href="https://tony-yin.github.io/2018/04/01/Daily_Article_Vol4/"/>
    <id>https://tony-yin.github.io/2018/04/01/Daily_Article_Vol4/</id>
    <published>2018-04-01T02:13:25.000Z</published>
    <updated>2018-12-13T16:40:24.421Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/2018_march.jpg" alt="Daily Article 3"></center><p>这个月主要因为离职和入职，花费了大量时间和相关的人沟通，还有办理了很多手续，包括找房子和搬家等等。真是忙的焦头烂额，奢侈地给自己放了一个星期的假期。</p><a id="more"></a><p>离开了工作了两年的公司，真是感慨万千。还没毕业就到这家公司实习，然后提前试用、转正。师父耐心的指导，无论是技术上还是生活上都受益匪浅，帮我扎实地掌握了一名软件开发工程师应该具备的技能；钱总作为<code>CTO</code>仿佛身上一直贴着技术控的标签，殊不知竟各项全能，机缘巧合带我做起了<code>Ceph</code>，这一年中不仅从钱总身上学到了很多高新技术，也从每次吃饭饭桌上、下班路上、地铁上倾听他年轻的故事中受益很多，常常听起来热血沸腾。还有很多帮助过我和关心过我的人就不一一点名了。总之，大家都很厉害，也正是因为如此，在我工作的两年中，我能够不断感受到压力，不断进步，并且以后会一直以你们为我的榜样，以后还要多多指教，多交流多切磋。</p><p>入职了新的公司，规模和规范都比原来上了一个档次，正式了许多，上下班都要打卡，一开始不习惯，下班总是忘记。。还有经常开会，要写很多设计和方案，感觉不像以后有师父和钱总这样带我走了，哈哈，但也多了很多参与感，大事小事都可以提出自己的想法，也可以从同事的想法中学习很多。也是巧合，之前网上因博客结缘的一位小伙伴现在和我同组，负责带我熟悉各方面，顿时轻松了很多，他人也很<code>nice</code>，看的出来很热爱技术，身上有很多值得我学习的点，算是一个挺优秀的同龄人了。总体来说，对新公司的印象还是不错的，好好加油吧！</p><p>这个月我买了极客时间上面陈皓老师（左耳朵耗子）的专栏，没买但想看的朋友可以点击我下面分享的链接观看，每个链接都有十个免费的观看圈，先到先到，如果觉得收获很大的话，建议买了看看，受益绝不止这<code>199</code>哦~~~</p><p>新公司任务调度用到了<code>celery</code>框架，感觉还蛮好用的，还在熟悉中…</p><ol><li><a href="http://www.sebastien-han.fr/blog/2015/04/27/ceph-manually-repair-object/" target="_blank" rel="noopener">Ceph: manually repair object</a>(3/2) <i class="fa fa-star"></i><i class="fa fa-star"></i> </li><li><a href="http://blog.csdn.net/younger_china/article/details/75150261" target="_blank" rel="noopener">【分析】Ceph数据一致性检查 - Scrub的介绍</a>(3/5)</li><li><a href="http://blog.csdn.net/younger_china/article/details/75149045" target="_blank" rel="noopener">【分析】Ceph数据一致性检查 - 端到端的数据校验</a>(3/5)</li><li><a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx5d7aad8e7ec33bfd&amp;redirect_uri=https%3A%2F%2Faccount.geekbang.org%2Faccount%2Foauth%2Fcallback%3Ftype%3Dwechatopen%26ident%3D60f4b1%26redirect%3Dhttps%253A%252F%252Ftime.geekbang.org%252Fcolumn%252Farticle%252F45c83454a044f89f8eff69b8a7dbeac3%252Fshare%253Ffailedurl%253Dhttps%253A%252F%252Ftime.geekbang.org%252Fcolumn%252Farticle%252F45c83454a044f89f8eff69b8a7dbeac3%252Fshare&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=d2b1c68fbd5a953da5f04515e46f9b48&amp;connect_redirect=1#wechat_redirect" target="_blank" rel="noopener">洞悉技术的本质，享受科技的乐趣</a>(3/17)</li><li><a href="https://time.geekbang.org/column/article/e3b6ea4c823d2c319bcbce9a1dc23501/share" target="_blank" rel="noopener">程序员如何用技术变现（上）</a>(3/17) <i class="fa fa-star"></i></li><li><a href="https://time.geekbang.org/column/article/c260269c38db5276c17f1be49718f74a/share" target="_blank" rel="noopener">程序员如何用技术变现（下）</a>(3/17)</li><li><a href="https://time.geekbang.org/column/article/70f255c35f7e58cb008e4410659cb39e/share" target="_blank" rel="noopener">Equifax信息泄露始末</a>(3/18)</li><li><a href="https://time.geekbang.org/column/article/3aa6350a995faf76c32e61ba6f7db3e9/share" target="_blank" rel="noopener">从Equifax信息泄露看数据安全</a>(3/18)</li><li><a href="https://time.geekbang.org/column/article/66c547af27e04afd4b7c2f8444d0971f/share" target="_blank" rel="noopener">何为技术领导力</a>(3/18)</li><li><a href="https://time.geekbang.org/column/article/0294f13512d5b6608115a601eb373287/share" target="_blank" rel="noopener">如何拥有技术领导力</a>(3/18)</li><li><a href="https://time.geekbang.org/column/article/5df06f61f6d635f5fc71b27ccc39902d/share" target="_blank" rel="noopener">每个程序员都该知道的事</a>(3/19)</li><li><a href="https://time.geekbang.org/column/article/af44ced83be43d287e728d2eaee10afc/share" target="_blank" rel="noopener">Go语言，Docker和新技术</a>(3/19)</li><li><a href="https://time.geekbang.org/column/article/946c705caf3299894fcc991bc59992de/share" target="_blank" rel="noopener">答疑解惑：渴望、热情和选择</a>(3/20)</li><li><a href="https://time.geekbang.org/column/article/ef3daa17d473e583835df8248082f6fc/share" target="_blank" rel="noopener">如何成为一个大家愿意追随的Leader？</a>(3/20)</li><li><a href="http://blog.51cto.com/hongtengfei/1684809" target="_blank" rel="noopener">NFS服务详细分析</a>(3/21) <i class="fa fa-star"></i></li><li><a href="http://blog.csdn.net/acs713/article/details/7322082" target="_blank" rel="noopener">理解Linux系统/etc/init.d目录和/etc/rc.local脚本</a>(3/21)</li><li><a href="https://time.geekbang.org/column/article/73253891c16c684d3c9dcfd02dfcb54f/share" target="_blank" rel="noopener">分布式系统架构的冰与火</a>(3/21) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://time.geekbang.org/column/article/a3b4de20403567fbdf305bdd4e403026/share" target="_blank" rel="noopener">从亚马逊的实践，谈分布式系统的难点</a>(3/22) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://blog.csdn.net/a18829898663/article/details/71065999" target="_blank" rel="noopener">访问网络文件共享服务-CIFS</a>(3/23) <i class="fa fa-star"></i></li><li><a href="https://www.liaoxuefeng.com/article/00137760323922531a8582c08814fb09e9930cede45e3cc000" target="_blank" rel="noopener">任务调度利器：Celery</a>(3/26)</li><li><a href="https://www.jianshu.com/p/1840035cb510" target="_blank" rel="noopener">异步任务神器 Celery 简明笔记</a>(3/26)</li><li><a href="http://www.open-open.com/lib/view/open1426298834326.html" target="_blank" rel="noopener">Python 并行分布式框架：Celery</a>(3/26) <i class="fa fa-star"></i></li><li><a href="https://www.jianshu.com/p/9c04890615ba" target="_blank" rel="noopener">Redis实现简单消息队列</a>(3/27) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://www.cnblogs.com/davidshen/p/8145984.html" target="_blank" rel="noopener">cifs协议与samba服务</a>(3/28~3/29) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://linuxtoy.org/archives/selinux-introduction.html" target="_blank" rel="noopener">SELinux 入门</a>(3/29)</li><li><a href="http://www.cnblogs.com/shanyou/archive/2013/02/04/2891300.html" target="_blank" rel="noopener">Ring Buffer 有什么特别?</a>(3/29) <i class="fa fa-star"></i></li><li><a href="https://time.geekbang.org/column/article/f9126577b469b13317889a99ea70d2f0/share" target="_blank" rel="noopener">分布式系统的技术栈</a>(3/30) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://time.geekbang.org/column/article/8efeb52c4015735a7ea424e0cff861c1/share" target="_blank" rel="noopener">分布式系统关键技术：全栈监控</a>(3/31) <i class="fa fa-star"></i><i class="fa fa-star"></i></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/2018_march.jpg&quot; alt=&quot;Daily Article 3&quot;&gt;&lt;/center&gt;

&lt;p&gt;这个月主要因为离职和入职，花费了大量时间和相关的人沟通，还有办理了很多手续，包括找房子和搬家等等。真是忙的焦头烂额，奢侈地给自己放了一个星期的假期。&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
      <category term="Daily-Article" scheme="https://tony-yin.github.io/tags/Daily-Article/"/>
    
  </entry>
  
  <entry>
    <title>硬件环境测试环境模拟</title>
    <link href="https://tony-yin.github.io/2018/03/09/Hardware-Test-Tool/"/>
    <id>https://tony-yin.github.io/2018/03/09/Hardware-Test-Tool/</id>
    <published>2018-03-09T06:35:06.000Z</published>
    <updated>2018-12-13T16:40:24.431Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/hardware-600x450.jpg" alt="hardware"></center><p>最近在做一个<code>feature</code>，测试的时候需要硬件环境的支撑。一般我们开发环境都是虚拟机，所以针对这种开发工作的自测无法进行，比如虚拟机上没有物理磁盘，没有<code>raid</code>卡等，为了一个小功能的测试，需要出<code>build</code>，需要硬件环境的部署和安装，这个工作量着实不小。</p><p>往往针对这种情况，作为开发人员可以针对硬件环境的具体需求，尽可能在自己的环境上做模拟，也就是我们俗称的“打桩”。</p><a id="more"></a><p>就拿我这次做的需求来说吧，我想获取磁盘的相关信息，获取方式是通过<code>raid</code>卡工具，可能是<code>megacli</code>，也可能是<code>sas3ircu</code>等等，这个取决于<code>lspci</code>查看<code>raid</code>卡的型号，然后还要通过<code>lsblk</code>和<code>lsscsi</code>工具获取相关信息。</p><p>我的做法是针对这些工具，自己写一个简易的小工具，就比如<code>lsblk</code>我也写一个<code>lsblk</code>的脚本，里面的代码也很简单，先找一个硬件环境，将<code>lsblk</code>读取的内容重定向到文件中，这时候我们自己写的脚本直接去读这个文件就可以了。务必要保证各个软件工具的一致性。</p><p>以<code>lsblk</code>为例，我可能需求两种情况<code>lsblk</code>和<code>lsblk -l</code>：</p><p><code>lsblk</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash                                                        </span></span><br><span class="line"></span><br><span class="line">lsblk_path=$(dirname $0)</span><br><span class="line">if [ $# -eq 0 ]; then</span><br><span class="line">    echo "$(cat $lsblk_path"/lsblk.txt")"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">while getopts ":l" opt; do</span><br><span class="line">    case $opt in  </span><br><span class="line">        l)  </span><br><span class="line">            echo "$(cat $lsblk_path"/lsblk_list.txt")"</span><br><span class="line">            ;;  </span><br><span class="line">        \?) </span><br><span class="line">            echo "Invalid option: -$OPTARG"</span><br><span class="line">            ;;  </span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><code>lsblk.txt</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">NAME     MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT </span><br><span class="line">sda        8:0    0   3.7T  0 disk </span><br><span class="line">├─sda1     8:1    0  30.5M  0 part ar</span><br><span class="line">├─sda2     8:2    0 488.3M  0 part ar</span><br><span class="line">├─sda3     8:3    0  93.1G  0 part /rt</span><br><span class="line">├─sda4     8:4    0   256G  0 part [SWAP]WA</span><br><span class="line">└─sda5     8:5    0   3.3T  0 part /data/osd.0sd</span><br><span class="line">sdb        8:16   0 372.1G  0 disk </span><br><span class="line">└─sdb1     8:17   0 372.1G  0 part ar</span><br><span class="line">sdc        8:32   0   2.7T  0 disk </span><br><span class="line">└─sdc1     8:33   0   2.7T  0 part /data/osd.1sd</span><br><span class="line">sdd        8:48   0   2.7T  0 disk </span><br><span class="line">└─sdd1     8:49   0   2.7T  0 part /data/osd.2sd</span><br><span class="line">sde        8:64   0   2.7T  0 disk </span><br><span class="line">└─sde1     8:65   0   2.7T  0 part /data/osd.3sd</span><br><span class="line">sdf        8:80   0   2.7T  0 disk </span><br><span class="line">└─sdf1     8:81   0   2.7T  0 part /data/osd.11d.</span><br><span class="line">sdg        8:96   0   2.7T  0 disk </span><br><span class="line">└─sdg1     8:97   0   2.7T  0 part /data/osd.12d.</span><br><span class="line">sdh        8:112  0   2.7T  0 disk </span><br><span class="line">└─sdh1     8:113  0   2.7T  0 part ar</span><br><span class="line">sdi        8:128  0   2.7T  0 disk </span><br><span class="line">└─sdi1     8:129  0   2.7T  0 part /data/osd.8sd</span><br><span class="line">sdj        8:144  0   2.7T  0 disk </span><br><span class="line">└─sdj1     8:145  0   2.7T  0 part /data/osd.9sd</span><br><span class="line">sdk        8:160  0   2.7T  0 disk </span><br><span class="line">└─sdk1     8:161  0   2.7T  0 part /data/osd.10d.</span><br><span class="line">sdl        8:176  0   2.7T  0 disk </span><br><span class="line">└─sdl1     8:177  0   2.7T  0 part ar</span><br><span class="line">sdm        8:192  0   2.7T  0 disk </span><br><span class="line">└─sdm1     8:193  0   2.7T  0 part ar</span><br><span class="line">sdn        8:208  0   2.7T  0 disk </span><br><span class="line">└─sdn1     8:209  0   2.7T  0 part ar</span><br><span class="line">sdo        8:224  0   2.7T  0 disk </span><br><span class="line">└─sdo1     8:225  0   2.7T  0 part</span><br><span class="line">sdp        8:240  0   2.7T  0 disk</span><br><span class="line">└─sdp1     8:241  0   2.7T  0 part</span><br><span class="line">sdq       65:0    0   2.7T  0 disk</span><br><span class="line">└─sdq1    65:1    0   2.7T  0 part</span><br><span class="line">sdr       65:16   0   2.7T  0 disk</span><br><span class="line">└─sdr1    65:17   0   2.7T  0 part</span><br><span class="line">sds       65:32   0   2.7T  0 disk</span><br><span class="line">└─sds1    65:33   0   2.7T  0 part</span><br><span class="line">sdt       65:48   0   2.7T  0 disk</span><br><span class="line">└─sdt1    65:49   0   2.7T  0 part</span><br><span class="line">sdu       65:64   0   2.7T  0 disk</span><br><span class="line">└─sdu1    65:65   0   2.7T  0 part</span><br><span class="line">sdv       65:80   0 744.7G  0 disk</span><br><span class="line">├─sdv1    65:81   0    50G  0 part</span><br><span class="line">├─sdv2    65:82   0    50G  0 part</span><br><span class="line">├─sdv3    65:83   0    50G  0 part</span><br><span class="line">├─sdv4    65:84   0    50G  0 part</span><br><span class="line">├─sdv5    65:85   0    50G  0 part</span><br><span class="line">├─sdv6    65:86   0    50G  0 part</span><br><span class="line">├─sdv7    65:87   0    50G  0 part</span><br><span class="line">├─sdv8    65:88   0    50G  0 part</span><br><span class="line">├─sdv9    65:89   0    50G  0 part</span><br><span class="line">├─sdv10   65:90   0    50G  0 part</span><br><span class="line">├─sdv11   65:91   0    50G  0 part</span><br><span class="line">└─sdv12   65:92   0    50G  0 part</span><br></pre></td></tr></table></figure><p><code>lsblk_list.txt</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0   3.7T  0 disk </span><br><span class="line">sda1     8:1    0  30.5M  0 part </span><br><span class="line">sda2     8:2    0 488.3M  0 part </span><br><span class="line">sda3     8:3    0  93.1G  0 part /</span><br><span class="line">sda4     8:4    0   256G  0 part [SWAP]</span><br><span class="line">sda5     8:5    0   3.3T  0 part /data/osd.0</span><br><span class="line">sdb      8:16   0 372.1G  0 disk </span><br><span class="line">sdb1     8:17   0 372.1G  0 part </span><br><span class="line">sdc      8:32   0   2.7T  0 disk </span><br><span class="line">sdc1     8:33   0   2.7T  0 part /data/osd.1</span><br><span class="line">sdd      8:48   0   2.7T  0 disk </span><br><span class="line">sdd1     8:49   0   2.7T  0 part /data/osd.2</span><br><span class="line">sde      8:64   0   2.7T  0 disk </span><br><span class="line">sde1     8:65   0   2.7T  0 part /data/osd.3</span><br><span class="line">sdf      8:80   0   2.7T  0 disk </span><br><span class="line">sdf1     8:81   0   2.7T  0 part /data/osd.11</span><br><span class="line">sdg      8:96   0   2.7T  0 disk </span><br><span class="line">sdg1     8:97   0   2.7T  0 part /data/osd.12</span><br><span class="line">sdh      8:112  0   2.7T  0 disk </span><br><span class="line">sdh1     8:113  0   2.7T  0 part </span><br><span class="line">sdi      8:128  0   2.7T  0 disk </span><br><span class="line">sdi1     8:129  0   2.7T  0 part /data/osd.8</span><br><span class="line">sdj      8:144  0   2.7T  0 disk </span><br><span class="line">sdj1     8:145  0   2.7T  0 part /data/osd.9</span><br><span class="line">sdk      8:160  0   2.7T  0 disk </span><br><span class="line">sdk1     8:161  0   2.7T  0 part /data/osd.10</span><br><span class="line">sdl      8:176  0   2.7T  0 disk </span><br><span class="line">sdl1     8:177  0   2.7T  0 part </span><br><span class="line">sdm      8:192  0   2.7T  0 disk </span><br><span class="line">sdm1     8:193  0   2.7T  0 part </span><br><span class="line">sdn      8:208  0   2.7T  0 disk </span><br><span class="line">sdn1     8:209  0   2.7T  0 part </span><br><span class="line">sdo      8:224  0   2.7T  0 disk </span><br><span class="line">sdo1     8:225  0   2.7T  0 part</span><br><span class="line">sdp      8:240  0   2.7T  0 disk</span><br><span class="line">sdp1     8:241  0   2.7T  0 part</span><br><span class="line">sdq     65:0    0   2.7T  0 disk</span><br><span class="line">sdq1    65:1    0   2.7T  0 part</span><br><span class="line">sdr     65:16   0   2.7T  0 disk</span><br><span class="line">sdr1    65:17   0   2.7T  0 part</span><br><span class="line">sds     65:32   0   2.7T  0 disk</span><br><span class="line">sds1    65:33   0   2.7T  0 part</span><br><span class="line">sdt     65:48   0   2.7T  0 disk</span><br><span class="line">sdt1    65:49   0   2.7T  0 part</span><br><span class="line">sdu     65:64   0   2.7T  0 disk</span><br><span class="line">sdu1    65:65   0   2.7T  0 part</span><br><span class="line">sdv     65:80   0 744.7G  0 disk</span><br><span class="line">sdv1    65:81   0    50G  0 part</span><br><span class="line">sdv2    65:82   0    50G  0 part</span><br><span class="line">sdv3    65:83   0    50G  0 part</span><br><span class="line">sdv4    65:84   0    50G  0 part</span><br><span class="line">sdv5    65:85   0    50G  0 part</span><br><span class="line">sdv6    65:86   0    50G  0 part</span><br><span class="line">sdv7    65:87   0    50G  0 part</span><br><span class="line">sdv8    65:88   0    50G  0 part</span><br><span class="line">sdv9    65:89   0    50G  0 part</span><br><span class="line">sdv10   65:90   0    50G  0 part</span><br><span class="line">sdv11   65:91   0    50G  0 part</span><br><span class="line">sdv12   65:92   0    50G  0 part</span><br></pre></td></tr></table></figure><p>还有一些其他工具我就不详细贴代码了，具体请去<code>github</code>上查看。</p><p>项目地址：<a href="https://github.com/tony-yin/Hardware_Test_Tool" target="_blank" rel="noopener">https://github.com/tony-yin/Hardware_Test_Tool</a></p><p>操作步骤：</p><p>1.下载代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:tony-yin/Hardware_Test_Tool.git</span><br></pre></td></tr></table></figure><p>2.安装工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build install</span><br></pre></td></tr></table></figure><p>3.卸载工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build uninstall</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/hardware-600x450.jpg&quot; alt=&quot;hardware&quot;&gt;&lt;/center&gt;

&lt;p&gt;最近在做一个&lt;code&gt;feature&lt;/code&gt;，测试的时候需要硬件环境的支撑。一般我们开发环境都是虚拟机，所以针对这种开发工作的自测无法进行，比如虚拟机上没有物理磁盘，没有&lt;code&gt;raid&lt;/code&gt;卡等，为了一个小功能的测试，需要出&lt;code&gt;build&lt;/code&gt;，需要硬件环境的部署和安装，这个工作量着实不小。&lt;/p&gt;
&lt;p&gt;往往针对这种情况，作为开发人员可以针对硬件环境的具体需求，尽可能在自己的环境上做模拟，也就是我们俗称的“打桩”。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Test" scheme="https://tony-yin.github.io/tags/Test/"/>
    
  </entry>
  
</feed>
