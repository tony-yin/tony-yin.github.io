<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tony&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tony-yin.github.io/"/>
  <updated>2017-09-28T06:04:25.270Z</updated>
  <id>https://tony-yin.github.io/</id>
  
  <author>
    <name>Tony</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS判断对象是否为空</title>
    <link href="https://tony-yin.github.io/2017/09/28/JS-Object-Null/"/>
    <id>https://tony-yin.github.io/2017/09/28/JS-Object-Null/</id>
    <published>2017-09-28T06:01:42.000Z</published>
    <updated>2017-09-28T06:04:25.270Z</updated>
    
    <content type="html"><![CDATA[<p>今天在项目中发现一个<code>Bug</code>，通过<code>debug</code>发现最终的原因便是判断对象是否为空导致的错误，一个小小的错误反映出<code>Javascript</code>这门语言的不严谨性，也提醒我们得熟悉它的一些技巧和原理，避免经常在一些问题上踩坑</p><a id="more"></a><p>场景还原：通过<code>if(object)</code>判断对象内容不为空，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">obj = &#123;&#125;;   // obj其实是通过其他方式获得，但是它的内容为空</div><div class="line">if (obj) &#123;</div><div class="line">        xxx;    // 判断当obj不为空的时候，执行判断内的代码</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>那么问题就出现了，即使对象内容为空，这个判断代码块里面的代码还是会被执行<br>用<code>chrome</code>简单的验证了一下：</p><center><img src="http://ow0mgad6r.bkt.clouddn.com/object_empty.png" alt="object empty"></center><p>这和一些其他语言不一样，比如<code>php</code>,<code>python</code>是可以通过<code>if(object)</code>来检查对象是否为空的，但是<code>JS</code>不可以，这个问题要不是遇到了肯定想不到</p><p>那么<code>JS</code>如何判断对象内容是否为空呢？网上搜了下，大概有以下方式：</p><h3 id="通过JSON-stringify将对象转换成字符串进行判断"><a href="#通过JSON-stringify将对象转换成字符串进行判断" class="headerlink" title="通过JSON.stringify将对象转换成字符串进行判断"></a>通过JSON.stringify将对象转换成字符串进行判断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var tt = &#123;&#125;;</div><div class="line">if (JSON.stringify(tt) == &quot;&#123;&#125;&quot;) &#123;</div><div class="line">        console.log(&apos;tt is not empty!&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="通过读取对象元素"><a href="#通过读取对象元素" class="headerlink" title="通过读取对象元素"></a>通过读取对象元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var tt = &#123;&#125;;</div><div class="line">var t = &#123;id: 1&#125;;</div><div class="line">if (tt.id) &#123;</div><div class="line">        console.log(&apos;tt is not empty!&apos;);</div><div class="line">&#125; </div><div class="line">if (t.id) &#123;</div><div class="line">        console.log(&apos;t is not empty&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>方法1相对于方法2来说更加严谨，阅读性高，而方法2的效率却比方法1高</p><h3 id="jQuery提供了判断对象是否为空的API"><a href="#jQuery提供了判断对象是否为空的API" class="headerlink" title="jQuery提供了判断对象是否为空的API"></a>jQuery提供了判断对象是否为空的API</h3><p>如果用的是<code>jquery</code>的话，可以使用其提供的现有方法：<code>isEmptyObject</code>,这是<code>jQuery1.4</code>版本后加入的功能，具体用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var tt = &#123;&#125;; </div><div class="line">if ($.isEmptyObject(tt)) &#123;  // jQuery.isEmptyObject(tt)这样调用也可以</div><div class="line">        console.log(&apos;tt is empty!&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="判断对象是否存在"><a href="#判断对象是否存在" class="headerlink" title="判断对象是否存在"></a>判断对象是否存在</h3><p>借助上面的问题，顺便了解了一下：<a href="http://www.ruanyifeng.com/blog/2011/05/how_to_judge_the_existence_of_a_global_object_in_javascript.html" target="_blank" rel="external">如何判断Javascript对象是否存在</a></p><p>这篇文章里面讲的还是比较全面的，针对不同场景给出了不同的方案</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在项目中发现一个&lt;code&gt;Bug&lt;/code&gt;，通过&lt;code&gt;debug&lt;/code&gt;发现最终的原因便是判断对象是否为空导致的错误，一个小小的错误反映出&lt;code&gt;Javascript&lt;/code&gt;这门语言的不严谨性，也提醒我们得熟悉它的一些技巧和原理，避免经常在一些问题上踩坑&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Javascript" scheme="https://tony-yin.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>OSD创建和删除全过程</title>
    <link href="https://tony-yin.github.io/2017/09/27/OSD-Create-And-Delete/"/>
    <id>https://tony-yin.github.io/2017/09/27/OSD-Create-And-Delete/</id>
    <published>2017-09-27T15:05:36.000Z</published>
    <updated>2017-09-28T06:05:56.148Z</updated>
    
    <content type="html"><![CDATA[<p><code>OSD</code>是<code>Ceph</code>中最基本也是最常用的功能，所以经常的创建和删除操作少不了，然后这个两个过程并不是一两个命令那么简单，本文就<code>OSD</code>的创建和删除进行内容进行步骤分离和讲解，结尾还有一份一键删除指定<code>OSD</code>的脚本</p><a id="more"></a><h2 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h2><h3 id="创建一个OSD"><a href="#创建一个OSD" class="headerlink" title="创建一个OSD"></a>创建一个OSD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd create [uuid]   #若没有uuid参数，则该命令自动生成一个uuid。该命令产生一个新的osd-number</div></pre></td></tr></table></figure><h3 id="为新的OSD创建默认的工作目录"><a href="#为新的OSD创建默认的工作目录" class="headerlink" title="为新的OSD创建默认的工作目录"></a>为新的OSD创建默认的工作目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir -p /var/lib/ceph/osd/ceph-&#123;osd-number&#125;</div></pre></td></tr></table></figure><h3 id="为新的OSD准备一块磁盘"><a href="#为新的OSD准备一块磁盘" class="headerlink" title="为新的OSD准备一块磁盘"></a>为新的OSD准备一块磁盘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkfs.xfs -f /dev/vde </div><div class="line">mount /dev/vde /var/lib/ceph/osd/ceph-&#123;osd-number&#125;</div></pre></td></tr></table></figure><h3 id="初始化新的OSD工作目录"><a href="#初始化新的OSD工作目录" class="headerlink" title="初始化新的OSD工作目录"></a>初始化新的OSD工作目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-osd -i &#123;osd-number&#125; --mkfs --mkkey</div></pre></td></tr></table></figure><blockquote><p> 注意：在执行上述命令前要求新的OSD工作目录必须为空</p></blockquote><h3 id="注册新的OSD认证密钥"><a href="#注册新的OSD认证密钥" class="headerlink" title="注册新的OSD认证密钥"></a>注册新的OSD认证密钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph auth add osd.&#123;osd-number&#125; osd &apos;allow *&apos; mon &apos;allow rwx&apos; -i /var/lib/ceph/osd/ceph-&#123;osd-number&#125;/keyring</div></pre></td></tr></table></figure><h3 id="将新的OSD添加到Crush-Map中"><a href="#将新的OSD添加到Crush-Map中" class="headerlink" title="将新的OSD添加到Crush Map中"></a>将新的OSD添加到Crush Map中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd crush add osd.&#123;osd-number&#125; &#123;weight&#125; [&#123;bucketype&#125;=&#123;bucket-name&#125;......&#125;</div></pre></td></tr></table></figure><p>此步骤也可以添加buckets后再添加osd，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ceph osd crush add-bucket node5 host     #创建一个名字为node5的bucket</div><div class="line">ceph osd crush move node5 root=default    #将创建出来的bucket放到root下</div><div class="line">ceph osd crush create-or-move osd.&#123;osd-number&#125; 1.0 root=default host=node5     #将新的OSD添加到node5下</div></pre></td></tr></table></figure><h3 id="将新的OSD信息填写到ceph-conf中"><a href="#将新的OSD信息填写到ceph-conf中" class="headerlink" title="将新的OSD信息填写到ceph.conf中"></a>将新的OSD信息填写到ceph.conf中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[osd.&#123;osd-number&#125;]</div><div class="line">host = &#123;hostname&#125;</div><div class="line">devs = /dev/vde</div></pre></td></tr></table></figure><h3 id="启动新的OSD"><a href="#启动新的OSD" class="headerlink" title="启动新的OSD"></a>启动新的OSD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/ceph start osd.&#123;osd-number&#125;</div></pre></td></tr></table></figure><blockquote><p>此时通过集群状态查看命令#ceph -s可以看到OSD数量以及up和in的数量都发生了变化，此时再通过命令#ceph -w可以看到ceph经过peering状态后，最终达到active+clean状态</p></blockquote><h2 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h2><h3 id="将需要删除的OSD在集群中的状态修改为out状态"><a href="#将需要删除的OSD在集群中的状态修改为out状态" class="headerlink" title="将需要删除的OSD在集群中的状态修改为out状态"></a>将需要删除的OSD在集群中的状态修改为out状态</h3><p>假定<code>osd</code>的<code>id</code>为<code>1</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd out osd.1</div></pre></td></tr></table></figure><h3 id="停止OSD进程"><a href="#停止OSD进程" class="headerlink" title="停止OSD进程"></a>停止OSD进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/ceph stop osd.1</div></pre></td></tr></table></figure><h3 id="将OSD从crush-map中删除"><a href="#将OSD从crush-map中删除" class="headerlink" title="将OSD从crush map中删除"></a>将OSD从crush map中删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ceph osd crush remove osd.1    #删除指定的OSD</div><div class="line">ceph osd crush remove node1    #删除OSD所在的bucket（此步骤可以不做）</div></pre></td></tr></table></figure><h3 id="清除到OSD的认证密钥"><a href="#清除到OSD的认证密钥" class="headerlink" title="清除到OSD的认证密钥"></a>清除到OSD的认证密钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph auth del osd.1</div></pre></td></tr></table></figure><h3 id="在OSD-Map中清除OSD"><a href="#在OSD-Map中清除OSD" class="headerlink" title="在OSD Map中清除OSD"></a>在OSD Map中清除OSD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd rm 1</div></pre></td></tr></table></figure><h3 id="从ceph-conf中清除OSD"><a href="#从ceph-conf中清除OSD" class="headerlink" title="从ceph.conf中清除OSD"></a>从ceph.conf中清除OSD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[osd.1]</div><div class="line">    host = &#123;hostname&#125;</div><div class="line">    ...</div></pre></td></tr></table></figure><h2 id="一键删除OSD脚本"><a href="#一键删除OSD脚本" class="headerlink" title="一键删除OSD脚本"></a>一键删除OSD脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#! /usr/bin/bash</div><div class="line"></div><div class="line">osd_id=$1</div><div class="line">ceph osd out osd.$osd_id</div><div class="line">/etc/init.d/ceph stop osd.$osd_id</div><div class="line">ceph osd crush remove osd.$osd_id</div><div class="line">ceph auth del osd.$osd_id</div><div class="line">ceph osd rm $osd_id</div><div class="line"># 清空 ceph.conf</div></pre></td></tr></table></figure><p>参考链接：</p><blockquote><p><a href="https://my.oschina.net/linuxhunter/blog/539312" target="_blank" rel="external">https://my.oschina.net/linuxhunter/blog/539312</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;OSD&lt;/code&gt;是&lt;code&gt;Ceph&lt;/code&gt;中最基本也是最常用的功能，所以经常的创建和删除操作少不了，然后这个两个过程并不是一两个命令那么简单，本文就&lt;code&gt;OSD&lt;/code&gt;的创建和删除进行内容进行步骤分离和讲解，结尾还有一份一键删除指定&lt;code&gt;OSD&lt;/code&gt;的脚本&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="OSD" scheme="https://tony-yin.github.io/tags/OSD/"/>
    
  </entry>
  
  <entry>
    <title>How-To-Forge-Product</title>
    <link href="https://tony-yin.github.io/2017/09/21/How-To-Forge-Product/"/>
    <id>https://tony-yin.github.io/2017/09/21/How-To-Forge-Product/</id>
    <published>2017-09-21T05:57:34.000Z</published>
    <updated>2017-09-21T06:26:40.504Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/gh.gif" alt="product"></center><p>今天<code>BOSS</code>带来一个曾经的得力干将。目前是腾讯一家游戏公司的老总，职位为<code>Producer</code>，在产品方面分享很多观点，受益匪浅。下面是分享过程中我总结的一些自己觉得正确的观点和心得</p><blockquote><p>虽热目前我是一个只负责敲代码的程序猿，产品这种事情好像跟我没多大关系，应该是产品经理的事情，但是其实一个<code>coder</code>想要进步，不仅仅是技术水平越来越强，对产品的理解也非常重要。这能理清自己逻辑，能够发散思维，能够帮你做出更好的产品，你开发出一个没人用的产品和一个上线客户量很大的产品对你自己来说无论是成就感还是技术提升都是天壤之别。也许未来我们可能也会创业，那到时候我们的职责可能是老板，可能是产品，可能是研发，更可能是各种职能集一身，对产品拥有良好理解和恰当的打磨技巧对我们来说都是宝贵的财富。</p></blockquote><a id="more"></a><h2 id="技能心态"><a href="#技能心态" class="headerlink" title="技能心态"></a>技能心态</h2><h3 id="工作强度"><a href="#工作强度" class="headerlink" title="工作强度"></a>工作强度</h3><p><code>BAT</code>加班不比任何一家中小公司少，腾讯一直把自己当做创业型公司，时刻保持压力和紧张感，这或许是其成功的一个很重要的原因（意料之外，之前没想到<code>BAT</code>工作强度这么大）</p><h3 id="不用过多的Design"><a href="#不用过多的Design" class="headerlink" title="不用过多的Design"></a>不用过多的Design</h3><p>因为没有一个产品可以凭借设计文档一步到位的，几乎每个成功的产品都和原来的设计有着天壤之别（仁者见仁，智者见智，把握一个度吧，没必要死扣设计为了最完美化而浪费大量的时间）</p><h3 id="没有具体的Deadline"><a href="#没有具体的Deadline" class="headerlink" title="没有具体的Deadline"></a>没有具体的Deadline</h3><p>每天都是<code>Deadline</code>，每天规定的任务做好了再回去</p><h3 id="谁的声音大听谁的"><a href="#谁的声音大听谁的" class="headerlink" title="谁的声音大听谁的"></a>谁的声音大听谁的</h3><p>不要在内部为了争执一个方案纠结和浪费太多时间，谁的声音大听谁的，因为这绝不是最后一次修改（有性格）</p><h3 id="产品是每个人的"><a href="#产品是每个人的" class="headerlink" title="产品是每个人的"></a>产品是每个人的</h3><p>一个人不应该被他的职位所局限，产品团队中的每个人都应该为这个产品在设计、宣传和包装等方面提意见</p><h3 id="Just-Do-It"><a href="#Just-Do-It" class="headerlink" title="Just Do It"></a>Just Do It</h3><p>很多事情自己不做一下是不知道的，很多行为看起来很low，不符合你的职位，但是只有真正去做了，才代表走过这条路，你才知道这条路可不可行，还有哪些其他路可以尝试（那位大佬制作某款卡牌游戏时，自己找了同类<code>50</code>多种游戏都玩了一遍，而且都玩到了很<code>6</code>的地步，用他的话说最后玩到吐。。。）</p><h3 id="相信自己的潜力"><a href="#相信自己的潜力" class="headerlink" title="相信自己的潜力"></a>相信自己的潜力</h3><p>永远不要觉得自己是做技术的，所以理所当然<code>UI</code>不擅长，宣传不擅长，包装不擅长，做一行就要把自己的头埋进去，逼着自己不断尝试，慢慢可能会发现自己做的不错（他们经常会亲自去<code>QQ</code>群、贴吧和其他社交平台宣传，我去，托这种事原来真的存在）</p><h3 id="学会成熟"><a href="#学会成熟" class="headerlink" title="学会成熟"></a>学会成熟</h3><p>对很多事情都要慢慢做到心里有底，比如清楚上线必有<code>Bug</code>，设计必会被颠覆（他说上线没问题他会很慌。。。）</p><h3 id="明确最终目的"><a href="#明确最终目的" class="headerlink" title="明确最终目的"></a>明确最终目的</h3><p>要明确做产品，开发等工作的目的不是按时完成任务，而是要把产品做起来，最终目的是赚钱，这样你做其他类型的事情就可以想明白很多，有时候开发并不一定是最优先最重要的，植物，但是作为一个开发经历了这些事情你的思维会不一样，做事方向也会不一样</p><h3 id="观察用户习惯"><a href="#观察用户习惯" class="headerlink" title="观察用户习惯"></a>观察用户习惯</h3><p>可以尝试花钱请人来使用产品，内部开发人员在背后观察它的使用习惯，不轻易提示</p><h3 id="用数据说话"><a href="#用数据说话" class="headerlink" title="用数据说话"></a>用数据说话</h3><p>当产品上线后，通过数据采集和分析，哪个页面或者操作用户比较感兴趣，哪一步开始用户量变少，出现这种情况，可以尝试做几个版本，然后让用户使用，选择最优的方案（在这个环节不以职位高低说话，完全靠数据评断）</p><h3 id="要相信自己的技术"><a href="#要相信自己的技术" class="headerlink" title="要相信自己的技术"></a>要相信自己的技术</h3><p>相信自己可以实现用户提的所有需求，当你全身心投入一件事的时候，手段很多，解决的方案也很多，比如这位大佬述说他收集一款游戏的同类游戏的经历，收集渠道除了iOS的还有android的，还有韩国市场的，还有模拟器的，还有页游等等（只有想不到，没有做不到）</p><h3 id="抄袭不丢脸"><a href="#抄袭不丢脸" class="headerlink" title="抄袭不丢脸"></a>抄袭不丢脸</h3><p>互联网产品从<code>0</code>到<code>1</code>很少很少，大家在做一个产品之前都会看看同类产品怎么做的，然后学习每个产品中的精华部分，这个说直接一点就是抄袭，但是不要因为这个觉得丢脸，因为抄袭容易，抄袭得好并不容易（谈到腾讯，大家都会因为<strong>抄袭</strong>而骂声不绝，但是静下想想这的确是个正常套路，一切为了快速出产品）</p><h3 id="不要害怕被告"><a href="#不要害怕被告" class="headerlink" title="不要害怕被告"></a>不要害怕被告</h3><p>等哪天你某些方面抄袭别人的，导致被告，那么说明你已经做大了，产品在某个方面来说已经相当成功了</p><h3 id="被骂是极好的"><a href="#被骂是极好的" class="headerlink" title="被骂是极好的"></a>被骂是极好的</h3><p>很多时候，用户会因为产品一些蹩脚的地方而骂声不断，这时候不要觉得丢脸或者懊恼，相反应该开心，因为很多时候别人愿意骂你说明很大程度上还是很喜欢这个产品的，而真正不喜欢的懒得留下评论</p><h2 id="产品本身"><a href="#产品本身" class="headerlink" title="产品本身"></a>产品本身</h2><h3 id="快速出Demo"><a href="#快速出Demo" class="headerlink" title="快速出Demo"></a>快速出Demo</h3><p>以上说的不用过多<code>Design</code>也好，还是不要过分争执也好，都是为了尽快做出一个产品<code>Demo</code>，就是最起码可以一个<code>work</code>的东西，这很重要，一旦<code>work</code>之后很多想法就会不一样了，他们往往两个星期出一个<code>Demo</code>，这对他们<code>UI</code>来说很有挑战，因为一般设计就要一个星期，然后原型图又是一个星期，但是两个星期就得弄出来，不管是借鉴别人的也好，还是网上买模板也好</p><h3 id="不用太完善"><a href="#不用太完善" class="headerlink" title="不用太完善"></a>不用太完善</h3><p>快速做出来不是说实现所有功能和面面俱到，而是可以做到静态页面或者是设计图去找用户，询问他们的观点和建议，这样既可以缩短时间，也可以通过询问客户的意见走向正确的道路，避免不必要的返工</p><h3 id="尽快让产品上线"><a href="#尽快让产品上线" class="headerlink" title="尽快让产品上线"></a>尽快让产品上线</h3><p>产品上线和不上线是天壤之别，因为自己内部永远是在想当然，而客户的反馈才是最重要的，这样才会往正确的方向不断迭代</p><h3 id="永远不要给用户看到错误信息"><a href="#永远不要给用户看到错误信息" class="headerlink" title="永远不要给用户看到错误信息"></a>永远不要给用户看到错误信息</h3><p>能解决的让系统自己解决，不能解决的人工处理，不要太<strong>实诚</strong>，否则用户会感觉到惊恐</p><h3 id="不要给用户太多选择"><a href="#不要给用户太多选择" class="headerlink" title="不要给用户太多选择"></a>不要给用户太多选择</h3><p>如果一个页面存在两个按钮让用户点击，<code>80%</code>的用户会点<code>A</code>按钮，<code>20%</code>的用户会点<code>B</code>按钮，那么页面就显示一个<code>A</code>按钮就好了，只要保证<code>B</code>按钮能够在页面其他地方能找到就可以了，太多选择会让用户心里没底自己选择的对不对（相信大家脑海里都会浮现某个用户做完一个操作询问对不对的场景吧？）</p><h3 id="数字必有颜色"><a href="#数字必有颜色" class="headerlink" title="数字必有颜色"></a>数字必有颜色</h3><p>这是一个约定俗成的习惯，保证页面的数字有合适的颜色，让用户一眼就能看到最想呈现的元素</p><h3 id="科技感很重要"><a href="#科技感很重要" class="headerlink" title="科技感很重要"></a>科技感很重要</h3><p>要让页面充满科技感，让别人觉得这是一家充满互联网气息的新公司，第一印象好</p><h3 id="恰当的图标"><a href="#恰当的图标" class="headerlink" title="恰当的图标"></a>恰当的图标</h3><p>图标选择要有意义，凸出按钮的作用</p><h3 id="恰当的名词"><a href="#恰当的名词" class="headerlink" title="恰当的名词"></a>恰当的名词</h3><p>用词准备具体，不要让用户去猜，比如下载就是下载，不要说保存</p><h3 id="易懂高大上的名词"><a href="#易懂高大上的名词" class="headerlink" title="易懂高大上的名词"></a>易懂高大上的名词</h3><p>用词不要太专业，这样会让用户不明白，可以高大上一些，比如远程数据复制可以叫云复制</p><h3 id="抓住用户的期望"><a href="#抓住用户的期望" class="headerlink" title="抓住用户的期望"></a>抓住用户的期望</h3><p>产品介绍要突出用户最期望的东西，而不是过分强调技术上面的高档，这不是客户最期望的东西，比如存储你与其说内部实现机制怎么分片，怎么自动控制，不如和用户说我能保证多少数据量的存储，能保证永远不会因为故障丢失数据，能存储多长时间等等</p><h3 id="调节气氛的话语"><a href="#调节气氛的话语" class="headerlink" title="调节气氛的话语"></a>调节气氛的话语</h3><p>多用网络诙谐的话语进行提示，比如亲，朕等等，这样会舒畅用户的心情</p><p>作者： Tony<br>日期： 2017/09/19</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/gh.gif&quot; alt=&quot;product&quot;&gt;&lt;/center&gt;

&lt;p&gt;今天&lt;code&gt;BOSS&lt;/code&gt;带来一个曾经的得力干将。目前是腾讯一家游戏公司的老总，职位为&lt;code&gt;Producer&lt;/code&gt;，在产品方面分享很多观点，受益匪浅。下面是分享过程中我总结的一些自己觉得正确的观点和心得&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虽热目前我是一个只负责敲代码的程序猿，产品这种事情好像跟我没多大关系，应该是产品经理的事情，但是其实一个&lt;code&gt;coder&lt;/code&gt;想要进步，不仅仅是技术水平越来越强，对产品的理解也非常重要。这能理清自己逻辑，能够发散思维，能够帮你做出更好的产品，你开发出一个没人用的产品和一个上线客户量很大的产品对你自己来说无论是成就感还是技术提升都是天壤之别。也许未来我们可能也会创业，那到时候我们的职责可能是老板，可能是产品，可能是研发，更可能是各种职能集一身，对产品拥有良好理解和恰当的打磨技巧对我们来说都是宝贵的财富。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="summary" scheme="https://tony-yin.github.io/categories/summary/"/>
    
    
      <category term="产品" scheme="https://tony-yin.github.io/tags/%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>PHP-Excel 开发解决方案</title>
    <link href="https://tony-yin.github.io/2017/09/18/PHP-Excel/"/>
    <id>https://tony-yin.github.io/2017/09/18/PHP-Excel/</id>
    <published>2017-09-18T10:37:28.000Z</published>
    <updated>2017-09-20T11:50:15.758Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/office-card-game.png" alt="office"></center><p> 过去工作中使用<code>PHPExcel</code>较多，碰到并解决了各种大大小小的问题，总结出这样一篇文章，一方面记录自己踩过的坑，一方面与大家分享，让大家少走弯路，并不断完善之，欢迎大家去<code>github</code>上面<code>star</code>和提交<code>pull request</code>，不断补充和优化，打造最全面的<code>PHPExcel</code>开发解决方案</p><p>Github 地址：<a href="https://github.com/tony-yin/PHPExcel_Road" target="_blank" rel="external">https://github.com/tony-yin/PHPExcel_Road</a><br>原文地址：<a href="https://tony-yin.github.io/2017/09/18/PHP-Excel/">https://tony-yin.github.io/2017/09/18/PHP-Excel/</a></p><a id="more"></a><h2 id="基础：小试牛刀"><a href="#基础：小试牛刀" class="headerlink" title="基础：小试牛刀"></a>基础：小试牛刀</h2><h3 id="1-引用文件"><a href="#1-引用文件" class="headerlink" title="1. 引用文件"></a>1. 引用文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yourpath . /phpexcel/PHPExcel.php</div></pre></td></tr></table></figure><h3 id="2-实例化phpexcel类"><a href="#2-实例化phpexcel类" class="headerlink" title="2. 实例化phpexcel类"></a>2. 实例化phpexcel类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$excel = new PHPExcel();</div></pre></td></tr></table></figure><h3 id="3-获取当前单sheet（多sheet会在下面讲）"><a href="#3-获取当前单sheet（多sheet会在下面讲）" class="headerlink" title="3. 获取当前单sheet（多sheet会在下面讲）"></a>3. 获取当前单sheet（多sheet会在下面讲）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$objexcel = $excel-&gt;getActiveSheet();</div></pre></td></tr></table></figure><h3 id="4-合并单元格"><a href="#4-合并单元格" class="headerlink" title="4. 合并单元格"></a>4. 合并单元格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$objexcel-&gt;mergeCells(&apos;A1:M1&apos;);</div></pre></td></tr></table></figure><h3 id="5-获取一个cell的样式"><a href="#5-获取一个cell的样式" class="headerlink" title="5. 获取一个cell的样式"></a>5. 获取一个cell的样式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$objexcel-&gt;getStyle(&apos;A1&apos;);</div></pre></td></tr></table></figure><ul><li>获取一个cell的字体样式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$cellFont = $objexcel-&gt;getStyle(&apos;A1&apos;)-&gt;getFont();</div></pre></td></tr></table></figure><ul><li>设置字体大小</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$fontStyle-&gt;setSize(15);</div></pre></td></tr></table></figure><ul><li>设置字体是否加粗</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$fontStyle-&gt;setBold(true);</div></pre></td></tr></table></figure><ul><li>设置字体颜色</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$fontStyle-&gt;getColor()-&gt;setARGB(PHPExcel_Style_Color::COLOR_RED);</div></pre></td></tr></table></figure><ul><li>获取一行样式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$rowStyle = $objexcel-&gt;getStyle(1)-&gt;getRowDimension();</div></pre></td></tr></table></figure><ul><li>设置行高度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$rowStyle-&gt;setRowHeight(2);</div></pre></td></tr></table></figure><ul><li>获取一列样式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$columnStyle = $objexcel-&gt;getStyle(&apos;A&apos;)-&gt;getColumnDimension();</div></pre></td></tr></table></figure><ul><li>设置列宽度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$columnStyle-&gt;setWidth(10);</div></pre></td></tr></table></figure><ul><li>获取一列对齐样式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$alignStyle = $objexcel-&gt;getStyle(&apos;A&apos;)-&gt;getAlignment();</div></pre></td></tr></table></figure><ul><li>设置水平居中：同一水平线上居中，即为左右的中间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$alignStyle&gt;setHorizontal(PHPExcel_Style_Alignment::HORIZONTAL_CENTER);</div></pre></td></tr></table></figure><ul><li>设置垂直居中：同一垂直线居中，即为上下的中间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$alignStyle-&gt;setVertical(PHPExcel_Style_Alignment::VERTICAL_CENTER);</div></pre></td></tr></table></figure><ul><li>自动换行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$alignStyle-&gt;setWrapText(true);</div></pre></td></tr></table></figure><h3 id="6-获取指定版本excel写对象"><a href="#6-获取指定版本excel写对象" class="headerlink" title="6. 获取指定版本excel写对象"></a>6. 获取指定版本excel写对象</h3><p>如需更早的版本可将<code>Excel2007</code>换成<code>Excel5</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$write = PHPExcel_IOFactory::createWriter(&quot;xcel, &apos;Excel2007&apos;);</div></pre></td></tr></table></figure></p><h2 id="进阶：一些有用的小知识"><a href="#进阶：一些有用的小知识" class="headerlink" title="进阶：一些有用的小知识"></a>进阶：一些有用的小知识</h2><h3 id="1-行列数字索引方法"><a href="#1-行列数字索引方法" class="headerlink" title="1.行列数字索引方法"></a>1.行列数字索引方法</h3><blockquote><p><code>phpexcel</code>一般获取<code>cell</code>或者获取列都是通过<code>ABC</code>这样的英文字母获取的，它也可以通过<code>0、1、2、3</code>这样的数字表示sheet中的列，从<code>0</code>开始，<code>0</code>对应<code>A</code>，<code>1</code>对应<code>B</code>，基本上大多数方法都是数字行列索引，例如<code>getStyleByColumnAndRow($col,$row)</code>,默认列参数在前，行参数在后，更多的可以参加<code>phpexcel</code>源码；</p></blockquote><h3 id="2-单行或单列参数格式"><a href="#2-单行或单列参数格式" class="headerlink" title="2. 单行或单列参数格式"></a>2. 单行或单列参数格式</h3><blockquote><p>有的时候一个方法需要行列两个参数，例如只需要某一行参数可写成<code>(null, $row)</code>,例如只需要获得某一列参数可写成<code>($col, null)</code></p></blockquote><h3 id="3-列的数字索引格式和字母索引格式互转"><a href="#3-列的数字索引格式和字母索引格式互转" class="headerlink" title="3. 列的数字索引格式和字母索引格式互转"></a>3. 列的数字索引格式和字母索引格式互转</h3><ul><li>数字转字符串</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PHPExcel_Cell::columnIndexFromString(<span class="string">'A'</span>);  <span class="comment">// Return 1 not 0;</span></div></pre></td></tr></table></figure><ul><li>字符串转数字</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PHPExcel_Cell::stringFromColumnIndex(<span class="number">0</span>);    <span class="comment">// Return 'A';</span></div></pre></td></tr></table></figure><h3 id="4-PHPExcel读取数字类型"><a href="#4-PHPExcel读取数字类型" class="headerlink" title="4.PHPExcel读取数字类型"></a>4.PHPExcel读取数字类型</h3><blockquote><p><code>PHPExcel</code>读取的<code>cell</code>数字，类型都是<code>double</code>型，可用<code>gettyle()</code>方法检测类型，当初我一直使用<code>is_int()</code>方法无果，搞得焦头烂额。。。</p></blockquote><h3 id="5-多cell边框线设置"><a href="#5-多cell边框线设置" class="headerlink" title="5. 多cell边框线设置"></a>5. 多cell边框线设置</h3><p><code>PHPExcel</code>生成的表格如果你不加处理，是不会帮你生成边框线的，生成边框线的方法如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$borderArray = <span class="keyword">array</span>(</div><div class="line">    <span class="string">'borders'</span> =&gt; <span class="keyword">array</span>(</div><div class="line">        <span class="string">'allborders'</span> =&gt; <span class="keyword">array</span>(</div><div class="line">            <span class="string">'style'</span> =&gt; PHPExcel_Style_Border::BORDER_THIN</div><div class="line">        )</div><div class="line">    )</div><div class="line">);</div><div class="line">$objexcel-&gt;getStyle($col1, $row1,$col2, $row2)-&gt;applyFromArray($borderArray);</div></pre></td></tr></table></figure></p><blockquote><p>注：<br>1: <code>getStyle()</code>可以看需求改为<code>getStyleByColumnAndRow()</code>方法通过数字行列索引读取<code>style</code><br>2: array中<code>PHPExcel_Style_Border::</code>后面有三种格式分别是<code>BORDER_THIN</code>和<code>BORDR_MEDIUM</code>，表示边框线的粗细；<br>3: <code>getStyle()</code>中的索引可以是静态的，也可以是动态的，一般是在导出<code>excel</code>的数据<code>set</code>完毕后填写左上角的单元格行列索引和右下角的单元格行列索引；</p><p>参考资料</p><p><a href="http://phpexcel.codeplex.com/workitem/22160" target="_blank" rel="external">http://phpexcel.codeplex.com/workitem/22160</a><br><a href="http://phpexcel.codeplex.com/workitem/20150" target="_blank" rel="external">http://phpexcel.codeplex.com/workitem/20150</a></p></blockquote><h3 id="6-多cell字体加粗处理"><a href="#6-多cell字体加粗处理" class="headerlink" title="6. 多cell字体加粗处理"></a>6. 多cell字体加粗处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$objexcel-&gt;getStyle($pCoordinate)-&gt;applyFromArray(array(</div><div class="line">    &apos;font&apos; =&gt; array(  </div><div class="line">        &apos;bold&apos; =&gt; true,                                              </div><div class="line">    ),                                                               </div><div class="line">));</div></pre></td></tr></table></figure><h3 id="7-多cell字体颜色处理"><a href="#7-多cell字体颜色处理" class="headerlink" title="7. 多cell字体颜色处理"></a>7. 多cell字体颜色处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$objexcel-&gt;getStyle($pCoordinate)-&gt;applyFromArray(array(</div><div class="line">    &apos;font&apos; =&gt; array(</div><div class="line">        &apos;color&apos; =&gt; array(</div><div class="line">            &apos;rgb&apos; =&gt; &apos;ff0000&apos;,</div><div class="line">            ),</div><div class="line">        ),</div><div class="line">    )</div><div class="line">);</div></pre></td></tr></table></figure><h3 id="8-多sheet导入"><a href="#8-多sheet导入" class="headerlink" title="8. 多sheet导入"></a>8. 多sheet导入</h3><p>动态为当前<code>sheet</code>设置索引，然后获取当前<code>sheet</code>，便可循环读取每一个<code>sheet</code>内容</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$objexcel-&gt;setActiveSheetIndex($index);   <span class="comment">//$index = 0 1 2 3</span></div><div class="line">$objexcel-&gt;getActiveSheet();    <span class="comment">//return sheet1 sheet2 sheet 3</span></div></pre></td></tr></table></figure><h3 id="9-固定格式excel读取在写入"><a href="#9-固定格式excel读取在写入" class="headerlink" title="9. 固定格式excel读取在写入"></a>9. 固定格式excel读取在写入</h3><blockquote><p>当需求是给定一个一个模板<code>excel</code>，需要往里面塞数据，我们不一定要通过代码给它设定样式，如果这个模板变化不大，我们完全可以存放一个格式相同的静态文件，然后通过<code>PHPExcel</code>读取，再往里面塞数据，最后进行保存操作，可以达到一样的效果，并且可以节省大量的资源。</p></blockquote><h3 id="10-合并单元格导入问题"><a href="#10-合并单元格导入问题" class="headerlink" title="10. 合并单元格导入问题"></a>10. 合并单元格导入问题</h3><blockquote><p>在特殊的表格中，合并单元格普遍存在，而多个单元格合并成的一个单元格，只能<code>setValue()</code>一次，而我们如何判断合并单元格的具体行列呢？</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$range = $start_cell-&gt;getMergeRange();  <span class="comment">// 通过合并单元格的开始单元格比如‘A1’，获取合并范围‘A1:A4’</span></div><div class="line">$cell-&gt;isInRange($range);    <span class="comment">// 遍历之后每一个单元格便可通过isInRange()方法判断当前单元格是否在合并范围内</span></div></pre></td></tr></table></figure><h2 id="高级：特殊场景特殊手段"><a href="#高级：特殊场景特殊手段" class="headerlink" title="高级：特殊场景特殊手段"></a>高级：特殊场景特殊手段</h2><h3 id="1-单元格文本格式数据处理"><a href="#1-单元格文本格式数据处理" class="headerlink" title="1. 单元格文本格式数据处理"></a>1. 单元格文本格式数据处理</h3><blockquote><p>一般excel单元格中数据的格式为数据类型，而<code>PHPExcel</code>中的<code>getValue()</code>方法读取的也是数据类型，当把数据从数据类型改为文本类型后，在<code>PHPExcel</code>中读出来的是<code>PHPExcel_RichText</code>类型，<code>getValue()</code>读取返回<code>PHPExcel_RichText</code>是一个<code>object</code>类型（<code>PHPExcel_RichText</code>数据保存格式）；那如何读取这一类的数据呢？仔细查看读取出来的对象，不难发现有<code>getPlainText()</code>这样的方法可以读取文本类型数据，所以我们只要判断当当前数据为文本数据时用<code>getPlainText()</code>读取，一般数据用<code>getValue()</code>读取</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ($cell-&gt;getValue() <span class="keyword">instanceof</span> PHPExcel_RichText) &#123;</div><div class="line">    $value = $cell-&gt;getValue();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    $value = $cell-&gt;getValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>参考资料</p><p><a href="http://www.cnblogs.com/DS-CzY/p/4955655.html" target="_blank" rel="external">http://www.cnblogs.com/DS-CzY/p/4955655.html</a><br><a href="http://phpexcel.codeplex.com/discussions/34513" target="_blank" rel="external">http://phpexcel.codeplex.com/discussions/34513</a></p></blockquote><h3 id="2-单元格数据算法处理"><a href="#2-单元格数据算法处理" class="headerlink" title="2. 单元格数据算法处理"></a>2. 单元格数据算法处理</h3><blockquote><p><code>excel</code>拥有强大的算法功能，一般算法格式为<code>=A3+A4</code>这类的，复杂的更多，如果使用<code>PHPExcel</code>提供的默认读取方法<code>getValue()</code>读取出来的结果则为字符串<code>=A3+A4</code>,好在<code>PHPExcel</code>也足够强大，提供了相应的接口：<code>getCalculatedValue()</code>，这个方法专门读取算法数据，但是我们不能将这个方法作为默认读取方法，因为这样可能会将一些本来要读成字符串的读成算法数据，而且<code>PHPExcel</code>没有将它作为默认读取方法的另一个重要原因就是算法方式读取很耗时间和性能，一般数据读取根本没有必要这样浪费资源，所以我们可以采用以下这种方式</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (strstr($cell-&gt;getValue(), <span class="string">'='</span>)) &#123;   </div><div class="line">    <span class="comment">// 判断如果cell内容以=号开头便默认为算法数据</span></div><div class="line">    $value = $cell-&gt;getCalculatedValue(); </div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    $value = $cell-&gt;getValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-日期数据处理"><a href="#3-日期数据处理" class="headerlink" title="3. 日期数据处理"></a>3. 日期数据处理</h3><blockquote><p>除了以上所说的文本数据和算法数据外，我还遇到过日期类型数据，比如<code>2016-12-28</code>输入到<code>excel</code>中，它会默认转换成<code>2016/12/28</code>，如果采用一般的<code>getValue()</code>方式读取也会读取到错误的数据，<code>PHPExcel</code>也提供了相应的接口<code>getFormattedValue()</code>,并提供了适配的识别方式<code>PHPExcel_Shared_Date::isDateTime($cell)</code>,所以代码就很好实现了</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (PHPExcel_Shared_Date::isDateTime($cell)) &#123;</div><div class="line">    $value = $cell-&gt;getFormattedValue(); </div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    $value = $cell-&gt;getValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-读取方法封装"><a href="#4-读取方法封装" class="headerlink" title="4. 读取方法封装"></a>4. 读取方法封装</h3><blockquote><p>针对<code>excel</code>各种数据类型，我们可以写一个函数，将原有的<code>getValue()</code>封装一下，这样以后就不用每次都判别一下数据类型了，目前我只遇到上面三种特殊格式，如果有新的，欢迎大家补充，封装函数如下</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_value_of_cell</span><span class="params">($cell)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (strstr($cell-&gt;getValue(), <span class="string">'='</span>)) &#123;   </div><div class="line">        $value = $cell-&gt;getCalculatedValue(); </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ($cell-&gt;getValue() <span class="keyword">instanceof</span> PHPExcel_RichText) &#123;</div><div class="line">        $value = $cell-&gt;getValue();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PHPExcel_Shared_Date::isDateTime($cell)) &#123;</div><div class="line">        $value = $cell-&gt;getFormattedValue(); </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        $value = $cell-&gt;getValue();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="5-导出文件在IE、360等浏览器中文件名中文乱码问题"><a href="#5-导出文件在IE、360等浏览器中文件名中文乱码问题" class="headerlink" title="5. 导出文件在IE、360等浏览器中文件名中文乱码问题"></a>5. 导出文件在IE、360等浏览器中文件名中文乱码问题</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$filename = <span class="string">'xxx导出表'</span>;</div><div class="line"><span class="comment">// 判断如果是IE内核形式的浏览器采用urlencode处理文件名</span></div><div class="line"><span class="keyword">if</span> (!preg_match(<span class="string">"/Firefox/"</span>, $_SERVER[<span class="string">"HTTP_USER_AGENT"</span>])) &#123;</div><div class="line">    $filename = urlencode($filename);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>未完待续。。。<br>期待你的补充和优化</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/office-card-game.png&quot; alt=&quot;office&quot;&gt;&lt;/center&gt;

&lt;p&gt; 过去工作中使用&lt;code&gt;PHPExcel&lt;/code&gt;较多，碰到并解决了各种大大小小的问题，总结出这样一篇文章，一方面记录自己踩过的坑，一方面与大家分享，让大家少走弯路，并不断完善之，欢迎大家去&lt;code&gt;github&lt;/code&gt;上面&lt;code&gt;star&lt;/code&gt;和提交&lt;code&gt;pull request&lt;/code&gt;，不断补充和优化，打造最全面的&lt;code&gt;PHPExcel&lt;/code&gt;开发解决方案&lt;/p&gt;
&lt;p&gt;Github 地址：&lt;a href=&quot;https://github.com/tony-yin/PHPExcel_Road&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/tony-yin/PHPExcel_Road&lt;/a&gt;&lt;br&gt;原文地址：&lt;a href=&quot;https://tony-yin.github.io/2017/09/18/PHP-Excel/&quot;&gt;https://tony-yin.github.io/2017/09/18/PHP-Excel/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="PHP" scheme="https://tony-yin.github.io/tags/PHP/"/>
    
      <category term="PHPExcel" scheme="https://tony-yin.github.io/tags/PHPExcel/"/>
    
  </entry>
  
  <entry>
    <title>Disk pull and plug record</title>
    <link href="https://tony-yin.github.io/2017/09/10/Disk-pull-and-plug-record/"/>
    <id>https://tony-yin.github.io/2017/09/10/Disk-pull-and-plug-record/</id>
    <published>2017-09-09T18:21:45.000Z</published>
    <updated>2017-09-20T13:48:28.521Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/open-uri20150611-11-s7rw56.png" alt="pull disk"></center><p>最近在做磁盘拔插后的<code>OSD</code>热恢复功能。在反复拔插盘的实践过程中，遇到了一个难题，就是时常会由于拔盘，然后再插盘后盘符发生了改变，<code>kernel</code>和<code>udev</code>接收不到任何<code>device</code>增加或删除的事件消息，<br>由于我是基于<code>udev</code>监测磁盘的插拔，所以一旦感知不到的话，就无法进行相应的恢复操作，所以在此对拔盘的记录进行一些记录，并在大量操作中得出总结。</p><a id="more"></a><h2 id="Operation-Record"><a href="#Operation-Record" class="headerlink" title="Operation Record"></a>Operation Record</h2><p><code>normal</code>: 表示正常情况，没有被拔</p><table><thead><tr><th style="text-align:center">env</th><th style="text-align:center">udev monitor</th><th style="text-align:center">UI data</th><th style="text-align:center">disk alias</th><th style="text-align:center">device</th><th style="text-align:center">lsblk</th><th style="text-align:center">mount info</th><th style="text-align:center">mount point </th></tr></thead><tbody><tr><td style="text-align:center">normal</td><td style="text-align:center">-</td><td style="text-align:center">/dev/sdg1</td><td style="text-align:center">osd4-data</td><td style="text-align:center">/dev/sdg</td><td style="text-align:center">exist</td><td style="text-align:center">exist</td><td style="text-align:center">/data/osd.1</td></tr><tr><td style="text-align:center">first pull</td><td style="text-align:center">remove sdg</td><td style="text-align:center">empty</td><td style="text-align:center">remove</td><td style="text-align:center">remove</td><td style="text-align:center">remove</td><td style="text-align:center">exist</td><td style="text-align:center">exist, readerror</td></tr><tr><td style="text-align:center">first plug</td><td style="text-align:center">add sdd</td><td style="text-align:center">/dev/sdd1</td><td style="text-align:center">osd4-data</td><td style="text-align:center">/dev/sdd</td><td style="text-align:center">exist</td><td style="text-align:center">exist</td><td style="text-align:center">exist, readerror</td></tr><tr><td style="text-align:center">second pull</td><td style="text-align:center">no remove</td><td style="text-align:center">empty</td><td style="text-align:center">osd4-data</td><td style="text-align:center">/dev/sdd</td><td style="text-align:center">not change</td><td style="text-align:center">exist</td><td style="text-align:center">exist, readerror</td></tr><tr><td style="text-align:center">second plug</td><td style="text-align:center">All Not Change</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">- </td></tr><tr><td style="text-align:center">clear mount</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">exist</td><td style="text-align:center">-</td><td style="text-align:center">exist</td><td style="text-align:center">remove</td><td style="text-align:center">change style</td></tr><tr><td style="text-align:center">third pull</td><td style="text-align:center">remove sdd</td><td style="text-align:center">empty</td><td style="text-align:center">remove</td><td style="text-align:center">remove</td><td style="text-align:center">remove</td><td style="text-align:center">remove</td><td style="text-align:center">change style</td></tr><tr><td style="text-align:center">third plug</td><td style="text-align:center">add sdd</td><td style="text-align:center">/dev/sdd1</td><td style="text-align:center">osd4-data</td><td style="text-align:center">/dev/sdd</td><td style="text-align:center">exist</td><td style="text-align:center">exist</td><td style="text-align:center">exist, readerror</td></tr></tbody></table><h2 id="Before-pull"><a href="#Before-pull" class="headerlink" title="Before pull"></a>Before pull</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/before_pull.png" alt="before pull"></center><h2 id="First-pull"><a href="#First-pull" class="headerlink" title="First pull"></a>First pull</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/first_pull.png" alt="First pull"></center><h2 id="Read-error"><a href="#Read-error" class="headerlink" title="Read error"></a>Read error</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/readerror.png" alt="Read error"></center><h2 id="First-plug"><a href="#First-plug" class="headerlink" title="First plug"></a>First plug</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/first_plug.png" alt="First plug"></center><h2 id="Second-pull"><a href="#Second-pull" class="headerlink" title="Second pull"></a>Second pull</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/second_pull.png" alt="Second pull"></center><h2 id="Second-plug"><a href="#Second-plug" class="headerlink" title="Second plug"></a>Second plug</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/second_pull.png" alt="Second plug"></center><h2 id="Clear-mount-info"><a href="#Clear-mount-info" class="headerlink" title="Clear mount info"></a>Clear mount info</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/clear_mount.png" alt="Clear mount info"></center><h2 id="Third-plug-udev-monitor"><a href="#Third-plug-udev-monitor" class="headerlink" title="Third plug udev monitor"></a>Third plug udev monitor</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/third_plug.png" alt="Third pull"></center><h2 id="Third-plug"><a href="#Third-plug" class="headerlink" title="Third plug"></a>Third plug</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/third_plug_alias.png" alt="Third plug"></center><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>通过上面的表格和图片，如果拔盘前没有卸载<code>mount</code>链接，那么可以发现：</p><ul><li>下次插盘，磁盘名称不再是原来的名称，在当前排序最后的一个磁盘名往后追加，比如当前最后一块盘是<code>sdf</code>，那么就改名为<code>sdg</code></li><li><code>lsblk</code>显示<code>device</code>列表不会变化，<code>alias name</code>也是不会变化</li><li>再次拔盘，<code>device</code>列表不会变化，<code>udev monitor</code>不会接收到任何设备的删除的事件信息</li><li>再次插盘，<code>device</code>列表不会变化，<code>udev monitor</code>不会接收到任何设备的添加的事件信息</li></ul><p>如果清除了<code>mount</code>信息，插拔变得正常起来</p><ul><li><code>udev</code>可以正常接收设备添加和删除的信息</li><li><code>lsblk</code>可以正常显示设备列表，会随着磁盘的拔盘而更新显示，<code>alias name</code>也是如此</li><li>磁盘名称变回正常，即开机最原始的名称，例如上文的<code>sdd</code></li></ul><p>所以针对一块硬盘的拔插只要做好即时清除<code>mount</code>就够了，那么这个时候拔另外插槽的一块盘呢？<br>结果是：</p><ul><li>第一次拔盘： <code>udev</code>感知到（<code>remove</code> 当前磁盘名），<code>device</code>列表和<code>alias name</code>消失 </li><li>第一次插盘： <code>udev</code>感知到（<code>add</code> <strong>sdg</strong>），<code>device</code>增加了<code>sdg</code>，<code>alias name</code>增加，没有变化</li><li>第二次拔盘： 一切都没了反应</li><li>清除<code>mount</code>信息后，插盘：无反应</li><li>删除<code>alias name</code>： 无反应</li><li>无论怎么样都没反应，也许除了开机或者这快盘插在别的插槽内</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h3><p>目前来看，只要拔盘超过两块，一旦第二块盘的磁盘名称变了跟之前名称不一样，那么之后再怎么清理<code>mount</code>信息或者反复拔插都不会被<code>udev</code>感知到<br>理论上来说，要实现硬盘热替换，那就得保证<code>udev</code>每次都能检测到硬盘的插入，拔盘检测倒不是那么重要，<br>针对这种情况，目前没发现什么比较好的解决方案，唯一一种也是我当前采用的方案，在检测拔盘事件时会触发一个脚本，做拔的盘的<code>mount</code>信息的检查，如果存在<code>mount</code>信息，那么就<code>umount</code>掉，这是一种比较完美的场景，也就是说要保证每次插盘前，当前盘在系统中都不存在任何<code>mount</code>信息</p><p>这种方案还是太完美化了，还需要大量的测试，期望能找出更能经得起推敲的方案</p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>测试过程中偶然发现每次硬盘插入如果被<code>udev</code>感知到，也会执行大量的<code>udev rules</code>，其中包括创建设备，建立连接，建立连接这个事情就包括硬盘分区的<code>alias</code>，而我们感知到磁盘设备插入执行脚本在这之前，找了一系列的方案，都没能够使得让脚本在它<code>alias</code>之后再执行</p><p>这里有一份官方的解释：<a href="http://www.reactivated.net/writing_udev_rules.html#external-run" target="_blank" rel="external">http://www.reactivated.net/writing_udev_rules.html#external-run</a></p><p>至于为什么脚本依赖这个别名，那是因为系统存的<code>data path</code>还是<code>journal path</code>都是以别名的形式，如果我们能够在别名之后执行脚本，那么理想情况下系统<code>db</code>之前存的别名会自动和插入的盘匹配建立连接，不需要我们再做过多的事情，否则我们得在每次创建<code>osd</code>的时候再存原始路径，记录分区信息等等，还有<code>/etc/fstab</code>存的都是别名，这样就导致有些操作无法进行，还有一些其他的矛盾暂时还没想到</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/open-uri20150611-11-s7rw56.png&quot; alt=&quot;pull disk&quot;&gt;&lt;/center&gt;

&lt;p&gt;最近在做磁盘拔插后的&lt;code&gt;OSD&lt;/code&gt;热恢复功能。在反复拔插盘的实践过程中，遇到了一个难题，就是时常会由于拔盘，然后再插盘后盘符发生了改变，&lt;code&gt;kernel&lt;/code&gt;和&lt;code&gt;udev&lt;/code&gt;接收不到任何&lt;code&gt;device&lt;/code&gt;增加或删除的事件消息，&lt;br&gt;由于我是基于&lt;code&gt;udev&lt;/code&gt;监测磁盘的插拔，所以一旦感知不到的话，就无法进行相应的恢复操作，所以在此对拔盘的记录进行一些记录，并在大量操作中得出总结。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
      <category term="Osd" scheme="https://tony-yin.github.io/tags/Osd/"/>
    
      <category term="Disk" scheme="https://tony-yin.github.io/tags/Disk/"/>
    
      <category term="Udev" scheme="https://tony-yin.github.io/tags/Udev/"/>
    
  </entry>
  
  <entry>
    <title>Linux Udev</title>
    <link href="https://tony-yin.github.io/2017/09/10/Linux-Udev/"/>
    <id>https://tony-yin.github.io/2017/09/10/Linux-Udev/</id>
    <published>2017-09-09T18:20:27.000Z</published>
    <updated>2017-09-20T12:17:41.944Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/pingu.png" alt="udev"></center><p>在我入门<code>udev</code>，看着各种各样的资料觉得这个东西很高深的时候，突然瞄到一篇文章里面说道： 要树立一个信念：<code>udev</code>很简单，当时不以为然，现在深表赞同。看起来很高端很遥远的<code>Title</code>，比如<code>Linux Kernel</code>，比如软硬件交互，比如热插拔等等，其实掌握几个<code>rules</code>，然后再动手实践实践，对比着讲解，就能知道七七八八了，想要再深入，就多看看文档实现和内核源码，其实很多东西都是这样，了解了就很简单，没事了解一点就比别人多知道一些，共勉 </p><a id="more"></a><h2 id="Udev-是什么"><a href="#Udev-是什么" class="headerlink" title="Udev 是什么"></a>Udev 是什么</h2><p><code>udev</code>是<code>linux kernel</code>的设备管理器，处理硬件的添加和删除，但它的功能远远不仅于此。比如<code>U</code>盘插入，电脑是如何即时的做出响应？耳机插入又是如何做到自动关闭外部音量？这些都跟<code>udev</code>有关。虽然<code>udev</code>很强大，功能很多，本来就针对<code>SCSI</code>硬盘设备的插拔做一些经验的分享。至于为什么我会研究到这个东西，是因为最近在做<code>ceph</code>相关的项目，需要实现一个类似热插拔的<code>feature</code>，懂的人应该很清楚，就是拔插硬盘后，<code>osd</code>自动恢复，主要应用于硬盘寿命即将到期，替换新盘的场景，不明白的同学也不要紧，因为本文主要讨论的是<code>udev</code></p><h2 id="Udev-Rules"><a href="#Udev-Rules" class="headerlink" title="Udev Rules"></a>Udev Rules</h2><p><code>udev</code>管理各种各样的设备，比如<code>usb</code>,<code>scsi</code>,<code>cd</code>等等，为了区别设备类型，精确匹配，<code>udev</code>制定了一套特色的<code>rules</code>，为什么说特色呢？因为我觉得它用最简洁的语法满足了方方面面的需求</p><p>这里推荐一些有用的<code>link</code>：</p><ul><li><a href="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html" target="_blank" rel="external">UDEV Primer</a>  <code>udev</code>入门必读，可以快速将<code>udev</code>了解一番</li><li><a href="http://www.reactivated.net/writing_udev_rules.html" target="_blank" rel="external">Writing udev rules</a>  经典文章，看完这个基本就能掌握<code>udev rules</code></li><li><a href="http://www.lai18.com/content/1612267.html" target="_blank" rel="external">Writing udev rules 修订版</a>  国内论坛对格式样式做了一些修改，有洁癖的可以看看</li><li><a href="http://blog.csdn.net/nhczp/article/details/4099647" target="_blank" rel="external">Writing udev rules 译</a>  翻译版本，英文不好的可以中英文对比着看</li><li><a href="http://www.jinbuguo.com/systemd/udev.html#" target="_blank" rel="external">udev 中文手册</a>  这位金步国先生为开源事业做出了杰出的贡献，早前就看过他翻译的<code>Apache</code>的手册</li><li><a href="http://wiki.dreamrunner.org/public_html/Embedded-System/kernel/udev-rules.html" target="_blank" rel="external">Writing udev rules and kernel examples</a>  看够了上面各种规则，来看看具体的例子吧</li><li><a href="http://blog.csdn.net/lqrensn/article/details/8097288" target="_blank" rel="external">Udev 详解</a>  文章如名，真的很详细</li><li><a href="http://www.cnblogs.com/qigaohua/p/6673930.html" target="_blank" rel="external">Udev 使用方法</a>  一些特殊的技巧  </li></ul><p>大家看完上面的文章应该知道<code>rules</code>文件的位置和规则,下面我贴一些我实践中的代码和例子</p><h3 id="Rules-Example"><a href="#Rules-Example" class="headerlink" title="Rules Example"></a>Rules Example</h3><p>这是两条分别针对<code>SCSI</code>硬盘设备的添加和删除的<code>rules</code>，设备事件分别会触发相应的脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">KERNEL==&quot;sd[a-z]&quot;, ACTION==&quot;add&quot;, SUBSYSTEM==&quot;block&quot;, RUN+=&quot;/usr/bin/python /root/test.py %k add&quot;</div><div class="line">KERNEL==&quot;sd[a-z]&quot;, ACTION==&quot;remove&quot;, SUBSYSTEM==&quot;block&quot;, RUN+=&quot;/usr/bin/python /root/test.py %k remove&quot;</div></pre></td></tr></table></figure></p><h3 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h3><ul><li>执行外部命令必须加上环境变量路径, 上面的这个也可以不加<code>/usr/bin/python</code>，但是必须在<code>py</code>脚本头部加上<code>shebang</code>：<code>#! /usr/bin/python</code></li><li><code>RUN</code>可以运行程序外的程序，而<code>PROGRAM</code>不是做这个事情的，而是为了生成之后需要的变量</li></ul><h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><ul><li><a href="http://www.cnblogs.com/daishuguang/p/4192703.html" target="_blank" rel="external">hashtag and shebang</a></li><li><a href="http://smilejay.com/2012/03/linux_shebang/" target="_blank" rel="external">shebang</a></li></ul><h2 id="Udevadm"><a href="#Udevadm" class="headerlink" title="Udevadm"></a>Udevadm</h2><p><code>udevadm</code>是一个<code>udev</code>的管理工具，可以用来获取设备信息(<code>info</code>)，监视和控制udev运行时的行为(<code>control</code>)，请求内核事件(<code>trigger</code>)，管理事件队列(<code>settle</code>)，以及提供简单的调试机制(<code>test</code>)。很实用，很好用！！！</p><h3 id="推荐-Link"><a href="#推荐-Link" class="headerlink" title="推荐 Link"></a>推荐 Link</h3><ul><li><a href="http://www.jinbuguo.com/systemd/udevadm.html" target="_blank" rel="external">udevadm 中文手册</a>  很全，很基础 ~~</li><li><a href="http://fibrevillage.com/sysadmin/93-udevadm-usage-examples" target="_blank" rel="external">udevadm command examples</a>  很多<code>udevadm</code>的命令可以借鉴，说不定以后可以用到呢？</li></ul><p>介绍几个我具体使用过的例子：</p><h3 id="udevadm-info"><a href="#udevadm-info" class="headerlink" title="udevadm info"></a>udevadm info</h3><p>可以从<code>udev</code>数据库中提取设备信息,此外，还可以从<code>sysfs</code>中提取设备的属性， 以帮助创建与此设备匹配的<code>udev</code>规则</p><p>获取<code>/dev/sdb</code>的<code>path</code>信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">udevadm info -q path -n /dev/sdb</div></pre></td></tr></table></figure></p><h3 id="udevadm-test"><a href="#udevadm-test" class="headerlink" title="udevadm test"></a>udevadm test</h3><p>模拟向<code>udev</code>发送设备信息，并不会真的触发，<strong>而是将触发后的过程信息打印出来</strong>，对调试很有帮助</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">udevadm test --action=&apos;add&apos; `udevadm info -q path -n /dev/sdb`</div></pre></td></tr></table></figure><p><strong>注意：</strong> <code>test</code>不会真正触发事件，而<code>trigger</code>可以</p><h3 id="udevadm-trigger"><a href="#udevadm-trigger" class="headerlink" title="udevadm trigger"></a>udevadm trigger</h3><p>可以真正触发<code>udev</code>事件，但是不会真正改变硬件，只是触发<code>kernel</code>和<code>udev</code>的事件，会触发<code>udev rules</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">udevadm trigger -v --action=add --sysname-match=sda</div></pre></td></tr></table></figure><p><strong>注意：</strong> </p><ul><li>不加<code>sysname-match</code>那么会触发所有设备，如果是<code>action=remove</code>，那么则会移除很多设备，甚至导致<code>sshd</code>服务停掉</li><li>后面是<code>sda</code>而不是<code>/dev/sda</code>因为它是根据<code>pci</code>路径来定位<code>name</code>的，比如<code>sda</code>的路径是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/sys/devices/pci0000:00/0000:00:10.0/host2/target2:0:0/2:0:0:0/block/sda</div></pre></td></tr></table></figure></li></ul><h3 id="udevadm-control"><a href="#udevadm-control" class="headerlink" title="udevadm control"></a>udevadm control</h3><ul><li><p>重载<code>udev rules</code>，对之后触发的新设备有效，对之前已经触发的无效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">udevadm control --relaod-rules</div></pre></td></tr></table></figure></li><li><p>更改<code>udev</code>日志等级为<code>info</code>，<code>udev</code>默认等级为<code>err</code>，可以在<code>/etc/udev/udev.conf</code>中查看，日志具体信息可以在<code>syslog</code>中查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">udevadm control --log-priority=info</div></pre></td></tr></table></figure></li></ul><h2 id="More-about-udev"><a href="#More-about-udev" class="headerlink" title="More about udev"></a>More about udev</h2><p><code>udev</code>还有很多有意思的地方，如果想要更加深入的学习，那么除了熟练地掌握<code>rules</code>等技巧，还要对其实现原理有了解，这就得多看文档，多看源码了，建议大家有条件的情况下多看源码，多看原始的东西，因为经过别人的总结就可能会变味，相互对比，不要一味依赖别人总结的产物</p><ul><li><a href="https://my.oschina.net/bwhite/blog/808995" target="_blank" rel="external">Linux 自动挂载usb设备 小例子</a>  如何在<code>usb</code>设备插入后自动挂载？</li><li><a href="http://www.jianshu.com/p/dd6cecd7755a" target="_blank" rel="external">udev使用笔记</a>  这篇文章里面那张图片不错</li><li><a href="http://blog.csdn.net/fjb2080/article/details/5009791" target="_blank" rel="external">写个程序检测我们的设备插拔</a>  模仿内核源码简单地实现一个设备插拔的检测</li><li><a href="http://www.itnose.net/detail/6691523.html" target="_blank" rel="external">linux下热插拔事件的产生是怎样通知到用户空间</a>  事件传递过程，<code>udev</code>源码解析</li><li><a href="http://blog.csdn.net/bingqingsuimeng/article/details/7950639" target="_blank" rel="external">热插拔的工作原理 hotplug机制和udev</a>  <code>udev</code>原理讲解</li><li><a href="http://blog.csdn.net/sunweizhong1024/article/details/7928530" target="_blank" rel="external">Uevent 上报event事件给上层的详细讲解</a>  <code>uevent</code>源码讲解</li><li><a href="http://blog.csdn.net/bingqingsuimeng/article/details/7924756" target="_blank" rel="external">linux内核空间和用户空间的是怎样区别的，如何交互，如何从用户空间进入内核空间</a>  内核空间和用户空间的一些剖析</li><li><a href="http://blog.chinaunix.net/uid-24943863-id-3223000.html" target="_blank" rel="external">Netlink实现热拔插监控 </a>  消息传输用的是什么？<code>Netlink</code>是如何做到的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/pingu.png&quot; alt=&quot;udev&quot;&gt;&lt;/center&gt;

&lt;p&gt;在我入门&lt;code&gt;udev&lt;/code&gt;，看着各种各样的资料觉得这个东西很高深的时候，突然瞄到一篇文章里面说道： 要树立一个信念：&lt;code&gt;udev&lt;/code&gt;很简单，当时不以为然，现在深表赞同。看起来很高端很遥远的&lt;code&gt;Title&lt;/code&gt;，比如&lt;code&gt;Linux Kernel&lt;/code&gt;，比如软硬件交互，比如热插拔等等，其实掌握几个&lt;code&gt;rules&lt;/code&gt;，然后再动手实践实践，对比着讲解，就能知道七七八八了，想要再深入，就多看看文档实现和内核源码，其实很多东西都是这样，了解了就很简单，没事了解一点就比别人多知道一些，共勉 &lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
      <category term="Udev" scheme="https://tony-yin.github.io/tags/Udev/"/>
    
  </entry>
  
  <entry>
    <title>Magicloud Route</title>
    <link href="https://tony-yin.github.io/2017/09/10/Magicloud-Route/"/>
    <id>https://tony-yin.github.io/2017/09/10/Magicloud-Route/</id>
    <published>2017-09-09T18:19:35.000Z</published>
    <updated>2017-09-20T13:39:28.092Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/router.png" alt="router"></center><p><code>Magicloud</code>是我目前负责的一个基于<code>ceph</code>的分布式存储项目，为了方便刚刚参与项目的成员熟悉整个项目的路由并能够快速着手，在这里对整个项目的路由梳理了一下，以图形为主，凸出整个流程的走向</p><a id="more"></a><p><code>Magicloud</code>目前有两种方式进行前后端通信，一种是<code>Ajax</code>,一种是<code>Restful Api</code></p><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>以前台<code>UI</code>的主机角色获取所有<code>Osd</code>列表为例：</p><center><img src="http://on-img.com/chart_image/599851a6e4b0b7b347e0e378.png" alt="image"></center><h3 id="Restful-API"><a href="#Restful-API" class="headerlink" title="Restful API"></a>Restful API</h3><center><img src="http://on-img.com/chart_image/59994a6ae4b06df7265d5447.png" alt="image"></center>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/router.png&quot; alt=&quot;router&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;code&gt;Magicloud&lt;/code&gt;是我目前负责的一个基于&lt;code&gt;ceph&lt;/code&gt;的分布式存储项目，为了方便刚刚参与项目的成员熟悉整个项目的路由并能够快速着手，在这里对整个项目的路由梳理了一下，以图形为主，凸出整个流程的走向&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Route" scheme="https://tony-yin.github.io/tags/Route/"/>
    
  </entry>
  
  <entry>
    <title>Osd Enable and Disable</title>
    <link href="https://tony-yin.github.io/2017/09/10/Osd-Enable-and-Disable/"/>
    <id>https://tony-yin.github.io/2017/09/10/Osd-Enable-and-Disable/</id>
    <published>2017-09-09T18:18:33.000Z</published>
    <updated>2017-09-20T13:40:23.815Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/osd.gif" alt="osd"></center><p>对项目中<code>osd</code>的<code>enable</code>和<code>disable</code>的代码流程的总结</p><a id="more"></a><h2 id="Osd-Disable"><a href="#Osd-Disable" class="headerlink" title="Osd Disable"></a>Osd Disable</h2><p>1.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stop_ezs3_service: stop_ezs3_service</div></pre></td></tr></table></figure></p><p>2.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stop osd</div></pre></td></tr></table></figure></p><p>3.<code>disable osd</code></p><ul><li>load config: /etc/mcs3/storage.conf(存储卷的配置信息，即<code>osd</code>的配置信息)</li><li>service ganglia-monitor stop’ returns ‘Stopping Ganglia Monitor Daemon: gmond.</li><li>get osd id by osd name </li><li>stop osd<ul><li>ezs3-ha service_ceph stop osd0</li><li>kill -9 xxx</li><li>ceph osd down 0, ceph osd out 0, ceph osd rm 0</li></ul></li><li>disable osd</li><li>umount:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mount_point = &quot;/data/osd.&#123;&#125;&quot;.format(self.get_osd_id())</div><div class="line">if os.path.ismount(mount_point):</div><div class="line">umount -f -l /data/osd.0 ?</div><div class="line">   ......</div><div class="line">   sed -i &apos;\@/data/osd.0@d&apos; /etc/fstab</div></pre></td></tr></table></figure></li></ul><p>4.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete part_map</div></pre></td></tr></table></figure></p><p>5.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set partition map</div></pre></td></tr></table></figure></p><p>6.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cl.node_management.osd_disabled</div></pre></td></tr></table></figure></p><h2 id="Osd-Enable"><a href="#Osd-Enable" class="headerlink" title="Osd Enable"></a>Osd Enable</h2><ul><li>prepare enable osd</li><li>set public interace,cluster interface(if cluster interface is true) and save in ceph.conf (osd, interface等信息存放文件：/etc/ceph/ceph.conf)</li><li>consolidate_raid_configure<ul><li>查看池信息：/opt/MegaRAID/MegaCli/MegaCli64 -AdpBbuCMD -Aall |grep Exit |tr -d “\n”</li><li>a series of megaci command</li></ul></li><li>记录 osd 的状态： role.set(OSD, RoleState.ENABLING)</li><li>enable osd (@monlock ?)<ul><li>update task info(有空看下代码，如何实现ajax轮询的)</li><li>get_partition_map:</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">try: </div><div class="line">    kvstore.get(&apos;partition_map&apos;, timeout, timeout!=0) </div><div class="line">catch: </div><div class="line">    rados -p .ezs3 get partition_map -</div></pre></td></tr></table></figure><ul><li>stop ezs3 service</li><li>创建桶节点并且建立link</li><li>service ganglia-monitor stop</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if not host_osd_enabled: </div><div class="line">    ceph osd crush add-bucket &#123;&#125; host&quot;.format(crush_host_bucket)</div><div class="line">    ceph osd crush link &#123;&#125; pool=default&quot;.format(crush_host_bucket)</div></pre></td></tr></table></figure><ul><li>StorageVolume<ul><li>enable_osd<ul><li>ceph osd create</li><li>mount: mount -o noatime,user_xattr /dev/disk/by-partlabel/osd1-data /data/osd.0</li><li>add osd and save</li><li>ceph mon getmap -o /tmp/monmap（二进制文件）</li><li>ceph-osd -i {osd_id} –monmap /tmp/monmap –mkfs –mkjournal</li><li>start osd: <code>ezs3-ha service_ceph start osd0</code></li><li>ceph osd crush add {osd_id} 0 pool=default host={crush_host_bucket}</li><li>set osd uuid and osd post  stop command</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/osd.gif&quot; alt=&quot;osd&quot;&gt;&lt;/center&gt;

&lt;p&gt;对项目中&lt;code&gt;osd&lt;/code&gt;的&lt;code&gt;enable&lt;/code&gt;和&lt;code&gt;disable&lt;/code&gt;的代码流程的总结&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Osd" scheme="https://tony-yin.github.io/tags/Osd/"/>
    
  </entry>
  
  <entry>
    <title>Disk Mon Daemon</title>
    <link href="https://tony-yin.github.io/2017/09/10/Disk-Mon-Daemon/"/>
    <id>https://tony-yin.github.io/2017/09/10/Disk-Mon-Daemon/</id>
    <published>2017-09-09T18:17:19.000Z</published>
    <updated>2017-09-20T13:37:18.765Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/daemon.gif" alt="daemon"></center><p>最近在做监控<code>SSD</code>磁盘健康状态这个需求的时候，发现项目中专门针对磁盘写了一个<code>daemon</code>，之前对<code>daemon</code>只是表面上的了解，所以这次正好深入学习下,了解一下这样做的原因和好处以及如何在以后的工作中熟练运用<code>daemon</code><br><a id="more"></a></p><h2 id="Daemon相关知识了解"><a href="#Daemon相关知识了解" class="headerlink" title="Daemon相关知识了解"></a>Daemon相关知识了解</h2><ul><li><a href="http://www.linfo.org/daemon.html" target="_blank" rel="external">Daemon Definition</a></li><li><a href="https://stackoverflow.com/questions/17954432/creating-a-daemon-in-linux" target="_blank" rel="external">Creating a daemon in Linux</a></li><li><a href="http://www.enderunix.org/docs/eng/daemon.php" target="_blank" rel="external">Unix Daemon Server Programming</a></li><li><a href="http://www.netzmafia.de/skripten/unix/linux-daemon-howto.html" target="_blank" rel="external">Linux Daemon Writing HOWTO</a></li><li><a href="http://www.cnblogs.com/mickole/p/3188321.html" target="_blank" rel="external">守护进程详解及创建，daemon()使用</a></li></ul><h2 id="MCS3DiskMonitor-Daemon使用"><a href="#MCS3DiskMonitor-Daemon使用" class="headerlink" title="MCS3DiskMonitor Daemon使用"></a>MCS3DiskMonitor Daemon使用</h2><ol><li><code>pid</code>文件路径： <code>/var/run/mcs3-smart-monitor.pid</code></li><li><code>daemon</code>所在位置: <code>/etc/init.d/</code></li><li><code>log</code>打印位置：<code>/var/log/mccloudstor/mcs3-disk-mon.log</code></li><li>操作方式：</li></ol><ul><li><code>service mcs3-smart-monitor start</code></li><li><code>service mcs3-smart-monitor stop</code></li><li><code>service mcs3-smart-monitor restart</code></li></ul><blockquote><p>改动<code>daemon</code>相关代码，需<code>restart daemon</code>才可以生效</p></blockquote><h2 id="MCS3DiskMonitor-Daemon-process"><a href="#MCS3DiskMonitor-Daemon-process" class="headerlink" title="MCS3DiskMonitor Daemon process"></a>MCS3DiskMonitor Daemon process</h2><p><strong>1.</strong> 单位时间避免邮件重复发送： 通过声明一个全局变量<code>send_email_time</code>, 记录当前时间的一个小时的时间，一旦发送邮件立即更新该变量为当前时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">sent_mail_time = datetime.datetime.now() - datetime.timedelta(0,3600) # 1 hour</div><div class="line"></div><div class="line">def send_disk_status_notification(disk_status):</div><div class="line">    global sent_mail_time</div><div class="line">    now = datetime.datetime.now()</div><div class="line">    if now &lt; sent_mail_time + datetime.timedelta(0,3600):</div><div class="line">        logger.info(&quot;Notification sent within one hour before. System will not send again.&quot;)</div><div class="line">        return</div><div class="line">            host = socket.gethostname()</div><div class="line">    title = &quot;Host &#123;&#125; Disk Health Status Warning!&quot;.format(host)</div><div class="line">    message = disk_status</div><div class="line">    try:</div><div class="line">        utils.send_notification(title, message)</div><div class="line">        sent_mail_time = datetime.datetime.now()</div><div class="line">    except Exception as e:</div><div class="line">        logger.error(str(e))</div></pre></td></tr></table></figure><p><strong>2.</strong> 执行命令报错影响其他代码的执行，有以下几处命令执行：</p><p><code>line48</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">output = utils.do_cmd(&quot;zpool status|grep state&quot;, force=True)</div></pre></td></tr></table></figure></p><p><code>line71~75</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">VDSTATE1 = do_cmd(MEGACLI_BIN + &quot; -cfgdsply -aALL -NoLog | grep State&quot;) </div><div class="line">VDSTATE2 = do_cmd(MEGACLI_BIN + &quot; -AdpAllInfo -aALL -NoLog | grep Degraded&quot;)</div><div class="line">VDSTATE3 = do_cmd(MEGACLI_BIN + &quot; -AdpAllInfo -aALL -NoLog | grep Offline&quot;)</div><div class="line">PDSTATE1 = do_cmd(MEGACLI_BIN + &quot; -AdpAllInfo -aALL -NoLog | grep \&quot;Critical Disks\&quot;&quot;)</div><div class="line">PDSTATE2 = do_cmd(MEGACLI_BIN + &quot; -AdpAllInfo -aALL -NoLog | grep \&quot;Failed Disks\&quot;&quot;)</div></pre></td></tr></table></figure></p><blockquote><p>暂时处理方法：在这些方法的外面单独包一层<code>try catch</code></p></blockquote><p><strong>3.</strong> <code>SSD Disk</code>信息获取</p><ul><li>获取健康寿命</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">smartctl -a -d megaraid,&#123;&#125; &#123;&#125;|grep &apos;Media_Wearout_Indicator&apos;</div></pre></td></tr></table></figure><ul><li>获取磁盘序列号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">smartctl -a -d megaraid,&#123;&#125; &#123;&#125;|grep &apos;Serial Number&apos;</div></pre></td></tr></table></figure><ul><li>判断是否为SSD Disk：如果为<code>1</code>则为机械硬盘，如果为<code>0</code>则为<code>SSD Disk</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /sys/block/&#123;&#125;/queue/rotational  // param such as sda or sdb etc</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/daemon.gif&quot; alt=&quot;daemon&quot;&gt;&lt;/center&gt;


&lt;p&gt;最近在做监控&lt;code&gt;SSD&lt;/code&gt;磁盘健康状态这个需求的时候，发现项目中专门针对磁盘写了一个&lt;code&gt;daemon&lt;/code&gt;，之前对&lt;code&gt;daemon&lt;/code&gt;只是表面上的了解，所以这次正好深入学习下,了解一下这样做的原因和好处以及如何在以后的工作中熟练运用&lt;code&gt;daemon&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
      <category term="Daemon" scheme="https://tony-yin.github.io/tags/Daemon/"/>
    
  </entry>
  
  <entry>
    <title>Network Down Notification</title>
    <link href="https://tony-yin.github.io/2017/09/10/network-down-notification/"/>
    <id>https://tony-yin.github.io/2017/09/10/network-down-notification/</id>
    <published>2017-09-09T18:14:34.000Z</published>
    <updated>2017-09-20T13:40:00.985Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/it_specialist_kit8-net.png" alt="network"></center><p>项目中要做一个<code>network</code> <code>down</code>了之后给用户发送邮件提醒的功能，这里面涉及到的问题有：</p><ul><li>如何监测 network 状态</li><li>network down之后，如何发送邮件</li><li>public network 和 storage network的用处和场景</li></ul><a id="more"></a><h2 id="get-role-interfaces"><a href="#get-role-interfaces" class="headerlink" title="get role interfaces"></a>get role interfaces</h2><h2 id="get-interfaces"><a href="#get-interfaces" class="headerlink" title="get interfaces"></a>get interfaces</h2><h2 id="get-interface-info"><a href="#get-interface-info" class="headerlink" title="get interface info"></a>get interface info</h2><h3 id="获取-MAC-和-busid"><a href="#获取-MAC-和-busid" class="headerlink" title="获取 MAC 和 busid"></a>获取 MAC 和 busid</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">syspath = os.path.join(&quot;/sys/class/net/&quot;, interface)  // interface such as &apos;eth0&apos;</div><div class="line">mac = linecache.getline(os.path.join(syspath, &quot;address&quot;), 1)[:-1].upper()</div><div class="line">buspath = os.path.realpath(syspath)</div><div class="line">bus_id = os.path.basename(os.path.dirname(os.path.dirname(buspath)))</div></pre></td></tr></table></figure><ul><li>MAC: 直接在<code>syspath</code>目录下读取<code>address</code>文件</li><li>假设为<code>eth0</code>,查看<code>eth0</code>目录可见该目录被建立了软连接，并不是真实地址，所以需要取出它的真实地址，这个需要使用<code>python</code>中的<code>os.path.realpath()</code>处理获得<code>0000:03:00.0</code>,作为下一步<code>lspci</code>的参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@ceph133:/sys/class/net# ll eth0</div><div class="line">lrwxrwxrwx 1 root root 0  8月  8 01:26 eth0 -&gt; ../../devices/pci0000:00/0000:00:15.0/0000:03:00.0/net/eth0/</div></pre></td></tr></table></figure><h3 id="获取网卡信息"><a href="#获取网卡信息" class="headerlink" title="获取网卡信息"></a>获取网卡信息</h3><p><code>lspci -s</code>后面的参数为<code>pci</code>设备的地址，也叫<code>pci寻址</code>，这个地址由总线编号、插槽编号和功能块编号信息组成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lspci -m -s xxx // 这边的参数就是上面的bus_id</div></pre></td></tr></table></figure></p><blockquote><p>具体<code>lspci</code>信息请参照：<br><a href="http://coolnull.com/2246.html" target="_blank" rel="external">lspci命令详解</a><br><a href="http://blog.csdn.net/xiadidi/article/details/18408169" target="_blank" rel="external">LSPCI命令详解分析</a></p></blockquote><h3 id="获取网卡状态"><a href="#获取网卡状态" class="headerlink" title="获取网卡状态"></a>获取网卡状态</h3><p>通过<code>ethtool</code>工具获取网卡状态，就是看<code>Link detected</code>是否为<code>yes</code>，<code>yes</code>表示已激活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/sbin/ethtool eth0 | grep &apos;Link detected: yes&apos; | wc -l</div></pre></td></tr></table></figure><h2 id="bond-filter"><a href="#bond-filter" class="headerlink" title="bond filter"></a>bond filter</h2><h2 id="Network-down-notification"><a href="#Network-down-notification" class="headerlink" title="Network down notification"></a>Network down notification</h2><p><strong>1.</strong> 目前无论是<code>storage</code>还是<code>public</code>网卡只要<code>down</code>其中一个都无法发送<code>email</code>:</p><ul><li>public: <code>visit foreign network and connect smtp server</code></li><li>storage: <code>connect ceph rados to get notification info, such as send account and smtp server etc</code><br>所以只能<code>monitor</code>除这两个以外的网卡</li></ul><p><strong>2.</strong> <code>Python</code></p><ul><li><code>log</code>打印的文件取决于当前文件进程的初始化<code>log level</code></li><li><code>logger</code>: <code>handler</code>, <code>formatter</code>, <code>filter</code></li><li><code>dictdefault</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/it_specialist_kit8-net.png&quot; alt=&quot;network&quot;&gt;&lt;/center&gt;

&lt;p&gt;项目中要做一个&lt;code&gt;network&lt;/code&gt; &lt;code&gt;down&lt;/code&gt;了之后给用户发送邮件提醒的功能，这里面涉及到的问题有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何监测 network 状态&lt;/li&gt;
&lt;li&gt;network down之后，如何发送邮件&lt;/li&gt;
&lt;li&gt;public network 和 storage network的用处和场景&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Network" scheme="https://tony-yin.github.io/tags/Network/"/>
    
      <category term="Notification" scheme="https://tony-yin.github.io/tags/Notification/"/>
    
  </entry>
  
  <entry>
    <title>Python Oracle</title>
    <link href="https://tony-yin.github.io/2017/09/10/Python-Oracle/"/>
    <id>https://tony-yin.github.io/2017/09/10/Python-Oracle/</id>
    <published>2017-09-09T17:02:41.000Z</published>
    <updated>2017-09-20T13:41:03.575Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/tvbuildin.gif" alt="oracle"></center><p>近期在做<code>Intel</code>的测试，需要监测各种故障情况下的热恢复或者热迁移等功能，比如拔线测试，拔盘测试，断电测试等，来检验分布式的稳定性和灵活性，以<code>Oracle</code>为例，需要一直向数据库中写数据，然后在发生故障时，通过观察插入数据的情况来判断是否能够处理异常情况，所以我需要写一个脚本，能够做到通过<code>python</code>自动连接<code>oracle</code>数据库并自动插入数据。</p><a id="more"></a><blockquote><p>当前环境：Linux Centos 7</p></blockquote><h3 id="1-下载安装包cx-Oracle"><a href="#1-下载安装包cx-Oracle" class="headerlink" title="1. 下载安装包cx_Oracle"></a>1. 下载安装包cx_Oracle</h3><p>由于我本地<code>Python</code>版本是<code>2.7</code>,所以选择是<code>2.7</code>版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://pypi.python.org/packages/e1/18/00987c6a9af9568ee87d1fcba877407684a3f1b87515e5eb82d5d5acb9ff/cx_Oracle-6.0rc1-py27-1.x86_64.rpm#md5=ff8f5cce07bd5ec8ed3ce5c79d451474</div></pre></td></tr></table></figure><p>参考:</p><blockquote><ul><li><a href="https://oracle.github.io/python-cx_Oracle/" target="_blank" rel="external">python-cx_Oracle</a></li><li><a href="https://pypi.python.org/pypi/cx_Oracle/5.3" target="_blank" rel="external">安装包列表</a></li></ul></blockquote><h3 id="2-安装cx-Oracle"><a href="#2-安装cx-Oracle" class="headerlink" title="2. 安装cx_Oracle"></a>2. 安装cx_Oracle</h3><ul><li>安装：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm -ivh cx_Oracle-6.0rc1-py27-1.x86_64.rpm</div></pre></td></tr></table></figure><ul><li>查看当前<code>python</code>引入模块库的路径</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root ~]# python</div><div class="line">Python 2.7.5 (default, Nov  6 2016, 00:28:07) </div><div class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-11)] on linux2</div><div class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div><div class="line">&gt;&gt;&gt; import sys</div><div class="line">&gt;&gt;&gt; print sys.path</div><div class="line">[&apos;&apos;, &apos;/usr/lib/python2.7/site-packages/AliyunUtil-0.0.1-py2.7.egg&apos;, &apos;/usr/lib/python2.7/site-packages/cloud_init-0.7.6-py2.7.egg&apos;, &apos;/usr/lib64/python27.zip&apos;, &apos;/usr/lib64/python2.7&apos;, &apos;/usr/lib64/python2.7/plat-linux2&apos;, &apos;/usr/lib64/python2.7/lib-tk&apos;, &apos;/usr/lib64/python2.7/lib-old&apos;, &apos;/usr/lib64/python2.7/lib-dynload&apos;, &apos;/usr/lib64/python2.7/site-packages&apos;, &apos;/usr/lib/python2.7/site-packages&apos;]</div></pre></td></tr></table></figure><ul><li>检查安装路径，如果<code>cx_Oracle.so</code>文件不在以上<code>python</code>引入路径内需要将该文件拷贝到以上<code>python</code>引入路径,所以我这里不需要进行拷贝操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root ~]# rpm -qa | grep cx_Oracle | xargs rpm -ql</div><div class="line">/usr/lib64/python2.7/site-packages/cx_Oracle-6.0rc1-py2.7.egg-info</div><div class="line">/usr/lib64/python2.7/site-packages/cx_Oracle-6.0rc1-py2.7.egg-info/PKG-INFO</div><div class="line">/usr/lib64/python2.7/site-packages/cx_Oracle-6.0rc1-py2.7.egg-info/SOURCES.txt</div><div class="line">/usr/lib64/python2.7/site-packages/cx_Oracle-6.0rc1-py2.7.egg-info/dependency_links.txt</div><div class="line">/usr/lib64/python2.7/site-packages/cx_Oracle-6.0rc1-py2.7.egg-info/top_level.txt</div><div class="line">/usr/lib64/python2.7/site-packages/cx_Oracle.so</div></pre></td></tr></table></figure><h3 id="3-下载-Oracle-Library"><a href="#3-下载-Oracle-Library" class="headerlink" title="3. 下载 Oracle Library"></a>3. 下载 Oracle Library</h3><p>由于<code>Oracle</code>官网下载东西存在<code>Auth</code>认证，所以简单点就点击选中的<code>rpm</code>包保存在<code>windows</code>上，然后上传到<code>linux</code>上即可</p><p><strong>注意：</strong></p><blockquote><ul><li>下载的版本要和连接的<code>Oracle</code>基本一致，我需要连接的<code>oracle</code>版本是<code>11.2</code>，所以我下载的是<code>oracle-instantclient11.2-basic-11.2.0.3.0-1.x86_64.rpm</code></li><li><strong>操作系统要和之前下载的<code>cx_Oracle</code>要一致</strong>，这很重要！！！我在这个上面栽了跟头，花了比较多的时间。。。所以我需要下载<code>64</code>位的</li><li>在<code>Oracle</code>官网下载东西你得先勾选<code>Accept License Agreement</code>，否则你下载不了</li><li>其次你得有<code>Oracle</code>的账号</li></ul></blockquote><h3 id="4-安装-Oracle-Library"><a href="#4-安装-Oracle-Library" class="headerlink" title="4. 安装 Oracle Library"></a>4. 安装 Oracle Library</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm -ivh oracle-instantclient11.2-basic-11.2.0.3.0-1.x86_64.rpm</div></pre></td></tr></table></figure><h3 id="5-配置环境变量"><a href="#5-配置环境变量" class="headerlink" title="5. 配置环境变量"></a>5. 配置环境变量</h3><ul><li><strong>修改<code>Oracle</code>安装路径</strong></li></ul><p>将<code>client64</code>改为<code>client</code>，至于为什么要改暂时还不清楚，只知道不改的话会报错<code>Oracle Client library cannot be loaded: libclntsh.so: cannot open shared object file: No such file or directory</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /usr/lib/oracle/11.2/</div><div class="line">mv client64 client</div></pre></td></tr></table></figure><ul><li>打开<code>/etc/profile</code>,追加环境变量路径</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/profile</div></pre></td></tr></table></figure><ul><li>配置环境变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 查看Oracle安装路径</div><div class="line">[root@iZbp180vortqapb7yf8217Z ~]# rpm -qa | grep oracle | xargs rpm -ql</div><div class="line">/usr/lib/oracle/11.2/client64/bin/adrci</div><div class="line">/usr/lib/oracle/11.2/client64/bin/genezi</div><div class="line">/usr/lib/oracle/11.2/client64/lib/libclntsh.so.11.1</div><div class="line">/usr/lib/oracle/11.2/client64/lib/libnnz11.so</div><div class="line">/usr/lib/oracle/11.2/client64/lib/libocci.so.11.1</div><div class="line">/usr/lib/oracle/11.2/client64/lib/libociei.so</div><div class="line">/usr/lib/oracle/11.2/client64/lib/libocijdbc11.so</div><div class="line">/usr/lib/oracle/11.2/client64/lib/ojdbc5.jar</div><div class="line">/usr/lib/oracle/11.2/client64/lib/ojdbc6.jar</div><div class="line">/usr/lib/oracle/11.2/client64/lib/xstreams.jar</div><div class="line">// 追加ORACLE_HOME环境变量路径</div><div class="line">export ORACLE_HOME=/usr/lib/oracle/11.2/client64</div><div class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ORACLE_HOME/lib</div></pre></td></tr></table></figure><ul><li>生效配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.bashrc</div></pre></td></tr></table></figure><h3 id="6-检查是否可以引入cx-Oracle"><a href="#6-检查是否可以引入cx-Oracle" class="headerlink" title="6. 检查是否可以引入cx_Oracle"></a>6. 检查是否可以引入<code>cx_Oracle</code></h3><p><code>import</code>没有报错，说明之前的辛苦没有白费</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root client64]# python</div><div class="line">Python 2.7.5 (default, Nov  6 2016, 00:28:07) </div><div class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-11)] on linux2</div><div class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div><div class="line">&gt;&gt;&gt; import cx_Oracle</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure><h3 id="7-连接-Oracle"><a href="#7-连接-Oracle" class="headerlink" title="7. 连接 Oracle"></a>7. 连接 Oracle</h3><p>一个插入10条数据的Python脚本demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: UTF-8 -*-</div><div class="line">import cx_Oracle</div><div class="line">con = cx_Oracle.connect(&apos;test/test@xxx.xxx.xxx.xxx/xe&apos;)</div><div class="line">cur = con.cursor()</div><div class="line">for n in range(1, 10):</div><div class="line">    cur.execute(&apos;insert into test(id, name) values (1, n);&apos;)</div><div class="line">cur.close()</div><div class="line">con.close()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/tvbuildin.gif&quot; alt=&quot;oracle&quot;&gt;&lt;/center&gt;

&lt;p&gt;近期在做&lt;code&gt;Intel&lt;/code&gt;的测试，需要监测各种故障情况下的热恢复或者热迁移等功能，比如拔线测试，拔盘测试，断电测试等，来检验分布式的稳定性和灵活性，以&lt;code&gt;Oracle&lt;/code&gt;为例，需要一直向数据库中写数据，然后在发生故障时，通过观察插入数据的情况来判断是否能够处理异常情况，所以我需要写一个脚本，能够做到通过&lt;code&gt;python&lt;/code&gt;自动连接&lt;code&gt;oracle&lt;/code&gt;数据库并自动插入数据。&lt;/p&gt;
    
    </summary>
    
      <category term="teach" scheme="https://tony-yin.github.io/categories/teach/"/>
    
    
      <category term="Python" scheme="https://tony-yin.github.io/tags/Python/"/>
    
      <category term="Oracle" scheme="https://tony-yin.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle Linux And Oracle Database 11g R2 Intsallation</title>
    <link href="https://tony-yin.github.io/2017/09/10/oracle_install/"/>
    <id>https://tony-yin.github.io/2017/09/10/oracle_install/</id>
    <published>2017-09-09T16:53:06.000Z</published>
    <updated>2017-09-20T13:38:36.267Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/oracle-eloqua-campaign-manager.png" alt="oralce"></center><p>最近工作中用到了<code>Oracle</code>作为<code>Intel</code>测试的数据库，在装<code>Oracle Linux</code>和<code>Oracle Database 11g R2</code>折腾了很久，这篇文章就这两点对大家分享一些我安装过程中遇到的问题和注意点，<code>rac</code>暂时还未配置，稍后找时间补上</p><a id="more"></a><blockquote><p>友情提醒： 本文参照<code>link</code>较多，请细心并且耐心地进行每一步操作</p><h3 id="Resource-Link"><a href="#Resource-Link" class="headerlink" title="Resource Link"></a>Resource Link</h3><ul><li><a href="https://pan.baidu.com/s/1pL7ENn9" target="_blank" rel="external">Oracle Linux ISO</a></li><li><a href="https://pan.baidu.com/s/1qYufAQo" target="_blank" rel="external">Linux Oracle Database 11g R2</a> </li><li><a href="https://pan.baidu.com/s/1kV3JpCr" target="_blank" rel="external">Windows Oracle Database 11g R2</a> </li></ul></blockquote><h3 id="Oracle-Linux-Installation"><a href="#Oracle-Linux-Installation" class="headerlink" title="Oracle Linux Installation"></a>Oracle Linux Installation</h3><p><strong>参考列表：</strong></p><ul><li><a href="https://wenku.baidu.com/view/afd5ca9e5022aaea998f0fa2.html" target="_blank" rel="external">oracle linux 6.5 安装 oracle 11gR2图文详解</a></li><li><a href="https://pan.baidu.com/s/1miDQEoC" target="_blank" rel="external">Oracle 11g R2（自己整理的Word，带详细RAC配置）</a></li></ul><blockquote><p>以下操作步骤基本是按上面两条<code>link</code>走的，有一些地方不一样或者是没必要的我会在下面详细讲解，我装的时候以<code>link1</code>为主线，然后参照<code>link2</code>的<code>word</code>文档进行，没有特殊标记的一般都是根据<code>link1</code>操作，大家也可以这样操作，可以少遇一些坑，节省一些时间~~~</p></blockquote><p><strong>注意点：</strong></p><ul><li><code>Base server</code>这一步很关键<ul><li>勾选<code>Oracle Linux Server</code>, <code>Resilient Storage</code>和 <code>Scalable Filesystem Support</code>（参照<code>link2</code>）</li><li>勾选<code>Customize Now</code>，这一步依然非常关键，只有勾选了才可以装一些<code>Oracle Linux</code>需要的套件</li><li>需要手动添加安装的套件（系统默认勾选的不要删掉，这边的操作只添加勾选）：<ul><li><code>Base System</code>：<code>Compatibility libraries</code></li><li><code>Servers</code>: <code>System administration tools</code></li><li><code>Desktops</code>: <code>Desktop</code>、<code>Desktop Platform</code>、<code>Fonts</code>、<code>General Purpose Desktop</code>、<code>Graphical Administration Tools</code>、<code>Input Methods</code>、<code>X Window System</code></li><li><code>Development</code>: <code>Additional Development</code>、<code>Development Tools</code></li><li><code>Appilication</code>: <code>Internet Browser</code></li></ul></li></ul></li><li>安装应该是<code>1390</code>个包，装好直接<code>reboot</code></li><li>这时候创建普通用户的时候，千万不要创建<code>oracle</code>用户，否则之后会有很多麻烦</li></ul><h3 id="Oracle-Linux-Configuration（important-and-complicated）"><a href="#Oracle-Linux-Configuration（important-and-complicated）" class="headerlink" title="Oracle Linux Configuration（important and complicated）"></a>Oracle Linux Configuration（important and complicated）</h3><p><strong>下面讲的主要是和两个文档不同的地方（依然以<code>link1</code>为主线）：</strong></p><p><strong>1.</strong> <code>selinux</code>需要<code>dsiable</code></p><p><strong>2.</strong> <code>/etc/sysctl.conf</code>参照<code>link2</code>，<code>kernel.shmmax = 536870912</code>（这行参照<code>link2</code>）</p><p><strong>3.</strong> <code>/etc/security/limits.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">oracle soft nproc 16384</div><div class="line">oracle hard nproc 16384</div><div class="line">oracle soft nofile 4096</div><div class="line">oracle hard nofile 65536</div><div class="line">oracle soft stack 10240</div></pre></td></tr></table></figure></p><p><strong>4.</strong> <code>oracle linux 6.5</code>光盘下载包（我是通过<code>yum</code>安装,没有安装的大部分都是系统已经安装了，少部分是没必要安装）</p><ul><li>需要安装：<ul><li><code>ksh</code></li><li><code>libaio-devel.i686</code></li><li><code>libaio-devel.x86_64</code></li><li><code>libaio.i686</code></li><li><code>libstdc++.i686</code></li><li><code>libstdc++-4.4.7-18.el6.i686</code></li><li><code>compat-libstdc++-33.i686</code></li></ul></li><li>不需要安装：<ul><li><code>numactl-devel-2*x86_64*</code></li></ul></li></ul><blockquote><p>由于我本地的是<code>libstdc++-4.4.7-4.el6.x86_64</code>，而安装的是<code>libstdc++-4.4.7-18.el6.i686</code>，版本不匹配会造成<code>yum</code>报错，而这个库作为众多库的依赖还不能删除，所以只能强行升级：<code>yum install libstdc++-4.4.7-18.el6.i686</code>，然后再安装<code>i686</code>文件</p></blockquote><p><strong>5.</strong> 路径、权限与环境变量配置<br>这一步参照: <a href="https://oracle-base.com/articles/linux/automating-database-startup-and-shutdown-on-linux" target="_blank" rel="external">Automating Database Startup and Shutdown on Linux</a></p><p><strong>附上脚本和<code>~/.bash_profile</code>:</strong></p><p><code>start_all.sh</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">. /home/oracle/scripts/setEnv.sh</div><div class="line"></div><div class="line">export ORAENV_ASK=NO</div><div class="line">. oraenv</div><div class="line">export ORAENV_ASK=YES</div><div class="line"></div><div class="line">dbstart $ORACLE_HOME</div></pre></td></tr></table></figure><p><code>stop_all.sh</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">. /home/oracle/scripts/setEnv.sh</div><div class="line"></div><div class="line">export ORAENV_ASK=NO</div><div class="line">. oraenv</div><div class="line">export ORAENV_ASK=YES</div><div class="line"></div><div class="line">dbshut $ORACLE_HOME</div></pre></td></tr></table></figure><p><code>setenv.sh</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># Oracle Settings</div><div class="line">export TMP=/tmp</div><div class="line">export TMPDIR=$TMP</div><div class="line"></div><div class="line">export ORACLE_HOSTNAME=tonydb.localdomain</div><div class="line">export ORACLE_UNQNAME=sampledb</div><div class="line">export ORACLE_BASE=/home/oracle/app/oracle</div><div class="line">export ORACLE_HOME=$ORACLE_BASE/product/11.2.0/dbhome_1</div><div class="line">export ORACLE_SID=sampledb</div><div class="line"></div><div class="line">export PATH=/usr/sbin:/usr/local/bin:$PATH</div><div class="line">export PATH=$ORACLE_HOME/bin:$PATH</div><div class="line"></div><div class="line">export LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/lib</div><div class="line">export CLASSPATH=$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib</div></pre></td></tr></table></figure><p><code>~/.bash_profile</code>最后一行追加： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">. /home/oracle/scripts/setenv.sh</div></pre></td></tr></table></figure><p><strong>6.</strong> 安装<code>FTP</code>并上传<code>zip</code>文件（这一步有需求就执行，我是通过<code>windows</code>传输到<code>linux</code>上）</p><blockquote><p>安装包在页面最上方<code>Resource Link</code>的第二个<code>link</code>，有两个<code>zip</code>包，都是需要的，这就是<code>Oracle Database 11g R2</code>的包，下面就开始安装数据库了，离成功也就不远了</p></blockquote><h3 id="Oracle-Database-11g-R2-Installation"><a href="#Oracle-Database-11g-R2-Installation" class="headerlink" title="Oracle Database 11g R2 Installation"></a>Oracle Database 11g R2 Installation</h3><p><strong>参照：</strong> <a href="https://www.tecmint.com/oracle-database-11g-release-2-installation-in-linux/" target="_blank" rel="external">Oracle Database 11g Release 2 Installation on RHEL/CentOS 6.x/5.x/4.x</a>，以这个<code>link</code>的步骤为主，<code>link1</code>和<code>link2</code>为辅</p><ol><li><p>如果出现<code>next button</code>闪退的现象，进入<code>preference</code>里面调节屏幕分辨率即可</p></li><li><p><code>check</code>时候报错，如果你在上面安装了那么就<code>ignore</code>吧，因为这些包都安装了，只不过版本比它<code>check</code>的高：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">libaio-0.3.105</div><div class="line">compat-libstdc++-33-3.2.3</div><div class="line">libaio-devel-0.3.105</div><div class="line">libgcc-3.4.6</div><div class="line">libstdc++-3.4.6</div><div class="line">unixODBC-2.2.11</div><div class="line">unixODBC-2.2.11</div><div class="line">unixODBC-devel-2.2.11</div><div class="line">unixODBC-devel-2.2.11</div><div class="line">pdksh-5.2.14</div></pre></td></tr></table></figure></li></ol><h3 id="Oracle-Listener-Configuration"><a href="#Oracle-Listener-Configuration" class="headerlink" title="Oracle Listener Configuration"></a>Oracle Listener Configuration</h3><p><strong>参照：</strong> <a href="http://blog.csdn.net/haiross/article/details/13613931" target="_blank" rel="external">Oracle Listener</a></p><blockquote><p>最后<code>test</code>不成功也没关系，先保存设置进行下一步，这边把<code>lsnrcetl</code>起起来就可以了，先不要进入<code>oracle</code>命令行，需要等下一步创建了数据库再进行<code>startup</code>等操作</p></blockquote><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><blockquote><p><code>dbca</code>进入创建向导，填写正确的<code>sid</code>，<code>sid</code>不用填<code>ORCL</code>,就用同步生成的就好，不同的数据库可以拥有不同的<code>sid</code>，按照默认的配置不断地<code>next</code>就好</p></blockquote><ul><li>安装后的默认数据库为orcl，如需创建新的数据库<ul><li>使用辅助工具(Linux UI mode)<blockquote><p>root@oracledb: xhost local:oracledb<br>root@oracledb: su - oracle<br>oracle@oracledb: dbca</p></blockquote></li><li>使用em管理WebUI</li></ul></li><li>创建表空间<ul><li>使用sqlplus<blockquote><p>su - oracle (Windows下此步骤省略)<br>sqlplus / as sysdba<br>create tablespace test_space datafile ‘/opt/oracle/oradata/test_data.dbf’ size 500M</p></blockquote></li><li>使用em管理WebUI</li></ul></li><li>创建用户    <ul><li>使用sqlplus<blockquote><p>su - oracle (Windows下此步骤省略)<br>sqlplus / as sysdba<br>create user test identified by test default tablespace test_space;</p></blockquote></li><li>使用em管理WebUI</li></ul></li><li>授权用户权限<ul><li>使用sqlplus<blockquote><p>su - oracle (Windows下此步骤省略)<br>sqlplus / as sysdba<br>grant connect, resource to test;</p></blockquote></li><li>使用em管理WebUI</li></ul></li><li>授权DBA权限（RMAN需要dba权限来运行）<ul><li>使用sqlplus<blockquote><p>su - oracle (Windows下此步骤省略)<br>sqlplus / as sysdba<br>grant sysdba to test;</p></blockquote></li><li>使用em管理WebUI</li></ul></li><li>数据库启动/关闭<ul><li>切换用户<blockquote><p>root@oracledb: su - oracle</p></blockquote></li><li>启动监听<blockquote><p>lsnrctl start</p></blockquote></li><li>启动实例<blockquote><p>su - oracle (Windows下此步骤省略)<br>sqlplus /nolog<br>conn /as sysdba<br>startup</p></blockquote></li><li>关闭实例<blockquote><p>su - oracle (Windows下此步骤省略)<br>sqlplus /nolog<br>conn /as sysdba<br>shutdown immediate<br>exit</p></blockquote></li><li>关闭监听<blockquote><p>lsnrctl stop</p></blockquote></li></ul></li><li>归档日志模式启动/关闭<ul><li>启动归档日志模式<blockquote><p>sqlplus /as sysdba<br>shutdown immediate<br>startup mount<br>alter database archivelog<br>alter database open</p></blockquote></li><li>关闭归档日志模式<blockquote><p>sqlplus /as sysdba<br>shutdown immediate<br>startup mount<br>alter database noarchivelog<br>alter database open</p></blockquote></li></ul></li></ul><p>作者： Tony</p><p>日期： 2017/06/26</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/oracle-eloqua-campaign-manager.png&quot; alt=&quot;oralce&quot;&gt;&lt;/center&gt;

&lt;p&gt;最近工作中用到了&lt;code&gt;Oracle&lt;/code&gt;作为&lt;code&gt;Intel&lt;/code&gt;测试的数据库，在装&lt;code&gt;Oracle Linux&lt;/code&gt;和&lt;code&gt;Oracle Database 11g R2&lt;/code&gt;折腾了很久，这篇文章就这两点对大家分享一些我安装过程中遇到的问题和注意点，&lt;code&gt;rac&lt;/code&gt;暂时还未配置，稍后找时间补上&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Oracle" scheme="https://tony-yin.github.io/tags/Oracle/"/>
    
      <category term="Oracle Linux" scheme="https://tony-yin.github.io/tags/Oracle-Linux/"/>
    
      <category term="Oracle 11g R2" scheme="https://tony-yin.github.io/tags/Oracle-11g-R2/"/>
    
  </entry>
  
  <entry>
    <title>Moodle Local Plugin</title>
    <link href="https://tony-yin.github.io/2017/09/09/Moodle-Local-Plugin/"/>
    <id>https://tony-yin.github.io/2017/09/09/Moodle-Local-Plugin/</id>
    <published>2017-09-09T15:05:05.000Z</published>
    <updated>2017-09-20T13:43:26.323Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/moodle-logo-concept.png" alt="moodle"></center><p><code>Local</code>插件在<code>Moodle</code>中相比于其他插件算是比较容易上手的一个插件，<code>Local</code>插件中前后台分离，不用遨游在杂糅前后端的代码里。学会<code>Local</code>插件是上手其他插件的前提，其实一旦学会<code>Local</code>插件也会发现其他插件不过是它的一种变种形式罢了，只要举一反三就能很快掌握。</p><a id="more"></a><h2 id="Moodle-Local-插件架构"><a href="#Moodle-Local-插件架构" class="headerlink" title="Moodle Local 插件架构"></a>Moodle Local 插件架构</h2><center><img src="http://on-img.com/chart_image/58b5173ce4b01d80b64d335e.png" alt="image"></center><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="Template"><a href="#Template" class="headerlink" title="Template"></a><a href="https://docs.moodle.org/dev/Templates" target="_blank" rel="external">Template</a></h3><p>服务器配置了相应的<code>url</code>，所以每个插件的加载首页都是<code>index.php</code>，但是并不意味着页面的代码就在<code>index.php</code>中，首先在<code>index.php</code>中调用<code>renderer.php</code> 中相应的页面渲染方法，例如  <code>render_index_page($page)</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public function render_index_page($page) &#123;</div><div class="line">$data = $page-&gt;export_for_template($this);</div><div class="line">    render_from_template(&apos;local_xxx/index&apos;, $data)</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>在这个方法中，首先调用了<code>index_page</code>这个类中的 <code>export_for_template</code> 方法，获得页面静态加载需要的数据，例如<code>mustache</code>模板需要的数据，<code>data</code>数组的索引与模板名称一一对应，例如<code>mustache</code>文件中若有 &#123;&#123;<code>#user</code>&#125;&#125;<code>hello!</code>&#123;&#123;<code>/user</code>&#125;&#125;，那么对应 class 一定存在 <code>$data[&#39;user&#39;] = xxxx</code>；</li><li>以 <code>render_from_template(&#39;local_xxx/index&#39;, $data)</code> 为例， <code>local_xxx/index</code>，<code>template</code>目录下必定有文件名为<code>index.mustache</code>的文件，这是<code>moodle</code> 封装好的命名规范，而<code>mustache</code>文件就是页面展示的代码所在了；</li><li>通过&#123;&#123;<code>#js</code>&#125;&#125;<code>require xxx</code>&#123;&#123;<code>/js</code>&#125;&#125;引入对应的<code>JavaScript</code>文件；</li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a><a href="https://docs.moodle.org/dev/CSS" target="_blank" rel="external">CSS</a></h3><p>每个 local 插件中都存在一个<code>style.css</code>这样的一个<code>css</code>样式文件，系统运行时，会将每个模块的<code>css</code>文件内容合并到一起，所以如果有两个名称一样的<code>css</code>，则会发生覆盖的现象，所以建议起名字统一在最前面加上当前的插件名称，要注意的是，每次新增、修改或者删除<code>css</code>文件内容后，如若需要立即查看效果，必要以<code>admin</code>角色进入系统，然后<strong>清空缓存</strong>；</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a><a href="https://docs.moodle.org/dev/Javascript_Modules" target="_blank" rel="external">JavaScript</a></h3><p>目前系统中的<code>js</code>是基于<code>RequireJS</code>框架，遵循<code>AMD</code>开发规范，利用<code>Grunt</code>构建的。<code>amd</code>目录下有<code>src</code>目录和<code>build</code>目录，<code>src</code>下的<code>xxx.js</code>是供开发时编写调试使用，而<code>build</code>目录下的<code>min.js</code>则是网站实际运行时所使用的<code>js</code>文件，经过压缩可以大幅度提升运行速度。所以每次修改<code>js</code>完毕后，提交代码切勿忘记生成对应的<code>min.js</code>文件并提供，生成命令为 <code>grunt uglify</code>；</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="db"><a href="#db" class="headerlink" title="db"></a><a href="https://docs.moodle.org/dev/Data_definition_API" target="_blank" rel="external">db</a></h3><ol><li><p>access.php<br>主要负责记录权限的配置；</p></li><li><p>service.php<br>负责接收<code>ajax</code>提交，配置对应的后台<code>API</code>的类名、路径 和方法名等信息，并将对应的<code>ajax</code>方法存入数据库中；</p></li><li><p>install.xml<br>用于安装系统时表结构的对应生成；</p></li><li><p>install.php<br>用于安装系统时数据库的缺省数据的提供；</p></li><li><p>upgrade.php <a href="https://note.youdao.com/share/?token=18D5479D0AFA4286A46EACE741345DF5&amp;gid=29389535" target="_blank" rel="external">开发规范</a><br>用于系统表结构变化等版本升级事项的实现，由于生产环境中客户已有大量数据存在于数据库中，所以这时候不能采取重装系统的方式更改表结构或者更改数据库等操作，这时候就得借助<code>upgrade.php</code>平滑升级。</p></li></ol><h3 id="后台-API"><a href="#后台-API" class="headerlink" title="后台 API"></a>后台 API</h3><ol><li><p>externallib.php<br>负责编写<code>service.php</code>中<code>ajax</code>提交方法对应的后台方法，并调用<code>lib.php</code>中的<code>API</code>实现；</p></li><li><p>lib.php<br>负责方法的具体实现，代码与数据库的数据交互</p></li><li><p>lang/en/xxx.php 和 lang/zh_cn/xxx.php</p></li></ol><p><code>en</code>目录下的表示英文翻译语言文件，<code>zh_cn</code>目录下的表示中文翻译语言文件，具体调用方法为： </p><ul><li><code>php</code>中： <code>get_string(字符串名, 插件名)</code></li><li><code>mustache</code>中： &#123;&#123;<code>#str</code>&#125;&#125;<code>字符串名, 插件名</code>&#123;&#123;<code>/str</code>&#125;&#125;</li></ul><p>作者：Tony<br>2017年02月28日</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/moodle-logo-concept.png&quot; alt=&quot;moodle&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;code&gt;Local&lt;/code&gt;插件在&lt;code&gt;Moodle&lt;/code&gt;中相比于其他插件算是比较容易上手的一个插件，&lt;code&gt;Local&lt;/code&gt;插件中前后台分离，不用遨游在杂糅前后端的代码里。学会&lt;code&gt;Local&lt;/code&gt;插件是上手其他插件的前提，其实一旦学会&lt;code&gt;Local&lt;/code&gt;插件也会发现其他插件不过是它的一种变种形式罢了，只要举一反三就能很快掌握。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Moodle" scheme="https://tony-yin.github.io/tags/Moodle/"/>
    
      <category term="PHP" scheme="https://tony-yin.github.io/tags/PHP/"/>
    
  </entry>
  
</feed>
