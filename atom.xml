<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tony&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tony-yin.github.io/"/>
  <updated>2017-11-14T02:56:22.194Z</updated>
  <id>https://tony-yin.github.io/</id>
  
  <author>
    <name>Tony</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LVM-Space-Expansion</title>
    <link href="https://tony-yin.github.io/2017/11/14/LVM-Space-Expansion/"/>
    <id>https://tony-yin.github.io/2017/11/14/LVM-Space-Expansion/</id>
    <published>2017-11-14T02:35:39.000Z</published>
    <updated>2017-11-14T02:56:22.194Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/work-for-love-600x450.png" alt="LVM Space Expansion"></center><p>在平时的开发工作中，经常会创建磁盘不足够大的虚拟机，然后往集群里面写一些数据导致磁盘满了。手动编辑虚拟机的磁盘大小是不会文件系统识别的，大多数同学只能无奈的重新装<code>OS</code>，这里我介绍一种基于<code>LVM</code>实现动态的方式。</p><a id="more"></a><h2 id="LVM了解"><a href="#LVM了解" class="headerlink" title="LVM了解"></a>LVM了解</h2><p><code>LVM</code>是逻辑盘卷管理（<code>LogicalVolumeManager</code>）的简称，它是<code>Linux</code>环境下对磁盘分区进行管理的一种机制，<code>LVM</code>是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。通过LVM系统管理员可以轻松管理磁盘分区，如：将若干个磁盘分区连接为一个整块的卷组（<code>volumegroup</code>），形成一个存储池。管理员可以在卷组上随意创建逻辑卷组（<code>logicalvolumes</code>），并进一步在逻辑卷组上创建文件系统。管理员通过<code>LVM</code>可以方便的调整存储卷组的大小，并且可以对磁盘存储按照组的方式进行命名、管理和分配。</p><h2 id="查看分区"><a href="#查看分区" class="headerlink" title="查看分区"></a>查看分区</h2><p>当前默认只有一个采用<code>lvm</code>的分区，一开始<code>sda</code>磁盘容量为<code>16G</code>，后来发现不够用了，编辑磁盘大小为<code>50G</code>，但是可以发现这<code>50G</code>并没有起到扩展分区容量的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[root@tony-play ~]# df -h</div><div class="line">Filesystem            Size  Used Avail Use% Mounted on</div><div class="line">/dev/mapper/vg_tonyplay-lv_root</div><div class="line">                       14G  3.4G  9.6G  26% /</div><div class="line">tmpfs                 1.9G   72K  1.9G   1% /dev/shm</div><div class="line">/dev/sda1             477M   42M  410M  10% /boot</div><div class="line"></div><div class="line">[root@tony-play ~]# lsblk</div><div class="line">NAME                           MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0                             11:0    1 1024M  0 rom  </div><div class="line">sda                              8:0    0   50G  0 disk </div><div class="line">├─sda1                           8:1    0  500M  0 part /boot</div><div class="line">└─sda2                           8:2    0 15.5G  0 part </div><div class="line">  ├─vg_tonyplay-lv_root (dm-0) 253:0    0 13.9G  0 lvm  /</div><div class="line">  └─vg_tonyplay-lv_swap (dm-1) 253:1    0  1.6G  0 lvm  [SWAP]</div></pre></td></tr></table></figure><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>可以通过新增一块其他磁盘来扩容，我这边采取的是增大当前磁盘的容量实现扩容。</p><p>有时候因为系统设备处于繁忙状态，所以分区需要重启后才会生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">[root@tony-play ~]# fdisk /dev/sda</div><div class="line">WARNING: DOS-compatible mode is deprecated. It&apos;s strongly recommended to</div><div class="line">         switch off the mode (command &apos;c&apos;) and change display units to</div><div class="line">         sectors (command &apos;u&apos;).</div><div class="line">Command (m for help): n</div><div class="line">Command action</div><div class="line">    e   extended</div><div class="line">    p   primary partition (1-4)</div><div class="line">p</div><div class="line">Partition number (1-4): 3</div><div class="line">First cylinder (2089-6527, default 2089):   // 直接回车，用默认值就可以了</div><div class="line">Using default value 2089</div><div class="line">Last cylinder, +cylinders or +size&#123;K,M,G&#125; (2089-6527, default 6527):    // 直接回车，用默认值就可以了</div><div class="line">Using default value 6527</div><div class="line">Command (m for help): w</div><div class="line">The partition table has been altered!</div><div class="line"></div><div class="line"># 可以看到新建的分区sda3已结被创建出来了，采取默认值会将剩余所有空间都分到分区中</div><div class="line">[root@tony-play ~]# lsblk</div><div class="line">NAME                           MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0                             11:0    1 1024M  0 rom  </div><div class="line">sda                              8:0    0   50G  0 disk </div><div class="line">├─sda1                           8:1    0  500M  0 part /boot</div><div class="line">├─sda2                           8:2    0 15.5G  0 part </div><div class="line">│ ├─vg_tonyplay-lv_root (dm-0) 253:0    0 13.9G  0 lvm  /</div><div class="line">│ └─vg_tonyplay-lv_swap (dm-1) 253:1    0  1.6G  0 lvm  [SWAP]</div><div class="line">└─sda3                           8:3    0   34G  0 part</div></pre></td></tr></table></figure><h2 id="查看当前文件系统"><a href="#查看当前文件系统" class="headerlink" title="查看当前文件系统"></a>查看当前文件系统</h2><p>当前文件系统为<code>ext4</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@tony-play ~]# mount</div><div class="line">/dev/mapper/vg_tonyplay-lv_root on / type ext4 (rw)</div><div class="line">proc on /proc type proc (rw)</div><div class="line">sysfs on /sys type sysfs (rw)</div><div class="line">devpts on /dev/pts type devpts (rw,gid=5,mode=620)</div><div class="line">tmpfs on /dev/shm type tmpfs (rw,rootcontext=&quot;system_u:object_r:tmpfs_t:s0&quot;)</div><div class="line">/dev/sda1 on /boot type ext4 (rw)</div><div class="line">none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)</div></pre></td></tr></table></figure><h2 id="为新分区创建文件系统"><a href="#为新分区创建文件系统" class="headerlink" title="为新分区创建文件系统"></a>为新分区创建文件系统</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">[root@tony-play ~]# sudo mkfs.ext4 /dev/sda3</div><div class="line">mke2fs 1.41.12 (17-May-2010)</div><div class="line">Filesystem label=</div><div class="line">OS type: Linux</div><div class="line">Block size=4096 (log=2)</div><div class="line">Fragment size=4096 (log=2)</div><div class="line">Stride=0 blocks, Stripe width=0 blocks</div><div class="line">2228224 inodes, 8912727 blocks</div><div class="line">445636 blocks (5.00%) reserved for the super user</div><div class="line">First data block=0</div><div class="line">Maximum filesystem blocks=4294967296</div><div class="line">272 block groups</div><div class="line">32768 blocks per group, 32768 fragments per group</div><div class="line">8192 inodes per group</div><div class="line">Superblock backups stored on blocks: </div><div class="line">    32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, </div><div class="line">    4096000, 7962624</div><div class="line"></div><div class="line">Writing inode tables: done                            </div><div class="line">Creating journal (32768 blocks): done</div><div class="line">Writing superblocks and filesystem accounting information: done</div><div class="line"></div><div class="line">This filesystem will be automatically checked every 39 mounts or</div><div class="line">180 days, whichever comes first.  Use tune2fs -c or -i to override.</div></pre></td></tr></table></figure><h2 id="查看卷组信息"><a href="#查看卷组信息" class="headerlink" title="查看卷组信息"></a>查看卷组信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[root@tony-play ~]# vgdisplay</div><div class="line">  --- Volume group ---</div><div class="line">  VG Name               vg_tonyplay     // 卷组名在下面扩展中会用到</div><div class="line">  System ID             </div><div class="line">  Format                lvm2</div><div class="line">  Metadata Areas        1</div><div class="line">  Metadata Sequence No  3</div><div class="line">  VG Access             read/write</div><div class="line">  VG Status             resizable</div><div class="line">  MAX LV                0</div><div class="line">  Cur LV                2</div><div class="line">  Open LV               2</div><div class="line">  Max PV                0</div><div class="line">  Cur PV                1</div><div class="line">  Act PV                1</div><div class="line">  VG Size               15.51 GiB</div><div class="line">  PE Size               4.00 MiB</div><div class="line">  Total PE              3970</div><div class="line">  Alloc PE / Size       3970 / 15.51 GiB</div><div class="line">  Free  PE / Size       0 / 0   </div><div class="line">  VG UUID               Y9usSM-nDU5-ZAUd-Y3Te-u5Pd-uFBr-gcYHf0</div></pre></td></tr></table></figure><h2 id="创建新物理卷"><a href="#创建新物理卷" class="headerlink" title="创建新物理卷"></a>创建新物理卷</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@tony-play ~]# pvcreate /dev/sda3</div><div class="line">  Physical volume &quot;/dev/sda3&quot; successfully created</div></pre></td></tr></table></figure><h2 id="扩展到卷组"><a href="#扩展到卷组" class="headerlink" title="扩展到卷组"></a>扩展到卷组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vgextend vg_tonyplay /dev/sda3  // 卷组名在查看卷组信息中</div><div class="line">  Volume group &quot;vg_tonyplay&quot; successfully extended</div></pre></td></tr></table></figure><h2 id="查看逻辑分区"><a href="#查看逻辑分区" class="headerlink" title="查看逻辑分区"></a>查看逻辑分区</h2><p><code>/dev/vg_tonyplay/lv_root</code>就是根分区，也是我们要扩展的分区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">[root@tony-play ~]# lvdisplay </div><div class="line">  --- Logical volume ---</div><div class="line">    LV Path                /dev/vg_tonyplay/lv_root   // 根分区</div><div class="line">    LV Name                lv_root</div><div class="line">    VG Name                vg_tonyplay</div><div class="line">    LV UUID                IPd7lm-Sx8g-pe7k-llNL-j1wc-mbA2-2cAdsy</div><div class="line">    LV Write Access        read/write</div><div class="line">    LV Creation host, time tony-play, 2017-04-10 17:58:53 -0400</div><div class="line">    LV Status              available</div><div class="line">    # open                 1</div><div class="line">    LV Size                13.91 GiB</div><div class="line">    Current LE             3561</div><div class="line">    Segments               1</div><div class="line">    Allocation             inherit</div><div class="line">    Read ahead sectors     auto</div><div class="line">    - currently set to     256</div><div class="line">    Block device           253:0</div><div class="line"></div><div class="line">    --- Logical volume ---</div><div class="line">    LV Path                /dev/vg_tonyplay/lv_swap</div><div class="line">    LV Name                lv_swap</div><div class="line">    VG Name                vg_tonyplay</div><div class="line">    LV UUID                qX637q-iD6i-8blp-hmmS-MvLy-xZ0y-b4D0BF</div><div class="line">    LV Write Access        read/write</div><div class="line">    LV Creation host, time tony-play, 2017-04-10 17:59:07 -0400</div><div class="line">    LV Status              available</div><div class="line">    # open                 1</div><div class="line">    LV Size                1.60 GiB</div><div class="line">    Current LE             409</div><div class="line">    Segments               1</div><div class="line">    Allocation             inherit</div><div class="line">    Read ahead sectors     auto</div><div class="line">    - currently set to     256</div><div class="line">    Block device           253:1</div></pre></td></tr></table></figure><h2 id="扩展容量到逻辑分区"><a href="#扩展容量到逻辑分区" class="headerlink" title="扩展容量到逻辑分区"></a>扩展容量到逻辑分区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@tony-play ~]# lvextend /dev/vg_tonyplay/lv_root /dev/sda3</div><div class="line">  Size of logical volume vg_tonyplay/lv_root changed from 13.91 GiB (3561 extents) to 47.91 GiB (12264 extents).</div><div class="line">  Logical volume lv_root successfully resized</div></pre></td></tr></table></figure><h2 id="刷新逻辑分区容量使扩展生效"><a href="#刷新逻辑分区容量使扩展生效" class="headerlink" title="刷新逻辑分区容量使扩展生效"></a>刷新逻辑分区容量使扩展生效</h2><p><code>ext4</code>用<code>resize2fs</code>，<code>xfs</code>用<code>xfs_growfs</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@tony-play ~]# resize2fs /dev/vg_tonyplay/lv_root</div><div class="line">resize2fs 1.41.12 (17-May-2010)</div><div class="line">Filesystem at /dev/vg_tonyplay/lv_root is mounted on /; on-line resizing required</div><div class="line">old desc_blocks = 1, new_desc_blocks = 3</div><div class="line">Performing an on-line resize of /dev/vg_tonyplay/lv_root to 12558336 (4k) blocks.</div><div class="line">The filesystem on /dev/vg_tonyplay/lv_root is now 12558336 blocks long.</div></pre></td></tr></table></figure><h2 id="查看逻辑分区容量"><a href="#查看逻辑分区容量" class="headerlink" title="查看逻辑分区容量"></a>查看逻辑分区容量</h2><p>可以发现<code>/dev/mapper/vg_tonyplay-lv_root</code>已经从开始的<code>14G</code>扩展到了<code>48G</code>。ok，这就说明大功告成了，再也不用通过重装系统这种蹩脚的方式扩容了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@tony-play ~]# df -h</div><div class="line">Filesystem            Size  Used Avail Use% Mounted on</div><div class="line">/dev/mapper/vg_tonyplay-lv_root</div><div class="line">                       48G  3.4G   42G   8% /</div><div class="line">tmpfs                 1.9G   72K  1.9G   1% /dev/shm</div><div class="line">/dev/sda1             477M   42M  410M  10% /boot</div></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，<code>lvm</code>扩容工作的过程应该是比较清楚了，之后有机会的话我会再补充一下<code>LVM</code>的压缩、删除等操作过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/work-for-love-600x450.png&quot; alt=&quot;LVM Space Expansion&quot;&gt;&lt;/center&gt;

&lt;p&gt;在平时的开发工作中，经常会创建磁盘不足够大的虚拟机，然后往集群里面写一些数据导致磁盘满了。手动编辑虚拟机的磁盘大小是不会文件系统识别的，大多数同学只能无奈的重新装&lt;code&gt;OS&lt;/code&gt;，这里我介绍一种基于&lt;code&gt;LVM&lt;/code&gt;实现动态的方式。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ceph 编译（Giant版本）</title>
    <link href="https://tony-yin.github.io/2017/11/14/Ceph-Compile/"/>
    <id>https://tony-yin.github.io/2017/11/14/Ceph-Compile/</id>
    <published>2017-11-14T01:30:29.000Z</published>
    <updated>2017-11-14T02:34:27.393Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/ceph-600x450.png" alt="Ceph Compile"></center><p>如今入门<code>Ceph</code>的时候，大家一般用<code>ceph-deploy</code>工具比较多，这个工具的确很强大，很方便，对应的也就是很无脑。如果之后想深入<code>Ceph</code>或者想在生产环境中部署<code>Ceph</code>的话，就得熟悉<code>Ceph</code>源码编译了。这对我们熟悉<code>Ceph</code>的<code>feature</code>的变化，<code>component</code>的相互关系以及围绕<code>Ceph</code>各种定制化扩展都大有裨益。本文就笔者<code>Ceph</code>源码编译过程和遇到的问题作出分享，希望有人能够得益于此。</p><a id="more"></a><h2 id="环境声明"><a href="#环境声明" class="headerlink" title="环境声明"></a>环境声明</h2><ul><li>OS： Centos 6.8</li><li>Ceph： Giant</li></ul><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><h3 id="指定-giant-分支"><a href="#指定-giant-分支" class="headerlink" title="指定 giant 分支"></a>指定 giant 分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone -b giant git://github.com/ceph/ceph.git</div></pre></td></tr></table></figure><h3 id="下载子模块"><a href="#下载子模块" class="headerlink" title="下载子模块"></a>下载子模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git submodule update --init --recursive</div></pre></td></tr></table></figure><p>这一步我始终更新不了，尝试了一些办法未果，所以就去直接手动下载了源码，这个问题以后有时间看下</p><h2 id="预检"><a href="#预检" class="headerlink" title="预检"></a>预检</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd ceph </div><div class="line">./autogen.sh </div><div class="line">./configure</div></pre></td></tr></table></figure><h3 id="Autogen"><a href="#Autogen" class="headerlink" title="Autogen"></a>Autogen</h3><p>这一步会频繁的报错一些<code>m4</code>文件没有，这需要我们手动创建这些<code>m4</code>文件夹即可，</p><p>一开始我在<code>ceph</code>根目录创建了<code>m4</code>文件夹，并生成了包括<code>acx_pthread.m4</code>在内的文件，但是还是报错：<code>acx_pthread.m4 not exist</code>，后来发现这时候已经<strong>切换目录</strong>了，不止一个地方需要<code>m4</code>文件夹，一共有这几个地方需要手动创建目录：<code>mkdir m4</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">./src/rocksdb/m4</div><div class="line">./src/gtest/m4</div><div class="line">./src/erasure-code/jerasure/jerasure/m4</div><div class="line">./src/erasure-code/jerasure/gf-complete/m4</div><div class="line">./m4</div></pre></td></tr></table></figure><p>如果还是报错一些文件不存在，并且通过上述方法不能自行初始化生成的话，可以从网上或者已经编译过的<code>ceph</code>环境拷贝过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">报错：umdefined macro</div></pre></td></tr></table></figure><p>下载地址：<a href="https://www.gnu.org/software/autoconf-archive/ax_check_classpath.html#ax_check_classpath" target="_blank" rel="external">https://www.gnu.org/software/autoconf-archive/ax_check_classpath.html#ax_check_classpath</a></p><h3 id="Configure"><a href="#Configure" class="headerlink" title="Configure"></a>Configure</h3><p>这一步是编译过程中可能出错的次数最多的，因为可能会因为你的环境缺少相应的包不断报错。不过数量虽多，解决起来还是比较容易的，就根据报错的缺包对应下载安装就好了，下面我先给出一个所有包的安装步骤，然后再针对每个报错环节给出具体的解决方案</p><h4 id="总体解决方案"><a href="#总体解决方案" class="headerlink" title="总体解决方案"></a>总体解决方案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 1. 通过yum安装所有可以安装的包</div><div class="line">yum install -y yasm libuuid-devel libblkid-devel libudev-devel cryptopp-devel fuse-devel libunwind-devel libedit-devel libatomic_ops-devel snappy-devel leveldb-devel libaio-devel xfsprogs-devel boost*</div><div class="line"></div><div class="line"># 2. 部分yum不能安装的可以通过rpm安装</div><div class="line">wget https://github.com/gperftools/gperftools/releases/download/gperftools-2.2.1/gperftools-2.2.1.tar.gz</div><div class="line">tar -zxvf gperftools-2.2.1.tar.g</div><div class="line">cd gperftools-2.2.1</div><div class="line">./configure</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure><h4 id="具体解决方案"><a href="#具体解决方案" class="headerlink" title="具体解决方案"></a>具体解决方案</h4><p>1.yasm</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yasm command not found</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install yasm -y</div></pre></td></tr></table></figure><p>2.libuuid</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: libuuid not found</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install libuuid-devel -y</div></pre></td></tr></table></figure><p>3.libblkid</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: blkid/blkid.h not found (libblkid-dev, libblkid-devel)</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install libblkid-devel -y</div></pre></td></tr></table></figure><p>4.libudev</p><p>报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: libudev.h not found (libudev-dev, libudev-devel)</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install libudev-devel -y</div></pre></td></tr></table></figure><p>5.crypto</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: no suitable crypto library found</div></pre></td></tr></table></figure><p> 解决：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install cryptopp-devel -y</div></pre></td></tr></table></figure><p> 6.fuse</p><p> 报错：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: no FUSE found (use --without-fuse to disable)</div></pre></td></tr></table></figure><p> 解决：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install fuse-devel -y</div></pre></td></tr></table></figure><p> 7.tcmalloc</p><p> 报错：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: no tcmalloc found (use --without-tcmalloc to disable)</div></pre></td></tr></table></figure><p> 解决：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 1. 需要先安装libunwind-devel，被gperftools依赖</div><div class="line"> yum install libunwind-devel -y</div><div class="line"></div><div class="line"># 2. 安装tcmalloc（yum无法安装，需要通过rpm的方式）</div><div class="line">wget https://github.com/gperftools/gperftools/releases/download/gperftools-2.2.1/gperftools-2.2.1.tar.gz</div><div class="line">tar -zxvf gperftools-2.2.1.tar.g</div><div class="line">cd gperftools-2.2.1</div><div class="line">./configure</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure><p>8.libedit</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: No usable version of libedit found.</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install  libedit-devel -y</div></pre></td></tr></table></figure><p>9.libatomic-ops</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: no libatomic-ops found (use --without-libatomic-ops to disable)</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install libatomic_ops-devel  -y</div></pre></td></tr></table></figure><p>10.libsnappy</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: libsnappy not found</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">yum install snappy-devel -y</div><div class="line"></div><div class="line">or </div><div class="line"></div><div class="line">wget ftp://195.220.108.108/linux/centos/6.9/os/x86_64/Packages/snappy-devel-1.1.0-1.el6.x86_64.rpm</div><div class="line">rpm -ivh snappy-devel-1.1.0-1.el6.x86_64.rpm</div></pre></td></tr></table></figure><p>11.libleveldb</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: libleveldb not found</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install leveldb-devel</div></pre></td></tr></table></figure><p>12.libaio</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: libaio not found</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install libaio-devel -y</div></pre></td></tr></table></figure><p>13.libxfs</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: xfs/xfs.h not found (--without-libxfs to disable)</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install xfsprogs-devel</div></pre></td></tr></table></figure><p>14.boost</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Can&apos;t find boost spirit headers</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install boost* -y</div></pre></td></tr></table></figure><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>机器配置不好的话，编译需要时间比较长。可以使用<code>make -j</code>增加并发度，<code>4</code>表示同时执行的<code>make</code>方法数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make -j4</div><div class="line">make install（可选）</div></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>ceph</code>手动源码编译遇到的问题还是蛮多的，如果不自己动手经历一下的话很多东西都不知道，当然这都是经验的积累，不断地锻炼自己解决问题的能力，要学会见招拆招，通过问题发现原理和本质。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/ceph-600x450.png&quot; alt=&quot;Ceph Compile&quot;&gt;&lt;/center&gt;

&lt;p&gt;如今入门&lt;code&gt;Ceph&lt;/code&gt;的时候，大家一般用&lt;code&gt;ceph-deploy&lt;/code&gt;工具比较多，这个工具的确很强大，很方便，对应的也就是很无脑。如果之后想深入&lt;code&gt;Ceph&lt;/code&gt;或者想在生产环境中部署&lt;code&gt;Ceph&lt;/code&gt;的话，就得熟悉&lt;code&gt;Ceph&lt;/code&gt;源码编译了。这对我们熟悉&lt;code&gt;Ceph&lt;/code&gt;的&lt;code&gt;feature&lt;/code&gt;的变化，&lt;code&gt;component&lt;/code&gt;的相互关系以及围绕&lt;code&gt;Ceph&lt;/code&gt;各种定制化扩展都大有裨益。本文就笔者&lt;code&gt;Ceph&lt;/code&gt;源码编译过程和遇到的问题作出分享，希望有人能够得益于此。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="编译" scheme="https://tony-yin.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>通过 ganesha-nfs 将 Ceph 导出为 NFS（Luminous）</title>
    <link href="https://tony-yin.github.io/2017/11/08/Ceph-NFS-Ganesha/"/>
    <id>https://tony-yin.github.io/2017/11/08/Ceph-NFS-Ganesha/</id>
    <published>2017-11-08T15:15:26.000Z</published>
    <updated>2017-11-08T15:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/ganesha-600x450.png" alt="ganesha"></center><p>自从<code>Jewel</code>版本，<code>nfs-ganesha</code>开始支持<code>ceph</code>，并且把对接点选择了<code>rados</code>。<code>Ganesha</code>支持两种方式将<code>Ceph</code>导出为<code>NFS</code>，一种通过<code>RGW</code>，一种通过<code>CephFS</code>，通过<code>FSAL</code>模块 连接到<code>RGW</code>或者<code>CephFS</code>， 其中，<code>FSAL_RGW</code>调用<code>librgw2</code>将<code>NFS</code>协议转义为<code>S3</code>协议再通过<code>RGW</code>存入到<code>Ceph</code>中，<code>FSAL_CEPH</code> 调用<code>libcephfs1</code>将<code>NFS</code>转义为<code>Cephfs</code>协议再存入到<code>Ceph</code> 中。所以需要额外安装这两个包。</p><p>本文就<code>Luminous</code>版本的<code>ceph</code>基于<code>ganesha</code>导出<code>nfs</code>部署，并且测试一下<code>rgw</code>和<code>cephfs</code>的性能。<a href="http://www.xuxiaopang.com/2017/03/27/ganesha-nfs-deploy/#more" target="_blank" rel="external">@徐小胖</a>已经就<code>jewel</code>版本的过程进行了大致的讲解，我这边主要分享一下我遇到他文章没提到的和<code>Luminous</code>场景导致的问题。</p><a id="more"></a><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><ul><li><a href="http://www.xuxiaopang.com/2017/03/27/ganesha-nfs-deploy/#more" target="_blank" rel="external">通过ganesha-nfs将 Ceph 导出为 NFS</a></li><li><a href="http://blog.csdn.net/younger_china/article/details/73432726" target="_blank" rel="external">RGW+Ganesha环境部署</a></li></ul><h2 id="环境声明"><a href="#环境声明" class="headerlink" title="环境声明"></a>环境声明</h2><ul><li>os： centos7</li><li>ceph： luminous</li><li>nfs-gnesha： <strong>v2.5 stable</strong>（important）</li></ul><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>一些编译需要的公共库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install gcc git cmake autoconf libtool bison flex doxygen openssl-devel gcc-c++ krb5-libs krb5-devel libuuid-devel nfs-utils -y</div></pre></td></tr></table></figure><p><code>ubuntu</code>的我也试了一下，主要有以下几个包不同：</p><ul><li><code>gcc-c++</code>   -&gt;   <code>g++</code></li><li><code>libuuid-devel</code> -&gt;  <code>uuid-dev</code></li><li><code>nfs-utils</code>   -&gt;  <code>nfs-kernel-server</code> </li></ul><p>如果要生成<code>FSAL_RGW</code>模块，需要安装<code>librgw2-devel</code>（我装的<code>librgw-devel</code>也可以<code>work</code>，看了<code>so</code>文件发现就是<code>2</code>，只是建立了映射关系，这个看了源码知道了是因为<code>K</code>版本对<code>librgw</code>编译这块做了升级，加了<code>2</code>标识一下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install librgw2-devel -y</div></pre></td></tr></table></figure><p>如果要生成<code>FSAL_CEPH</code>模块，需要安装<code>libcephfs1-devel</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install libcephfs1-devel -y</div></pre></td></tr></table></figure><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p>上面两篇文章一个下载的是<code>v2.3 stable</code>，一个是<code>v2.4 stable</code>，两个我都试过，都会在<code>make</code>到<code>80%</code>左右的时候报错，应该是源码版本和库的版本有冲突导致的，这个问题耽误我挺长时间的，后来猜想可能是版本问题，尝试了一下<code>v2.5 stable</code>的源码就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">git clone -b V2.5-stable https://github.com/nfs-ganesha/nfs-ganesha.git --recursive</div></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译<code>nfs-ganesha</code>， <strong>注意打开对应的模块：</strong></p><ul><li>如果需要生成<code>FSAL_RGW</code>模块，则在编译选项中添加： <code>-DUSE_FSAL_RGW=ON</code></li><li>如果需要生成<code>FSAL_CEPH</code>模块，则在编译选项中添加： <code>-DUSE_FSAL_CEPH=ON</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd src/</div><div class="line">mkdir build</div><div class="line">cd /build/</div><div class="line">cmake -DUSE_FSAL_RGW=ON -DUSE_FSAL_CEPH=ON ../</div></pre></td></tr></table></figure><p><code>cmake</code>的过程中会有以下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">-- Looking for ceph_ll_lookup_root in cephfs - found</div><div class="line">-- Found cephfs libraries: /usr/lib64/libcephfs.so</div><div class="line">-- Found CEPHFS: /usr/include  </div><div class="line">-- Looking for rgw_mount in rgw</div><div class="line">-- Looking for rgw_mount in rgw - found</div><div class="line">-- Found rgw libraries: /usr/lib64/librgw.so</div><div class="line">-- Found RGW: /usr (found suitable version &quot;1.1&quot;, minimum required is &quot;1.1&quot;) </div><div class="line">...</div><div class="line">-- USE_FSAL_CEPH = ON</div><div class="line">-- USE_FSAL_CEPH_MKNOD = OFF</div><div class="line">-- USE_FSAL_CEPH_SETLK = OFF</div><div class="line">-- USE_FSAL_CEPH_LL_LOOKUP_ROOT = ON</div><div class="line">-- USE_FSAL_RGW = ON</div></pre></td></tr></table></figure><p>这一步，很重要，很多时候会因为没有装好的<code>librgw2-devel</code>或者<code>libcephfs1-devel</code>导致这边的<code>USE_FSAL_RGW</code>或者<code>USE_FSAL_CEPH</code>状态为<code>OFF</code></p><p><strong>确保，确保，确保：</strong> <code>-- USE_FSAL_CEPH</code>为<code>ON</code>，以及<code>-- USE_FSAL_RGW</code>为<code>ON</code>。</p><p>如果是<code>OFF</code>，请检查下<code>librgw2-devel</code>或者<code>libcephfs1-devel</code>是否有安装，如果这两个包都已经安装了，还显示为<code>OFF</code>， 可以尝试下清空编译目录：<code>rm -rf build/*</code>，再进行编译，如果依旧为 <code>OFF</code>，可以尝试下删除所有的<code>Ceph</code>包，再重新<code>yum install ceph librgw2-devel libcephfs1-devel -y</code>。</p><p>编译和安装，在<code>build</code>目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure><blockquote><p>PS:<br>在<code>make install</code>生成的输出中，可以看到:</p><p>– Up-to-date: /usr/share/doc/ganesha/config_samples/rgw.conf<br>…<br>– Up-to-date: /usr/share/doc/ganesha/config_samples/ceph.conf</p><p>这两个文件就是配置将<code>RGW</code>和<code>CephFS</code>配置为<code>ganesha-nfs</code>的配置模板。</p></blockquote><h2 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h2><p>注意<code>Path</code>后面的路径需要加引号，<code>rgw</code>替换成创建<code>S3</code>用户生成的用户信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">cat /etc/ganesha/ganesha.conf</div><div class="line">EXPORT</div><div class="line">&#123;</div><div class="line">        Export_ID=1;</div><div class="line">        Path = &quot;/&quot;;</div><div class="line">        Pseudo = /cephfs;</div><div class="line">        Access_Type = RW;</div><div class="line">        NFS_Protocols = 4;</div><div class="line">        Transport_Protocols = TCP;</div><div class="line">        FSAL &#123;</div><div class="line">                Name = CEPH;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">EXPORT</div><div class="line">&#123;</div><div class="line">        Export_ID=2;</div><div class="line">        Path = &quot;/&quot;;</div><div class="line">        Pseudo = /rgw;</div><div class="line">        Access_Type = RW;</div><div class="line">        Squash = No_root_squash;</div><div class="line">        NFS_Protocols = 4;</div><div class="line">        Transport_Protocols = TCP;</div><div class="line">        FSAL &#123;</div><div class="line">                Name = RGW;</div><div class="line">                User_Id = &quot;admin&quot;;</div><div class="line">                Access_Key_Id =&quot;1MWH3LWM1BS4ZF4HN5IH&quot;;</div><div class="line">                Secret_Access_Key = &quot;cuObxYgtl1lJgqNxOIpENycVqXfxLxZ8z5IXDM0O&quot;;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">RGW &#123;</div><div class="line">    ceph_conf = &quot;/etc/ceph/ceph.conf&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="启动-Ganesha"><a href="#启动-Ganesha" class="headerlink" title="启动 Ganesha"></a>启动 Ganesha</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ganesha.nfsd -f /etc/ganesha/ganesha.conf -L /var/log/nfs-ganesha.log -N NIV_DEBUG</div></pre></td></tr></table></figure><p>如果一切顺利，你应该可以看到<code>ganesha.nfsd</code> 进程在那，如果进程不在，那么查看<code>Log</code>，记得在启动进程前，关闭所有<code>CephX</code>配置。</p><p><strong>重要</strong>：<code>librgw init failed (-5)</code> 解决方法</p><p>报错内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RGW-1 : nfs-ganesha-2232083[main] create_export :FSAL :CRIT :RGW module: librgw init failed (-5)</div><div class="line">RGW-1 : nfs-ganesha-2232083[main] mdcache_fsal_create_export :FSAL :MAJ :Failed to call create_export on underlying FSAL</div></pre></td></tr></table></figure><p>经过多次尝试，包括在<code>ganesha.conf</code>内添加<code>init_args</code>指定秘钥和<code>Ceph</code>的用户，<code>ganesha-nfs</code> 均无法启动，报的错如标题，解决方法就是关闭<code>CephX</code>，将<code>/etc/ceph/ceph.conf</code>内的三个 <code>cephx</code>改为<code>none</code>，然后重启<code>ceph-mon</code>，<code>ceph-osd</code>，<code>ceph-radosgw</code>，<code>ceph-mds</code> 进程，再启动<code>ganesha-nfs</code>，即可正常运行。</p><p><strong>需要注意的是：</strong></p><p>当你在当前节点上，关闭<code>cephx</code>后，你用<code>ceph -s</code>查看集群状态时，这时候会报错说明由于没有<code>auth</code>认证导致无法连接集群，所以我当时试了很久，尽管<code>nfs-ganesha</code>已经运行了，但是<code>mount</code>都没有成功<code>export</code>，查看<code>log</code>才发现原来在<code>init</code>配置的时候就失败了，导致这个问题的原因是我只关闭了一个节点的<code>cephx</code>，所以需要做的就是将集群内所有节点的<code>cephx</code>全部关闭，然后集群就可以正常访问了，并且<code>nfs-ganesha</code>也不会因为<code>cephx</code>导致加载配置出错</p><h2 id="Check-Export"><a href="#Check-Export" class="headerlink" title="Check Export"></a>Check Export</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@node1 build]# showmount -e  </div><div class="line">Export list for node1:  </div><div class="line">/ (everyone)  </div><div class="line">/ (everyone)</div></pre></td></tr></table></figure><h2 id="挂载-NFS"><a href="#挂载-NFS" class="headerlink" title="挂载 NFS"></a>挂载 NFS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@node1 mnt]# mount -t nfs4 192.168.1.1:/  /mnt/ceph/  </div><div class="line">root@node1 mnt]# ls ceph/*  </div><div class="line">ceph/cephfs:  </div><div class="line">test  </div><div class="line">   </div><div class="line">ceph/rgw:  </div><div class="line">my-new-bucket</div></pre></td></tr></table></figure><p>说明<code>CephFS</code>和<code>RGW</code>都已经正常对接。<br>如果，你所使用的<code>admin</code>用户名下有很多的桶，那么这些桶都会以<code>/mnt/rgw/xxbucket</code>的结构显示出来，如果你在<code>/mnt/rgw/</code>下建立的一个目录，那么就相当于通过<code>RGW</code>建立了一个桶，所以，你执行<code>touch /mnt/rgw/123</code>是会报错的，因为不符合<code>S3</code>的对象必须位于桶内的规定，简单点说，就是把<code>/mnt/rgw/</code>和<code>S3</code>的根目录一一对应即可。</p><p>同样，<code>CephFS</code>内的内容都会显示在<code>/mnt/cephfs/</code>目录下。可以开始愉快的玩耍了！！</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/ganesha-600x450.png&quot; alt=&quot;ganesha&quot;&gt;&lt;/center&gt;

&lt;p&gt;自从&lt;code&gt;Jewel&lt;/code&gt;版本，&lt;code&gt;nfs-ganesha&lt;/code&gt;开始支持&lt;code&gt;ceph&lt;/code&gt;，并且把对接点选择了&lt;code&gt;rados&lt;/code&gt;。&lt;code&gt;Ganesha&lt;/code&gt;支持两种方式将&lt;code&gt;Ceph&lt;/code&gt;导出为&lt;code&gt;NFS&lt;/code&gt;，一种通过&lt;code&gt;RGW&lt;/code&gt;，一种通过&lt;code&gt;CephFS&lt;/code&gt;，通过&lt;code&gt;FSAL&lt;/code&gt;模块 连接到&lt;code&gt;RGW&lt;/code&gt;或者&lt;code&gt;CephFS&lt;/code&gt;， 其中，&lt;code&gt;FSAL_RGW&lt;/code&gt;调用&lt;code&gt;librgw2&lt;/code&gt;将&lt;code&gt;NFS&lt;/code&gt;协议转义为&lt;code&gt;S3&lt;/code&gt;协议再通过&lt;code&gt;RGW&lt;/code&gt;存入到&lt;code&gt;Ceph&lt;/code&gt;中，&lt;code&gt;FSAL_CEPH&lt;/code&gt; 调用&lt;code&gt;libcephfs1&lt;/code&gt;将&lt;code&gt;NFS&lt;/code&gt;转义为&lt;code&gt;Cephfs&lt;/code&gt;协议再存入到&lt;code&gt;Ceph&lt;/code&gt; 中。所以需要额外安装这两个包。&lt;/p&gt;
&lt;p&gt;本文就&lt;code&gt;Luminous&lt;/code&gt;版本的&lt;code&gt;ceph&lt;/code&gt;基于&lt;code&gt;ganesha&lt;/code&gt;导出&lt;code&gt;nfs&lt;/code&gt;部署，并且测试一下&lt;code&gt;rgw&lt;/code&gt;和&lt;code&gt;cephfs&lt;/code&gt;的性能。&lt;a href=&quot;http://www.xuxiaopang.com/2017/03/27/ganesha-nfs-deploy/#more&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@徐小胖&lt;/a&gt;已经就&lt;code&gt;jewel&lt;/code&gt;版本的过程进行了大致的讲解，我这边主要分享一下我遇到他文章没提到的和&lt;code&gt;Luminous&lt;/code&gt;场景导致的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="NFS-Ganesha" scheme="https://tony-yin.github.io/tags/NFS-Ganesha/"/>
    
  </entry>
  
  <entry>
    <title>Ceph RGW 安装和创建</title>
    <link href="https://tony-yin.github.io/2017/11/08/Ceph-RGW/"/>
    <id>https://tony-yin.github.io/2017/11/08/Ceph-RGW/</id>
    <published>2017-11-08T15:11:59.000Z</published>
    <updated>2017-11-08T15:20:27.000Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/gateway-600x450.png" alt="Ceph RGW"></center><p>本文通过<code>ceph-deploy</code>安装和创建<code>RGW</code>，然后分别创建<code>S3</code>和<code>Swift</code>接口并提供了相应的方案。</p><p><code>Ceph RGW</code>基于<code>librados</code>，是为应用提供<code>RESTful</code>类型的对象存储接口。<code>RGW</code>提供两种类型的接口：</p><ul><li>S3：兼容<code>Amazon S3 RESTful API</code></li><li>Swift：兼容<code>OpenStack Swift API</code></li></ul><p><code>S3</code>和<code>Swift API</code>共享同一个命名空间，所以可以使用两种<code>API</code>访问相同的数据。</p><a id="more"></a><p>参考链接: <a href="http://blog.csdn.net/younger_china/article/details/73410918" target="_blank" rel="external">Ceph：创建RGW</a></p><h2 id="部署-RGW"><a href="#部署-RGW" class="headerlink" title="部署 RGW"></a>部署 RGW</h2><h3 id="进入-ceph-目录"><a href="#进入-ceph-目录" class="headerlink" title="进入 ceph 目录"></a>进入 ceph 目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd /etc/ceph</div></pre></td></tr></table></figure><h3 id="安装-ceph-object-gateway"><a href="#安装-ceph-object-gateway" class="headerlink" title="安装 ceph object gateway"></a>安装 ceph object gateway</h3><p>我这边是<code>node1</code>，根据<code>hostname</code>对号入座就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy install --rgw node1</div></pre></td></tr></table></figure><h3 id="Gather-keys"><a href="#Gather-keys" class="headerlink" title="Gather keys"></a>Gather keys</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy gatherkeys node1</div></pre></td></tr></table></figure><h3 id="创建-rgw-实例"><a href="#创建-rgw-实例" class="headerlink" title="创建 rgw 实例"></a>创建 rgw 实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy rgw create node1</div></pre></td></tr></table></figure><h3 id="Ceph-CLI"><a href="#Ceph-CLI" class="headerlink" title="Ceph CLI"></a>Ceph CLI</h3><p><code>Ceph CLI</code>工具需要在管理员模式下运行，因此需要执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy admin node1</div></pre></td></tr></table></figure><h3 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h3><p>一旦<code>RGW</code>开始运行，就可以通过端口<code>7480</code>（如果没有修改的话）来访问。如：<br><code>http://node1:7480</code>，如果<code>RGW</code>运行正常，它应该返回类似的信息： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">This XML file does not appear to have any style information associated with it. The document tree is shown below.</div><div class="line">&lt;ListAllMyBucketsResult xmlns=&quot;http://s3.amazonaws.com/doc/2006-03-01/&quot;&gt;</div><div class="line">&lt;Owner&gt;</div><div class="line">&lt;ID&gt;anonymous&lt;/ID&gt;</div><div class="line">&lt;DisplayName/&gt;</div><div class="line">&lt;/Owner&gt;</div><div class="line">&lt;Buckets/&gt;</div><div class="line">&lt;/ListAllMyBucketsResult&gt;</div></pre></td></tr></table></figure><h2 id="创建-S3-用户"><a href="#创建-S3-用户" class="headerlink" title="创建 S3 用户"></a>创建 S3 用户</h2><p>想正常的访问<code>RGW</code>，需要创建相应的<code>RGW</code>用户，并赋予相应的权限，<code>radosgw-admin</code>命令实现了这些功能。</p><p>其中<code>keys</code>中的<code>user</code>，<code>access_key</code>和<code>secret_key</code>用于之后的<code>S3</code>接口访问确认</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">[root@node1 ~]# radosgw-admin user create --uid=&quot;admin&quot; --display-name=&quot;First user&quot;</div><div class="line">2017-11-08 16:51:39.883217 7fb6868fac40  0 WARNING: detected a version of libcurl which contains a bug in curl_multi_wait(). enabling a workaround that may degrade performance slightly.</div><div class="line">&#123;</div><div class="line">    &quot;user_id&quot;: &quot;admin&quot;,</div><div class="line">    &quot;display_name&quot;: &quot;First user&quot;,</div><div class="line">    &quot;email&quot;: &quot;&quot;,</div><div class="line">    &quot;suspended&quot;: 0,</div><div class="line">    &quot;max_buckets&quot;: 1000,</div><div class="line">    &quot;auid&quot;: 0,</div><div class="line">    &quot;subusers&quot;: [],</div><div class="line">    &quot;keys&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;user&quot;: &quot;admin&quot;,</div><div class="line">            &quot;access_key&quot;: &quot;1MWH3LWM1BS4ZF4HN5IH&quot;,</div><div class="line">            &quot;secret_key&quot;: &quot;cuObxYgtl1lJgqNxOIpENycVqXfxLxZ8z5IXDM0O&quot;</div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    &quot;swift_keys&quot;: [],</div><div class="line">    &quot;caps&quot;: [],</div><div class="line">    &quot;op_mask&quot;: &quot;read, write, delete&quot;,</div><div class="line">    &quot;default_placement&quot;: &quot;&quot;,</div><div class="line">    &quot;placement_tags&quot;: [],</div><div class="line">    &quot;bucket_quota&quot;: &#123;</div><div class="line">        &quot;enabled&quot;: false,</div><div class="line">        &quot;check_on_raw&quot;: false,</div><div class="line">        &quot;max_size&quot;: -1,</div><div class="line">        &quot;max_size_kb&quot;: 0,</div><div class="line">        &quot;max_objects&quot;: -1</div><div class="line">    &#125;,</div><div class="line">    &quot;user_quota&quot;: &#123;</div><div class="line">        &quot;enabled&quot;: false,</div><div class="line">        &quot;check_on_raw&quot;: false,</div><div class="line">        &quot;max_size&quot;: -1,</div><div class="line">        &quot;max_size_kb&quot;: 0,</div><div class="line">        &quot;max_objects&quot;: -1</div><div class="line">    &#125;,</div><div class="line">    &quot;temp_url_keys&quot;: [],</div><div class="line">    &quot;type&quot;: &quot;rgw&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="创建-Swift-用户"><a href="#创建-Swift-用户" class="headerlink" title="创建 Swift 用户"></a>创建 Swift 用户</h2><p><code>Swift</code>用户是作为子用户<code>subuser</code>被创建的，执行以下命令：</p><p>其中<code>swift_keys</code>中的<code>user</code>和<code>secret_key</code>用于之后的<code>swift</code>接口访问确认</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">[root@node1 ~]# radosgw-admin subuser create --uid=admin --subuser=admin:swift --access=full</div><div class="line">2017-11-08 16:55:05.371174 7fb4cbfc2c40  0 WARNING: detected a version of libcurl which contains a bug in curl_multi_wait(). enabling a workaround that may degrade performance slightly.</div><div class="line">&#123;</div><div class="line">    &quot;user_id&quot;: &quot;admin&quot;,</div><div class="line">    &quot;display_name&quot;: &quot;First user&quot;,</div><div class="line">    &quot;email&quot;: &quot;&quot;,</div><div class="line">    &quot;suspended&quot;: 0,</div><div class="line">    &quot;max_buckets&quot;: 1000,</div><div class="line">    &quot;auid&quot;: 0,</div><div class="line">    &quot;subusers&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;id&quot;: &quot;admin:swift&quot;,</div><div class="line">            &quot;permissions&quot;: &quot;full-control&quot;</div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    &quot;keys&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;user&quot;: &quot;admin&quot;,</div><div class="line">            &quot;access_key&quot;: &quot;1MWH3LWM1BS4ZF4HN5IH&quot;,</div><div class="line">            &quot;secret_key&quot;: &quot;cuObxYgtl1lJgqNxOIpENycVqXfxLxZ8z5IXDM0O&quot;</div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    &quot;swift_keys&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;user&quot;: &quot;admin:swift&quot;,</div><div class="line">            &quot;secret_key&quot;: &quot;PKRXACd8Ysgx7MCTjd9gHnL3sdpJ2J6wsuy2IS0P&quot;</div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    &quot;caps&quot;: [],</div><div class="line">    &quot;op_mask&quot;: &quot;read, write, delete&quot;,</div><div class="line">    &quot;default_placement&quot;: &quot;&quot;,</div><div class="line">    &quot;placement_tags&quot;: [],</div><div class="line">    &quot;bucket_quota&quot;: &#123;</div><div class="line">        &quot;enabled&quot;: false,</div><div class="line">        &quot;check_on_raw&quot;: false,</div><div class="line">        &quot;max_size&quot;: -1,</div><div class="line">        &quot;max_size_kb&quot;: 0,</div><div class="line">        &quot;max_objects&quot;: -1</div><div class="line">    &#125;,</div><div class="line">    &quot;user_quota&quot;: &#123;</div><div class="line">        &quot;enabled&quot;: false,</div><div class="line">        &quot;check_on_raw&quot;: false,</div><div class="line">        &quot;max_size&quot;: -1,</div><div class="line">        &quot;max_size_kb&quot;: 0,</div><div class="line">        &quot;max_objects&quot;: -1</div><div class="line">    &#125;,</div><div class="line">    &quot;temp_url_keys&quot;: [],</div><div class="line">    &quot;type&quot;: &quot;rgw&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="测试-S3-接口"><a href="#测试-S3-接口" class="headerlink" title="测试 S3 接口"></a>测试 S3 接口</h2><p>需要创建一个<code>python</code>测试脚本来测试<code>S3</code>访问。该脚本会连接<code>RGW</code>，创建一个<code>bucket</code>并打印输出所有的<code>bucket</code>。其中，变量<code>access_key</code>和<code>secret_access</code>的值，来自于创建<code>S3</code>用户命令时，<code>radosgw-admin</code>命令返回的<code>keys-&gt;access_key</code>和<code>keys-&gt;secret_key</code>。</p><h3 id="安装-python-boto库"><a href="#安装-python-boto库" class="headerlink" title="安装 python-boto库"></a>安装 python-boto库</h3><p>执行以下步骤，首先安装<code>python-boto</code>库，该库用于连接<code>S3</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y python-boto</div></pre></td></tr></table></figure><h3 id="创建脚本"><a href="#创建脚本" class="headerlink" title="创建脚本"></a>创建脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python  </div><div class="line"># -*- coding:utf-8 -*-  </div><div class="line"></div><div class="line">import boto.s3.connection  </div><div class="line">   </div><div class="line">access_key = &apos;1MWH3LWM1BS4ZF4HN5IH&apos;     </div><div class="line">secret_key =&apos;cuObxYgtl1lJgqNxOIpENycVqXfxLxZ8z5IXDM0O&apos;  </div><div class="line">conn = boto.connect_s3(  </div><div class="line">        aws_access_key_id=access_key,  </div><div class="line">        aws_secret_access_key=secret_key,  </div><div class="line">        host=&apos;&#123;hostname&#125;&apos;,port=&#123;port&#125;,  </div><div class="line">        is_secure=False,calling_format=boto.s3.connection.OrdinaryCallingFormat(),  </div><div class="line">        )  </div><div class="line">   </div><div class="line">bucket = conn.create_bucket(&apos;my-new-bucket&apos;)  </div><div class="line">for bucket in conn.get_all_buckets():  </div><div class="line">    print&quot;&#123;name&#125; &#123;created&#125;&quot;.format(  </div><div class="line">            name=bucket.name,  </div><div class="line">            created=bucket.creation_date,  </div><div class="line">            )</div></pre></td></tr></table></figure><p>需要将上面的<code>{hostname}</code>替换成对应的<code>hostname</code>或者<code>IP</code>,例如<code>192.168.1.1</code>；将<code>{port}</code>替换成<code>RGW</code>运行的端口，默认为<code>7480</code>；前者为字符串，后者为数字</p><h3 id="执行脚本测试"><a href="#执行脚本测试" class="headerlink" title="执行脚本测试"></a>执行脚本测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@node1 ceph]# python s3test.py </div><div class="line">my-new-bucket 2017-11-01T10:58:53.670Z</div></pre></td></tr></table></figure><h2 id="测试-Swift-接口"><a href="#测试-Swift-接口" class="headerlink" title="测试 Swift 接口"></a>测试 Swift 接口</h2><h3 id="安装相关软件包"><a href="#安装相关软件包" class="headerlink" title="安装相关软件包"></a>安装相关软件包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pip installpython-setuptools    </div><div class="line">pip installpython-swiftclient</div></pre></td></tr></table></figure><h3 id="命令行访问"><a href="#命令行访问" class="headerlink" title="命令行访问"></a>命令行访问</h3><p>替换<code>{ip}</code>，<code>{port}</code>和<code>{swift_secret_key}</code>，其中<code>{swift_secret_key}</code>为创建<code>Swift</code>用户时，<code>radosgw-admin</code>命令返回的<code>swift_keys-&gt;secret_key</code>的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swift -A http://&#123;ip&#125;:&#123;port&#125;/auth/1.0 -Utestuser:swift -K &apos;&#123;swift_secret_key&#125;&apos; list</div></pre></td></tr></table></figure><p>正常输出应该如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@node1 ceph]# swift -Ahttp://192.168.1.1:7480/auth/1.0 -U admin:swift -K &apos;PKRXACd8Ysgx7MCTjd9gHnL3sdpJ2J6wsuy2IS0P&apos; list  </div><div class="line">my-new-bucket</div></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>ceph-deploy</code>命令，大大地简化了对<code>Ceph</code>集群和<code>RGW的</code>安装和配置，可以很快速的搭建测试环境，达到测试效果，但如果要在生产环境中应用的话，可能需要手动做一些配置就，不能完全依赖<code>ceph-deploy</code>了。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/gateway-600x450.png&quot; alt=&quot;Ceph RGW&quot;&gt;&lt;/center&gt;

&lt;p&gt;本文通过&lt;code&gt;ceph-deploy&lt;/code&gt;安装和创建&lt;code&gt;RGW&lt;/code&gt;，然后分别创建&lt;code&gt;S3&lt;/code&gt;和&lt;code&gt;Swift&lt;/code&gt;接口并提供了相应的方案。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ceph RGW&lt;/code&gt;基于&lt;code&gt;librados&lt;/code&gt;，是为应用提供&lt;code&gt;RESTful&lt;/code&gt;类型的对象存储接口。&lt;code&gt;RGW&lt;/code&gt;提供两种类型的接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S3：兼容&lt;code&gt;Amazon S3 RESTful API&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Swift：兼容&lt;code&gt;OpenStack Swift API&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;S3&lt;/code&gt;和&lt;code&gt;Swift API&lt;/code&gt;共享同一个命名空间，所以可以使用两种&lt;code&gt;API&lt;/code&gt;访问相同的数据。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="RGW" scheme="https://tony-yin.github.io/tags/RGW/"/>
    
  </entry>
  
  <entry>
    <title>使用NFS挂载RBD</title>
    <link href="https://tony-yin.github.io/2017/10/31/RBD-Mount-NFS/"/>
    <id>https://tony-yin.github.io/2017/10/31/RBD-Mount-NFS/</id>
    <published>2017-10-31T14:45:25.000Z</published>
    <updated>2017-10-31T14:52:40.000Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ovv1r40we.bkt.clouddn.com/rbd-london-christmas-600x450.jpg" alt="RBD"></center><p><strong>具体场景</strong></p><ul><li>在<code>Server</code>端创建<code>RBD</code>块设备并挂载到某个目录，然后在<code>Client</code>端通过<code>NFS</code>将<code>Server</code>端之前说的目录再挂载到本地，就可以实现在客户端写文件通过<code>NFS</code>到<code>Server</code>端的块设备上</li><li>这波操作的目的是因为测试<code>EC</code>性能时，<code>Ceph</code>版本还是<code>Hammer</code>，<code>CephFS</code>不是很稳定，性能不行，所以想用<code>RBD</code>的方式取代，但是<code>Hammer</code>版本中<code>EC</code>是只支持<code>RGW</code>的，并不支持<code>CephFS</code>和<code>RBD</code>，至于这个场景具体流程之后会在其他文章分享</li><li>这波操作在之前<code>Ceph</code>的<code>Hammer</code>版本做过，这次是要在新版本<code>Luminous</code>上实践，由于遇到了很多问题，大部分都是新版本缘故引入的，故与大家分享</li></ul><blockquote><p>PS：<code>Luminous</code>新版本提供了新的<code>NFS</code>的处理方式，不再需要用这种老式的<code>RBD</code>的手段，之后也会在其他文章分享出来</p></blockquote><a id="more"></a><h2 id="Hammer版本"><a href="#Hammer版本" class="headerlink" title="Hammer版本"></a>Hammer版本</h2><p>操作步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">1. 使用RBD方式导出NFS，步骤如下：</div><div class="line"></div><div class="line">1.1 create RBD block device image (size unit: MB)</div><div class="line"># rbd create --size 1024 ec-pool/test_image</div><div class="line"></div><div class="line">1.2 map RBD device</div><div class="line"># rbd map ec-pool/test_image</div><div class="line"></div><div class="line">[Optional] check mapped device</div><div class="line"># rbd showmapped</div><div class="line"></div><div class="line">1.3 create filesystem on the device</div><div class="line"># mkfs.ext4 /dev/rbd0</div><div class="line"></div><div class="line">1.4 mount it,</div><div class="line"># mkdir -p /vol/test_image</div><div class="line"># mount /dev/rbd0 /vol/test_image/</div><div class="line"></div><div class="line">1.5 export it, modify the /etc/exports</div><div class="line"># cat /etc/exports</div><div class="line">/vol/test_image *(rw,async,no_subtree_check,no_root_squash)</div><div class="line"># service nfs-kernel-server restart</div><div class="line"># exportfs -r</div><div class="line"></div><div class="line">1.6 check mount info for NFS server</div><div class="line"># showmount -e 192.168.1.167</div><div class="line"></div><div class="line">2. 在客户端以nfs方式mount上述导出的文件夹</div><div class="line"># mount -t nfs 192.168.1.167:/vol/test_image /mnt</div></pre></td></tr></table></figure><h2 id="Luminous版本"><a href="#Luminous版本" class="headerlink" title="Luminous版本"></a>Luminous版本</h2><h3 id="Create-RBD-image"><a href="#Create-RBD-image" class="headerlink" title="Create RBD image"></a>Create RBD image</h3><p>之前<code>EC Pool</code>只能为<code>RGW</code>服务 ，直到<code>Luminous</code>版本，<code>EC Pool</code>也可以应用在<code>RBD</code>和<code>CephFS</code>，并且增加了<code>data-pool</code>这样的新特性，具体请参考官网：<a href="http://docs.ceph.com/docs/luminous/rados/operations/erasure-code/#erasure-coding-with-overwrites" target="_blank" rel="external">http://docs.ceph.com/docs/luminous/rados/operations/erasure-code/#erasure-coding-with-overwrites</a></p><p>所以创建<code>image</code>的方式也有所改变</p><h4 id="Enable-ec-overwrites"><a href="#Enable-ec-overwrites" class="headerlink" title="Enable ec overwrites"></a>Enable ec overwrites</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd pool set ec_pool allow_ec_overwrites true</div></pre></td></tr></table></figure><h4 id="Create-pool-and-image"><a href="#Create-pool-and-image" class="headerlink" title="Create pool and image"></a>Create pool and image</h4><p>由于<code>EC</code>不支持<code>omap</code>，所以在<code>CephFS</code>或者<code>RBD</code>场景使用<code>EC</code>时，需要将<code>data</code>存在<code>EC Pool</code>中，将<code>metadata</code>存在<code>Replicated Pool</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 创建pool</div><div class="line">ceph osd pool create ec-pool 12 12 erasure  // ec pool, store data</div><div class="line">ceph osd pool create md-pool 12 12 replicated   // replicated pool, store metadata</div><div class="line">ceph osd pool create ssd-pool 12 12 replicated  // replicated pool, used as cache pool</div><div class="line">// 创建image</div><div class="line">rbd create --size 1024 --data-pool ec-pool md-pool/test_image</div></pre></td></tr></table></figure><h3 id="Map-RBD"><a href="#Map-RBD" class="headerlink" title="Map RBD"></a>Map RBD</h3><p>这一步之前的操作是<code>rbd map ec-pool/test_image</code>，所以当前需要执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd map md-pool/test_image</div></pre></td></tr></table></figure><p>但是一直<code>timeout</code>，通过查看<code>dmesg</code>和网上资料发现是因为<code>linux kernel</code>版本太低，所以升级了一下内核到<code>4.3</code>版本之后就可以<code>work</code>了</p><p>升级内核版本请参考：</p><blockquote><ul><li><a href="http://www.jianshu.com/p/66a724a1f3af" target="_blank" rel="external">内核版本过低导致RBD Feature不支持</a></li><li><a href="http://xiaqunfeng.cc/2017/06/06/ceph-rbd-map-failed/" target="_blank" rel="external">RBD Feature</a></li></ul></blockquote><h3 id="Check-map"><a href="#Check-map" class="headerlink" title="Check map"></a>Check map</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd showmapped</div></pre></td></tr></table></figure><h3 id="Create-filesystem-on-RBD"><a href="#Create-filesystem-on-RBD" class="headerlink" title="Create filesystem on RBD"></a>Create filesystem on RBD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkfs.ext4 /dev/rbd0</div></pre></td></tr></table></figure><h3 id="Mount"><a href="#Mount" class="headerlink" title="Mount"></a>Mount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir -p /vol/test_image</div><div class="line">mount /dev/rbd0 /vol/test_image/</div></pre></td></tr></table></figure><h3 id="Modify-export-for-nfs-on-server"><a href="#Modify-export-for-nfs-on-server" class="headerlink" title="Modify export for nfs on server"></a>Modify export for nfs on server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vim /etc/exports</div><div class="line">/vol/test_image *(rw,async,no_subtree_check,no_root_squash) // Modify it to /etc/exports</div></pre></td></tr></table></figure><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><h5 id="Install-NFS-on-server-and-client"><a href="#Install-NFS-on-server-and-client" class="headerlink" title="Install NFS on server and client"></a>Install NFS on server and client</h5><p><code>Server</code>端执行一下操作</p><h5 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install nfs-utils rpcbind</div></pre></td></tr></table></figure><h5 id="Start-service"><a href="#Start-service" class="headerlink" title="Start service"></a>Start service</h5><p><code>nfs</code>依赖<code>rpcbind</code>，所以必须先启动<code>rpcbind</code>，这很重要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">service rpcbind start</div><div class="line">service nfs start</div><div class="line">exportfs -r</div></pre></td></tr></table></figure><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><p>客户端也执行以上操作，假设客户端<code>ip</code>为<code>192.168.1.1</code>，服务端为<code>192.168.1.2</code></p><h5 id="Check-mount"><a href="#Check-mount" class="headerlink" title="Check mount"></a>Check mount</h5><p>查看是否可以挂载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">showmount -e 192.168.1.2</div></pre></td></tr></table></figure><h5 id="Mount-server-to-client"><a href="#Mount-server-to-client" class="headerlink" title="Mount server to client"></a>Mount server to client</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount -t nfs 192.168.1.2:/vol/test_image /mnt</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>遇到的主要问题</p><ul><li><code>EC Pool</code>创建<code>image</code>因为新版本改动</li><li><code>rbd map</code>因为<code>linux kernel</code>版本低</li><li><code>nfs</code>因为<code>nfs</code>在<code>rpcbind</code>前启动</li></ul><p>希望帮助大家尽量少些踩坑 ~~~</p><p>作者： Tony<br>日期： 2017-10-31 22:33</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ovv1r40we.bkt.clouddn.com/rbd-london-christmas-600x450.jpg&quot; alt=&quot;RBD&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;具体场景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;Server&lt;/code&gt;端创建&lt;code&gt;RBD&lt;/code&gt;块设备并挂载到某个目录，然后在&lt;code&gt;Client&lt;/code&gt;端通过&lt;code&gt;NFS&lt;/code&gt;将&lt;code&gt;Server&lt;/code&gt;端之前说的目录再挂载到本地，就可以实现在客户端写文件通过&lt;code&gt;NFS&lt;/code&gt;到&lt;code&gt;Server&lt;/code&gt;端的块设备上&lt;/li&gt;
&lt;li&gt;这波操作的目的是因为测试&lt;code&gt;EC&lt;/code&gt;性能时，&lt;code&gt;Ceph&lt;/code&gt;版本还是&lt;code&gt;Hammer&lt;/code&gt;，&lt;code&gt;CephFS&lt;/code&gt;不是很稳定，性能不行，所以想用&lt;code&gt;RBD&lt;/code&gt;的方式取代，但是&lt;code&gt;Hammer&lt;/code&gt;版本中&lt;code&gt;EC&lt;/code&gt;是只支持&lt;code&gt;RGW&lt;/code&gt;的，并不支持&lt;code&gt;CephFS&lt;/code&gt;和&lt;code&gt;RBD&lt;/code&gt;，至于这个场景具体流程之后会在其他文章分享&lt;/li&gt;
&lt;li&gt;这波操作在之前&lt;code&gt;Ceph&lt;/code&gt;的&lt;code&gt;Hammer&lt;/code&gt;版本做过，这次是要在新版本&lt;code&gt;Luminous&lt;/code&gt;上实践，由于遇到了很多问题，大部分都是新版本缘故引入的，故与大家分享&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;PS：&lt;code&gt;Luminous&lt;/code&gt;新版本提供了新的&lt;code&gt;NFS&lt;/code&gt;的处理方式，不再需要用这种老式的&lt;code&gt;RBD&lt;/code&gt;的手段，之后也会在其他文章分享出来&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="RBD" scheme="https://tony-yin.github.io/tags/RBD/"/>
    
      <category term="EC" scheme="https://tony-yin.github.io/tags/EC/"/>
    
      <category term="NFS" scheme="https://tony-yin.github.io/tags/NFS/"/>
    
  </entry>
  
  <entry>
    <title>Python Profiler</title>
    <link href="https://tony-yin.github.io/2017/10/10/Python-Profiler/"/>
    <id>https://tony-yin.github.io/2017/10/10/Python-Profiler/</id>
    <published>2017-10-10T13:46:24.000Z</published>
    <updated>2017-10-10T13:56:47.000Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ovv1r40we.bkt.clouddn.com/publicenemyno1-600x400.png" alt="Python Profiler"></center><p><code>OSD</code>启用过程耗时较长，需要进行性能优化。期间通过<code>python profilers</code>对代码进行性能分析和数据统计，有坑，有收获，总而言之，这是一个不错的工具</p><a id="more"></a><h2 id="Profilers简介"><a href="#Profilers简介" class="headerlink" title="Profilers简介"></a>Profilers简介</h2><p><code>python profilers</code>内置的主要有三种<code>cprofile</code>, <code>profile</code>和<code>hotshot</code>,<code>cprofile</code>是基于<code>profile</code>之上做的扩展，性能要比后者好很多，所以我用的就是<code>cprofile</code></p><p>更详细的介绍可以查看官网，<code>python profilers</code>的好处在于不用看教程，只要看着官网简短的概述，就能掌握其使用方法</p><ul><li><a href="https://docs.python.org/2/library/profile.html" target="_blank" rel="external">Python Profile</a></li><li><a href="http://www.cnblogs.com/btchenguang/archive/2012/02/03/2337112.html" target="_blank" rel="external">关于Python Profilers性能分析器</a></li></ul><h2 id="Cprofile快速使用"><a href="#Cprofile快速使用" class="headerlink" title="Cprofile快速使用"></a>Cprofile快速使用</h2><h3 id="官网例子"><a href="#官网例子" class="headerlink" title="官网例子"></a>官网例子</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cProfile</div><div class="line"><span class="keyword">import</span> re</div><div class="line">cProfile.run(<span class="string">'re.compile("foo|bar")'</span>)</div></pre></td></tr></table></figure><h4 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">197 function calls (192 primitive calls) in 0.002 seconds</div><div class="line">Ordered by: standard name</div><div class="line">ncalls  tottime  percall  cumtime  percall filename:lineno(function)</div><div class="line">     1    0.000    0.000    0.001    0.001 &lt;string&gt;:1(&lt;module&gt;)</div><div class="line">     1    0.000    0.000    0.001    0.001 re.py:212(compile)</div><div class="line">     1    0.000    0.000    0.001    0.001 re.py:268(_compile)</div><div class="line">     1    0.000    0.000    0.000    0.000 sre_compile.py:172(_compile_charset)</div><div class="line">     1    0.000    0.000    0.000    0.000 sre_compile.py:201(_optimize_charset)</div><div class="line">     4    0.000    0.000    0.000    0.000 sre_compile.py:25(_identityfunction)</div><div class="line">   3/1    0.000    0.000    0.000    0.000 sre_compile.py:33(_compile)</div></pre></td></tr></table></figure><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><center><img src="http://images.cnblogs.com/cnblogs_com/btchenguang/201202/201202031502512968.png" alt="cprofile"></center><h2 id="Cprofile深入"><a href="#Cprofile深入" class="headerlink" title="Cprofile深入"></a>Cprofile深入</h2><p>上面的基本用法可以在脚本中测试某个语句或者函数，然后打印到控制台。<code>cprofile</code>也可以将结果输出到文件中，这是比较常见的做法，因为打印到控制台，第一不能保存结果，第二如果数据量多没法全部浏览，并且影响阅读效果。而放在文件中还可以对结果进行按需排序、筛选等操作</p><h3 id="输出文件"><a href="#输出文件" class="headerlink" title="输出文件"></a>输出文件</h3><ol><li>参数方式</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cProfile</div><div class="line"><span class="keyword">import</span> re</div><div class="line">cProfile.run(<span class="string">'re.compile("foo|bar")'</span>, <span class="string">'restats'</span>)</div></pre></td></tr></table></figure><ol><li>CLI方式</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python -m cProfile [-o output_file] [-s sort_order] myscript.py</div></pre></td></tr></table></figure><h2 id="Cprofile优雅使用"><a href="#Cprofile优雅使用" class="headerlink" title="Cprofile优雅使用"></a>Cprofile优雅使用</h2><p>上述方式可以使得<code>cprofile</code>在一些测试环境中受用，但是在一些复杂的环境中不能很好的<code>work</code>。由于<code>cprofile</code>是根据<code>python</code>在每个事件中存放的<code>hook</code>进行性能分析，所以在<code>cprofile.run()</code>的时候，要保证他就是最上层，他是调用的源头。</p><p>但是实际场景中，我们经常会对一些<code>API</code>中的某个方法进行性能分析，如果在被调用处使用<code>cprofile</code>，会出现变量或者模块<code>undefined</code>的现象，模块不能识别还可以在<code>run</code>方法中引入，然后通过分号分隔，例如<code>cprofile.run(import re, re.compile(&quot;foo|bar&quot;))</code>，具体可以参考这篇文章：<a href="http://ju.outofmemory.cn/entry/46805" target="_blank" rel="external">Python Profile 工具性能分析</a></p><p>变量无法识别更是让人头疼，所以为了达到测试效果，你会不得不修改一些并不是很少量的源代码，并且测一个方法就要搞一次很麻烦。还有一些多进程或者跨机器的场景导致代码异步执行，这样<code>cprofile</code>更不能达到用户的需求</p><p>还好我们可以通过<code>python</code>装饰器的机制来做，这样既不用改动源代码，也可以很方便的切换函数分析</p><h3 id="装饰器接口"><a href="#装饰器接口" class="headerlink" title="装饰器接口"></a>装饰器接口</h3><p>这里要注意设置全局变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PROFILING=y</div></pre></td></tr></table></figure><p>接口定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cProfile</div><div class="line"><span class="keyword">import</span> pstats</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="comment"># 性能分析装饰器定义</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_cprofile</span><span class="params">(filename)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">profiled_func</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">            <span class="comment"># Flag for do profiling or not.</span></div><div class="line">            DO_PROF = os.getenv(<span class="string">"PROFILING"</span>)</div><div class="line">            <span class="keyword">if</span> DO_PROF:</div><div class="line">                profile = cProfile.Profile()</div><div class="line">                profile.enable()</div><div class="line">                result = func(*args, **kwargs)</div><div class="line">                profile.disable()</div><div class="line">                <span class="comment"># Sort stat by internal time.</span></div><div class="line">                sortby = <span class="string">"tottime"</span></div><div class="line">                ps = pstats.Stats(profile).sort_stats(sortby)</div><div class="line">                ps.dump_stats(filename)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                result = func(*args, **kwargs)</div><div class="line">            <span class="keyword">return</span> result</div><div class="line">        <span class="keyword">return</span> profiled_func</div><div class="line">    <span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure><h3 id="分析使用"><a href="#分析使用" class="headerlink" title="分析使用"></a>分析使用</h3><p>这时候只需要在调用的函数上面加一个装饰器即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@do_cprofile('filename')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></div></pre></td></tr></table></figure><h2 id="pstats分析工具"><a href="#pstats分析工具" class="headerlink" title="pstats分析工具"></a>pstats分析工具</h2><p><code>pstats</code>可以根据<code>cprofile</code>生成的文件进行排序、筛选等处理，呈现更主要的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pstats</div><div class="line"> </div><div class="line"><span class="comment"># 创建Stats对象</span></div><div class="line">p = pstats.Stats(<span class="string">"result.out"</span>)</div><div class="line"> </div><div class="line"><span class="comment"># strip_dirs(): 去掉无关的路径信息</span></div><div class="line"><span class="comment"># sort_stats(): 排序，支持的方式和上述的一致</span></div><div class="line"><span class="comment"># print_stats(): 打印分析结果，可以指定打印前几行</span></div><div class="line"> </div><div class="line"><span class="comment"># 和直接运行cProfile.run("test()")的结果是一样的</span></div><div class="line">p.strip_dirs().sort_stats(<span class="number">-1</span>).print_stats()</div><div class="line"> </div><div class="line"><span class="comment"># 按照函数名排序，只打印前3行函数的信息, 参数还可为小数,表示前百分之几的函数信息 </span></div><div class="line">p.strip_dirs().sort_stats(<span class="string">"name"</span>).print_stats(<span class="number">3</span>)</div><div class="line"> </div><div class="line"><span class="comment"># 按照运行时间和函数名进行排序</span></div><div class="line">p.strip_dirs().sort_stats(<span class="string">"cumulative"</span>, <span class="string">"name"</span>).print_stats(<span class="number">0.5</span>)</div><div class="line"> </div><div class="line"><span class="comment"># 如果想知道有哪些函数调用了sum_num</span></div><div class="line">p.print_callers(<span class="number">0.5</span>, <span class="string">"sum_num"</span>)</div><div class="line"> </div><div class="line"><span class="comment"># 查看test()函数中调用了哪些函数</span></div><div class="line">p.print_callees(<span class="string">"test"</span>)</div></pre></td></tr></table></figure><p>上述代码摘自：<a href="http://xianglong.me/article/analysis-python-application-performance-using-cProfile/" target="_blank" rel="external">使用cProfile分析Python程序性能</a>，原文还提供了<code>pstats</code>命令行交互工具方式</p><h2 id="图形可视化"><a href="#图形可视化" class="headerlink" title="图形可视化"></a>图形可视化</h2><p>上面的命令行界面的确是有点反人类，不易一下子清晰地分析性能瓶颈，有很多图形可视化工具可以帮助我们生成简洁明了的图片</p><p>工具有：</p><ul><li>gprof2dot</li><li>vprof</li><li>RunSnakeRun</li><li>KCacheGrind &amp; pyprof2calltree</li></ul><p>最终我选择了<code>gprof2dot</code>，比较符合我的口味</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我的机器是<code>ubuntu</code>，其他类型机器找对应方式，具体参考：<a href="https://github.com/jrfonseca/gprof2dot" target="_blank" rel="external">Github gprof2dot</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-get install python graphviz</div><div class="line">pip install gprof2dot</div></pre></td></tr></table></figure><p>注意：</p><p>如果<code>pip</code>安装软件包报错：’Cannot fetch index base URL  <a href="http://pypi.python.org/simple/" target="_blank" rel="external">http://pypi.python.org/simple/</a>‘</p><p>解决办法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1. windows下创建/%user%/pip/pop.ini，并添加以下内容。</div><div class="line">[global]  </div><div class="line">index-url=http://pypi.douban.com/simple/</div><div class="line">2. linux创建文件~/.pip/pip.conf，并添加一下内容。</div><div class="line">[global]  </div><div class="line">index-url=http://pypi.douban.com/simple/</div><div class="line">3. 再次使用pip安装相应的包即可。</div></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>根据<code>cpofile</code>输出的文件生成图片，这边输出的文件名为<code>osd.out</code>，生成的图片名为<code>osd.png</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gprof2dot -f pstats osd.out | dot -Tpng -o osd.png</div></pre></td></tr></table></figure><p>具体参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/24495603/" target="_blank" rel="external">Python优化第一步: 性能分析实践</a>，写的很好，也很具体</p><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p>这是我进行性能分析产生的两张图</p><p>Picture 1：</p><center><img src="http://ovv1r40we.bkt.clouddn.com/enable_osd3.png" alt="enable_osd1"></center><p>Picture 2：</p><center><img src="http://ovv1r40we.bkt.clouddn.com/enable_osd3-2.png" alt="enable_osd2"></center><h2 id="继续深入"><a href="#继续深入" class="headerlink" title="继续深入"></a>继续深入</h2><ul><li><code>pstats</code>深入了解</li><li><code>gprof2dot</code>深入了解</li><li>其他的可视化工具</li></ul><p>不过最终的目的都是通过性能分析找到性能瓶颈，然后进行优化，适合自己的就好</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ovv1r40we.bkt.clouddn.com/publicenemyno1-600x400.png&quot; alt=&quot;Python Profiler&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;code&gt;OSD&lt;/code&gt;启用过程耗时较长，需要进行性能优化。期间通过&lt;code&gt;python profilers&lt;/code&gt;对代码进行性能分析和数据统计，有坑，有收获，总而言之，这是一个不错的工具&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Profile" scheme="https://tony-yin.github.io/tags/Profile/"/>
    
      <category term="Python" scheme="https://tony-yin.github.io/tags/Python/"/>
    
      <category term="性能优化" scheme="https://tony-yin.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>启用OSD性能剖析脚本</title>
    <link href="https://tony-yin.github.io/2017/10/10/Enable-OSD-Profile-Script/"/>
    <id>https://tony-yin.github.io/2017/10/10/Enable-OSD-Profile-Script/</id>
    <published>2017-10-10T13:34:16.000Z</published>
    <updated>2017-10-10T13:46:10.000Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ovv1r40we.bkt.clouddn.com/pozza-600x450.png" alt="Profile"></center><p>针对<code>OSD</code>启用过程缓慢进行性能剖析，用到了一系列的脚本，例如批量创建<code>OSD</code>,批量启用<code>OSD</code>,<code>Cprofile</code>装饰器接口等</p><a id="more"></a><p><code>docprofile.py</code>：提供<code>cprofiler</code>的装饰器接口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cProfile</div><div class="line"><span class="keyword">import</span> pstats</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_cprofile</span><span class="params">(filename)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">profiled_func</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">            <span class="keyword">print</span> filename</div><div class="line">            <span class="comment"># Flag for do profiling or not.</span></div><div class="line">            DO_PROF = os.getenv(<span class="string">"PROFILING"</span>)</div><div class="line">            <span class="keyword">if</span> DO_PROF:</div><div class="line">                profile = cProfile.Profile()</div><div class="line">                profile.enable()</div><div class="line">                result = func(*args, **kwargs)</div><div class="line">                profile.disable()</div><div class="line">                <span class="comment"># Sort stat by internal time.</span></div><div class="line">                sortby = <span class="string">"cum"</span></div><div class="line">                ps = pstats.Stats(profile).sort_stats(sortby)</div><div class="line">                ps.dump_stats(filename)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                result = func(*args, **kwargs)</div><div class="line">            <span class="keyword">return</span> result</div><div class="line">        <span class="keyword">return</span> profiled_func</div><div class="line">    <span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure><p><code>create_osd.py</code>：批量创建<code>osd</code>的脚本，目前支持批量创建20个或者以下数量的<code>osd</code>，默认<code>/dev/sda</code>和<code>/dev/sdb</code>各<code>10</code>个，并且<code>journal</code>分区采用预设分区，分区类型为单一分区，缓存为空，参数较为简单，仅供测试使用，如果有其他需求，需要适当修改代码</p><p>使用方法: <code>python create_osd.py osd1 20</code>    // 起始osd， 数量   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> mcs3 <span class="keyword">import</span> storage</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">first_osd = sys.argv[<span class="number">1</span>]</div><div class="line">num = sys.argv[<span class="number">2</span>]</div><div class="line">first_number = int(first_osd[<span class="number">3</span>:])</div><div class="line"></div><div class="line">count = <span class="number">1</span></div><div class="line"><span class="keyword">for</span> osd <span class="keyword">in</span> range(first_number, int(num) + first_number)</div><div class="line">    sv_name = <span class="string">'osd'</span> + str(osd)</div><div class="line">    data_dev = <span class="string">'/dev/sda'</span> + str(osd) <span class="keyword">if</span> count &lt;=<span class="number">10</span> <span class="keyword">else</span> <span class="string">'/dev/sdb'</span> + str(osd - <span class="number">10</span>)</div><div class="line">    journal_dev = <span class="string">''</span></div><div class="line">    cache_dev = <span class="string">''</span></div><div class="line">    host = <span class="string">'10.16.100.99'</span></div><div class="line">    storage.add_storage_volume_single(sv_name, data_dev, journal_dev, cache_dev, _host=host)</div><div class="line">    count += <span class="number">1</span></div></pre></td></tr></table></figure><p><code>enable_osd.py</code>：<code>admin</code>层启用<code>osd</code>的后端脚本，一些参数都是默认设置好的，所以有需要改变的要修改部分<code>hardcode</code></p><blockquote><p>需要注意的是这段代码不会等待后端所有启用工作执行完毕才结束，而是调用后就直接结束脚本执行了</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> mcs3.config</div><div class="line"><span class="keyword">from</span> mcs3.cluster <span class="keyword">import</span> ClusterManager, IfaceRoleChangeInUse, IfaceRoleNotDefined</div><div class="line"><span class="keyword">from</span> mcs3.license <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> mcs3.node_management <span class="keyword">import</span> prepare_enable_osd, enable_osd</div><div class="line"><span class="keyword">from</span> mcs3.remote <span class="keyword">import</span> TASK_TICKET, ASYNC_MODE</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">from</span> docprofile <span class="keyword">import</span> do_cprofile</div><div class="line"></div><div class="line"><span class="meta">@do_cprofile('./enable_osd.out')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></div><div class="line">    ip = <span class="string">'10.16.100.99'</span></div><div class="line">    cluster_if = <span class="string">''</span></div><div class="line">    public_if = <span class="string">'eth0'</span></div><div class="line">    first_osd = sys.argv[<span class="number">1</span>]</div><div class="line">    num = sys.argv[<span class="number">2</span>]</div><div class="line">    svs = []</div><div class="line">    <span class="keyword">for</span> osd <span class="keyword">in</span> range(int(first_osd[<span class="number">3</span>:]), int(num)+int(first_osd[<span class="number">3</span>:])):</div><div class="line">        svs.append(<span class="string">'osd'</span> + str(osd))</div><div class="line">    <span class="keyword">print</span> svs</div><div class="line">    mgr = ClusterManager()</div><div class="line">    all_osds = mgr.list_hosts_in_pool(<span class="string">"default"</span>)</div><div class="line"></div><div class="line">    cluster_ip = mcs3.config.Mcs3CephConfig().get_storage_ip()</div><div class="line">    lic_str = get_license_key(cluster_ip)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> lic_str:</div><div class="line">        lic_str = get_pre_license()</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lic_str:</div><div class="line">            <span class="keyword">raise</span> LicenseNotFound()</div><div class="line">        set_license_key(lic_str, ip)</div><div class="line">        </div><div class="line">    prepare_enable_osd(cluster_if, public_if, svs, _host=ip)</div><div class="line">    enable_osd(svs, <span class="keyword">True</span>,</div><div class="line">        _host=ip,</div><div class="line">        _async=ASYNC_MODE.WAIT_UPDATED,</div><div class="line">        _ticket=TASK_TICKET.ENABLE_OSD)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__  == <span class="string">'__main__'</span>:</div><div class="line">    test()</div></pre></td></tr></table></figure><p><code>pstat.py</code>：用于处理生成的<code>cprofiler</code>文件，做一些排序，截取和打印等工作,默认按<code>culativetime</code>排序，打印前<code>100</code>条记录，有其他需求的可以适当修改参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pstats, sys</div><div class="line">file = sys.argv[<span class="number">1</span>]</div><div class="line">p = pstats.Stats(file)</div><div class="line">p.strip_dirs().sort_stats(<span class="string">'cum'</span>).print_stats(<span class="number">100</span>)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ovv1r40we.bkt.clouddn.com/pozza-600x450.png&quot; alt=&quot;Profile&quot;&gt;&lt;/center&gt;

&lt;p&gt;针对&lt;code&gt;OSD&lt;/code&gt;启用过程缓慢进行性能剖析，用到了一系列的脚本，例如批量创建&lt;code&gt;OSD&lt;/code&gt;,批量启用&lt;code&gt;OSD&lt;/code&gt;,&lt;code&gt;Cprofile&lt;/code&gt;装饰器接口等&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Script" scheme="https://tony-yin.github.io/tags/Script/"/>
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="OSD" scheme="https://tony-yin.github.io/tags/OSD/"/>
    
      <category term="Profile" scheme="https://tony-yin.github.io/tags/Profile/"/>
    
  </entry>
  
  <entry>
    <title>批量创建和删除磁盘分区脚本</title>
    <link href="https://tony-yin.github.io/2017/10/02/Batch-Create-And-Delete-Disk-Partition-Script/"/>
    <id>https://tony-yin.github.io/2017/10/02/Batch-Create-And-Delete-Disk-Partition-Script/</id>
    <published>2017-10-02T05:07:06.000Z</published>
    <updated>2017-10-10T13:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/floppy_disk_600-450.png" alt="Disk Partition"></center><p>最近在做批量启用<code>OSD</code>的性能优化，需要反复的删除磁盘分区，以保证彻底的删除数据，然后就要批量创建分区，保证足够量的分区数量创建足够多的<code>OSD</code>，由于数量较多，每次手动搞都要二十几次，所以针对创建和删除写了两个脚本，支持单一、批量和选择大小等功能</p><a id="more"></a><h2 id="清空分区"><a href="#清空分区" class="headerlink" title="清空分区"></a>清空分区</h2><h3 id="脚本名称"><a href="#脚本名称" class="headerlink" title="脚本名称"></a>脚本名称</h3><p><code>clean_disks.py</code></p><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ul><li><code>python clean_disks.py [disk_name1, disk_name2 ...]</code> </li><li>支持单磁盘和多磁盘清空</li><li>支持脚本参数，如果没有参数，默认清空所有磁盘分区，加磁盘参数则可清空指定磁盘分区, 多磁盘则累加多位磁盘参数</li><li>为了保证安全，脚本不会清空系统磁盘，脚本会做过滤工作</li></ul><h3 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h3><ul><li>清空所有磁盘分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python clean_disks.py</div></pre></td></tr></table></figure><ul><li>清空<code>sdb</code>的分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python clean_disks.py sdb</div></pre></td></tr></table></figure><ul><li>清空<code>sdb</code>和<code>sdc</code>的分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python clean_disks.py sdb sdc</div></pre></td></tr></table></figure><h3 id="脚本代码"><a href="#脚本代码" class="headerlink" title="脚本代码"></a>脚本代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">from mcs3.command import do_cmd</div><div class="line"></div><div class="line">def clean_disk(disk_name):</div><div class="line">    print &apos;disk: &#123;&#125; clean start ...&apos;.format(disk_name)</div><div class="line">    do_cmd(&apos;sgdisk -Zog /dev/&#123;&#125;&apos;.format(disk_name))</div><div class="line">    print &apos;disk: &#123;&#125; clean done ...&apos;.format(disk_name)</div><div class="line"></div><div class="line">mount_info = do_cmd(&apos;mount&apos;)</div><div class="line">sys_disk_name = mount_info[5:8]</div><div class="line"></div><div class="line">if len(sys.argv) &gt; 1:</div><div class="line">    disks = sys.argv[1:]</div><div class="line">    for disk_name in disks:</div><div class="line">        if disk_name == sys_disk_name:</div><div class="line">            print &apos;&#123;&#125; is system disk, can\&apos;t be clean!&apos;.format(disk_name)</div><div class="line">        else:</div><div class="line">            clean_disk(disk_name)</div><div class="line">else:</div><div class="line">    all_disks = do_cmd(&apos;lsblk&apos;).splitlines()</div><div class="line">    for disk in all_disks:</div><div class="line">        if (disk.startswith(&apos;sd&apos;)):</div><div class="line">            disk_name = disk.split()[0]</div><div class="line">            if disk_name != sys_disk_name:</div><div class="line">                clean_disk(disk_name)</div></pre></td></tr></table></figure><h2 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h2><h3 id="脚本名称-1"><a href="#脚本名称-1" class="headerlink" title="脚本名称"></a>脚本名称</h3><p><code>create_partitions.py</code></p><h3 id="使用说明-1"><a href="#使用说明-1" class="headerlink" title="使用说明"></a>使用说明</h3><ul><li><code>python create_partitions.py size num [disk_name1, disk_name2 ...]</code>, <code>size</code>为分区大小，<code>num</code>为分区数</li><li>支持单磁盘和多磁盘创建分区</li><li>支持脚本参数，如果没有参数，默认为所有磁盘创建分区，加磁盘参数则可清空指定磁盘分区, 多磁盘则累加多位磁盘参数</li><li>为了保证安全，脚本不会为系统磁盘创建磁盘分区，脚本会做过滤工作</li></ul><h3 id="使用范例-1"><a href="#使用范例-1" class="headerlink" title="使用范例"></a>使用范例</h3><ul><li>为<code>sdb</code>和<code>sdc</code>分别都创建两个大小为<code>100G</code>的分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python create_partitions.py 100G 2 sdb sdc</div></pre></td></tr></table></figure><ul><li>为所有磁盘创建三个大小为<code>10G</code>的分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python create_partitions.py 10G 3</div></pre></td></tr></table></figure><ul><li>为<code>sdc</code>创建四个大小为<code>1T</code>的分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python create_partitions.py 1024G 4 sdc</div></pre></td></tr></table></figure><h3 id="脚本代码-1"><a href="#脚本代码-1" class="headerlink" title="脚本代码"></a>脚本代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">from mcs3.command import do_cmd</div><div class="line"></div><div class="line">size = sys.argv[1]</div><div class="line">num = sys.argv[2]</div><div class="line">mount_info = do_cmd(&apos;mount&apos;)</div><div class="line">sys_disk_name = mount_info[5:8]</div><div class="line"></div><div class="line">def parted_disks(num, size, disk):</div><div class="line">    for i in range(int(num)):</div><div class="line">        do_cmd(&apos;sgdisk -n &#123;&#125;:0:+&#123;&#125; /dev/&#123;&#125;&apos;.format(i+1, size, disk))</div><div class="line">        print &apos;disk &#123;&#125; partition &#123;&#125; done ...&apos;.format(disk, i+1)</div><div class="line"></div><div class="line">if len(sys.argv) &gt; 3:</div><div class="line">    disks = sys.argv[3:]</div><div class="line">    for disk in disks:</div><div class="line">        if disk == sys_disk_name:</div><div class="line">            print &apos;&#123;&#125; is system disk, can\&apos;t be parted!&apos;.format(disk)</div><div class="line">        else:</div><div class="line">            parted_disks(num, size, disk)</div><div class="line">else:</div><div class="line">    all_disks = do_cmd(&apos;lsblk&apos;).splitlines()</div><div class="line">    for disk in all_disks:</div><div class="line">        if (disk.startswith(&apos;sd&apos;)):</div><div class="line">            disk_name = disk.split()[0]</div><div class="line">            if disk_name != sys_disk_name:</div><div class="line">                parted_disks(num, size, disk)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/floppy_disk_600-450.png&quot; alt=&quot;Disk Partition&quot;&gt;&lt;/center&gt;

&lt;p&gt;最近在做批量启用&lt;code&gt;OSD&lt;/code&gt;的性能优化，需要反复的删除磁盘分区，以保证彻底的删除数据，然后就要批量创建分区，保证足够量的分区数量创建足够多的&lt;code&gt;OSD&lt;/code&gt;，由于数量较多，每次手动搞都要二十几次，所以针对创建和删除写了两个脚本，支持单一、批量和选择大小等功能&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Disk" scheme="https://tony-yin.github.io/tags/Disk/"/>
    
      <category term="Partition" scheme="https://tony-yin.github.io/tags/Partition/"/>
    
      <category term="Script" scheme="https://tony-yin.github.io/tags/Script/"/>
    
  </entry>
  
  <entry>
    <title>JS判断对象是否为空</title>
    <link href="https://tony-yin.github.io/2017/09/28/JS-Object-Null/"/>
    <id>https://tony-yin.github.io/2017/09/28/JS-Object-Null/</id>
    <published>2017-09-28T06:01:42.000Z</published>
    <updated>2017-10-02T04:55:29.000Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/jsbanana-600-450.png" alt="JS"></center><p>今天在项目中发现一个<code>Bug</code>，通过<code>debug</code>发现最终的原因便是判断对象是否为空导致的错误，一个小小的错误反映出<code>Javascript</code>这门语言的不严谨性，也提醒我们得熟悉它的一些技巧和原理，避免经常在一些问题上踩坑</p><a id="more"></a><p>场景还原：通过<code>if(object)</code>判断对象内容不为空，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">obj = &#123;&#125;;   // obj其实是通过其他方式获得，但是它的内容为空</div><div class="line">if (obj) &#123;</div><div class="line">        xxx;    // 判断当obj不为空的时候，执行判断内的代码</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>那么问题就出现了，即使对象内容为空，这个判断代码块里面的代码还是会被执行<br>用<code>chrome</code>简单的验证了一下：</p><center><img src="http://ow0mgad6r.bkt.clouddn.com/object_empty.png" alt="object empty"></center><p>这和一些其他语言不一样，比如<code>php</code>,<code>python</code>是可以通过<code>if(object)</code>来检查对象是否为空的，但是<code>JS</code>不可以，这个问题要不是遇到了肯定想不到</p><p>那么<code>JS</code>如何判断对象内容是否为空呢？网上搜了下，大概有以下方式：</p><h3 id="通过JSON-stringify将对象转换成字符串进行判断"><a href="#通过JSON-stringify将对象转换成字符串进行判断" class="headerlink" title="通过JSON.stringify将对象转换成字符串进行判断"></a>通过JSON.stringify将对象转换成字符串进行判断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var tt = &#123;&#125;;</div><div class="line">if (JSON.stringify(tt) == &quot;&#123;&#125;&quot;) &#123;</div><div class="line">        console.log(&apos;tt is not empty!&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="通过读取对象元素"><a href="#通过读取对象元素" class="headerlink" title="通过读取对象元素"></a>通过读取对象元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var tt = &#123;&#125;;</div><div class="line">var t = &#123;id: 1&#125;;</div><div class="line">if (tt.id) &#123;</div><div class="line">        console.log(&apos;tt is not empty!&apos;);</div><div class="line">&#125; </div><div class="line">if (t.id) &#123;</div><div class="line">        console.log(&apos;t is not empty&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>方法1相对于方法2来说更加严谨，阅读性高，而方法2的效率却比方法1高</p><h3 id="jQuery提供了判断对象是否为空的API"><a href="#jQuery提供了判断对象是否为空的API" class="headerlink" title="jQuery提供了判断对象是否为空的API"></a>jQuery提供了判断对象是否为空的API</h3><p>如果用的是<code>jquery</code>的话，可以使用其提供的现有方法：<code>isEmptyObject</code>,这是<code>jQuery1.4</code>版本后加入的功能，具体用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var tt = &#123;&#125;; </div><div class="line">if ($.isEmptyObject(tt)) &#123;  // jQuery.isEmptyObject(tt)这样调用也可以</div><div class="line">        console.log(&apos;tt is empty!&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="判断对象是否存在"><a href="#判断对象是否存在" class="headerlink" title="判断对象是否存在"></a>判断对象是否存在</h3><p>借助上面的问题，顺便了解了一下：<a href="http://www.ruanyifeng.com/blog/2011/05/how_to_judge_the_existence_of_a_global_object_in_javascript.html" target="_blank" rel="external">如何判断Javascript对象是否存在</a></p><p>这篇文章里面讲的还是比较全面的，针对不同场景给出了不同的方案</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/jsbanana-600-450.png&quot; alt=&quot;JS&quot;&gt;&lt;/center&gt;

&lt;p&gt;今天在项目中发现一个&lt;code&gt;Bug&lt;/code&gt;，通过&lt;code&gt;debug&lt;/code&gt;发现最终的原因便是判断对象是否为空导致的错误，一个小小的错误反映出&lt;code&gt;Javascript&lt;/code&gt;这门语言的不严谨性，也提醒我们得熟悉它的一些技巧和原理，避免经常在一些问题上踩坑&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Javascript" scheme="https://tony-yin.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>OSD创建和删除全过程</title>
    <link href="https://tony-yin.github.io/2017/09/27/OSD-Create-And-Delete/"/>
    <id>https://tony-yin.github.io/2017/09/27/OSD-Create-And-Delete/</id>
    <published>2017-09-27T15:05:36.000Z</published>
    <updated>2017-10-02T04:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/5ways-facebook-600-450.png" alt="create and delete process"></center><p><code>OSD</code>是<code>Ceph</code>中最基本也是最常用的功能，所以经常的创建和删除操作少不了，然后这个两个过程并不是一两个命令那么简单，本文就<code>OSD</code>的创建和删除进行内容进行步骤分离和讲解，结尾还有一份一键删除指定<code>OSD</code>的脚本</p><a id="more"></a><h2 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h2><h3 id="创建一个OSD"><a href="#创建一个OSD" class="headerlink" title="创建一个OSD"></a>创建一个OSD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd create [uuid]   #若没有uuid参数，则该命令自动生成一个uuid。该命令产生一个新的osd-number</div></pre></td></tr></table></figure><h3 id="为新的OSD创建默认的工作目录"><a href="#为新的OSD创建默认的工作目录" class="headerlink" title="为新的OSD创建默认的工作目录"></a>为新的OSD创建默认的工作目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir -p /var/lib/ceph/osd/ceph-&#123;osd-number&#125;</div></pre></td></tr></table></figure><h3 id="为新的OSD准备一块磁盘"><a href="#为新的OSD准备一块磁盘" class="headerlink" title="为新的OSD准备一块磁盘"></a>为新的OSD准备一块磁盘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkfs.xfs -f /dev/vde </div><div class="line">mount /dev/vde /var/lib/ceph/osd/ceph-&#123;osd-number&#125;</div></pre></td></tr></table></figure><h3 id="初始化新的OSD工作目录"><a href="#初始化新的OSD工作目录" class="headerlink" title="初始化新的OSD工作目录"></a>初始化新的OSD工作目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-osd -i &#123;osd-number&#125; --mkfs --mkkey</div></pre></td></tr></table></figure><blockquote><p> 注意：在执行上述命令前要求新的OSD工作目录必须为空</p></blockquote><h3 id="注册新的OSD认证密钥"><a href="#注册新的OSD认证密钥" class="headerlink" title="注册新的OSD认证密钥"></a>注册新的OSD认证密钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph auth add osd.&#123;osd-number&#125; osd &apos;allow *&apos; mon &apos;allow rwx&apos; -i /var/lib/ceph/osd/ceph-&#123;osd-number&#125;/keyring</div></pre></td></tr></table></figure><h3 id="将新的OSD添加到Crush-Map中"><a href="#将新的OSD添加到Crush-Map中" class="headerlink" title="将新的OSD添加到Crush Map中"></a>将新的OSD添加到Crush Map中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd crush add osd.&#123;osd-number&#125; &#123;weight&#125; [&#123;bucketype&#125;=&#123;bucket-name&#125;......&#125;</div></pre></td></tr></table></figure><p>此步骤也可以添加buckets后再添加osd，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ceph osd crush add-bucket node5 host     #创建一个名字为node5的bucket</div><div class="line">ceph osd crush move node5 root=default    #将创建出来的bucket放到root下</div><div class="line">ceph osd crush create-or-move osd.&#123;osd-number&#125; 1.0 root=default host=node5     #将新的OSD添加到node5下</div></pre></td></tr></table></figure><h3 id="将新的OSD信息填写到ceph-conf中"><a href="#将新的OSD信息填写到ceph-conf中" class="headerlink" title="将新的OSD信息填写到ceph.conf中"></a>将新的OSD信息填写到ceph.conf中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[osd.&#123;osd-number&#125;]</div><div class="line">host = &#123;hostname&#125;</div><div class="line">devs = /dev/vde</div></pre></td></tr></table></figure><h3 id="启动新的OSD"><a href="#启动新的OSD" class="headerlink" title="启动新的OSD"></a>启动新的OSD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/ceph start osd.&#123;osd-number&#125;</div></pre></td></tr></table></figure><blockquote><p>此时通过集群状态查看命令#ceph -s可以看到OSD数量以及up和in的数量都发生了变化，此时再通过命令#ceph -w可以看到ceph经过peering状态后，最终达到active+clean状态</p></blockquote><h2 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h2><h3 id="将需要删除的OSD在集群中的状态修改为out状态"><a href="#将需要删除的OSD在集群中的状态修改为out状态" class="headerlink" title="将需要删除的OSD在集群中的状态修改为out状态"></a>将需要删除的OSD在集群中的状态修改为out状态</h3><p>假定<code>osd</code>的<code>id</code>为<code>1</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd out osd.1</div></pre></td></tr></table></figure><h3 id="停止OSD进程"><a href="#停止OSD进程" class="headerlink" title="停止OSD进程"></a>停止OSD进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/ceph stop osd.1</div></pre></td></tr></table></figure><h3 id="将OSD从crush-map中删除"><a href="#将OSD从crush-map中删除" class="headerlink" title="将OSD从crush map中删除"></a>将OSD从crush map中删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ceph osd crush remove osd.1    #删除指定的OSD</div><div class="line">ceph osd crush remove node1    #删除OSD所在的bucket（此步骤可以不做）</div></pre></td></tr></table></figure><h3 id="清除到OSD的认证密钥"><a href="#清除到OSD的认证密钥" class="headerlink" title="清除到OSD的认证密钥"></a>清除到OSD的认证密钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph auth del osd.1</div></pre></td></tr></table></figure><h3 id="在OSD-Map中清除OSD"><a href="#在OSD-Map中清除OSD" class="headerlink" title="在OSD Map中清除OSD"></a>在OSD Map中清除OSD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd rm 1</div></pre></td></tr></table></figure><h3 id="从ceph-conf中清除OSD"><a href="#从ceph-conf中清除OSD" class="headerlink" title="从ceph.conf中清除OSD"></a>从ceph.conf中清除OSD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[osd.1]</div><div class="line">    host = &#123;hostname&#125;</div><div class="line">    ...</div></pre></td></tr></table></figure><h2 id="一键删除OSD脚本"><a href="#一键删除OSD脚本" class="headerlink" title="一键删除OSD脚本"></a>一键删除OSD脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#! /usr/bin/bash</div><div class="line"></div><div class="line">osd_id=$1</div><div class="line">ceph osd out osd.$osd_id</div><div class="line">/etc/init.d/ceph stop osd.$osd_id</div><div class="line">ceph osd crush remove osd.$osd_id</div><div class="line">ceph auth del osd.$osd_id</div><div class="line">ceph osd rm $osd_id</div><div class="line"># 清空 ceph.conf</div></pre></td></tr></table></figure><p>参考链接：</p><blockquote><p><a href="https://my.oschina.net/linuxhunter/blog/539312" target="_blank" rel="external">https://my.oschina.net/linuxhunter/blog/539312</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/5ways-facebook-600-450.png&quot; alt=&quot;create and delete process&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;code&gt;OSD&lt;/code&gt;是&lt;code&gt;Ceph&lt;/code&gt;中最基本也是最常用的功能，所以经常的创建和删除操作少不了，然后这个两个过程并不是一两个命令那么简单，本文就&lt;code&gt;OSD&lt;/code&gt;的创建和删除进行内容进行步骤分离和讲解，结尾还有一份一键删除指定&lt;code&gt;OSD&lt;/code&gt;的脚本&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="OSD" scheme="https://tony-yin.github.io/tags/OSD/"/>
    
  </entry>
  
  <entry>
    <title>How-To-Forge-Product</title>
    <link href="https://tony-yin.github.io/2017/09/21/How-To-Forge-Product/"/>
    <id>https://tony-yin.github.io/2017/09/21/How-To-Forge-Product/</id>
    <published>2017-09-21T05:57:34.000Z</published>
    <updated>2017-10-02T05:01:31.000Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/product-600-450.jpg" alt="product"></center><p>今天<code>BOSS</code>带来一个曾经的得力干将。目前是腾讯一家游戏公司的老总，职位为<code>Producer</code>，在产品方面分享很多观点，受益匪浅。下面是分享过程中我总结的一些自己觉得正确的观点和心得</p><blockquote><p>虽热目前我是一个只负责敲代码的程序猿，产品这种事情好像跟我没多大关系，应该是产品经理的事情，但是其实一个<code>coder</code>想要进步，不仅仅是技术水平越来越强，对产品的理解也非常重要。这能理清自己逻辑，能够发散思维，能够帮你做出更好的产品，你开发出一个没人用的产品和一个上线客户量很大的产品对你自己来说无论是成就感还是技术提升都是天壤之别。也许未来我们可能也会创业，那到时候我们的职责可能是老板，可能是产品，可能是研发，更可能是各种职能集一身，对产品拥有良好理解和恰当的打磨技巧对我们来说都是宝贵的财富。</p></blockquote><a id="more"></a><h2 id="技能心态"><a href="#技能心态" class="headerlink" title="技能心态"></a>技能心态</h2><h3 id="工作强度"><a href="#工作强度" class="headerlink" title="工作强度"></a>工作强度</h3><p><code>BAT</code>加班不比任何一家中小公司少，腾讯一直把自己当做创业型公司，时刻保持压力和紧张感，这或许是其成功的一个很重要的原因（意料之外，之前没想到<code>BAT</code>工作强度这么大）</p><h3 id="不用过多的Design"><a href="#不用过多的Design" class="headerlink" title="不用过多的Design"></a>不用过多的Design</h3><p>因为没有一个产品可以凭借设计文档一步到位的，几乎每个成功的产品都和原来的设计有着天壤之别（仁者见仁，智者见智，把握一个度吧，没必要死扣设计为了最完美化而浪费大量的时间）</p><h3 id="没有具体的Deadline"><a href="#没有具体的Deadline" class="headerlink" title="没有具体的Deadline"></a>没有具体的Deadline</h3><p>每天都是<code>Deadline</code>，每天规定的任务做好了再回去</p><h3 id="谁的声音大听谁的"><a href="#谁的声音大听谁的" class="headerlink" title="谁的声音大听谁的"></a>谁的声音大听谁的</h3><p>不要在内部为了争执一个方案纠结和浪费太多时间，谁的声音大听谁的，因为这绝不是最后一次修改（有性格）</p><h3 id="产品是每个人的"><a href="#产品是每个人的" class="headerlink" title="产品是每个人的"></a>产品是每个人的</h3><p>一个人不应该被他的职位所局限，产品团队中的每个人都应该为这个产品在设计、宣传和包装等方面提意见</p><h3 id="Just-Do-It"><a href="#Just-Do-It" class="headerlink" title="Just Do It"></a>Just Do It</h3><p>很多事情自己不做一下是不知道的，很多行为看起来很low，不符合你的职位，但是只有真正去做了，才代表走过这条路，你才知道这条路可不可行，还有哪些其他路可以尝试（那位大佬制作某款卡牌游戏时，自己找了同类<code>50</code>多种游戏都玩了一遍，而且都玩到了很<code>6</code>的地步，用他的话说最后玩到吐。。。）</p><h3 id="相信自己的潜力"><a href="#相信自己的潜力" class="headerlink" title="相信自己的潜力"></a>相信自己的潜力</h3><p>永远不要觉得自己是做技术的，所以理所当然<code>UI</code>不擅长，宣传不擅长，包装不擅长，做一行就要把自己的头埋进去，逼着自己不断尝试，慢慢可能会发现自己做的不错（他们经常会亲自去<code>QQ</code>群、贴吧和其他社交平台宣传，我去，托这种事原来真的存在）</p><h3 id="学会成熟"><a href="#学会成熟" class="headerlink" title="学会成熟"></a>学会成熟</h3><p>对很多事情都要慢慢做到心里有底，比如清楚上线必有<code>Bug</code>，设计必会被颠覆（他说上线没问题他会很慌。。。）</p><h3 id="明确最终目的"><a href="#明确最终目的" class="headerlink" title="明确最终目的"></a>明确最终目的</h3><p>要明确做产品，开发等工作的目的不是按时完成任务，而是要把产品做起来，最终目的是赚钱，这样你做其他类型的事情就可以想明白很多，有时候开发并不一定是最优先最重要的，植物，但是作为一个开发经历了这些事情你的思维会不一样，做事方向也会不一样</p><h3 id="观察用户习惯"><a href="#观察用户习惯" class="headerlink" title="观察用户习惯"></a>观察用户习惯</h3><p>可以尝试花钱请人来使用产品，内部开发人员在背后观察它的使用习惯，不轻易提示</p><h3 id="用数据说话"><a href="#用数据说话" class="headerlink" title="用数据说话"></a>用数据说话</h3><p>当产品上线后，通过数据采集和分析，哪个页面或者操作用户比较感兴趣，哪一步开始用户量变少，出现这种情况，可以尝试做几个版本，然后让用户使用，选择最优的方案（在这个环节不以职位高低说话，完全靠数据评断）</p><h3 id="要相信自己的技术"><a href="#要相信自己的技术" class="headerlink" title="要相信自己的技术"></a>要相信自己的技术</h3><p>相信自己可以实现用户提的所有需求，当你全身心投入一件事的时候，手段很多，解决的方案也很多，比如这位大佬述说他收集一款游戏的同类游戏的经历，收集渠道除了iOS的还有android的，还有韩国市场的，还有模拟器的，还有页游等等（只有想不到，没有做不到）</p><h3 id="抄袭不丢脸"><a href="#抄袭不丢脸" class="headerlink" title="抄袭不丢脸"></a>抄袭不丢脸</h3><p>互联网产品从<code>0</code>到<code>1</code>很少很少，大家在做一个产品之前都会看看同类产品怎么做的，然后学习每个产品中的精华部分，这个说直接一点就是抄袭，但是不要因为这个觉得丢脸，因为抄袭容易，抄袭得好并不容易（谈到腾讯，大家都会因为<strong>抄袭</strong>而骂声不绝，但是静下想想这的确是个正常套路，一切为了快速出产品）</p><h3 id="不要害怕被告"><a href="#不要害怕被告" class="headerlink" title="不要害怕被告"></a>不要害怕被告</h3><p>等哪天你某些方面抄袭别人的，导致被告，那么说明你已经做大了，产品在某个方面来说已经相当成功了</p><h3 id="被骂是极好的"><a href="#被骂是极好的" class="headerlink" title="被骂是极好的"></a>被骂是极好的</h3><p>很多时候，用户会因为产品一些蹩脚的地方而骂声不断，这时候不要觉得丢脸或者懊恼，相反应该开心，因为很多时候别人愿意骂你说明很大程度上还是很喜欢这个产品的，而真正不喜欢的懒得留下评论</p><h2 id="产品本身"><a href="#产品本身" class="headerlink" title="产品本身"></a>产品本身</h2><h3 id="快速出Demo"><a href="#快速出Demo" class="headerlink" title="快速出Demo"></a>快速出Demo</h3><p>以上说的不用过多<code>Design</code>也好，还是不要过分争执也好，都是为了尽快做出一个产品<code>Demo</code>，就是最起码可以一个<code>work</code>的东西，这很重要，一旦<code>work</code>之后很多想法就会不一样了，他们往往两个星期出一个<code>Demo</code>，这对他们<code>UI</code>来说很有挑战，因为一般设计就要一个星期，然后原型图又是一个星期，但是两个星期就得弄出来，不管是借鉴别人的也好，还是网上买模板也好</p><h3 id="不用太完善"><a href="#不用太完善" class="headerlink" title="不用太完善"></a>不用太完善</h3><p>快速做出来不是说实现所有功能和面面俱到，而是可以做到静态页面或者是设计图去找用户，询问他们的观点和建议，这样既可以缩短时间，也可以通过询问客户的意见走向正确的道路，避免不必要的返工</p><h3 id="尽快让产品上线"><a href="#尽快让产品上线" class="headerlink" title="尽快让产品上线"></a>尽快让产品上线</h3><p>产品上线和不上线是天壤之别，因为自己内部永远是在想当然，而客户的反馈才是最重要的，这样才会往正确的方向不断迭代</p><h3 id="永远不要给用户看到错误信息"><a href="#永远不要给用户看到错误信息" class="headerlink" title="永远不要给用户看到错误信息"></a>永远不要给用户看到错误信息</h3><p>能解决的让系统自己解决，不能解决的人工处理，不要太<strong>实诚</strong>，否则用户会感觉到惊恐</p><h3 id="不要给用户太多选择"><a href="#不要给用户太多选择" class="headerlink" title="不要给用户太多选择"></a>不要给用户太多选择</h3><p>如果一个页面存在两个按钮让用户点击，<code>80%</code>的用户会点<code>A</code>按钮，<code>20%</code>的用户会点<code>B</code>按钮，那么页面就显示一个<code>A</code>按钮就好了，只要保证<code>B</code>按钮能够在页面其他地方能找到就可以了，太多选择会让用户心里没底自己选择的对不对（相信大家脑海里都会浮现某个用户做完一个操作询问对不对的场景吧？）</p><h3 id="数字必有颜色"><a href="#数字必有颜色" class="headerlink" title="数字必有颜色"></a>数字必有颜色</h3><p>这是一个约定俗成的习惯，保证页面的数字有合适的颜色，让用户一眼就能看到最想呈现的元素</p><h3 id="科技感很重要"><a href="#科技感很重要" class="headerlink" title="科技感很重要"></a>科技感很重要</h3><p>要让页面充满科技感，让别人觉得这是一家充满互联网气息的新公司，第一印象好</p><h3 id="恰当的图标"><a href="#恰当的图标" class="headerlink" title="恰当的图标"></a>恰当的图标</h3><p>图标选择要有意义，凸出按钮的作用</p><h3 id="恰当的名词"><a href="#恰当的名词" class="headerlink" title="恰当的名词"></a>恰当的名词</h3><p>用词准备具体，不要让用户去猜，比如下载就是下载，不要说保存</p><h3 id="易懂高大上的名词"><a href="#易懂高大上的名词" class="headerlink" title="易懂高大上的名词"></a>易懂高大上的名词</h3><p>用词不要太专业，这样会让用户不明白，可以高大上一些，比如远程数据复制可以叫云复制</p><h3 id="抓住用户的期望"><a href="#抓住用户的期望" class="headerlink" title="抓住用户的期望"></a>抓住用户的期望</h3><p>产品介绍要突出用户最期望的东西，而不是过分强调技术上面的高档，这不是客户最期望的东西，比如存储你与其说内部实现机制怎么分片，怎么自动控制，不如和用户说我能保证多少数据量的存储，能保证永远不会因为故障丢失数据，能存储多长时间等等</p><h3 id="调节气氛的话语"><a href="#调节气氛的话语" class="headerlink" title="调节气氛的话语"></a>调节气氛的话语</h3><p>多用网络诙谐的话语进行提示，比如亲，朕等等，这样会舒畅用户的心情</p><p>作者： Tony<br>日期： 2017/09/19</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/product-600-450.jpg&quot; alt=&quot;product&quot;&gt;&lt;/center&gt;

&lt;p&gt;今天&lt;code&gt;BOSS&lt;/code&gt;带来一个曾经的得力干将。目前是腾讯一家游戏公司的老总，职位为&lt;code&gt;Producer&lt;/code&gt;，在产品方面分享很多观点，受益匪浅。下面是分享过程中我总结的一些自己觉得正确的观点和心得&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虽热目前我是一个只负责敲代码的程序猿，产品这种事情好像跟我没多大关系，应该是产品经理的事情，但是其实一个&lt;code&gt;coder&lt;/code&gt;想要进步，不仅仅是技术水平越来越强，对产品的理解也非常重要。这能理清自己逻辑，能够发散思维，能够帮你做出更好的产品，你开发出一个没人用的产品和一个上线客户量很大的产品对你自己来说无论是成就感还是技术提升都是天壤之别。也许未来我们可能也会创业，那到时候我们的职责可能是老板，可能是产品，可能是研发，更可能是各种职能集一身，对产品拥有良好理解和恰当的打磨技巧对我们来说都是宝贵的财富。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="summary" scheme="https://tony-yin.github.io/categories/summary/"/>
    
    
      <category term="产品" scheme="https://tony-yin.github.io/tags/%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>PHP-Excel 开发解决方案</title>
    <link href="https://tony-yin.github.io/2017/09/18/PHP-Excel/"/>
    <id>https://tony-yin.github.io/2017/09/18/PHP-Excel/</id>
    <published>2017-09-18T10:37:28.000Z</published>
    <updated>2017-09-20T11:50:15.000Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/office-card-game.png" alt="office"></center><p> 过去工作中使用<code>PHPExcel</code>较多，碰到并解决了各种大大小小的问题，总结出这样一篇文章，一方面记录自己踩过的坑，一方面与大家分享，让大家少走弯路，并不断完善之，欢迎大家去<code>github</code>上面<code>star</code>和提交<code>pull request</code>，不断补充和优化，打造最全面的<code>PHPExcel</code>开发解决方案</p><p>Github 地址：<a href="https://github.com/tony-yin/PHPExcel_Road" target="_blank" rel="external">https://github.com/tony-yin/PHPExcel_Road</a><br>原文地址：<a href="https://tony-yin.github.io/2017/09/18/PHP-Excel/">https://tony-yin.github.io/2017/09/18/PHP-Excel/</a></p><a id="more"></a><h2 id="基础：小试牛刀"><a href="#基础：小试牛刀" class="headerlink" title="基础：小试牛刀"></a>基础：小试牛刀</h2><h3 id="1-引用文件"><a href="#1-引用文件" class="headerlink" title="1. 引用文件"></a>1. 引用文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yourpath . /phpexcel/PHPExcel.php</div></pre></td></tr></table></figure><h3 id="2-实例化phpexcel类"><a href="#2-实例化phpexcel类" class="headerlink" title="2. 实例化phpexcel类"></a>2. 实例化phpexcel类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$excel = new PHPExcel();</div></pre></td></tr></table></figure><h3 id="3-获取当前单sheet（多sheet会在下面讲）"><a href="#3-获取当前单sheet（多sheet会在下面讲）" class="headerlink" title="3. 获取当前单sheet（多sheet会在下面讲）"></a>3. 获取当前单sheet（多sheet会在下面讲）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$objexcel = $excel-&gt;getActiveSheet();</div></pre></td></tr></table></figure><h3 id="4-合并单元格"><a href="#4-合并单元格" class="headerlink" title="4. 合并单元格"></a>4. 合并单元格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$objexcel-&gt;mergeCells(&apos;A1:M1&apos;);</div></pre></td></tr></table></figure><h3 id="5-获取一个cell的样式"><a href="#5-获取一个cell的样式" class="headerlink" title="5. 获取一个cell的样式"></a>5. 获取一个cell的样式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$objexcel-&gt;getStyle(&apos;A1&apos;);</div></pre></td></tr></table></figure><ul><li>获取一个cell的字体样式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$cellFont = $objexcel-&gt;getStyle(&apos;A1&apos;)-&gt;getFont();</div></pre></td></tr></table></figure><ul><li>设置字体大小</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$fontStyle-&gt;setSize(15);</div></pre></td></tr></table></figure><ul><li>设置字体是否加粗</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$fontStyle-&gt;setBold(true);</div></pre></td></tr></table></figure><ul><li>设置字体颜色</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$fontStyle-&gt;getColor()-&gt;setARGB(PHPExcel_Style_Color::COLOR_RED);</div></pre></td></tr></table></figure><ul><li>获取一行样式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$rowStyle = $objexcel-&gt;getStyle(1)-&gt;getRowDimension();</div></pre></td></tr></table></figure><ul><li>设置行高度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$rowStyle-&gt;setRowHeight(2);</div></pre></td></tr></table></figure><ul><li>获取一列样式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$columnStyle = $objexcel-&gt;getStyle(&apos;A&apos;)-&gt;getColumnDimension();</div></pre></td></tr></table></figure><ul><li>设置列宽度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$columnStyle-&gt;setWidth(10);</div></pre></td></tr></table></figure><ul><li>获取一列对齐样式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$alignStyle = $objexcel-&gt;getStyle(&apos;A&apos;)-&gt;getAlignment();</div></pre></td></tr></table></figure><ul><li>设置水平居中：同一水平线上居中，即为左右的中间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$alignStyle&gt;setHorizontal(PHPExcel_Style_Alignment::HORIZONTAL_CENTER);</div></pre></td></tr></table></figure><ul><li>设置垂直居中：同一垂直线居中，即为上下的中间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$alignStyle-&gt;setVertical(PHPExcel_Style_Alignment::VERTICAL_CENTER);</div></pre></td></tr></table></figure><ul><li>自动换行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$alignStyle-&gt;setWrapText(true);</div></pre></td></tr></table></figure><h3 id="6-获取指定版本excel写对象"><a href="#6-获取指定版本excel写对象" class="headerlink" title="6. 获取指定版本excel写对象"></a>6. 获取指定版本excel写对象</h3><p>如需更早的版本可将<code>Excel2007</code>换成<code>Excel5</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$write = PHPExcel_IOFactory::createWriter(&quot;xcel, &apos;Excel2007&apos;);</div></pre></td></tr></table></figure></p><h2 id="进阶：一些有用的小知识"><a href="#进阶：一些有用的小知识" class="headerlink" title="进阶：一些有用的小知识"></a>进阶：一些有用的小知识</h2><h3 id="1-行列数字索引方法"><a href="#1-行列数字索引方法" class="headerlink" title="1.行列数字索引方法"></a>1.行列数字索引方法</h3><blockquote><p><code>phpexcel</code>一般获取<code>cell</code>或者获取列都是通过<code>ABC</code>这样的英文字母获取的，它也可以通过<code>0、1、2、3</code>这样的数字表示sheet中的列，从<code>0</code>开始，<code>0</code>对应<code>A</code>，<code>1</code>对应<code>B</code>，基本上大多数方法都是数字行列索引，例如<code>getStyleByColumnAndRow($col,$row)</code>,默认列参数在前，行参数在后，更多的可以参加<code>phpexcel</code>源码；</p></blockquote><h3 id="2-单行或单列参数格式"><a href="#2-单行或单列参数格式" class="headerlink" title="2. 单行或单列参数格式"></a>2. 单行或单列参数格式</h3><blockquote><p>有的时候一个方法需要行列两个参数，例如只需要某一行参数可写成<code>(null, $row)</code>,例如只需要获得某一列参数可写成<code>($col, null)</code></p></blockquote><h3 id="3-列的数字索引格式和字母索引格式互转"><a href="#3-列的数字索引格式和字母索引格式互转" class="headerlink" title="3. 列的数字索引格式和字母索引格式互转"></a>3. 列的数字索引格式和字母索引格式互转</h3><ul><li>数字转字符串</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PHPExcel_Cell::columnIndexFromString(<span class="string">'A'</span>);  <span class="comment">// Return 1 not 0;</span></div></pre></td></tr></table></figure><ul><li>字符串转数字</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PHPExcel_Cell::stringFromColumnIndex(<span class="number">0</span>);    <span class="comment">// Return 'A';</span></div></pre></td></tr></table></figure><h3 id="4-PHPExcel读取数字类型"><a href="#4-PHPExcel读取数字类型" class="headerlink" title="4.PHPExcel读取数字类型"></a>4.PHPExcel读取数字类型</h3><blockquote><p><code>PHPExcel</code>读取的<code>cell</code>数字，类型都是<code>double</code>型，可用<code>gettyle()</code>方法检测类型，当初我一直使用<code>is_int()</code>方法无果，搞得焦头烂额。。。</p></blockquote><h3 id="5-多cell边框线设置"><a href="#5-多cell边框线设置" class="headerlink" title="5. 多cell边框线设置"></a>5. 多cell边框线设置</h3><p><code>PHPExcel</code>生成的表格如果你不加处理，是不会帮你生成边框线的，生成边框线的方法如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$borderArray = <span class="keyword">array</span>(</div><div class="line">    <span class="string">'borders'</span> =&gt; <span class="keyword">array</span>(</div><div class="line">        <span class="string">'allborders'</span> =&gt; <span class="keyword">array</span>(</div><div class="line">            <span class="string">'style'</span> =&gt; PHPExcel_Style_Border::BORDER_THIN</div><div class="line">        )</div><div class="line">    )</div><div class="line">);</div><div class="line">$objexcel-&gt;getStyle($col1, $row1,$col2, $row2)-&gt;applyFromArray($borderArray);</div></pre></td></tr></table></figure></p><blockquote><p>注：<br>1: <code>getStyle()</code>可以看需求改为<code>getStyleByColumnAndRow()</code>方法通过数字行列索引读取<code>style</code><br>2: array中<code>PHPExcel_Style_Border::</code>后面有三种格式分别是<code>BORDER_THIN</code>和<code>BORDR_MEDIUM</code>，表示边框线的粗细；<br>3: <code>getStyle()</code>中的索引可以是静态的，也可以是动态的，一般是在导出<code>excel</code>的数据<code>set</code>完毕后填写左上角的单元格行列索引和右下角的单元格行列索引；</p><p>参考资料</p><p><a href="http://phpexcel.codeplex.com/workitem/22160" target="_blank" rel="external">http://phpexcel.codeplex.com/workitem/22160</a><br><a href="http://phpexcel.codeplex.com/workitem/20150" target="_blank" rel="external">http://phpexcel.codeplex.com/workitem/20150</a></p></blockquote><h3 id="6-多cell字体加粗处理"><a href="#6-多cell字体加粗处理" class="headerlink" title="6. 多cell字体加粗处理"></a>6. 多cell字体加粗处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$objexcel-&gt;getStyle($pCoordinate)-&gt;applyFromArray(array(</div><div class="line">    &apos;font&apos; =&gt; array(  </div><div class="line">        &apos;bold&apos; =&gt; true,                                              </div><div class="line">    ),                                                               </div><div class="line">));</div></pre></td></tr></table></figure><h3 id="7-多cell字体颜色处理"><a href="#7-多cell字体颜色处理" class="headerlink" title="7. 多cell字体颜色处理"></a>7. 多cell字体颜色处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$objexcel-&gt;getStyle($pCoordinate)-&gt;applyFromArray(array(</div><div class="line">    &apos;font&apos; =&gt; array(</div><div class="line">        &apos;color&apos; =&gt; array(</div><div class="line">            &apos;rgb&apos; =&gt; &apos;ff0000&apos;,</div><div class="line">            ),</div><div class="line">        ),</div><div class="line">    )</div><div class="line">);</div></pre></td></tr></table></figure><h3 id="8-多sheet导入"><a href="#8-多sheet导入" class="headerlink" title="8. 多sheet导入"></a>8. 多sheet导入</h3><p>动态为当前<code>sheet</code>设置索引，然后获取当前<code>sheet</code>，便可循环读取每一个<code>sheet</code>内容</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$objexcel-&gt;setActiveSheetIndex($index);   <span class="comment">//$index = 0 1 2 3</span></div><div class="line">$objexcel-&gt;getActiveSheet();    <span class="comment">//return sheet1 sheet2 sheet 3</span></div></pre></td></tr></table></figure><h3 id="9-固定格式excel读取在写入"><a href="#9-固定格式excel读取在写入" class="headerlink" title="9. 固定格式excel读取在写入"></a>9. 固定格式excel读取在写入</h3><blockquote><p>当需求是给定一个一个模板<code>excel</code>，需要往里面塞数据，我们不一定要通过代码给它设定样式，如果这个模板变化不大，我们完全可以存放一个格式相同的静态文件，然后通过<code>PHPExcel</code>读取，再往里面塞数据，最后进行保存操作，可以达到一样的效果，并且可以节省大量的资源。</p></blockquote><h3 id="10-合并单元格导入问题"><a href="#10-合并单元格导入问题" class="headerlink" title="10. 合并单元格导入问题"></a>10. 合并单元格导入问题</h3><blockquote><p>在特殊的表格中，合并单元格普遍存在，而多个单元格合并成的一个单元格，只能<code>setValue()</code>一次，而我们如何判断合并单元格的具体行列呢？</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$range = $start_cell-&gt;getMergeRange();  <span class="comment">// 通过合并单元格的开始单元格比如‘A1’，获取合并范围‘A1:A4’</span></div><div class="line">$cell-&gt;isInRange($range);    <span class="comment">// 遍历之后每一个单元格便可通过isInRange()方法判断当前单元格是否在合并范围内</span></div></pre></td></tr></table></figure><h2 id="高级：特殊场景特殊手段"><a href="#高级：特殊场景特殊手段" class="headerlink" title="高级：特殊场景特殊手段"></a>高级：特殊场景特殊手段</h2><h3 id="1-单元格文本格式数据处理"><a href="#1-单元格文本格式数据处理" class="headerlink" title="1. 单元格文本格式数据处理"></a>1. 单元格文本格式数据处理</h3><blockquote><p>一般excel单元格中数据的格式为数据类型，而<code>PHPExcel</code>中的<code>getValue()</code>方法读取的也是数据类型，当把数据从数据类型改为文本类型后，在<code>PHPExcel</code>中读出来的是<code>PHPExcel_RichText</code>类型，<code>getValue()</code>读取返回<code>PHPExcel_RichText</code>是一个<code>object</code>类型（<code>PHPExcel_RichText</code>数据保存格式）；那如何读取这一类的数据呢？仔细查看读取出来的对象，不难发现有<code>getPlainText()</code>这样的方法可以读取文本类型数据，所以我们只要判断当当前数据为文本数据时用<code>getPlainText()</code>读取，一般数据用<code>getValue()</code>读取</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ($cell-&gt;getValue() <span class="keyword">instanceof</span> PHPExcel_RichText) &#123;</div><div class="line">    $value = $cell-&gt;getValue();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    $value = $cell-&gt;getValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>参考资料</p><p><a href="http://www.cnblogs.com/DS-CzY/p/4955655.html" target="_blank" rel="external">http://www.cnblogs.com/DS-CzY/p/4955655.html</a><br><a href="http://phpexcel.codeplex.com/discussions/34513" target="_blank" rel="external">http://phpexcel.codeplex.com/discussions/34513</a></p></blockquote><h3 id="2-单元格数据算法处理"><a href="#2-单元格数据算法处理" class="headerlink" title="2. 单元格数据算法处理"></a>2. 单元格数据算法处理</h3><blockquote><p><code>excel</code>拥有强大的算法功能，一般算法格式为<code>=A3+A4</code>这类的，复杂的更多，如果使用<code>PHPExcel</code>提供的默认读取方法<code>getValue()</code>读取出来的结果则为字符串<code>=A3+A4</code>,好在<code>PHPExcel</code>也足够强大，提供了相应的接口：<code>getCalculatedValue()</code>，这个方法专门读取算法数据，但是我们不能将这个方法作为默认读取方法，因为这样可能会将一些本来要读成字符串的读成算法数据，而且<code>PHPExcel</code>没有将它作为默认读取方法的另一个重要原因就是算法方式读取很耗时间和性能，一般数据读取根本没有必要这样浪费资源，所以我们可以采用以下这种方式</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (strstr($cell-&gt;getValue(), <span class="string">'='</span>)) &#123;   </div><div class="line">    <span class="comment">// 判断如果cell内容以=号开头便默认为算法数据</span></div><div class="line">    $value = $cell-&gt;getCalculatedValue(); </div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    $value = $cell-&gt;getValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-日期数据处理"><a href="#3-日期数据处理" class="headerlink" title="3. 日期数据处理"></a>3. 日期数据处理</h3><blockquote><p>除了以上所说的文本数据和算法数据外，我还遇到过日期类型数据，比如<code>2016-12-28</code>输入到<code>excel</code>中，它会默认转换成<code>2016/12/28</code>，如果采用一般的<code>getValue()</code>方式读取也会读取到错误的数据，<code>PHPExcel</code>也提供了相应的接口<code>getFormattedValue()</code>,并提供了适配的识别方式<code>PHPExcel_Shared_Date::isDateTime($cell)</code>,所以代码就很好实现了</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (PHPExcel_Shared_Date::isDateTime($cell)) &#123;</div><div class="line">    $value = $cell-&gt;getFormattedValue(); </div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    $value = $cell-&gt;getValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-读取方法封装"><a href="#4-读取方法封装" class="headerlink" title="4. 读取方法封装"></a>4. 读取方法封装</h3><blockquote><p>针对<code>excel</code>各种数据类型，我们可以写一个函数，将原有的<code>getValue()</code>封装一下，这样以后就不用每次都判别一下数据类型了，目前我只遇到上面三种特殊格式，如果有新的，欢迎大家补充，封装函数如下</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_value_of_cell</span><span class="params">($cell)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (strstr($cell-&gt;getValue(), <span class="string">'='</span>)) &#123;   </div><div class="line">        $value = $cell-&gt;getCalculatedValue(); </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ($cell-&gt;getValue() <span class="keyword">instanceof</span> PHPExcel_RichText) &#123;</div><div class="line">        $value = $cell-&gt;getValue();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PHPExcel_Shared_Date::isDateTime($cell)) &#123;</div><div class="line">        $value = $cell-&gt;getFormattedValue(); </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        $value = $cell-&gt;getValue();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="5-导出文件在IE、360等浏览器中文件名中文乱码问题"><a href="#5-导出文件在IE、360等浏览器中文件名中文乱码问题" class="headerlink" title="5. 导出文件在IE、360等浏览器中文件名中文乱码问题"></a>5. 导出文件在IE、360等浏览器中文件名中文乱码问题</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$filename = <span class="string">'xxx导出表'</span>;</div><div class="line"><span class="comment">// 判断如果是IE内核形式的浏览器采用urlencode处理文件名</span></div><div class="line"><span class="keyword">if</span> (!preg_match(<span class="string">"/Firefox/"</span>, $_SERVER[<span class="string">"HTTP_USER_AGENT"</span>])) &#123;</div><div class="line">    $filename = urlencode($filename);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>未完待续。。。<br>期待你的补充和优化</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/office-card-game.png&quot; alt=&quot;office&quot;&gt;&lt;/center&gt;

&lt;p&gt; 过去工作中使用&lt;code&gt;PHPExcel&lt;/code&gt;较多，碰到并解决了各种大大小小的问题，总结出这样一篇文章，一方面记录自己踩过的坑，一方面与大家分享，让大家少走弯路，并不断完善之，欢迎大家去&lt;code&gt;github&lt;/code&gt;上面&lt;code&gt;star&lt;/code&gt;和提交&lt;code&gt;pull request&lt;/code&gt;，不断补充和优化，打造最全面的&lt;code&gt;PHPExcel&lt;/code&gt;开发解决方案&lt;/p&gt;
&lt;p&gt;Github 地址：&lt;a href=&quot;https://github.com/tony-yin/PHPExcel_Road&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/tony-yin/PHPExcel_Road&lt;/a&gt;&lt;br&gt;原文地址：&lt;a href=&quot;https://tony-yin.github.io/2017/09/18/PHP-Excel/&quot;&gt;https://tony-yin.github.io/2017/09/18/PHP-Excel/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="PHP" scheme="https://tony-yin.github.io/tags/PHP/"/>
    
      <category term="PHPExcel" scheme="https://tony-yin.github.io/tags/PHPExcel/"/>
    
  </entry>
  
  <entry>
    <title>Disk pull and plug record</title>
    <link href="https://tony-yin.github.io/2017/09/10/Disk-pull-and-plug-record/"/>
    <id>https://tony-yin.github.io/2017/09/10/Disk-pull-and-plug-record/</id>
    <published>2017-09-09T18:21:45.000Z</published>
    <updated>2017-09-20T13:48:28.000Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/open-uri20150611-11-s7rw56.png" alt="pull disk"></center><p>最近在做磁盘拔插后的<code>OSD</code>热恢复功能。在反复拔插盘的实践过程中，遇到了一个难题，就是时常会由于拔盘，然后再插盘后盘符发生了改变，<code>kernel</code>和<code>udev</code>接收不到任何<code>device</code>增加或删除的事件消息，<br>由于我是基于<code>udev</code>监测磁盘的插拔，所以一旦感知不到的话，就无法进行相应的恢复操作，所以在此对拔盘的记录进行一些记录，并在大量操作中得出总结。</p><a id="more"></a><h2 id="Operation-Record"><a href="#Operation-Record" class="headerlink" title="Operation Record"></a>Operation Record</h2><p><code>normal</code>: 表示正常情况，没有被拔</p><table><thead><tr><th style="text-align:center">env</th><th style="text-align:center">udev monitor</th><th style="text-align:center">UI data</th><th style="text-align:center">disk alias</th><th style="text-align:center">device</th><th style="text-align:center">lsblk</th><th style="text-align:center">mount info</th><th style="text-align:center">mount point </th></tr></thead><tbody><tr><td style="text-align:center">normal</td><td style="text-align:center">-</td><td style="text-align:center">/dev/sdg1</td><td style="text-align:center">osd4-data</td><td style="text-align:center">/dev/sdg</td><td style="text-align:center">exist</td><td style="text-align:center">exist</td><td style="text-align:center">/data/osd.1</td></tr><tr><td style="text-align:center">first pull</td><td style="text-align:center">remove sdg</td><td style="text-align:center">empty</td><td style="text-align:center">remove</td><td style="text-align:center">remove</td><td style="text-align:center">remove</td><td style="text-align:center">exist</td><td style="text-align:center">exist, readerror</td></tr><tr><td style="text-align:center">first plug</td><td style="text-align:center">add sdd</td><td style="text-align:center">/dev/sdd1</td><td style="text-align:center">osd4-data</td><td style="text-align:center">/dev/sdd</td><td style="text-align:center">exist</td><td style="text-align:center">exist</td><td style="text-align:center">exist, readerror</td></tr><tr><td style="text-align:center">second pull</td><td style="text-align:center">no remove</td><td style="text-align:center">empty</td><td style="text-align:center">osd4-data</td><td style="text-align:center">/dev/sdd</td><td style="text-align:center">not change</td><td style="text-align:center">exist</td><td style="text-align:center">exist, readerror</td></tr><tr><td style="text-align:center">second plug</td><td style="text-align:center">All Not Change</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">- </td></tr><tr><td style="text-align:center">clear mount</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">exist</td><td style="text-align:center">-</td><td style="text-align:center">exist</td><td style="text-align:center">remove</td><td style="text-align:center">change style</td></tr><tr><td style="text-align:center">third pull</td><td style="text-align:center">remove sdd</td><td style="text-align:center">empty</td><td style="text-align:center">remove</td><td style="text-align:center">remove</td><td style="text-align:center">remove</td><td style="text-align:center">remove</td><td style="text-align:center">change style</td></tr><tr><td style="text-align:center">third plug</td><td style="text-align:center">add sdd</td><td style="text-align:center">/dev/sdd1</td><td style="text-align:center">osd4-data</td><td style="text-align:center">/dev/sdd</td><td style="text-align:center">exist</td><td style="text-align:center">exist</td><td style="text-align:center">exist, readerror</td></tr></tbody></table><h2 id="Before-pull"><a href="#Before-pull" class="headerlink" title="Before pull"></a>Before pull</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/before_pull.png" alt="before pull"></center><h2 id="First-pull"><a href="#First-pull" class="headerlink" title="First pull"></a>First pull</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/first_pull.png" alt="First pull"></center><h2 id="Read-error"><a href="#Read-error" class="headerlink" title="Read error"></a>Read error</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/readerror.png" alt="Read error"></center><h2 id="First-plug"><a href="#First-plug" class="headerlink" title="First plug"></a>First plug</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/first_plug.png" alt="First plug"></center><h2 id="Second-pull"><a href="#Second-pull" class="headerlink" title="Second pull"></a>Second pull</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/second_pull.png" alt="Second pull"></center><h2 id="Second-plug"><a href="#Second-plug" class="headerlink" title="Second plug"></a>Second plug</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/second_pull.png" alt="Second plug"></center><h2 id="Clear-mount-info"><a href="#Clear-mount-info" class="headerlink" title="Clear mount info"></a>Clear mount info</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/clear_mount.png" alt="Clear mount info"></center><h2 id="Third-plug-udev-monitor"><a href="#Third-plug-udev-monitor" class="headerlink" title="Third plug udev monitor"></a>Third plug udev monitor</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/third_plug.png" alt="Third pull"></center><h2 id="Third-plug"><a href="#Third-plug" class="headerlink" title="Third plug"></a>Third plug</h2><center><img src="http://ovv1r40we.bkt.clouddn.com/third_plug_alias.png" alt="Third plug"></center><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>通过上面的表格和图片，如果拔盘前没有卸载<code>mount</code>链接，那么可以发现：</p><ul><li>下次插盘，磁盘名称不再是原来的名称，在当前排序最后的一个磁盘名往后追加，比如当前最后一块盘是<code>sdf</code>，那么就改名为<code>sdg</code></li><li><code>lsblk</code>显示<code>device</code>列表不会变化，<code>alias name</code>也是不会变化</li><li>再次拔盘，<code>device</code>列表不会变化，<code>udev monitor</code>不会接收到任何设备的删除的事件信息</li><li>再次插盘，<code>device</code>列表不会变化，<code>udev monitor</code>不会接收到任何设备的添加的事件信息</li></ul><p>如果清除了<code>mount</code>信息，插拔变得正常起来</p><ul><li><code>udev</code>可以正常接收设备添加和删除的信息</li><li><code>lsblk</code>可以正常显示设备列表，会随着磁盘的拔盘而更新显示，<code>alias name</code>也是如此</li><li>磁盘名称变回正常，即开机最原始的名称，例如上文的<code>sdd</code></li></ul><p>所以针对一块硬盘的拔插只要做好即时清除<code>mount</code>就够了，那么这个时候拔另外插槽的一块盘呢？<br>结果是：</p><ul><li>第一次拔盘： <code>udev</code>感知到（<code>remove</code> 当前磁盘名），<code>device</code>列表和<code>alias name</code>消失 </li><li>第一次插盘： <code>udev</code>感知到（<code>add</code> <strong>sdg</strong>），<code>device</code>增加了<code>sdg</code>，<code>alias name</code>增加，没有变化</li><li>第二次拔盘： 一切都没了反应</li><li>清除<code>mount</code>信息后，插盘：无反应</li><li>删除<code>alias name</code>： 无反应</li><li>无论怎么样都没反应，也许除了开机或者这快盘插在别的插槽内</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h3><p>目前来看，只要拔盘超过两块，一旦第二块盘的磁盘名称变了跟之前名称不一样，那么之后再怎么清理<code>mount</code>信息或者反复拔插都不会被<code>udev</code>感知到<br>理论上来说，要实现硬盘热替换，那就得保证<code>udev</code>每次都能检测到硬盘的插入，拔盘检测倒不是那么重要，<br>针对这种情况，目前没发现什么比较好的解决方案，唯一一种也是我当前采用的方案，在检测拔盘事件时会触发一个脚本，做拔的盘的<code>mount</code>信息的检查，如果存在<code>mount</code>信息，那么就<code>umount</code>掉，这是一种比较完美的场景，也就是说要保证每次插盘前，当前盘在系统中都不存在任何<code>mount</code>信息</p><p>这种方案还是太完美化了，还需要大量的测试，期望能找出更能经得起推敲的方案</p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>测试过程中偶然发现每次硬盘插入如果被<code>udev</code>感知到，也会执行大量的<code>udev rules</code>，其中包括创建设备，建立连接，建立连接这个事情就包括硬盘分区的<code>alias</code>，而我们感知到磁盘设备插入执行脚本在这之前，找了一系列的方案，都没能够使得让脚本在它<code>alias</code>之后再执行</p><p>这里有一份官方的解释：<a href="http://www.reactivated.net/writing_udev_rules.html#external-run" target="_blank" rel="external">http://www.reactivated.net/writing_udev_rules.html#external-run</a></p><p>至于为什么脚本依赖这个别名，那是因为系统存的<code>data path</code>还是<code>journal path</code>都是以别名的形式，如果我们能够在别名之后执行脚本，那么理想情况下系统<code>db</code>之前存的别名会自动和插入的盘匹配建立连接，不需要我们再做过多的事情，否则我们得在每次创建<code>osd</code>的时候再存原始路径，记录分区信息等等，还有<code>/etc/fstab</code>存的都是别名，这样就导致有些操作无法进行，还有一些其他的矛盾暂时还没想到</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/open-uri20150611-11-s7rw56.png&quot; alt=&quot;pull disk&quot;&gt;&lt;/center&gt;

&lt;p&gt;最近在做磁盘拔插后的&lt;code&gt;OSD&lt;/code&gt;热恢复功能。在反复拔插盘的实践过程中，遇到了一个难题，就是时常会由于拔盘，然后再插盘后盘符发生了改变，&lt;code&gt;kernel&lt;/code&gt;和&lt;code&gt;udev&lt;/code&gt;接收不到任何&lt;code&gt;device&lt;/code&gt;增加或删除的事件消息，&lt;br&gt;由于我是基于&lt;code&gt;udev&lt;/code&gt;监测磁盘的插拔，所以一旦感知不到的话，就无法进行相应的恢复操作，所以在此对拔盘的记录进行一些记录，并在大量操作中得出总结。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Disk" scheme="https://tony-yin.github.io/tags/Disk/"/>
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Osd" scheme="https://tony-yin.github.io/tags/Osd/"/>
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
      <category term="Udev" scheme="https://tony-yin.github.io/tags/Udev/"/>
    
  </entry>
  
  <entry>
    <title>Linux Udev</title>
    <link href="https://tony-yin.github.io/2017/09/10/Linux-Udev/"/>
    <id>https://tony-yin.github.io/2017/09/10/Linux-Udev/</id>
    <published>2017-09-09T18:20:27.000Z</published>
    <updated>2017-09-20T12:17:41.000Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/pingu.png" alt="udev"></center><p>在我入门<code>udev</code>，看着各种各样的资料觉得这个东西很高深的时候，突然瞄到一篇文章里面说道： 要树立一个信念：<code>udev</code>很简单，当时不以为然，现在深表赞同。看起来很高端很遥远的<code>Title</code>，比如<code>Linux Kernel</code>，比如软硬件交互，比如热插拔等等，其实掌握几个<code>rules</code>，然后再动手实践实践，对比着讲解，就能知道七七八八了，想要再深入，就多看看文档实现和内核源码，其实很多东西都是这样，了解了就很简单，没事了解一点就比别人多知道一些，共勉 </p><a id="more"></a><h2 id="Udev-是什么"><a href="#Udev-是什么" class="headerlink" title="Udev 是什么"></a>Udev 是什么</h2><p><code>udev</code>是<code>linux kernel</code>的设备管理器，处理硬件的添加和删除，但它的功能远远不仅于此。比如<code>U</code>盘插入，电脑是如何即时的做出响应？耳机插入又是如何做到自动关闭外部音量？这些都跟<code>udev</code>有关。虽然<code>udev</code>很强大，功能很多，本来就针对<code>SCSI</code>硬盘设备的插拔做一些经验的分享。至于为什么我会研究到这个东西，是因为最近在做<code>ceph</code>相关的项目，需要实现一个类似热插拔的<code>feature</code>，懂的人应该很清楚，就是拔插硬盘后，<code>osd</code>自动恢复，主要应用于硬盘寿命即将到期，替换新盘的场景，不明白的同学也不要紧，因为本文主要讨论的是<code>udev</code></p><h2 id="Udev-Rules"><a href="#Udev-Rules" class="headerlink" title="Udev Rules"></a>Udev Rules</h2><p><code>udev</code>管理各种各样的设备，比如<code>usb</code>,<code>scsi</code>,<code>cd</code>等等，为了区别设备类型，精确匹配，<code>udev</code>制定了一套特色的<code>rules</code>，为什么说特色呢？因为我觉得它用最简洁的语法满足了方方面面的需求</p><p>这里推荐一些有用的<code>link</code>：</p><ul><li><a href="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html" target="_blank" rel="external">UDEV Primer</a>  <code>udev</code>入门必读，可以快速将<code>udev</code>了解一番</li><li><a href="http://www.reactivated.net/writing_udev_rules.html" target="_blank" rel="external">Writing udev rules</a>  经典文章，看完这个基本就能掌握<code>udev rules</code></li><li><a href="http://www.lai18.com/content/1612267.html" target="_blank" rel="external">Writing udev rules 修订版</a>  国内论坛对格式样式做了一些修改，有洁癖的可以看看</li><li><a href="http://blog.csdn.net/nhczp/article/details/4099647" target="_blank" rel="external">Writing udev rules 译</a>  翻译版本，英文不好的可以中英文对比着看</li><li><a href="http://www.jinbuguo.com/systemd/udev.html#" target="_blank" rel="external">udev 中文手册</a>  这位金步国先生为开源事业做出了杰出的贡献，早前就看过他翻译的<code>Apache</code>的手册</li><li><a href="http://wiki.dreamrunner.org/public_html/Embedded-System/kernel/udev-rules.html" target="_blank" rel="external">Writing udev rules and kernel examples</a>  看够了上面各种规则，来看看具体的例子吧</li><li><a href="http://blog.csdn.net/lqrensn/article/details/8097288" target="_blank" rel="external">Udev 详解</a>  文章如名，真的很详细</li><li><a href="http://www.cnblogs.com/qigaohua/p/6673930.html" target="_blank" rel="external">Udev 使用方法</a>  一些特殊的技巧  </li></ul><p>大家看完上面的文章应该知道<code>rules</code>文件的位置和规则,下面我贴一些我实践中的代码和例子</p><h3 id="Rules-Example"><a href="#Rules-Example" class="headerlink" title="Rules Example"></a>Rules Example</h3><p>这是两条分别针对<code>SCSI</code>硬盘设备的添加和删除的<code>rules</code>，设备事件分别会触发相应的脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">KERNEL==&quot;sd[a-z]&quot;, ACTION==&quot;add&quot;, SUBSYSTEM==&quot;block&quot;, RUN+=&quot;/usr/bin/python /root/test.py %k add&quot;</div><div class="line">KERNEL==&quot;sd[a-z]&quot;, ACTION==&quot;remove&quot;, SUBSYSTEM==&quot;block&quot;, RUN+=&quot;/usr/bin/python /root/test.py %k remove&quot;</div></pre></td></tr></table></figure></p><h3 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h3><ul><li>执行外部命令必须加上环境变量路径, 上面的这个也可以不加<code>/usr/bin/python</code>，但是必须在<code>py</code>脚本头部加上<code>shebang</code>：<code>#! /usr/bin/python</code></li><li><code>RUN</code>可以运行程序外的程序，而<code>PROGRAM</code>不是做这个事情的，而是为了生成之后需要的变量</li></ul><h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><ul><li><a href="http://www.cnblogs.com/daishuguang/p/4192703.html" target="_blank" rel="external">hashtag and shebang</a></li><li><a href="http://smilejay.com/2012/03/linux_shebang/" target="_blank" rel="external">shebang</a></li></ul><h2 id="Udevadm"><a href="#Udevadm" class="headerlink" title="Udevadm"></a>Udevadm</h2><p><code>udevadm</code>是一个<code>udev</code>的管理工具，可以用来获取设备信息(<code>info</code>)，监视和控制udev运行时的行为(<code>control</code>)，请求内核事件(<code>trigger</code>)，管理事件队列(<code>settle</code>)，以及提供简单的调试机制(<code>test</code>)。很实用，很好用！！！</p><h3 id="推荐-Link"><a href="#推荐-Link" class="headerlink" title="推荐 Link"></a>推荐 Link</h3><ul><li><a href="http://www.jinbuguo.com/systemd/udevadm.html" target="_blank" rel="external">udevadm 中文手册</a>  很全，很基础 ~~</li><li><a href="http://fibrevillage.com/sysadmin/93-udevadm-usage-examples" target="_blank" rel="external">udevadm command examples</a>  很多<code>udevadm</code>的命令可以借鉴，说不定以后可以用到呢？</li></ul><p>介绍几个我具体使用过的例子：</p><h3 id="udevadm-info"><a href="#udevadm-info" class="headerlink" title="udevadm info"></a>udevadm info</h3><p>可以从<code>udev</code>数据库中提取设备信息,此外，还可以从<code>sysfs</code>中提取设备的属性， 以帮助创建与此设备匹配的<code>udev</code>规则</p><p>获取<code>/dev/sdb</code>的<code>path</code>信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">udevadm info -q path -n /dev/sdb</div></pre></td></tr></table></figure></p><h3 id="udevadm-test"><a href="#udevadm-test" class="headerlink" title="udevadm test"></a>udevadm test</h3><p>模拟向<code>udev</code>发送设备信息，并不会真的触发，<strong>而是将触发后的过程信息打印出来</strong>，对调试很有帮助</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">udevadm test --action=&apos;add&apos; `udevadm info -q path -n /dev/sdb`</div></pre></td></tr></table></figure><p><strong>注意：</strong> <code>test</code>不会真正触发事件，而<code>trigger</code>可以</p><h3 id="udevadm-trigger"><a href="#udevadm-trigger" class="headerlink" title="udevadm trigger"></a>udevadm trigger</h3><p>可以真正触发<code>udev</code>事件，但是不会真正改变硬件，只是触发<code>kernel</code>和<code>udev</code>的事件，会触发<code>udev rules</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">udevadm trigger -v --action=add --sysname-match=sda</div></pre></td></tr></table></figure><p><strong>注意：</strong> </p><ul><li>不加<code>sysname-match</code>那么会触发所有设备，如果是<code>action=remove</code>，那么则会移除很多设备，甚至导致<code>sshd</code>服务停掉</li><li>后面是<code>sda</code>而不是<code>/dev/sda</code>因为它是根据<code>pci</code>路径来定位<code>name</code>的，比如<code>sda</code>的路径是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/sys/devices/pci0000:00/0000:00:10.0/host2/target2:0:0/2:0:0:0/block/sda</div></pre></td></tr></table></figure></li></ul><h3 id="udevadm-control"><a href="#udevadm-control" class="headerlink" title="udevadm control"></a>udevadm control</h3><ul><li><p>重载<code>udev rules</code>，对之后触发的新设备有效，对之前已经触发的无效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">udevadm control --relaod-rules</div></pre></td></tr></table></figure></li><li><p>更改<code>udev</code>日志等级为<code>info</code>，<code>udev</code>默认等级为<code>err</code>，可以在<code>/etc/udev/udev.conf</code>中查看，日志具体信息可以在<code>syslog</code>中查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">udevadm control --log-priority=info</div></pre></td></tr></table></figure></li></ul><h2 id="More-about-udev"><a href="#More-about-udev" class="headerlink" title="More about udev"></a>More about udev</h2><p><code>udev</code>还有很多有意思的地方，如果想要更加深入的学习，那么除了熟练地掌握<code>rules</code>等技巧，还要对其实现原理有了解，这就得多看文档，多看源码了，建议大家有条件的情况下多看源码，多看原始的东西，因为经过别人的总结就可能会变味，相互对比，不要一味依赖别人总结的产物</p><ul><li><a href="https://my.oschina.net/bwhite/blog/808995" target="_blank" rel="external">Linux 自动挂载usb设备 小例子</a>  如何在<code>usb</code>设备插入后自动挂载？</li><li><a href="http://www.jianshu.com/p/dd6cecd7755a" target="_blank" rel="external">udev使用笔记</a>  这篇文章里面那张图片不错</li><li><a href="http://blog.csdn.net/fjb2080/article/details/5009791" target="_blank" rel="external">写个程序检测我们的设备插拔</a>  模仿内核源码简单地实现一个设备插拔的检测</li><li><a href="http://www.itnose.net/detail/6691523.html" target="_blank" rel="external">linux下热插拔事件的产生是怎样通知到用户空间</a>  事件传递过程，<code>udev</code>源码解析</li><li><a href="http://blog.csdn.net/bingqingsuimeng/article/details/7950639" target="_blank" rel="external">热插拔的工作原理 hotplug机制和udev</a>  <code>udev</code>原理讲解</li><li><a href="http://blog.csdn.net/sunweizhong1024/article/details/7928530" target="_blank" rel="external">Uevent 上报event事件给上层的详细讲解</a>  <code>uevent</code>源码讲解</li><li><a href="http://blog.csdn.net/bingqingsuimeng/article/details/7924756" target="_blank" rel="external">linux内核空间和用户空间的是怎样区别的，如何交互，如何从用户空间进入内核空间</a>  内核空间和用户空间的一些剖析</li><li><a href="http://blog.chinaunix.net/uid-24943863-id-3223000.html" target="_blank" rel="external">Netlink实现热拔插监控 </a>  消息传输用的是什么？<code>Netlink</code>是如何做到的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/pingu.png&quot; alt=&quot;udev&quot;&gt;&lt;/center&gt;

&lt;p&gt;在我入门&lt;code&gt;udev&lt;/code&gt;，看着各种各样的资料觉得这个东西很高深的时候，突然瞄到一篇文章里面说道： 要树立一个信念：&lt;code&gt;udev&lt;/code&gt;很简单，当时不以为然，现在深表赞同。看起来很高端很遥远的&lt;code&gt;Title&lt;/code&gt;，比如&lt;code&gt;Linux Kernel&lt;/code&gt;，比如软硬件交互，比如热插拔等等，其实掌握几个&lt;code&gt;rules&lt;/code&gt;，然后再动手实践实践，对比着讲解，就能知道七七八八了，想要再深入，就多看看文档实现和内核源码，其实很多东西都是这样，了解了就很简单，没事了解一点就比别人多知道一些，共勉 &lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
      <category term="Udev" scheme="https://tony-yin.github.io/tags/Udev/"/>
    
  </entry>
  
  <entry>
    <title>Magicloud Route</title>
    <link href="https://tony-yin.github.io/2017/09/10/Magicloud-Route/"/>
    <id>https://tony-yin.github.io/2017/09/10/Magicloud-Route/</id>
    <published>2017-09-09T18:19:35.000Z</published>
    <updated>2017-09-20T13:39:28.000Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/router.png" alt="router"></center><p><code>Magicloud</code>是我目前负责的一个基于<code>ceph</code>的分布式存储项目，为了方便刚刚参与项目的成员熟悉整个项目的路由并能够快速着手，在这里对整个项目的路由梳理了一下，以图形为主，凸出整个流程的走向</p><a id="more"></a><p><code>Magicloud</code>目前有两种方式进行前后端通信，一种是<code>Ajax</code>,一种是<code>Restful Api</code></p><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>以前台<code>UI</code>的主机角色获取所有<code>Osd</code>列表为例：</p><center><img src="http://on-img.com/chart_image/599851a6e4b0b7b347e0e378.png" alt="image"></center><h3 id="Restful-API"><a href="#Restful-API" class="headerlink" title="Restful API"></a>Restful API</h3><center><img src="http://on-img.com/chart_image/59994a6ae4b06df7265d5447.png" alt="image"></center>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/router.png&quot; alt=&quot;router&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;code&gt;Magicloud&lt;/code&gt;是我目前负责的一个基于&lt;code&gt;ceph&lt;/code&gt;的分布式存储项目，为了方便刚刚参与项目的成员熟悉整个项目的路由并能够快速着手，在这里对整个项目的路由梳理了一下，以图形为主，凸出整个流程的走向&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Route" scheme="https://tony-yin.github.io/tags/Route/"/>
    
  </entry>
  
  <entry>
    <title>Osd Enable and Disable</title>
    <link href="https://tony-yin.github.io/2017/09/10/Osd-Enable-and-Disable/"/>
    <id>https://tony-yin.github.io/2017/09/10/Osd-Enable-and-Disable/</id>
    <published>2017-09-09T18:18:33.000Z</published>
    <updated>2017-10-02T05:01:09.000Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/fireart_blog-600-450.jpg" alt="osd"></center><p>对项目中<code>osd</code>的<code>enable</code>和<code>disable</code>的代码流程的总结</p><a id="more"></a><h2 id="Osd-Disable"><a href="#Osd-Disable" class="headerlink" title="Osd Disable"></a>Osd Disable</h2><p>1.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stop_ezs3_service: stop_ezs3_service</div></pre></td></tr></table></figure></p><p>2.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stop osd</div></pre></td></tr></table></figure></p><p>3.<code>disable osd</code></p><ul><li>load config: /etc/mcs3/storage.conf(存储卷的配置信息，即<code>osd</code>的配置信息)</li><li>service ganglia-monitor stop’ returns ‘Stopping Ganglia Monitor Daemon: gmond.</li><li>get osd id by osd name </li><li>stop osd<ul><li>ezs3-ha service_ceph stop osd0</li><li>kill -9 xxx</li><li>ceph osd down 0, ceph osd out 0, ceph osd rm 0</li></ul></li><li>disable osd</li><li>umount:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mount_point = &quot;/data/osd.&#123;&#125;&quot;.format(self.get_osd_id())</div><div class="line">if os.path.ismount(mount_point):</div><div class="line">umount -f -l /data/osd.0 ?</div><div class="line">   ......</div><div class="line">   sed -i &apos;\@/data/osd.0@d&apos; /etc/fstab</div></pre></td></tr></table></figure></li></ul><p>4.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete part_map</div></pre></td></tr></table></figure></p><p>5.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set partition map</div></pre></td></tr></table></figure></p><p>6.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cl.node_management.osd_disabled</div></pre></td></tr></table></figure></p><h2 id="Osd-Enable"><a href="#Osd-Enable" class="headerlink" title="Osd Enable"></a>Osd Enable</h2><ul><li>prepare enable osd</li><li>set public interace,cluster interface(if cluster interface is true) and save in ceph.conf (osd, interface等信息存放文件：/etc/ceph/ceph.conf)</li><li>consolidate_raid_configure<ul><li>查看池信息：/opt/MegaRAID/MegaCli/MegaCli64 -AdpBbuCMD -Aall |grep Exit |tr -d “\n”</li><li>a series of megaci command</li></ul></li><li>记录 osd 的状态： role.set(OSD, RoleState.ENABLING)</li><li>enable osd (@monlock ?)<ul><li>update task info(有空看下代码，如何实现ajax轮询的)</li><li>get_partition_map:</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">try: </div><div class="line">    kvstore.get(&apos;partition_map&apos;, timeout, timeout!=0) </div><div class="line">catch: </div><div class="line">    rados -p .ezs3 get partition_map -</div></pre></td></tr></table></figure><ul><li>stop ezs3 service</li><li>创建桶节点并且建立link</li><li>service ganglia-monitor stop</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if not host_osd_enabled: </div><div class="line">    ceph osd crush add-bucket &#123;&#125; host&quot;.format(crush_host_bucket)</div><div class="line">    ceph osd crush link &#123;&#125; pool=default&quot;.format(crush_host_bucket)</div></pre></td></tr></table></figure><ul><li>StorageVolume<ul><li>enable_osd<ul><li>ceph osd create</li><li>mount: mount -o noatime,user_xattr /dev/disk/by-partlabel/osd1-data /data/osd.0</li><li>add osd and save</li><li>ceph mon getmap -o /tmp/monmap（二进制文件）</li><li>ceph-osd -i {osd_id} –monmap /tmp/monmap –mkfs –mkjournal</li><li>start osd: <code>ezs3-ha service_ceph start osd0</code></li><li>ceph osd crush add {osd_id} 0 pool=default host={crush_host_bucket}</li><li>set osd uuid and osd post  stop command</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/fireart_blog-600-450.jpg&quot; alt=&quot;osd&quot;&gt;&lt;/center&gt;

&lt;p&gt;对项目中&lt;code&gt;osd&lt;/code&gt;的&lt;code&gt;enable&lt;/code&gt;和&lt;code&gt;disable&lt;/code&gt;的代码流程的总结&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Osd" scheme="https://tony-yin.github.io/tags/Osd/"/>
    
  </entry>
  
  <entry>
    <title>Disk Mon Daemon</title>
    <link href="https://tony-yin.github.io/2017/09/10/Disk-Mon-Daemon/"/>
    <id>https://tony-yin.github.io/2017/09/10/Disk-Mon-Daemon/</id>
    <published>2017-09-09T18:17:19.000Z</published>
    <updated>2017-10-02T05:05:29.000Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/dribbble-health-600-450.png" alt="daemon"></center><p>最近在做监控<code>SSD</code>磁盘健康状态这个需求的时候，发现项目中专门针对磁盘写了一个<code>daemon</code>，之前对<code>daemon</code>只是表面上的了解，所以这次正好深入学习下,了解一下这样做的原因和好处以及如何在以后的工作中熟练运用<code>daemon</code><br><a id="more"></a></p><h2 id="Daemon相关知识了解"><a href="#Daemon相关知识了解" class="headerlink" title="Daemon相关知识了解"></a>Daemon相关知识了解</h2><ul><li><a href="http://www.linfo.org/daemon.html" target="_blank" rel="external">Daemon Definition</a></li><li><a href="https://stackoverflow.com/questions/17954432/creating-a-daemon-in-linux" target="_blank" rel="external">Creating a daemon in Linux</a></li><li><a href="http://www.enderunix.org/docs/eng/daemon.php" target="_blank" rel="external">Unix Daemon Server Programming</a></li><li><a href="http://www.netzmafia.de/skripten/unix/linux-daemon-howto.html" target="_blank" rel="external">Linux Daemon Writing HOWTO</a></li><li><a href="http://www.cnblogs.com/mickole/p/3188321.html" target="_blank" rel="external">守护进程详解及创建，daemon()使用</a></li></ul><h2 id="MCS3DiskMonitor-Daemon使用"><a href="#MCS3DiskMonitor-Daemon使用" class="headerlink" title="MCS3DiskMonitor Daemon使用"></a>MCS3DiskMonitor Daemon使用</h2><ol><li><code>pid</code>文件路径： <code>/var/run/mcs3-smart-monitor.pid</code></li><li><code>daemon</code>所在位置: <code>/etc/init.d/</code></li><li><code>log</code>打印位置：<code>/var/log/mccloudstor/mcs3-disk-mon.log</code></li><li>操作方式：</li></ol><ul><li><code>service mcs3-smart-monitor start</code></li><li><code>service mcs3-smart-monitor stop</code></li><li><code>service mcs3-smart-monitor restart</code></li></ul><blockquote><p>改动<code>daemon</code>相关代码，需<code>restart daemon</code>才可以生效</p></blockquote><h2 id="MCS3DiskMonitor-Daemon-process"><a href="#MCS3DiskMonitor-Daemon-process" class="headerlink" title="MCS3DiskMonitor Daemon process"></a>MCS3DiskMonitor Daemon process</h2><p><strong>1.</strong> 单位时间避免邮件重复发送： 通过声明一个全局变量<code>send_email_time</code>, 记录当前时间的一个小时的时间，一旦发送邮件立即更新该变量为当前时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">sent_mail_time = datetime.datetime.now() - datetime.timedelta(0,3600) # 1 hour</div><div class="line"></div><div class="line">def send_disk_status_notification(disk_status):</div><div class="line">    global sent_mail_time</div><div class="line">    now = datetime.datetime.now()</div><div class="line">    if now &lt; sent_mail_time + datetime.timedelta(0,3600):</div><div class="line">        logger.info(&quot;Notification sent within one hour before. System will not send again.&quot;)</div><div class="line">        return</div><div class="line">            host = socket.gethostname()</div><div class="line">    title = &quot;Host &#123;&#125; Disk Health Status Warning!&quot;.format(host)</div><div class="line">    message = disk_status</div><div class="line">    try:</div><div class="line">        utils.send_notification(title, message)</div><div class="line">        sent_mail_time = datetime.datetime.now()</div><div class="line">    except Exception as e:</div><div class="line">        logger.error(str(e))</div></pre></td></tr></table></figure><p><strong>2.</strong> 执行命令报错影响其他代码的执行，有以下几处命令执行：</p><p><code>line48</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">output = utils.do_cmd(&quot;zpool status|grep state&quot;, force=True)</div></pre></td></tr></table></figure></p><p><code>line71~75</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">VDSTATE1 = do_cmd(MEGACLI_BIN + &quot; -cfgdsply -aALL -NoLog | grep State&quot;) </div><div class="line">VDSTATE2 = do_cmd(MEGACLI_BIN + &quot; -AdpAllInfo -aALL -NoLog | grep Degraded&quot;)</div><div class="line">VDSTATE3 = do_cmd(MEGACLI_BIN + &quot; -AdpAllInfo -aALL -NoLog | grep Offline&quot;)</div><div class="line">PDSTATE1 = do_cmd(MEGACLI_BIN + &quot; -AdpAllInfo -aALL -NoLog | grep \&quot;Critical Disks\&quot;&quot;)</div><div class="line">PDSTATE2 = do_cmd(MEGACLI_BIN + &quot; -AdpAllInfo -aALL -NoLog | grep \&quot;Failed Disks\&quot;&quot;)</div></pre></td></tr></table></figure></p><blockquote><p>暂时处理方法：在这些方法的外面单独包一层<code>try catch</code></p></blockquote><p><strong>3.</strong> <code>SSD Disk</code>信息获取</p><ul><li>获取健康寿命</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">smartctl -a -d megaraid,&#123;&#125; &#123;&#125;|grep &apos;Media_Wearout_Indicator&apos;</div></pre></td></tr></table></figure><ul><li>获取磁盘序列号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">smartctl -a -d megaraid,&#123;&#125; &#123;&#125;|grep &apos;Serial Number&apos;</div></pre></td></tr></table></figure><ul><li>判断是否为SSD Disk：如果为<code>1</code>则为机械硬盘，如果为<code>0</code>则为<code>SSD Disk</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /sys/block/&#123;&#125;/queue/rotational  // param such as sda or sdb etc</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/dribbble-health-600-450.png&quot; alt=&quot;daemon&quot;&gt;&lt;/center&gt;


&lt;p&gt;最近在做监控&lt;code&gt;SSD&lt;/code&gt;磁盘健康状态这个需求的时候，发现项目中专门针对磁盘写了一个&lt;code&gt;daemon&lt;/code&gt;，之前对&lt;code&gt;daemon&lt;/code&gt;只是表面上的了解，所以这次正好深入学习下,了解一下这样做的原因和好处以及如何在以后的工作中熟练运用&lt;code&gt;daemon&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
      <category term="Daemon" scheme="https://tony-yin.github.io/tags/Daemon/"/>
    
  </entry>
  
  <entry>
    <title>Network Down Notification</title>
    <link href="https://tony-yin.github.io/2017/09/10/network-down-notification/"/>
    <id>https://tony-yin.github.io/2017/09/10/network-down-notification/</id>
    <published>2017-09-09T18:14:34.000Z</published>
    <updated>2017-09-20T13:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/it_specialist_kit8-net.png" alt="network"></center><p>项目中要做一个<code>network</code> <code>down</code>了之后给用户发送邮件提醒的功能，这里面涉及到的问题有：</p><ul><li>如何监测 network 状态</li><li>network down之后，如何发送邮件</li><li>public network 和 storage network的用处和场景</li></ul><a id="more"></a><h2 id="get-role-interfaces"><a href="#get-role-interfaces" class="headerlink" title="get role interfaces"></a>get role interfaces</h2><h2 id="get-interfaces"><a href="#get-interfaces" class="headerlink" title="get interfaces"></a>get interfaces</h2><h2 id="get-interface-info"><a href="#get-interface-info" class="headerlink" title="get interface info"></a>get interface info</h2><h3 id="获取-MAC-和-busid"><a href="#获取-MAC-和-busid" class="headerlink" title="获取 MAC 和 busid"></a>获取 MAC 和 busid</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">syspath = os.path.join(&quot;/sys/class/net/&quot;, interface)  // interface such as &apos;eth0&apos;</div><div class="line">mac = linecache.getline(os.path.join(syspath, &quot;address&quot;), 1)[:-1].upper()</div><div class="line">buspath = os.path.realpath(syspath)</div><div class="line">bus_id = os.path.basename(os.path.dirname(os.path.dirname(buspath)))</div></pre></td></tr></table></figure><ul><li>MAC: 直接在<code>syspath</code>目录下读取<code>address</code>文件</li><li>假设为<code>eth0</code>,查看<code>eth0</code>目录可见该目录被建立了软连接，并不是真实地址，所以需要取出它的真实地址，这个需要使用<code>python</code>中的<code>os.path.realpath()</code>处理获得<code>0000:03:00.0</code>,作为下一步<code>lspci</code>的参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@ceph133:/sys/class/net# ll eth0</div><div class="line">lrwxrwxrwx 1 root root 0  8月  8 01:26 eth0 -&gt; ../../devices/pci0000:00/0000:00:15.0/0000:03:00.0/net/eth0/</div></pre></td></tr></table></figure><h3 id="获取网卡信息"><a href="#获取网卡信息" class="headerlink" title="获取网卡信息"></a>获取网卡信息</h3><p><code>lspci -s</code>后面的参数为<code>pci</code>设备的地址，也叫<code>pci寻址</code>，这个地址由总线编号、插槽编号和功能块编号信息组成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lspci -m -s xxx // 这边的参数就是上面的bus_id</div></pre></td></tr></table></figure></p><blockquote><p>具体<code>lspci</code>信息请参照：<br><a href="http://coolnull.com/2246.html" target="_blank" rel="external">lspci命令详解</a><br><a href="http://blog.csdn.net/xiadidi/article/details/18408169" target="_blank" rel="external">LSPCI命令详解分析</a></p></blockquote><h3 id="获取网卡状态"><a href="#获取网卡状态" class="headerlink" title="获取网卡状态"></a>获取网卡状态</h3><p>通过<code>ethtool</code>工具获取网卡状态，就是看<code>Link detected</code>是否为<code>yes</code>，<code>yes</code>表示已激活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/sbin/ethtool eth0 | grep &apos;Link detected: yes&apos; | wc -l</div></pre></td></tr></table></figure><h2 id="bond-filter"><a href="#bond-filter" class="headerlink" title="bond filter"></a>bond filter</h2><h2 id="Network-down-notification"><a href="#Network-down-notification" class="headerlink" title="Network down notification"></a>Network down notification</h2><p><strong>1.</strong> 目前无论是<code>storage</code>还是<code>public</code>网卡只要<code>down</code>其中一个都无法发送<code>email</code>:</p><ul><li>public: <code>visit foreign network and connect smtp server</code></li><li>storage: <code>connect ceph rados to get notification info, such as send account and smtp server etc</code><br>所以只能<code>monitor</code>除这两个以外的网卡</li></ul><p><strong>2.</strong> <code>Python</code></p><ul><li><code>log</code>打印的文件取决于当前文件进程的初始化<code>log level</code></li><li><code>logger</code>: <code>handler</code>, <code>formatter</code>, <code>filter</code></li><li><code>dictdefault</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/it_specialist_kit8-net.png&quot; alt=&quot;network&quot;&gt;&lt;/center&gt;

&lt;p&gt;项目中要做一个&lt;code&gt;network&lt;/code&gt; &lt;code&gt;down&lt;/code&gt;了之后给用户发送邮件提醒的功能，这里面涉及到的问题有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何监测 network 状态&lt;/li&gt;
&lt;li&gt;network down之后，如何发送邮件&lt;/li&gt;
&lt;li&gt;public network 和 storage network的用处和场景&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Magicloud" scheme="https://tony-yin.github.io/tags/Magicloud/"/>
    
      <category term="Network" scheme="https://tony-yin.github.io/tags/Network/"/>
    
      <category term="Notification" scheme="https://tony-yin.github.io/tags/Notification/"/>
    
  </entry>
  
  <entry>
    <title>Python Oracle</title>
    <link href="https://tony-yin.github.io/2017/09/10/Python-Oracle/"/>
    <id>https://tony-yin.github.io/2017/09/10/Python-Oracle/</id>
    <published>2017-09-09T17:02:41.000Z</published>
    <updated>2017-10-02T05:00:17.000Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/we-love-python-6000-450.png" alt="Python"></center><p>近期在做<code>Intel</code>的测试，需要监测各种故障情况下的热恢复或者热迁移等功能，比如拔线测试，拔盘测试，断电测试等，来检验分布式的稳定性和灵活性，以<code>Oracle</code>为例，需要一直向数据库中写数据，然后在发生故障时，通过观察插入数据的情况来判断是否能够处理异常情况，所以我需要写一个脚本，能够做到通过<code>python</code>自动连接<code>oracle</code>数据库并自动插入数据。</p><a id="more"></a><blockquote><p>当前环境：Linux Centos 7</p></blockquote><h3 id="1-下载安装包cx-Oracle"><a href="#1-下载安装包cx-Oracle" class="headerlink" title="1. 下载安装包cx_Oracle"></a>1. 下载安装包cx_Oracle</h3><p>由于我本地<code>Python</code>版本是<code>2.7</code>,所以选择是<code>2.7</code>版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://pypi.python.org/packages/e1/18/00987c6a9af9568ee87d1fcba877407684a3f1b87515e5eb82d5d5acb9ff/cx_Oracle-6.0rc1-py27-1.x86_64.rpm#md5=ff8f5cce07bd5ec8ed3ce5c79d451474</div></pre></td></tr></table></figure><p>参考:</p><blockquote><ul><li><a href="https://oracle.github.io/python-cx_Oracle/" target="_blank" rel="external">python-cx_Oracle</a></li><li><a href="https://pypi.python.org/pypi/cx_Oracle/5.3" target="_blank" rel="external">安装包列表</a></li></ul></blockquote><h3 id="2-安装cx-Oracle"><a href="#2-安装cx-Oracle" class="headerlink" title="2. 安装cx_Oracle"></a>2. 安装cx_Oracle</h3><ul><li>安装：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm -ivh cx_Oracle-6.0rc1-py27-1.x86_64.rpm</div></pre></td></tr></table></figure><ul><li>查看当前<code>python</code>引入模块库的路径</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root ~]# python</div><div class="line">Python 2.7.5 (default, Nov  6 2016, 00:28:07) </div><div class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-11)] on linux2</div><div class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div><div class="line">&gt;&gt;&gt; import sys</div><div class="line">&gt;&gt;&gt; print sys.path</div><div class="line">[&apos;&apos;, &apos;/usr/lib/python2.7/site-packages/AliyunUtil-0.0.1-py2.7.egg&apos;, &apos;/usr/lib/python2.7/site-packages/cloud_init-0.7.6-py2.7.egg&apos;, &apos;/usr/lib64/python27.zip&apos;, &apos;/usr/lib64/python2.7&apos;, &apos;/usr/lib64/python2.7/plat-linux2&apos;, &apos;/usr/lib64/python2.7/lib-tk&apos;, &apos;/usr/lib64/python2.7/lib-old&apos;, &apos;/usr/lib64/python2.7/lib-dynload&apos;, &apos;/usr/lib64/python2.7/site-packages&apos;, &apos;/usr/lib/python2.7/site-packages&apos;]</div></pre></td></tr></table></figure><ul><li>检查安装路径，如果<code>cx_Oracle.so</code>文件不在以上<code>python</code>引入路径内需要将该文件拷贝到以上<code>python</code>引入路径,所以我这里不需要进行拷贝操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root ~]# rpm -qa | grep cx_Oracle | xargs rpm -ql</div><div class="line">/usr/lib64/python2.7/site-packages/cx_Oracle-6.0rc1-py2.7.egg-info</div><div class="line">/usr/lib64/python2.7/site-packages/cx_Oracle-6.0rc1-py2.7.egg-info/PKG-INFO</div><div class="line">/usr/lib64/python2.7/site-packages/cx_Oracle-6.0rc1-py2.7.egg-info/SOURCES.txt</div><div class="line">/usr/lib64/python2.7/site-packages/cx_Oracle-6.0rc1-py2.7.egg-info/dependency_links.txt</div><div class="line">/usr/lib64/python2.7/site-packages/cx_Oracle-6.0rc1-py2.7.egg-info/top_level.txt</div><div class="line">/usr/lib64/python2.7/site-packages/cx_Oracle.so</div></pre></td></tr></table></figure><h3 id="3-下载-Oracle-Library"><a href="#3-下载-Oracle-Library" class="headerlink" title="3. 下载 Oracle Library"></a>3. 下载 Oracle Library</h3><p>由于<code>Oracle</code>官网下载东西存在<code>Auth</code>认证，所以简单点就点击选中的<code>rpm</code>包保存在<code>windows</code>上，然后上传到<code>linux</code>上即可</p><p><strong>注意：</strong></p><blockquote><ul><li>下载的版本要和连接的<code>Oracle</code>基本一致，我需要连接的<code>oracle</code>版本是<code>11.2</code>，所以我下载的是<code>oracle-instantclient11.2-basic-11.2.0.3.0-1.x86_64.rpm</code></li><li><strong>操作系统要和之前下载的<code>cx_Oracle</code>要一致</strong>，这很重要！！！我在这个上面栽了跟头，花了比较多的时间。。。所以我需要下载<code>64</code>位的</li><li>在<code>Oracle</code>官网下载东西你得先勾选<code>Accept License Agreement</code>，否则你下载不了</li><li>其次你得有<code>Oracle</code>的账号</li></ul></blockquote><h3 id="4-安装-Oracle-Library"><a href="#4-安装-Oracle-Library" class="headerlink" title="4. 安装 Oracle Library"></a>4. 安装 Oracle Library</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm -ivh oracle-instantclient11.2-basic-11.2.0.3.0-1.x86_64.rpm</div></pre></td></tr></table></figure><h3 id="5-配置环境变量"><a href="#5-配置环境变量" class="headerlink" title="5. 配置环境变量"></a>5. 配置环境变量</h3><ul><li><strong>修改<code>Oracle</code>安装路径</strong></li></ul><p>将<code>client64</code>改为<code>client</code>，至于为什么要改暂时还不清楚，只知道不改的话会报错<code>Oracle Client library cannot be loaded: libclntsh.so: cannot open shared object file: No such file or directory</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /usr/lib/oracle/11.2/</div><div class="line">mv client64 client</div></pre></td></tr></table></figure><ul><li>打开<code>/etc/profile</code>,追加环境变量路径</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/profile</div></pre></td></tr></table></figure><ul><li>配置环境变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 查看Oracle安装路径</div><div class="line">[root@iZbp180vortqapb7yf8217Z ~]# rpm -qa | grep oracle | xargs rpm -ql</div><div class="line">/usr/lib/oracle/11.2/client64/bin/adrci</div><div class="line">/usr/lib/oracle/11.2/client64/bin/genezi</div><div class="line">/usr/lib/oracle/11.2/client64/lib/libclntsh.so.11.1</div><div class="line">/usr/lib/oracle/11.2/client64/lib/libnnz11.so</div><div class="line">/usr/lib/oracle/11.2/client64/lib/libocci.so.11.1</div><div class="line">/usr/lib/oracle/11.2/client64/lib/libociei.so</div><div class="line">/usr/lib/oracle/11.2/client64/lib/libocijdbc11.so</div><div class="line">/usr/lib/oracle/11.2/client64/lib/ojdbc5.jar</div><div class="line">/usr/lib/oracle/11.2/client64/lib/ojdbc6.jar</div><div class="line">/usr/lib/oracle/11.2/client64/lib/xstreams.jar</div><div class="line">// 追加ORACLE_HOME环境变量路径</div><div class="line">export ORACLE_HOME=/usr/lib/oracle/11.2/client64</div><div class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ORACLE_HOME/lib</div></pre></td></tr></table></figure><ul><li>生效配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.bashrc</div></pre></td></tr></table></figure><h3 id="6-检查是否可以引入cx-Oracle"><a href="#6-检查是否可以引入cx-Oracle" class="headerlink" title="6. 检查是否可以引入cx_Oracle"></a>6. 检查是否可以引入<code>cx_Oracle</code></h3><p><code>import</code>没有报错，说明之前的辛苦没有白费</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root client64]# python</div><div class="line">Python 2.7.5 (default, Nov  6 2016, 00:28:07) </div><div class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-11)] on linux2</div><div class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div><div class="line">&gt;&gt;&gt; import cx_Oracle</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure><h3 id="7-连接-Oracle"><a href="#7-连接-Oracle" class="headerlink" title="7. 连接 Oracle"></a>7. 连接 Oracle</h3><p>一个插入10条数据的Python脚本demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: UTF-8 -*-</div><div class="line">import cx_Oracle</div><div class="line">con = cx_Oracle.connect(&apos;test/test@xxx.xxx.xxx.xxx/xe&apos;)</div><div class="line">cur = con.cursor()</div><div class="line">for n in range(1, 10):</div><div class="line">    cur.execute(&apos;insert into test(id, name) values (1, n);&apos;)</div><div class="line">cur.close()</div><div class="line">con.close()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/we-love-python-6000-450.png&quot; alt=&quot;Python&quot;&gt;&lt;/center&gt;

&lt;p&gt;近期在做&lt;code&gt;Intel&lt;/code&gt;的测试，需要监测各种故障情况下的热恢复或者热迁移等功能，比如拔线测试，拔盘测试，断电测试等，来检验分布式的稳定性和灵活性，以&lt;code&gt;Oracle&lt;/code&gt;为例，需要一直向数据库中写数据，然后在发生故障时，通过观察插入数据的情况来判断是否能够处理异常情况，所以我需要写一个脚本，能够做到通过&lt;code&gt;python&lt;/code&gt;自动连接&lt;code&gt;oracle&lt;/code&gt;数据库并自动插入数据。&lt;/p&gt;
    
    </summary>
    
      <category term="teach" scheme="https://tony-yin.github.io/categories/teach/"/>
    
    
      <category term="Python" scheme="https://tony-yin.github.io/tags/Python/"/>
    
      <category term="Oracle" scheme="https://tony-yin.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle Linux And Oracle Database 11g R2 Intsallation</title>
    <link href="https://tony-yin.github.io/2017/09/10/oracle_install/"/>
    <id>https://tony-yin.github.io/2017/09/10/oracle_install/</id>
    <published>2017-09-09T16:53:06.000Z</published>
    <updated>2017-09-20T13:38:36.000Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/oracle-eloqua-campaign-manager.png" alt="oralce"></center><p>最近工作中用到了<code>Oracle</code>作为<code>Intel</code>测试的数据库，在装<code>Oracle Linux</code>和<code>Oracle Database 11g R2</code>折腾了很久，这篇文章就这两点对大家分享一些我安装过程中遇到的问题和注意点，<code>rac</code>暂时还未配置，稍后找时间补上</p><a id="more"></a><blockquote><p>友情提醒： 本文参照<code>link</code>较多，请细心并且耐心地进行每一步操作</p><h3 id="Resource-Link"><a href="#Resource-Link" class="headerlink" title="Resource Link"></a>Resource Link</h3><ul><li><a href="https://pan.baidu.com/s/1pL7ENn9" target="_blank" rel="external">Oracle Linux ISO</a></li><li><a href="https://pan.baidu.com/s/1qYufAQo" target="_blank" rel="external">Linux Oracle Database 11g R2</a> </li><li><a href="https://pan.baidu.com/s/1kV3JpCr" target="_blank" rel="external">Windows Oracle Database 11g R2</a> </li></ul></blockquote><h3 id="Oracle-Linux-Installation"><a href="#Oracle-Linux-Installation" class="headerlink" title="Oracle Linux Installation"></a>Oracle Linux Installation</h3><p><strong>参考列表：</strong></p><ul><li><a href="https://wenku.baidu.com/view/afd5ca9e5022aaea998f0fa2.html" target="_blank" rel="external">oracle linux 6.5 安装 oracle 11gR2图文详解</a></li><li><a href="https://pan.baidu.com/s/1miDQEoC" target="_blank" rel="external">Oracle 11g R2（自己整理的Word，带详细RAC配置）</a></li></ul><blockquote><p>以下操作步骤基本是按上面两条<code>link</code>走的，有一些地方不一样或者是没必要的我会在下面详细讲解，我装的时候以<code>link1</code>为主线，然后参照<code>link2</code>的<code>word</code>文档进行，没有特殊标记的一般都是根据<code>link1</code>操作，大家也可以这样操作，可以少遇一些坑，节省一些时间~~~</p></blockquote><p><strong>注意点：</strong></p><ul><li><code>Base server</code>这一步很关键<ul><li>勾选<code>Oracle Linux Server</code>, <code>Resilient Storage</code>和 <code>Scalable Filesystem Support</code>（参照<code>link2</code>）</li><li>勾选<code>Customize Now</code>，这一步依然非常关键，只有勾选了才可以装一些<code>Oracle Linux</code>需要的套件</li><li>需要手动添加安装的套件（系统默认勾选的不要删掉，这边的操作只添加勾选）：<ul><li><code>Base System</code>：<code>Compatibility libraries</code></li><li><code>Servers</code>: <code>System administration tools</code></li><li><code>Desktops</code>: <code>Desktop</code>、<code>Desktop Platform</code>、<code>Fonts</code>、<code>General Purpose Desktop</code>、<code>Graphical Administration Tools</code>、<code>Input Methods</code>、<code>X Window System</code></li><li><code>Development</code>: <code>Additional Development</code>、<code>Development Tools</code></li><li><code>Appilication</code>: <code>Internet Browser</code></li></ul></li></ul></li><li>安装应该是<code>1390</code>个包，装好直接<code>reboot</code></li><li>这时候创建普通用户的时候，千万不要创建<code>oracle</code>用户，否则之后会有很多麻烦</li></ul><h3 id="Oracle-Linux-Configuration（important-and-complicated）"><a href="#Oracle-Linux-Configuration（important-and-complicated）" class="headerlink" title="Oracle Linux Configuration（important and complicated）"></a>Oracle Linux Configuration（important and complicated）</h3><p><strong>下面讲的主要是和两个文档不同的地方（依然以<code>link1</code>为主线）：</strong></p><p><strong>1.</strong> <code>selinux</code>需要<code>dsiable</code></p><p><strong>2.</strong> <code>/etc/sysctl.conf</code>参照<code>link2</code>，<code>kernel.shmmax = 536870912</code>（这行参照<code>link2</code>）</p><p><strong>3.</strong> <code>/etc/security/limits.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">oracle soft nproc 16384</div><div class="line">oracle hard nproc 16384</div><div class="line">oracle soft nofile 4096</div><div class="line">oracle hard nofile 65536</div><div class="line">oracle soft stack 10240</div></pre></td></tr></table></figure></p><p><strong>4.</strong> <code>oracle linux 6.5</code>光盘下载包（我是通过<code>yum</code>安装,没有安装的大部分都是系统已经安装了，少部分是没必要安装）</p><ul><li>需要安装：<ul><li><code>ksh</code></li><li><code>libaio-devel.i686</code></li><li><code>libaio-devel.x86_64</code></li><li><code>libaio.i686</code></li><li><code>libstdc++.i686</code></li><li><code>libstdc++-4.4.7-18.el6.i686</code></li><li><code>compat-libstdc++-33.i686</code></li></ul></li><li>不需要安装：<ul><li><code>numactl-devel-2*x86_64*</code></li></ul></li></ul><blockquote><p>由于我本地的是<code>libstdc++-4.4.7-4.el6.x86_64</code>，而安装的是<code>libstdc++-4.4.7-18.el6.i686</code>，版本不匹配会造成<code>yum</code>报错，而这个库作为众多库的依赖还不能删除，所以只能强行升级：<code>yum install libstdc++-4.4.7-18.el6.i686</code>，然后再安装<code>i686</code>文件</p></blockquote><p><strong>5.</strong> 路径、权限与环境变量配置<br>这一步参照: <a href="https://oracle-base.com/articles/linux/automating-database-startup-and-shutdown-on-linux" target="_blank" rel="external">Automating Database Startup and Shutdown on Linux</a></p><p><strong>附上脚本和<code>~/.bash_profile</code>:</strong></p><p><code>start_all.sh</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">. /home/oracle/scripts/setEnv.sh</div><div class="line"></div><div class="line">export ORAENV_ASK=NO</div><div class="line">. oraenv</div><div class="line">export ORAENV_ASK=YES</div><div class="line"></div><div class="line">dbstart $ORACLE_HOME</div></pre></td></tr></table></figure><p><code>stop_all.sh</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">. /home/oracle/scripts/setEnv.sh</div><div class="line"></div><div class="line">export ORAENV_ASK=NO</div><div class="line">. oraenv</div><div class="line">export ORAENV_ASK=YES</div><div class="line"></div><div class="line">dbshut $ORACLE_HOME</div></pre></td></tr></table></figure><p><code>setenv.sh</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># Oracle Settings</div><div class="line">export TMP=/tmp</div><div class="line">export TMPDIR=$TMP</div><div class="line"></div><div class="line">export ORACLE_HOSTNAME=tonydb.localdomain</div><div class="line">export ORACLE_UNQNAME=sampledb</div><div class="line">export ORACLE_BASE=/home/oracle/app/oracle</div><div class="line">export ORACLE_HOME=$ORACLE_BASE/product/11.2.0/dbhome_1</div><div class="line">export ORACLE_SID=sampledb</div><div class="line"></div><div class="line">export PATH=/usr/sbin:/usr/local/bin:$PATH</div><div class="line">export PATH=$ORACLE_HOME/bin:$PATH</div><div class="line"></div><div class="line">export LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/lib</div><div class="line">export CLASSPATH=$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib</div></pre></td></tr></table></figure><p><code>~/.bash_profile</code>最后一行追加： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">. /home/oracle/scripts/setenv.sh</div></pre></td></tr></table></figure><p><strong>6.</strong> 安装<code>FTP</code>并上传<code>zip</code>文件（这一步有需求就执行，我是通过<code>windows</code>传输到<code>linux</code>上）</p><blockquote><p>安装包在页面最上方<code>Resource Link</code>的第二个<code>link</code>，有两个<code>zip</code>包，都是需要的，这就是<code>Oracle Database 11g R2</code>的包，下面就开始安装数据库了，离成功也就不远了</p></blockquote><h3 id="Oracle-Database-11g-R2-Installation"><a href="#Oracle-Database-11g-R2-Installation" class="headerlink" title="Oracle Database 11g R2 Installation"></a>Oracle Database 11g R2 Installation</h3><p><strong>参照：</strong> <a href="https://www.tecmint.com/oracle-database-11g-release-2-installation-in-linux/" target="_blank" rel="external">Oracle Database 11g Release 2 Installation on RHEL/CentOS 6.x/5.x/4.x</a>，以这个<code>link</code>的步骤为主，<code>link1</code>和<code>link2</code>为辅</p><ol><li><p>如果出现<code>next button</code>闪退的现象，进入<code>preference</code>里面调节屏幕分辨率即可</p></li><li><p><code>check</code>时候报错，如果你在上面安装了那么就<code>ignore</code>吧，因为这些包都安装了，只不过版本比它<code>check</code>的高：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">libaio-0.3.105</div><div class="line">compat-libstdc++-33-3.2.3</div><div class="line">libaio-devel-0.3.105</div><div class="line">libgcc-3.4.6</div><div class="line">libstdc++-3.4.6</div><div class="line">unixODBC-2.2.11</div><div class="line">unixODBC-2.2.11</div><div class="line">unixODBC-devel-2.2.11</div><div class="line">unixODBC-devel-2.2.11</div><div class="line">pdksh-5.2.14</div></pre></td></tr></table></figure></li></ol><h3 id="Oracle-Listener-Configuration"><a href="#Oracle-Listener-Configuration" class="headerlink" title="Oracle Listener Configuration"></a>Oracle Listener Configuration</h3><p><strong>参照：</strong> <a href="http://blog.csdn.net/haiross/article/details/13613931" target="_blank" rel="external">Oracle Listener</a></p><blockquote><p>最后<code>test</code>不成功也没关系，先保存设置进行下一步，这边把<code>lsnrcetl</code>起起来就可以了，先不要进入<code>oracle</code>命令行，需要等下一步创建了数据库再进行<code>startup</code>等操作</p></blockquote><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><blockquote><p><code>dbca</code>进入创建向导，填写正确的<code>sid</code>，<code>sid</code>不用填<code>ORCL</code>,就用同步生成的就好，不同的数据库可以拥有不同的<code>sid</code>，按照默认的配置不断地<code>next</code>就好</p></blockquote><ul><li>安装后的默认数据库为orcl，如需创建新的数据库<ul><li>使用辅助工具(Linux UI mode)<blockquote><p>root@oracledb: xhost local:oracledb<br>root@oracledb: su - oracle<br>oracle@oracledb: dbca</p></blockquote></li><li>使用em管理WebUI</li></ul></li><li>创建表空间<ul><li>使用sqlplus<blockquote><p>su - oracle (Windows下此步骤省略)<br>sqlplus / as sysdba<br>create tablespace test_space datafile ‘/opt/oracle/oradata/test_data.dbf’ size 500M</p></blockquote></li><li>使用em管理WebUI</li></ul></li><li>创建用户    <ul><li>使用sqlplus<blockquote><p>su - oracle (Windows下此步骤省略)<br>sqlplus / as sysdba<br>create user test identified by test default tablespace test_space;</p></blockquote></li><li>使用em管理WebUI</li></ul></li><li>授权用户权限<ul><li>使用sqlplus<blockquote><p>su - oracle (Windows下此步骤省略)<br>sqlplus / as sysdba<br>grant connect, resource to test;</p></blockquote></li><li>使用em管理WebUI</li></ul></li><li>授权DBA权限（RMAN需要dba权限来运行）<ul><li>使用sqlplus<blockquote><p>su - oracle (Windows下此步骤省略)<br>sqlplus / as sysdba<br>grant sysdba to test;</p></blockquote></li><li>使用em管理WebUI</li></ul></li><li>数据库启动/关闭<ul><li>切换用户<blockquote><p>root@oracledb: su - oracle</p></blockquote></li><li>启动监听<blockquote><p>lsnrctl start</p></blockquote></li><li>启动实例<blockquote><p>su - oracle (Windows下此步骤省略)<br>sqlplus /nolog<br>conn /as sysdba<br>startup</p></blockquote></li><li>关闭实例<blockquote><p>su - oracle (Windows下此步骤省略)<br>sqlplus /nolog<br>conn /as sysdba<br>shutdown immediate<br>exit</p></blockquote></li><li>关闭监听<blockquote><p>lsnrctl stop</p></blockquote></li></ul></li><li>归档日志模式启动/关闭<ul><li>启动归档日志模式<blockquote><p>sqlplus /as sysdba<br>shutdown immediate<br>startup mount<br>alter database archivelog<br>alter database open</p></blockquote></li><li>关闭归档日志模式<blockquote><p>sqlplus /as sysdba<br>shutdown immediate<br>startup mount<br>alter database noarchivelog<br>alter database open</p></blockquote></li></ul></li></ul><p>作者： Tony</p><p>日期： 2017/06/26</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/oracle-eloqua-campaign-manager.png&quot; alt=&quot;oralce&quot;&gt;&lt;/center&gt;

&lt;p&gt;最近工作中用到了&lt;code&gt;Oracle&lt;/code&gt;作为&lt;code&gt;Intel&lt;/code&gt;测试的数据库，在装&lt;code&gt;Oracle Linux&lt;/code&gt;和&lt;code&gt;Oracle Database 11g R2&lt;/code&gt;折腾了很久，这篇文章就这两点对大家分享一些我安装过程中遇到的问题和注意点，&lt;code&gt;rac&lt;/code&gt;暂时还未配置，稍后找时间补上&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Oracle" scheme="https://tony-yin.github.io/tags/Oracle/"/>
    
      <category term="Oracle Linux" scheme="https://tony-yin.github.io/tags/Oracle-Linux/"/>
    
      <category term="Oracle 11g R2" scheme="https://tony-yin.github.io/tags/Oracle-11g-R2/"/>
    
  </entry>
  
</feed>
