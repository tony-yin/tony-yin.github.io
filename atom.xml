<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tony&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tony-yin.github.io/"/>
  <updated>2018-12-17T04:35:36.549Z</updated>
  <id>https://tony-yin.github.io/</id>
  
  <author>
    <name>Tony</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Centos7系统安装设置gpt分区</title>
    <link href="https://tony-yin.github.io/2018/12/10/Centos7-GPT/"/>
    <id>https://tony-yin.github.io/2018/12/10/Centos7-GPT/</id>
    <published>2018-12-10T05:07:06.000Z</published>
    <updated>2018-12-17T04:35:36.549Z</updated>
    
    <content type="html"><![CDATA[<p>硬盘分区最常见的类型为<code>msdos</code>和<code>gpt</code>，前者表示<code>MBR</code>分区，而后者表示<code>GPT</code>分区。系统安装默认分区方式为<code>MBR</code>，本文讲解如何设置<code>GPT</code>分区方式安装系统，这个看起来没什么技术含量，但是笔者实践过程中还是遇到了不少阻力，并且发现相关文章甚少，故做此记录。</p><center><img src="http://cdn.tony-yin.site/lazycat.png" alt="centos7 gpt"></center><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>MBR</code>分区表(即主引导记录) 最大只支持<code>2TB</code>的分区，最多只支持<code>4</code>个主分区或<code>3</code>个主分区加一个扩展分区，信息只存储在一个区域；<code>GPT</code>（即<code>GUID</code>分区表），是源自<code>EFI</code>标准的一种较新的磁盘分区表结构的标准，是未来磁盘分区的主要形式，与<code>MBR</code>分区方式相比，突破<code>4</code>个主分区限制，每个磁盘最多支持<code>128</code>个分区，支持大于<code>2T</code>的分区，最大卷可达 <code>18EB</code>，信息存储在多个区域，当一部分受损后可修复。</p><p>设置<code>GPT</code>方式有<code>UEFI</code>和<code>BIOS</code>两种方式，<code>UEFI</code>启动是一种新的主板引导项，与传统的<code>Bios</code>方式相比可以提高开机后操作系统的启动速度。如今很多主板已经直接支持<code>UEFI</code>，这种场景下可以直接通过<code>UEFI</code>的方式设置<code>GPT</code>方式，如若主板不支持，那么还得通过传统的<code>Bios</code>方式强制设置<code>GPT</code>方式。</p><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">操作系统： centos7</span><br><span class="line">软raid配置：/分区为raid1，boot分区为raid1</span><br></pre></td></tr></table></figure><h2 id="UEFI方式"><a href="#UEFI方式" class="headerlink" title="UEFI方式"></a>UEFI方式</h2><h3 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h3><p>进入引导页面，如果存在<code>UEFI</code>安装方式，则选择<code>UEFI</code>方式安装</p><center><img src="https://raw.githubusercontent.com/tony-yin/Picture-Lib/master/lib/load_uefi.png" alt="load uefi"></center><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>配置软<code>raid</code>阶段，<code>UEFI</code>安装方式的必须存在一个<code>UEFI</code>分区，分区方式为 <code>raid1</code>，<code>/boot/efi</code>分区必须也设置为<code>raid1</code>，否则会有报错。</p><center><img src="https://raw.githubusercontent.com/tony-yin/Picture-Lib/master/lib/uefi_partition.png" alt="uefi partition"></center><h2 id="BIOS-Boot方式"><a href="#BIOS-Boot方式" class="headerlink" title="BIOS Boot方式"></a>BIOS Boot方式</h2><h3 id="引导-1"><a href="#引导-1" class="headerlink" title="引导"></a>引导</h3><p>进入引导页面，如果不存在<code>UEFI</code>安装方式，如果存在则选择默认的<code>BIOS Boot</code>方式安装</p><center><img src="https://raw.githubusercontent.com/tony-yin/Picture-Lib/master/lib/load_biosboot.png" alt="load bios boot"></center><p>进入系统安装页面，强制设置GPT方式安装：</p><center><img src="https://raw.githubusercontent.com/tony-yin/Picture-Lib/master/lib/centos7_install.png" alt="centos7 install"></center><p>点击<code>tab</code>键，在末尾输入<code>inst.gpt</code></p><center><img src="https://raw.githubusercontent.com/tony-yin/Picture-Lib/master/lib/centos7_inst_gpt.png" alt="centos7 inst gpt"></center><h3 id="分区-1"><a href="#分区-1" class="headerlink" title="分区"></a>分区</h3><p>配置软raid阶段，<code>BIOS Boot</code>安装方式的必须存在一个<code>bios</code>分区，分区方式设置为<code>raid1</code>会报错如下：</p><center><img src="https://raw.githubusercontent.com/tony-yin/Picture-Lib/master/lib/biosboot_partition_error.png" alt="bios boot raid1 partition error"></center><p>然后系统也不能继续安装下去：</p><center><img src="https://raw.githubusercontent.com/tony-yin/Picture-Lib/master/lib/biosboot_cannot_install.png" alt="Can not continue to install"></center><p>需要将分区方式改成<code>standard</code>：</p><center><img src="https://raw.githubusercontent.com/tony-yin/Picture-Lib/master/lib/biosboot_standard_partition.png" alt="BIOS Boot Standard partition"></center><p>可以继续安装系统，但是过程中会出现<code>boot loader install failed</code>的报错，直接忽略即可</p><center><img src="https://raw.githubusercontent.com/tony-yin/Picture-Lib/master/lib/boot_loader_install_error.png" alt="Boot loader install failed"></center><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体看来<code>GPT</code>分区俨然成为<code>MBR</code>的替代者，<code>fdisk</code>只能操作<code>MBR</code>方式的磁盘，而<code>parted</code>工具能够操作<code>GPT</code>或<code>MBR</code>中任意方式的磁盘。</p><h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ol><li><a href="https://my.oschina.net/guol/blog/61424" target="_blank" rel="noopener">使用parted划分GPT分区</a></li><li><a href="https://www.xncoding.com/2017/03/14/ceph/disk-partition.html" target="_blank" rel="noopener">Linux磁盘分区总结</a></li><li><a href="http://blog.51cto.com/isenknows/2053969" target="_blank" rel="noopener">CentOS 7 安装强制使用GPT分区</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;硬盘分区最常见的类型为&lt;code&gt;msdos&lt;/code&gt;和&lt;code&gt;gpt&lt;/code&gt;，前者表示&lt;code&gt;MBR&lt;/code&gt;分区，而后者表示&lt;code&gt;GPT&lt;/code&gt;分区。系统安装默认分区方式为&lt;code&gt;MBR&lt;/code&gt;，本文讲解如何设置&lt;code&gt;GPT&lt;/code&gt;分区方式安装系统，这个看起来没什么技术含量，但是笔者实践过程中还是遇到了不少阻力，并且发现相关文章甚少，故做此记录。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/lazycat.png&quot; alt=&quot;centos7 gpt&quot;&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Disk" scheme="https://tony-yin.github.io/tags/Disk/"/>
    
      <category term="Partition" scheme="https://tony-yin.github.io/tags/Partition/"/>
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ES告警详解之Sentinl</title>
    <link href="https://tony-yin.github.io/2018/12/01/ES-Sentinl/"/>
    <id>https://tony-yin.github.io/2018/12/01/ES-Sentinl/</id>
    <published>2018-12-01T05:07:06.000Z</published>
    <updated>2018-12-17T04:26:43.105Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/sentinl.png" alt="sentinl"></center><p>上一篇文章详细讲解了<code>ElastAlert</code>这款告警组件，今天我们聊聊另一个<code>ES</code>开源告警组件<code>Sentinl</code>。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>sentinl</code>是基于<code>javascript</code>开发的<code>kibana</code>插件，拥有告警和报表两大功能，分别作为<code>X-Pack</code> 的<code>Alert</code>和<code>Reporting</code>的替代品，即插即用，它将前端<code>UI</code>、<code>webserver</code>和告警逻辑代码都集成在一个项目中，这一点要比上篇文章提到同为<code>kibana</code>插件的<code>elastalert-kibana-plugin</code>要强大不少，并且可以说<code>sentinl</code>的<code>UI</code>无论是美观程度还是操作友好程度都完全秒杀<code>elastalert-kibana-plugin</code>。说了这么多是不是<code>sentinl</code>就很完美呢？请看下文慢慢讲述。</p><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch: 6.4.2</span><br><span class="line">kibana: 6.4.2</span><br><span class="line">sentinl: 6.4.2</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装环节很简单，只需要进行通用的<code>kibana</code>安装插件的方式安装即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /usr/share/kibana/bin/kibana-plugin install https://github.com/sirensolutions/sentinl/releases/download/tag-6.4.2-0/sentinl-v6.4.2.zip</span></span><br></pre></td></tr></table></figure><p>安装完成以后，重启<code>kibana</code>服务即可在<code>kibana</code>页面上看到<code>sentinl</code>。</p><h2 id="Alert配置"><a href="#Alert配置" class="headerlink" title="Alert配置"></a>Alert配置</h2><p>告警配置环节其实也很简单，因为<code>sentinl</code>大部分配置都是通过<code>UI</code>创建告警的时候配置的，需要手动配置的地方并不多，只有告警方式相关的。</p><p>和上节一样，众多告警方式我们就选择最普遍的邮件告警进行讲解</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/kibana/kibana.yml</span></span><br></pre></td></tr></table></figure><p>在文件最下方添加以下配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sentinl:</span><br><span class="line">  settings:</span><br><span class="line">    email:</span><br><span class="line">      active: true          // 开启email方式</span><br><span class="line">      host: 'smtp.163.com'  // smtp server</span><br><span class="line">      user: 'xxx@163.com'   // 发送邮箱账号</span><br><span class="line">      password: 'xxx'       //发送邮箱客户端授权码或密码</span><br><span class="line">      timeout: 10000        // 连接smtp server的最大timeout</span><br></pre></td></tr></table></figure><p>配置完成需要重启<code>kibana</code>服务才可以生效。这里需要注意的是<code>host</code>、<code>user</code>和<code>password</code>三个选项，<code>host</code>表示<code>smtp</code>主机地址，<code>user</code>表示发送邮箱的账号，<code>password</code>表示客户端授权码，如果没有授权码才是密码。</p><p>如果这样配置了，还是无法发送邮件成功，可以通过查看<code>kibana</code>的日志定位原因，大部分情况都是由于<code>smtp server</code>连接失败导致，可以通过本地邮件客户端进行测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mailx -S smtp=&lt;smtp-server-address&gt; -r &lt;from-address&gt; -s &lt;subject&gt; -v &lt;to-address&gt; &lt; body.txt</span></span><br></pre></td></tr></table></figure><h2 id="Report配置"><a href="#Report配置" class="headerlink" title="Report配置"></a>Report配置</h2><p><code>sentinl</code>除了提供告警功能，还提供了一个类似<code>X-Pack Reporting</code>的报表功能。</p><p>同样这个功能需要开启和配置，不得不说这个功能和相关文档还是存在着不少的问题，比如尽管文档声称默认<code>engine</code>是<code>horseman</code>，但是现在默认的是<code>puppeteer</code>。 </p><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>官方文档提供的<a href="https://sentinl.readthedocs.io/en/latest/Config-Example/" target="_blank" rel="noopener">配置例子</a>是这样的:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sentinl:</span><br><span class="line">  settings:</span><br><span class="line">    report:</span><br><span class="line">      active: true</span><br><span class="line">      executable_path: '/usr/bin/chromium' # path to Chrome v59+ or Chromium v59+</span><br></pre></td></tr></table></figure><p><code>chromium</code>环境中不存在的话，手动下载后同步配置中对应的路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sentinl:</span><br><span class="line">  settings:</span><br><span class="line">    active: true</span><br><span class="line">      engine: 'puppeteer'</span><br><span class="line">      executable_path: '/usr/bin/chromium-browser'</span><br></pre></td></tr></table></figure><p>运用上述配置会有以下报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Option &quot;report.executable_path&quot; was deprecated. The path is handled automatically!</span><br></pre></td></tr></table></figure><p>报错中显示<code>executable_path</code>这个选项已经被弃用，这个路径会被自动解析，一脸懵逼，文档中丝毫没提及。。。</p><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p>当时笔者也很奇怪，如何自动解析？如何知晓<code>chromium</code>的路径呢？这个下面再讲，然后就先注释掉该选项配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sentinl:</span><br><span class="line">  settings:</span><br><span class="line">    active: true</span><br><span class="line">      engine: &apos;puppeteer&apos;</span><br><span class="line">      # executable_path: &apos;/usr/bin/chromium-browser&apos;</span><br></pre></td></tr></table></figure><p>页面换了个报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActionError: report action: execute: run &apos;puppeteer&apos; report: puppeteer work</span><br></pre></td></tr></table></figure><p>如下图所示：</p><center><img src="http://cdn.tony-yin.site/puppeteer_execute.png" alt="error1"></center><p>这个时候笔者就通过关键字谷歌搜索，发现<code>sentinl</code>里面有一个<a href="https://github.com/sirensolutions/sentinl/issues/535" target="_blank" rel="noopener">issue 535</a>，里面提到查看日志里面是否存在类似下面信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">server    log   [07:52:27.332] [info][Sentinl][init] Chrome bin found at: /media/trex/safe1/Development/siren/kibi-internal/plugins/sentinl/node_modules/puppeteer/.local-chromium/linux-564778/chrome-linux/chrome</span><br><span class="line">...</span><br><span class="line">server    log   [07:52:27.428] [info][Sentinl][init] PhantomJS bin found at: /media/trex/safe1/Development/siren/kibi-internal/plugins/sentinl/phantomjs/phantomjs-2.1.1-linux-x86_64/bin/phantomjs</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>笔者去日志里面查了查，还真发现类似信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;type&quot;:&quot;log&quot;,&quot;@timestamp&quot;:&quot;2018-11-23T10:27:44Z&quot;,&quot;tags&quot;:[&quot;error&quot;,&quot;Sentinl&quot;,&quot;init&quot;],&quot;pid&quot;:8219,&quot;message&quot;:&quot;setting puppeteer report engine: Error: user has no permissions to make file executable: /usr/share/kibana/plugins/sentinl/node_modules/puppeteer/.local-chromium/linux-564778/chrome-linux/chrome&quot;&#125;</span><br></pre></td></tr></table></figure><p>如下图所示</p><p><img src="http://cdn.tony-yin.site/puppeteer_permission.PNG" alt="puppeteer permission"></p><p>这就是为什么可以自动解析<code>chrome</code>路径了，因为<code>sentinl</code>内置了<code>chrome</code>，所以<code>sentinl</code>默认解析的是其内置<code>chrome</code>路径而非其他第三方下载的，所以文档中的<code>/usr/bin/chromium</code>也有点误导的感觉。</p><p>这一段日志提示<code>chrome</code>没有执行权限，于是查看权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ll /usr/share/kibana/plugins/sentinl/node_modules/puppeteer/.<span class="built_in">local</span>-chromium/linux-564778/chrome-linux/chrome</span></span><br><span class="line">-rw-r--r-- 1 root root 206915904 Nov 22 10:16 /usr/share/kibana/plugins/sentinl/node_modules/puppeteer/.local-chromium/linux-564778/chrome-linux/chrome</span><br></pre></td></tr></table></figure><p>果然是不存在执行权限，然后手动添加权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x /usr/share/kibana/plugins/sentinl/node_modules/puppeteer/.local-chromium/linux-564778/chrome-linux/chrome</span><br></pre></td></tr></table></figure><h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><p>更改之后这个报错没有了，但是又有了新的报错（真是醉了）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to load url</span><br></pre></td></tr></table></figure><p>如下图所示</p><p><img src="http://cdn.tony-yin.site/load_url_error.PNG" alt="load url error"></p><p>然后继续谷歌大法，在 <a href="https://github.com/sirensolutions/sentinl/issues/495" target="_blank" rel="noopener">issue 495</a> 中看到了相关信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for the error &quot;Failed to load url&quot; I just replaced the action&apos;s url with a valide link from a chosen dashboard</span><br></pre></td></tr></table></figure><p>于是返回告警配置界面，发现有一个<code>url</code>选项，笔者也没填（因为当时也不知道这个<code>url</code>是干嘛的）。结合上面这哥们描述的，该<code>url</code>应该是<code>kibana</code>上面<code>dashbord</code>模块中某个已经存在的<code>dashbord</code>的链接，然后根据该<code>dashbord</code>生成报表。</p><p>于是手动创建了一个<code>dashbord</code>，然后将该<code>dashbord</code>的<code>url</code>更新至配置中的<code>url</code>。</p><h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h3><p>这次没报错了，<code>report</code>也发送到了指定邮箱，但是<code>report</code>是空的，这是因为新创建的<code>dashbord</code>并没有导入任何可视化图表，所以将<code>url</code>切换成了已经存在可视化图表的<code>dashbord</code>的<code>url</code>，这下可以发现发送的<code>report</code>是存在图表的。</p><p>结合之前<code>monitoring</code>的了解，突然想到这个<code>url</code>可能不是<code>dashbord</code>直接显示的<code>url</code>，而应该是通过<code>share</code>功能提供的<code>link</code>。</p><h3 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h3><p>上面<code>engine</code>选择<code>puppeteer</code>，笔者又尝试将<code>engine</code>切换成<code>horseman</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sentinl:</span><br><span class="line">  settings:</span><br><span class="line">    report:</span><br><span class="line">      active: true</span><br><span class="line">      engine: &apos;horseman&apos;</span><br></pre></td></tr></table></figure><p>换了<code>engine</code>，依然报错不停：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActionError: report action: execute: run &apos;horseman&apos; report: spawn EACCES</span><br></pre></td></tr></table></figure><p>如下图所示</p><p><img src="http://cdn.tony-yin.site/eacces_error.PNG" alt="eacces error"></p><p>其实这个问题，上文提到的 <a href="https://github.com/sirensolutions/sentinl/issues/535" target="_blank" rel="noopener">issue 535</a> 中也给出了答案，<code>horseman engine</code>依赖的是<code>phantomjs</code>库，<code>puppeteer</code>依赖的是<code>chrome</code>库，问题<code>2</code>是<code>chrome</code>缺少可执行权限，而<code>spawn EACCES</code>这样的关键字则表示<code>phantomjs</code>库无法使用，根据上文<code>chrome</code>的路径笔者找到<code>phantomjs</code>的路径并检查权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ll /usr/share/kibana/plugins/sentinl/node_modules/phantomjs-prebuilt/bin/phantomjs </span></span><br><span class="line">-rw-r--r-- 1 root root 1050 Nov 22 10:15 /usr/share/kibana/plugins/sentinl/node_modules/phantomjs-prebuilt/bin/phantomjs</span><br></pre></td></tr></table></figure><p>发现<code>phantomjs</code>也缺少可执行权限，添加权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x /usr/share/kibana/plugins/sentinl/node_modules/phantomjs-prebuilt/bin/phantomjs</span></span><br></pre></td></tr></table></figure><p>但是<code>UI</code>上还是有相同的报错，只能继续查看日志，发现报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"type":"log","@timestamp":"2018-11-22T02:27:28Z","tags":["info","Sentinl","init"],"pid":21134,"message":"PhantomJS bin found at: /usr/share/kibana/plugins/sentinl/phantomjs/phantomjs-2.1.1-linux-x86_64/bin/phantomjs"&#125;</span><br></pre></td></tr></table></figure><p>原来<code>sentinl</code>解析库不是上面<code>node_modules</code>目录的那个路径，而是在<code>phantomjs</code>这个目录下，查看权限情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -lh /usr/share/kibana/plugins/sentinl/phantomjs/phantomjs-2.1.1-linux-x86_64/bin/phantomjs</span></span><br><span class="line">-rw-r--r-- 1 root root 65M Nov 22 10:15 /usr/share/kibana/plugins/sentinl/phantomjs/phantomjs-2.1.1-linux-x86_64/bin/phantomjs</span><br></pre></td></tr></table></figure><p>果然还是缺少执行权限，添加权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x /usr/share/kibana/plugins/sentinl/phantomjs/phantomjs-2.1.1-linux-x86_64/bin/phantomjs</span></span><br></pre></td></tr></table></figure><p>终于不报错了。。。</p><h3 id="官方回应"><a href="#官方回应" class="headerlink" title="官方回应"></a>官方回应</h3><p>这一系列问题，笔者也给<code>sentinl</code>提了 <a href="https://github.com/sirensolutions/sentinl/issues/619" target="_blank" rel="noopener">issue</a>，作者也表示了这个权限问题之后会通过脚本等方式自动处理，然后表示<a href="https://sentinl.readthedocs.io/en/docs/Config-Example/" target="_blank" rel="noopener">这个文档</a>没有同步更新，可以看<a href="https://sentinl.readthedocs.io/en/latest/" target="_blank" rel="noopener">最新同步文档</a>。</p><h2 id="Sentinl-amp-ElastAlert"><a href="#Sentinl-amp-ElastAlert" class="headerlink" title="Sentinl &amp; ElastAlert"></a>Sentinl &amp; ElastAlert</h2><p>与<code>elastalert</code>相比较，就告警功能而言的话，如果要求不高，推荐使用<code>sentinl</code>，因为安装容易并且配置简单；但如果有复杂的告警场景或独立的告警方式，那推荐选择<code>elastalert</code>。</p><p>整理一个对比表格，想必这样看起来更直观：</p><table><thead><tr><th style="text-align:center">比较</th><th style="text-align:center">Sentinl</th><th style="text-align:center">ElastAlert</th></tr></thead><tbody><tr><td style="text-align:center">安装</td><td style="text-align:center">简单</td><td style="text-align:center">一般复杂</td></tr><tr><td style="text-align:center">配置</td><td style="text-align:center">简单</td><td style="text-align:center">一般复杂</td></tr><tr><td style="text-align:center">UI</td><td style="text-align:center">简单美观</td><td style="text-align:center">不友好</td></tr><tr><td style="text-align:center">告警规则数量</td><td style="text-align:center">1个</td><td style="text-align:center">11个</td></tr><tr><td style="text-align:center">告警方式数量</td><td style="text-align:center">6个</td><td style="text-align:center">11个</td></tr><tr><td style="text-align:center">告警方式隔离</td><td style="text-align:center">不独立</td><td style="text-align:center">独立</td></tr><tr><td style="text-align:center">开发语言</td><td style="text-align:center">javascript</td><td style="text-align:center">python</td></tr><tr><td style="text-align:center">后端配置透明度</td><td style="text-align:center">不透明</td><td style="text-align:center">透明</td></tr><tr><td style="text-align:center">成熟度</td><td style="text-align:center">700+ star</td><td style="text-align:center">5000+ start</td></tr><tr><td style="text-align:center">开发者数量</td><td style="text-align:center">28</td><td style="text-align:center">160</td></tr><tr><td style="text-align:center">commit数</td><td style="text-align:center">1500+</td><td style="text-align:center">1800+</td></tr><tr><td style="text-align:center">开发周期</td><td style="text-align:center">2016/08</td><td style="text-align:center">2015/11</td></tr></tbody></table><p>根据上述表格，我们可以看出各有各的优势，<code>sentinl</code>更加偏向于集成进<code>kibana</code>的一种页面展示插件，而<code>elastalert</code>则是更偏向与后端告警功能的打磨。单从告警功能来看，<code>elastalert</code>看起来更强大一些，但是<code>sentinl</code>也有它的优势，<code>UI</code>非常地棒，其次还支持<code>report</code>功能，虽然现在还存在很多问题，但相信之后肯定越来越好，而且目前通过开发者数量和代码提交量可以看出有后来居上的感觉。就笔者而言，喜爱<code>sentinl</code>的<code>UI</code>,喜爱<code>elastalert</code>的告警<code>rule</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>sentinl</code>作为一个开源组件，提供了<code>X-Pack</code>两款收费组件：<code>Alert</code>和<code>Reporting</code>的替代功能，着实不错，告警功能配置简单、页面美观、操作友好；但是<code>Report</code>功能就显得问题较多，并且生成的报表也有很多瑕疵。希望之后可以不断优化和强大吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/sentinl.png&quot; alt=&quot;sentinl&quot;&gt;&lt;/center&gt;

&lt;p&gt;上一篇文章详细讲解了&lt;code&gt;ElastAlert&lt;/code&gt;这款告警组件，今天我们聊聊另一个&lt;code&gt;ES&lt;/code&gt;开源告警组件&lt;code&gt;Sentinl&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Elasticsearch" scheme="https://tony-yin.github.io/tags/Elasticsearch/"/>
    
      <category term="Monitor" scheme="https://tony-yin.github.io/tags/Monitor/"/>
    
  </entry>
  
  <entry>
    <title>ES告警详解之ElastAlert</title>
    <link href="https://tony-yin.github.io/2018/11/15/ES-ElastAlert/"/>
    <id>https://tony-yin.github.io/2018/11/15/ES-ElastAlert/</id>
    <published>2018-11-15T05:07:06.000Z</published>
    <updated>2018-12-17T04:41:01.407Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/alert.png" alt="alert"></center><p>今天聊聊<code>ES</code>的告警，<code>X-Pack</code>提供了报警组件<code>Alert</code>，但是这个功能是需要付费，在寻求其他方案的时候，发现了<code>ElastAlert</code>，可以说这是一款为<code>ES</code>量身定制的告警组件，能够完美替代<code>Alert</code>提供的所有功能。今天就<code>ElastAlert</code>强大的告警功能和笔者实践过程中遇到的一些问题进行分享。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>ElastAlert</code>是基于<code>python2</code>开发的一个告警框架，它主要有以下特点：</p><ul><li>成熟，<a href="https://github.com/Yelp/elastalert" target="_blank" rel="noopener">Github</a>上已有<code>5k+ star</code></li><li>开源，<a href="https://elastalert.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">文档</a>很全面</li><li>开发语言为<code>python</code>，研究和扩展源码较为容易</li><li>告警规则丰富</li><li>告警方式丰富</li><li><code>SMTP</code>以每个告警为单位，相对独立</li></ul><p>网上已经有了相当多的基础介绍文章，但是笔者发现大多数文章的内容都是过时的，甚至官方文档经常还会展示一些弃用配置；还有虎头蛇尾的通病，往往不全面，经常对一些关键性的细节不提及；再者一些地方解释地不够清晰，导致歧义。笔者在搭建和测试过程中同时借鉴多篇文章，然后在反复尝试中最后才成功，这其中失败了很多次，浪费了很多时间，所以这篇文章借鉴了上面提到的种种问题，保证本文的全面性、细节性以及具体性。</p><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Centos7</span><br><span class="line">Elasticsearch 6.4.2</span><br><span class="line">Kibana 6.4.2</span><br></pre></td></tr></table></figure><h2 id="ElastAlert安装"><a href="#ElastAlert安装" class="headerlink" title="ElastAlert安装"></a>ElastAlert安装</h2><p>安装较为简单，但为了不虎头蛇尾还是做一个完整的步骤介绍：</p><h3 id="克隆代码"><a href="#克隆代码" class="headerlink" title="克隆代码"></a>克隆代码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git clone https://github.com/Yelp/elastalert.git</span><br></pre></td></tr></table></figure><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd elastalert</span><br><span class="line"><span class="meta">$</span> python setup.py install</span><br><span class="line"><span class="meta">$</span> pip install -r requirements.txt</span><br></pre></td></tr></table></figure><h3 id="整体配置"><a href="#整体配置" class="headerlink" title="整体配置"></a>整体配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cp config.yaml.example config.yaml    // 根据模板生成配置文件</span><br><span class="line"><span class="meta">$</span> vim config.yaml   // 修改配置</span><br></pre></td></tr></table></figure><p>主要修改几个必需的选项，比如<code>rules_folder</code>、<code>es_host</code>、<code>es_port</code>等，那些非必需没有特殊需求就不用更改了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 用来加载rule的目录，默认是example_rules</span><br><span class="line">rules_folder: example_rules</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 用来设置定时向elasticsearch发送请求</span><br><span class="line">run_every:</span><br><span class="line">  minutes: 1</span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span> 用来设置请求里时间字段的范围</span><br><span class="line">buffer_time:</span><br><span class="line">  minutes: 15</span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span> elasticsearch的host地址</span><br><span class="line">es_host: 192.168.232.191</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> elasticsearch 对应的端口号</span><br><span class="line">es_port: 9200</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 可选的，es url前缀</span><br><span class="line"><span class="meta">#</span>es_url_prefix：elasticsearch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 可选的，查询es的方式，默认是GET</span><br><span class="line"><span class="meta">#</span>es_send_get_body_as：GET</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 可选的，选择是否用SSL连接es，true或者false</span><br><span class="line"><span class="meta">#</span>use_ssl: True</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>可选的，是否验证TLS证书，设置为true或者false，默认为- true</span><br><span class="line"><span class="meta">#</span>verify_certs: True</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> es认证的username和password</span><br><span class="line"><span class="meta">#</span>es_username: someusername</span><br><span class="line"><span class="meta">#</span>es_password: somepassword</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> elastalert产生的日志在elasticsearch中的创建的索引</span><br><span class="line">writeback_index: elastalert_status</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 失败重试的时间限制</span><br><span class="line">alert_time_limit:</span><br><span class="line">  days: 2</span><br></pre></td></tr></table></figure><p>详情请参考文档：<a href="http://elastalert.readthedocs.io/en/latest/ruletypes.html#rule-configuration-cheat-sheet" target="_blank" rel="noopener">http://elastalert.readthedocs.io/en/latest/ruletypes.html#rule-configuration-cheat-sheet</a></p><h3 id="创建ElastAlert索引"><a href="#创建ElastAlert索引" class="headerlink" title="创建ElastAlert索引"></a>创建ElastAlert索引</h3><p>可以在<code>/usr/bin/</code>目录下看到以下四个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ll /usr/bin/elastalert*</span><br><span class="line">-rwxr-xr-x 1 root root 399 Nov 20 16:39 /usr/bin/elastalert</span><br><span class="line">-rwxr-xr-x 1 root root 425 Nov 20 16:39 /usr/bin/elastalert-create-index</span><br><span class="line">-rwxr-xr-x 1 root root 433 Nov 20 16:39 /usr/bin/elastalert-rule-from-kibana</span><br><span class="line">-rwxr-xr-x 1 root root 419 Nov 20 16:39 /usr/bin/elastalert-test-rule</span><br></pre></td></tr></table></figure><ul><li><code>elastalert-create-index</code>会创建一个索引，<code>ElastAlert</code> 会把执行记录存放到这个索引中，默认情况下，索引名叫 <code>elastalert_status</code>。其中有<code>4</code>个<code>_type</code>，都有自己的<code>@timestamp</code> 字段，所以同样也可以用<code>kibana</code>来查看这个索引的日志记录情况。</li><li><code>elastalert-rule-from-kibana</code>从<code>Kibana3</code>已保存的仪表盘中读取<code>Filtering</code> 设置，帮助生成<code>config.yaml</code>里的配置。不过注意，它只会读取 <code>filtering</code>，不包括<code>queries</code>。</li><li><code>elastalert-test-rule</code>测试自定义配置中的<code>rule</code>设置。</li></ul><p>执行<code>elastalert-create-index</code>命令在<code>ES</code>创建索引，这不是必须的步骤，但是强烈建议创建。因为对于审计和测试很有用，并且重启<code>ES</code>不影响计数和发送<code>alert</code>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> elastalert-create-index</span><br></pre></td></tr></table></figure><p>具体参见文档： <a href="http://elastalert.readthedocs.io/en/latest/running_elastalert.html#setting-up-elasticsearch" target="_blank" rel="noopener">setting-up-elasticsearch</a></p><h2 id="Rule配置"><a href="#Rule配置" class="headerlink" title="Rule配置"></a>Rule配置</h2><p><code>rule</code>配置算是<code>ElastAlert</code>最核心的功能了，支持<code>11</code>种告警规则，就不一一介绍了，选用一个最为普遍使用的告警规则<code>frequency</code>，告警方式也选用最普遍的<code>email</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># Alert when the rate of events exceeds a threshold</span><br><span class="line"></span><br><span class="line"># (Optional)</span><br><span class="line"># Elasticsearch host</span><br><span class="line">es_host: 192.168.232.191</span><br><span class="line"></span><br><span class="line"># (Optional)</span><br><span class="line"># Elasticsearch port</span><br><span class="line">es_port: 9200</span><br><span class="line"></span><br><span class="line"># (OptionaL) Connect with SSL to Elasticsearch</span><br><span class="line">#use_ssl: True</span><br><span class="line"></span><br><span class="line"># (Optional) basic-auth username and password for Elasticsearch</span><br><span class="line">#es_username: someusername</span><br><span class="line">#es_password: somepassword</span><br><span class="line"></span><br><span class="line"># (Required)</span><br><span class="line"># Rule name, must be unique</span><br><span class="line">name: Example frequency rule</span><br><span class="line"></span><br><span class="line"># (Required)</span><br><span class="line"># Type of alert.</span><br><span class="line"># the frequency rule type alerts when num_events events occur with timeframe time</span><br><span class="line">type: frequency</span><br><span class="line"></span><br><span class="line"># (Required)</span><br><span class="line"># Index to search, wildcard supported</span><br><span class="line">index: metricbeat-*</span><br><span class="line"></span><br><span class="line"># (Required, frequency specific)</span><br><span class="line"># Alert when this many documents matching the query occur within a timeframe</span><br><span class="line">num_events: 5</span><br><span class="line"></span><br><span class="line"># (Required, frequency specific)</span><br><span class="line"># num_events must occur within this amount of time to trigger an alert</span><br><span class="line">timeframe:</span><br><span class="line">  hours: 4</span><br><span class="line"></span><br><span class="line"># (Required)</span><br><span class="line"># A list of Elasticsearch filters used for find events</span><br><span class="line"># These filters are joined with AND and nested in a filtered query</span><br><span class="line"># For more info: http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl.html</span><br><span class="line">filter:</span><br><span class="line">- query_string:</span><br><span class="line">    query: &quot;system.process.cpu.total.pct: &gt;10%&quot;     // field支持嵌套</span><br><span class="line"></span><br><span class="line">smtp_host: smtp.163.com</span><br><span class="line">smtp_port: 25</span><br><span class="line">smtp_auth_file: /opt/elastalert/smtp_auth.yaml</span><br><span class="line">#回复给那个邮箱</span><br><span class="line">email_reply_to: xxx@163.com</span><br><span class="line">##从哪个邮箱发送</span><br><span class="line">from_addr: xxx@163.com</span><br><span class="line"># (Required)</span><br><span class="line"># The alert is use when a match is found</span><br><span class="line">alert:</span><br><span class="line">- &quot;email&quot;</span><br><span class="line"></span><br><span class="line"># (required, email specific)</span><br><span class="line"># a list of email addresses to send alerts to</span><br><span class="line">email:</span><br><span class="line">- &quot;yyy@qq.com&quot;</span><br></pre></td></tr></table></figure><p>上述配置表示选择<code>metricbeat</code>作为告警索引，在<code>4</code>小时内将匹配过滤条件，当<code>CPU</code>使用百分比的值为<code>10%</code>超过<code>5</code>次后，即满足告警条件，然后发送邮件。</p><h2 id="邮件配置"><a href="#邮件配置" class="headerlink" title="邮件配置"></a>邮件配置</h2><p>上述配置中已经展示了一部分邮件配置，主要有<code>smtp host</code>、<code>smtp port</code>、<code>from addr</code>和<code>to_addr</code>等。这里笔者选择一个网易<code>163</code>的邮箱作为发送邮箱，一个<code>QQ</code>邮箱作为接收邮件进行测试，所以<code>smpt host</code>应该为<code>smtp.163.com</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">smtp_host: smtp.163.com</span><br><span class="line">smtp_port: 25</span><br><span class="line">smtp_auth_file: /opt/elastalert/smtp_auth.yaml</span><br><span class="line"><span class="meta">#</span>回复给那个邮箱</span><br><span class="line">email_reply_to: xxx@163.com</span><br><span class="line"><span class="meta">#</span>#从哪个邮箱发送</span><br><span class="line">from_addr: xxx@163.com</span><br><span class="line"><span class="meta">#</span> (Required)</span><br><span class="line"><span class="meta">#</span> The alert is use when a match is found</span><br><span class="line">alert:</span><br><span class="line">- "email"</span><br><span class="line"><span class="meta">#</span> (required, email specific)</span><br><span class="line"><span class="meta">#</span> a list of email addresses to send alerts to</span><br><span class="line">email:</span><br><span class="line">- "yyy@qq.com"</span><br></pre></td></tr></table></figure><p>还有一个<code>smtp_auth.yaml</code>文件，这个里面记录了发送邮箱的账号和密码，<code>163</code>邮箱有授权码机制，所以密码处应该填写授权码（没有的话则需要开启）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>发送邮件的邮箱</span><br><span class="line">user: xxx@163.com</span><br><span class="line"><span class="meta">#</span>#不是邮箱密码，是设置的POP3密码</span><br><span class="line">password: xxx</span><br></pre></td></tr></table></figure><h2 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h2><h3 id="避免重复告警"><a href="#避免重复告警" class="headerlink" title="避免重复告警"></a>避免重复告警</h3><p>避免一定时间段中重复告警，可以配置<code>realert</code>和<code>exponential_realert</code>这两个选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 5分钟内相同的报警不会重复发送</span><br><span class="line">realert:</span><br><span class="line">  minutes: 5</span><br><span class="line"></span><br><span class="line"># 指数级扩大 realert 时间，中间如果有报警，</span><br><span class="line"># 则按照5-&gt;10-&gt;20-&gt;40-&gt;60不断增大报警时间到制定的最大时间，</span><br><span class="line"># 如果之后报警减少，则会慢慢恢复原始realert时间</span><br><span class="line">exponential_realert:</span><br><span class="line">  hours: 1</span><br></pre></td></tr></table></figure><h3 id="聚合相同告警"><a href="#聚合相同告警" class="headerlink" title="聚合相同告警"></a>聚合相同告警</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 根据报警的内，将相同的报警安装 name 来聚合</span><br><span class="line">aggregation_key: name</span><br><span class="line"></span><br><span class="line"># 聚合报警的内容，只展示 name 与 message</span><br><span class="line">summary_table_fields:</span><br><span class="line">  - name</span><br><span class="line">  - message</span><br></pre></td></tr></table></figure><h3 id="告警内容格式化"><a href="#告警内容格式化" class="headerlink" title="告警内容格式化"></a>告警内容格式化</h3><p>可以自定义告警内容，内部是使用<code>Python</code>的<code>format</code>来实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">alert_subject: &quot;Error &#123;&#125; @&#123;&#125;&quot;</span><br><span class="line">alert_subject_args:</span><br><span class="line">  - name</span><br><span class="line">  - &quot;@timestamp&quot;</span><br><span class="line"></span><br><span class="line">alert_text_type: alert_text_only</span><br><span class="line">alert_text: |</span><br><span class="line">  ### Error frequency exceeds</span><br><span class="line">  &gt; Name: &#123;&#125;</span><br><span class="line">  &gt; Message: &#123;&#125;</span><br><span class="line">  &gt; Host: &#123;&#125; (&#123;&#125;)</span><br><span class="line">alert_text_args:</span><br><span class="line">  - name</span><br><span class="line">  - message</span><br><span class="line">  - hostname</span><br><span class="line">  - host</span><br></pre></td></tr></table></figure><p>当然还有更多高级配置，详情请参考文档。</p><h2 id="测试Rule"><a href="#测试Rule" class="headerlink" title="测试Rule"></a>测试Rule</h2><p>可以在运行<code>rule</code>之前先通过<code>elastalert-test-rule</code>命令来测试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ elastalert-test-rule ~/elastalert/example_rules/example_frequency.yaml</span><br></pre></td></tr></table></figure><p>详情参考文档：<a href="http://elastalert.readthedocs.io/en/latest/running_elastalert.html#testing-your-rule" target="_blank" rel="noopener">http://elastalert.readthedocs.io/en/latest/running_elastalert.html#testing-your-rule</a></p><h2 id="运行Rule"><a href="#运行Rule" class="headerlink" title="运行Rule"></a>运行Rule</h2><p>启动<code>elastalert</code>服务，监听<code>es</code>，这里加了<code>--rule example_frequency.yaml</code>表示只运行<code>example_frequency.yaml</code>这一个<code>rule</code>文件，如果不加该选项则会运行<code>rules_folder</code>下所有<code>rule</code>文件，上面配置中的<code>rules_folder</code>为默认的<code>example_rules</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m elastalert.elastalert --verbose --rule example_frequency.yaml</span><br></pre></td></tr></table></figure><p>为了让服务后台运行并且可以达到守护进程的效果，在生产环境中笔者建议使用<code>supervisor</code>管理。</p><h2 id="其他Rule"><a href="#其他Rule" class="headerlink" title="其他Rule"></a>其他Rule</h2><ul><li><code>any</code>：只要有匹配就报警；</li><li><code>blacklist</code>：<code>compare_key</code>字段的内容匹配上<code>blacklist</code>数组里任意内容；</li><li><code>whitelist</code>：<code>compare_key</code>字段的内容一个都没能匹配上<code>whitelist</code>数组里内容；</li><li><code>change</code>：在相同<code>query_key</code>条件下，<code>compare_key</code>字段的内容，在 <code>timeframe</code>范围内 发送变化；</li><li><code>frequency</code>：在相同<code>query_key</code>条件下，<code>timeframe</code> 范围内有<code>num_events</code>个被过滤出 来的异常；</li><li><code>spike</code>：在相同<code>query_key</code>条件下，前后两个<code>timeframe</code>范围内数据量相差比例超过<code>spike_height</code>。其中可以通过<code>spike_type</code>设置具体涨跌方向是- <code>up</code>、<code>down</code>、<code>both</code>。还可以通过<code>threshold_ref</code>设置要求上一个周期数据量的下限，<code>threshold_cur</code>设置要求当前周期数据量的下限，如果数据量不到下限，也不触发；</li><li><code>flatline</code>：<code>timeframe</code>范围内，数据量小于<code>threshold</code>阈值；</li><li><code>new_term</code>：fields字段新出现之前<code>terms_window_size</code>(默认<code>30</code>天)范围内最多的<code>terms_size</code>(默认<code>50</code>)个结果以外的数据；</li><li><code>cardinality</code>：在相同 <code>query_key</code>条件下，<code>timeframe</code>范围内<code>cardinality_field</code>的值超过 <code>max_cardinality</code>或者低于<code>min_cardinality</code></li></ul><p>摘自：<a href="https://segmentfault.com/a/1190000008227486" target="_blank" rel="noopener">ElastAlert介绍和安装－1</a><br>详细请参考文档：<a href="https://elastalert.readthedocs.io/en/latest/ruletypes.html#rule-types" target="_blank" rel="noopener">https://elastalert.readthedocs.io/en/latest/ruletypes.html#rule-types</a></p><h2 id="其他告警方式"><a href="#其他告警方式" class="headerlink" title="其他告警方式"></a>其他告警方式</h2><p>除了<code>email</code>，还有<code>jira</code>、<code>webhook</code>等内置告警方式，由于笔者没有实践，就不一一赘述了。</p><p>第三方的微信和钉钉：</p><ul><li>微信：<a href="https://github.com/anjia0532/elastalert-wechat-plugin" target="_blank" rel="noopener">https://github.com/anjia0532/elastalert-wechat-plugin</a></li><li>钉钉：<a href="https://github.com/xuyaoqiang/elastalert-dingtalk-plugin" target="_blank" rel="noopener">https://github.com/xuyaoqiang/elastalert-dingtalk-plugin</a></li></ul><p>也可以根据文档自己实现：<a href="https://elastalert.readthedocs.io/en/latest/recipes/adding_alerts.html" target="_blank" rel="noopener">https://elastalert.readthedocs.io/en/latest/recipes/adding_alerts.html</a></p><h2 id="elastalert-kibana-plugin"><a href="#elastalert-kibana-plugin" class="headerlink" title="elastalert-kibana-plugin"></a>elastalert-kibana-plugin</h2><p><code>elastalert-kibana-plugin</code>是围绕<code>elastalert</code>做的一个<code>kibana</code>展示插件，可以在<code>kibana</code>上创建、编辑和删除告警，但是说实话这个插件还不是很好用，首先配置就有点麻烦，其次展示效果并不友好，提供配置<code>rule</code>的方式太专业化了，对小白或者一般用户来说要求稍高。</p><h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><p>下载<code>6.4.2</code>的<code>release</code>安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wget https://github.com/bitsensor/elastalert-kibana-plugin/releases/download/1.0.1/elastalert-kibana-plugin-1.0.1-6.4.2.zip</span><br></pre></td></tr></table></figure><h3 id="本地安装插件"><a href="#本地安装插件" class="headerlink" title="本地安装插件"></a>本地安装插件</h3><p><code>Kibana</code>插件本地安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> /usr/share/kibana/bin/kibana-plugin install file:///root/elastalert-kibana-plugin-1.0.1-6.4.2.zip</span><br></pre></td></tr></table></figure><p>本地安装前面需要加上<code>file://</code>，否则会默认为在线资源去解析<code>url</code>并下载</p><p><strong>Unix：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo bin/elasticsearch-plugin install file:///path/to/plugin.zip</span><br></pre></td></tr></table></figure><p><strong>Windows：</strong></p><p>假定需要安装的插件本地地址为<code>C:\path\to\plugin.zip</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin\elasticsearch-plugin install file:///C:/path/to/plugin.zip</span><br></pre></td></tr></table></figure><h3 id="安装Server"><a href="#安装Server" class="headerlink" title="安装Server"></a>安装Server</h3><p>上面安装的只是<code>kibana</code>的一个展示插件，插件内部并没有集成<code>server</code>，所以还需要再安装一个<code>server</code>，笔者之前因为没有做这一步，一直卡着，页面显示报错<code>502 Bad Gateway</code>，关键是官方文档也没说清楚一定要装这个。。</p><h4 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git clone https://github.com/bitsensor/elastalert.git elastalert-server</span><br><span class="line"><span class="meta">$</span> cd elastalert-server</span><br></pre></td></tr></table></figure><p>这边我们先不用官网说的<code>docker</code>运行的方式，先用本地<code>npm</code>起服务的方式运行。</p><h4 id="下载指定版本的npm"><a href="#下载指定版本的npm" class="headerlink" title="下载指定版本的npm"></a>下载指定版本的<code>npm</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install &quot;$(cat .nvmrc)&quot;</span><br></pre></td></tr></table></figure><h4 id="安装依赖-1"><a href="#安装依赖-1" class="headerlink" title="安装依赖"></a>安装依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><p>这一步很重要，因为很多地方没有说的很清楚，包括<code>docker</code>运行方式在这一块也没说清楚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim config/config.json</span><br></pre></td></tr></table></figure><p>默认的配置需要修改，尤其是<code>elastalertPath</code>和<code>rulesPath</code>中的<code>path</code>选项</p><p><code>elastalertPath</code>表示的是我们最初安装的<code>elastalert</code>仓库的目录，也就是说<code>elastalert-kibana-plugin</code>运行需要三个仓库，分别是<code>elastalert</code>、<code>elastalert-kibana-plugin</code>、和<code>elastalert-server</code>，分别对应的是后端代码、前端代码、<code>webserver</code>，这也就是笔者之前提到的安装提到的安装麻烦所在了；</p><p>其次<code>rulesPath</code>中<code>path</code>选项表示运用<code>elastalert-kibana-plugin</code>插件创建告警后<code>rule</code>文件存放的目录，上面笔者在<code>elastalert</code>配置的<code>rules_folder</code>为<code>example_rules</code>，这里配置的<code>path</code>为<code>rules</code>，主要是因为<code>elastalert-server</code>目录下用的是这个，笔者也在<code>elastalert</code>项目中创建了个<code>rules</code>的目录，并将<code>rules_folder</code>配置进行同步，这个看个人喜好自定义即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;appName&quot;: &quot;elastalert-server&quot;,</span><br><span class="line">  &quot;port&quot;: 3030,</span><br><span class="line">  &quot;elastalertPath&quot;: &quot;/root/elastalert&quot;,</span><br><span class="line">  &quot;verbose&quot;: false,</span><br><span class="line">  &quot;es_debug&quot;: false,</span><br><span class="line">  &quot;debug&quot;: false,</span><br><span class="line">  &quot;rulesPath&quot;: &#123;</span><br><span class="line">    &quot;relative&quot;: true,</span><br><span class="line">    &quot;path&quot;: &quot;/rules&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;templatesPath&quot;: &#123;</span><br><span class="line">    &quot;relative&quot;: true,</span><br><span class="line">    &quot;path&quot;: &quot;/rule_templates&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;es_host&quot;: &quot;192.168.232.191&quot;,</span><br><span class="line">  &quot;es_port&quot;: 9200,</span><br><span class="line">  &quot;writeback_index&quot;: &quot;elastalert_status&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="起服务"><a href="#起服务" class="headerlink" title="起服务"></a>起服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><h4 id="容器方式"><a href="#容器方式" class="headerlink" title="容器方式"></a>容器方式</h4><p>官网提供的命令依旧是很模糊，很多同学直接运行了，也没报错，但是也没正常运行，这是因为跟上面一样，下面这些目录都要对应修改，具体参考上面配置文件即可，最重要的还是要明白整体架构，三个项目各自的作用，知道原理就一目了然了，但不得不说如果官方文档描述地详细一点，大家也许会更容易地搞成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3030:3030 \</span><br><span class="line">    -v `pwd`/config/elastalert.yaml:/opt/elastalert/config.yaml \</span><br><span class="line">    -v `pwd`/config/config.json:/opt/elastalert-server/config/config.json \</span><br><span class="line">    -v `pwd`/rules:/opt/elastalert/rules \</span><br><span class="line">    -v `pwd`/rule_templates:/opt/elastalert/rule_templates \</span><br><span class="line">    --net=&quot;host&quot; \</span><br><span class="line">    --name elastalert bitsensor/elastalert:latest</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从<code>elastalert</code>的安装讲起，接着涉猎<code>rule</code>配置、<code>email</code>配置等环节，然后通过测试和运行来对<code>rule</code>文件进行验证，最后再详细介绍了<code>elastalert-kibana-plugin</code>的安装和用法。</p><p>总的来说，<code>elastalert</code>围绕<code>es</code>所提供的告警功能是很强大的，文中提供的案例只是冰山一角，大家感兴趣的可以多看看官方文档，<code>elastalert</code>的官方文档还是很全的。</p><p>至于<code>elastalert-kibana-plugin</code>这个插件，笔者认为一般般，配置过程稍显麻烦，其次功能很弱，跟后端手动修改配置文件没什么两样，也没有同名校验这些机制，相比而言，<code>sentinl</code>的<code>UI</code>就显得简单美观了，请听下回分解。</p><h2 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h2><ol><li><a href="https://www.freebuf.com/articles/web/160254.html" target="_blank" rel="noopener">ElastAlert监控日志告警Web攻击行为</a></li><li><a href="https://blog.xizhibei.me/2017/11/19/alerting-with-elastalert/" target="_blank" rel="noopener">ElastAlert：『Hi，咱服务挂了』</a></li><li><a href="https://segmentfault.com/a/1190000008227486" target="_blank" rel="noopener">ElastAlert介绍和安装－1</a></li><li><a href="https://www.jianshu.com/p/f82812e0a743" target="_blank" rel="noopener">elastalert的简单运用</a></li><li><a href="https://anjia0532.github.io/2017/02/14/elasticsearch-elastalert/#&amp;gid=1&amp;pid=1" target="_blank" rel="noopener">ElastAlert 基于Elasticsearch的监控告警</a></li><li><a href="https://my.oschina.net/qixiaobo025/blog/1932752" target="_blank" rel="noopener">elastAlert之kibana的插件使用</a></li><li><a href="https://www.elastic.co/guide/cn/kibana/current/installing_plugins.html" target="_blank" rel="noopener">Install plugins</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/plugins/current/plugin-management-custom-url.html" target="_blank" rel="noopener">plugin management custom url</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/alert.png&quot; alt=&quot;alert&quot;&gt;&lt;/center&gt;

&lt;p&gt;今天聊聊&lt;code&gt;ES&lt;/code&gt;的告警，&lt;code&gt;X-Pack&lt;/code&gt;提供了报警组件&lt;code&gt;Alert&lt;/code&gt;，但是这个功能是需要付费，在寻求其他方案的时候，发现了&lt;code&gt;ElastAlert&lt;/code&gt;，可以说这是一款为&lt;code&gt;ES&lt;/code&gt;量身定制的告警组件，能够完美替代&lt;code&gt;Alert&lt;/code&gt;提供的所有功能。今天就&lt;code&gt;ElastAlert&lt;/code&gt;强大的告警功能和笔者实践过程中遇到的一些问题进行分享。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Elasticsearch" scheme="https://tony-yin.github.io/tags/Elasticsearch/"/>
    
      <category term="Monitor" scheme="https://tony-yin.github.io/tags/Monitor/"/>
    
  </entry>
  
  <entry>
    <title>如何避免 Cronjob 重复运行</title>
    <link href="https://tony-yin.github.io/2018/11/05/How-To-Avoid-Cronjob-Duplicate-Running/"/>
    <id>https://tony-yin.github.io/2018/11/05/How-To-Avoid-Cronjob-Duplicate-Running/</id>
    <published>2018-11-05T05:07:06.000Z</published>
    <updated>2018-12-13T16:40:24.434Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/cronjob.png" alt="cronjob"></center><p><code>Cronjob</code>使用中有很多问题需要注意，前段时间写了一篇文章<a href="https://www.tony-yin.site/2018/10/29/Why-Crontab-Not-Work/" target="_blank" rel="noopener">《为什么 Cronjob 不执行》</a>，里面谈到了各种会导致<code>cronjob</code>不执行的因素和解决方案，而本文就<code>cronjob</code>重复运行的场景，对技术手段、技术方案、具体代码和相互优劣展开详细讲解。</p><a id="more"></a><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>之前写过一篇文章<a href="https://www.tony-yin.site/2018/05/20/Ctdb-Rados-2/" target="_blank" rel="noopener">《Ctdb Rados（二）：多场景断网高可用》</a>，文中提到支持秒级的定时任务的方法，因为<code>cronjob</code>本身最小只支持分钟级别的定时任务，所以笔者在<code>cronjob</code>定时脚本中通过<code>for</code>循环来达到秒级定时的目的。</p><p>然而这种定时间隔很短的任务是很容易出现重复运行的问题的。正常情况下脚本执行时间是很短的，但是一旦遇到<code>IO</code>阻塞等问题，会出现多个任务同时运行的情况，这种情况往往不是我们所期望的，可能会导致意想不到的问题。</p><p>即使不是秒级的定时任务，只要任务执行时间超过定时间隔都会出现重复运行的问题，比如每分钟运行的定时任务，而其执行时间需要三分钟等等</p><p>例子如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -elf | grep forever</span></span><br><span class="line">4 S vagrant   4095  4094  0  80   0 -  1111 wait   21:59 ?        00:00:00 /bin/sh -c /var/tmp/forever.sh</span><br><span class="line">0 S vagrant   4096  4095  0  80   0 -  2779 wait   21:59 ?        00:00:00 /bin/bash /var/tmp/forever.sh</span><br><span class="line">4 S vagrant   4100  4099  0  80   0 -  1111 wait   22:00 ?        00:00:00 /bin/sh -c /var/tmp/forever.sh</span><br><span class="line">0 S vagrant   4101  4100  0  80   0 -  2779 wait   22:00 ?        00:00:00 /bin/bash /var/tmp/forever.sh</span><br><span class="line">4 S vagrant   4130  4129  0  80   0 -  1111 wait   22:01 ?        00:00:00 /bin/sh -c /var/tmp/forever.sh</span><br><span class="line">0 S vagrant   4131  4130  0  80   0 -  2779 wait   22:01 ?        00:00:00 /bin/bash /var/tmp/forever.sh</span><br><span class="line">4 S vagrant   4135  4134  0  80   0 -  1111 wait   22:02 ?        00:00:00 /bin/sh -c /var/tmp/forever.sh</span><br><span class="line">0 S vagrant   4136  4135  0  80   0 -  2779 wait   22:02 ?        00:00:00 /bin/bash /var/tmp/forever.sh</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案1：进程数"><a href="#方案1：进程数" class="headerlink" title="方案1：进程数"></a>方案1：进程数</h3><p>这是笔者第一时间自己想的方式，通过进程数来判断当前定时脚本同时执行的数量，比如执行的脚本名为<code>/opt/test.sh</code>，当有一个任务在运行的时候：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# ps -ef | grep /opt/test.sh</span><br><span class="line">root      1107 25880  0 23:26 pts/0    00:00:00 /usr/bin/bash /opt/test.sh</span><br><span class="line">root      1305  1175  0 23:27 pts/5    00:00:00 grep --color=auto /opt/test.sh</span><br></pre></td></tr></table></figure><p>此时通过<code>ps -ef | grep /opt/test.sh | wc -l</code>得到的数量应该是<code>2</code>，如果定时间隔完毕后又刷新了一轮，总进程数则会变成<code>3</code>。</p><p>所以我们可以在<code>/opt/test.sh</code>中加入进程数的判断，如果进程数大于<code>2</code>，就说明存在已有任务在运行，此时应该退出执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count=$(ps -ef | grep /opt/test.sh | wc -l)</span><br><span class="line">if [ $count -gt 2 ]; then</span><br><span class="line">    echo "Exist job running!"</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line">do something</span><br></pre></td></tr></table></figure><p>但是事与愿违，当我们在<code>/opt/test.sh</code>中通过<code>ps</code>命令获取定时任务运行数量的时候发现，如果只存在当前的任务运行时，得到的进程数是<code>3</code>，如果有其他一个已在运行，则进程数是<code>4</code>，以此类推。这是为什么呢？</p><p>经过一番研究发现，当只存在当前任务运行时，如果脚本里面是直接运行<code>ps</code>命令，得到的进程数是<code>2</code>，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep /opt/test.sh | wc -l</span><br></pre></td></tr></table></figure><p>不难看出这是<code>$()</code>的原因，它在<code>shell</code>中起了一个子<code>shell</code>，所以在子<code>shell</code>执行<code>ps</code>的同时多了一个当前脚本任务运行的进程，所以比正常进程数多<code>1</code>，所以上面代码我们需要改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count=$(ps -ef | grep /opt/test.sh | wc -l)</span><br><span class="line">if [ $count -gt 3 ]; then</span><br><span class="line">    echo "Exist job running!"</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line">do something</span><br></pre></td></tr></table></figure><h3 id="方案2：普通文件锁"><a href="#方案2：普通文件锁" class="headerlink" title="方案2：普通文件锁"></a>方案2：普通文件锁</h3><p>可以通过一个文件来标识当前是否存在任务在运行，具体做法为当运行任务时，先检查是否存在文件锁，如果存在则表示上个任务还没有运行结束，则退出；如果不存在文件锁，则新创建一个文件锁，然后执行任务，最后执行完毕后删除文件锁。</p><p>具体代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">file_lock=/opt/test.lock</span><br><span class="line">if [ -f file_lock ]; then</span><br><span class="line">    echo "Exist job running!"</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line">touch file_lock</span><br><span class="line">do something</span><br><span class="line">rm -f file_lock</span><br></pre></td></tr></table></figure><h3 id="方案3：进程号文件锁"><a href="#方案3：进程号文件锁" class="headerlink" title="方案3：进程号文件锁"></a>方案3：进程号文件锁</h3><p>所谓进程号文件锁，相比于方案<code>2</code>的普通文件锁不同的地方就是会把当前运行任务对应的进程号写入锁文件中，其优势在于除了可以通过检查文件是否存在来判断是否存在已经运行的任务，还可以再通过锁文件里面的进程号来做第二次确认。</p><p>也许有人会问这个二次确认有啥用？你还别说，这个还真有用，很多时候进程意外终止或者被手动杀掉后，文件锁依然存在，那么使用普通文件锁的结果就是其实并没有正在运行的任务，但是由于存在文件锁，之后所有的任务都不会再运行。而进程号文件锁则可以在文件锁判断之外，再对锁文件中的进程号进行判断是否还在运行，具体代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PIDFILE=/opt/test.pid</span><br><span class="line">if [ -f $PIDFILE ]</span><br><span class="line">then</span><br><span class="line">  PID=$(cat $PIDFILE)</span><br><span class="line">  ps -p $PID &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">  if [ $? -eq 0 ]</span><br><span class="line">  then</span><br><span class="line">    echo "Exist job running!"</span><br><span class="line">    exit 1</span><br><span class="line">  else</span><br><span class="line">    echo $$ &gt; $PIDFILE</span><br><span class="line">    if [ $? -ne 0 ]</span><br><span class="line">    then</span><br><span class="line">      echo "Could not create PID file!"</span><br><span class="line">      exit 1</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">else</span><br><span class="line">  echo $$ &gt; $PIDFILE</span><br><span class="line">  if [ $? -ne 0 ]</span><br><span class="line">  then</span><br><span class="line">    echo "Could not create PID file!"</span><br><span class="line">    exit 1</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">do something</span><br><span class="line">rm $PIDFILE</span><br></pre></td></tr></table></figure><p>虽然此方案看起来很完美，但是还是有一个场景没有考虑到，那就是如果正在运行任务的进程被<code>kill</code>掉，然后另一个进程使用了和被<code>kill</code>进程相同的<code>pid</code>，这样也会导致其实任务并没有在运行，由于存在锁文件和对应进程号的进程在运行，之后所有的任务不再运行。虽然这种场景很极端，但是也是有可能出现的，不过没关系，下面的方案会帮你解决这个问题。</p><h3 id="方案4：flock-锁"><a href="#方案4：flock-锁" class="headerlink" title="方案4：flock 锁"></a>方案4：flock 锁</h3><p><code>linux flock</code>锁有区别于一般的锁，它不仅仅是检查文件是否存在，它会一直存在直到进程结束，所以可以直接地知道进程是否真的执行结束了。</p><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flock [-sxun][-w #] fd#</span><br><span class="line">flock [-sxon][-w #] file [-c] command</span><br></pre></td></tr></table></figure><p>选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-s, --shared:    获得一个共享锁 </span><br><span class="line">-x, --exclusive: 获得一个独占锁 </span><br><span class="line">-u, --unlock:    移除一个锁，脚本执行完会自动丢弃锁 </span><br><span class="line">-n, --nonblock:  如果没有立即获得锁，直接失败而不是等待 </span><br><span class="line">-w, --timeout:   如果没有立即获得锁，等待指定时间 </span><br><span class="line">-o, --close:     在运行命令前关闭文件的描述符号。用于如果命令产生子进程时会不受锁的管控 </span><br><span class="line">-c, --command:   在shell中运行一个单独的命令 </span><br><span class="line">-h, --help       显示帮助 </span><br><span class="line">-V, --version:   显示版本</span><br></pre></td></tr></table></figure><p>锁类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">共享锁：多个进程可以使用同一把锁，常被用作读共享锁</span><br><span class="line">独占锁：同时只允许一个进程使用，又称排他锁，写锁。</span><br></pre></td></tr></table></figure><p>这里由于我们只允许同时存在一个任务运行，所以选择独占锁，然后需要在脚本执行完丢弃锁：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * *  flock -xn /opt/test.lock -c /opt/test.sh</span><br></pre></td></tr></table></figure><h3 id="方案5：solo-程序"><a href="#方案5：solo-程序" class="headerlink" title="方案5：solo 程序"></a>方案5：solo 程序</h3><p><a href="http://timkay.com/solo/" target="_blank" rel="noopener">Solo</a>是一个<code>Perl</code>脚本，它的工作原理与<code>flock</code>类似，但它并不依赖于锁文件，因为<code>Solo</code>程序是通过绑定端口来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./solo -port=6000 /opt/test.sh &amp;</span></span><br><span class="line">[1] 7503</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./solo -port=6000 /opt/test.sh</span></span><br><span class="line">solo(6000): Address already in use</span><br></pre></td></tr></table></figure><p>执行<code>solo</code>时，将绑定指定的端口并执行后面指定的命令。一旦命令完成，就会释放端口，允许任务的下一个调用正常执行。</p><p><code>solo</code>的优势在于没有人能够通过删除一个文件并意外地导致任务重复运行。即使使用<code>flock</code>命令，如果锁文件被删除，也可以启动第二个作业。由于<code>solo</code>绑定了一个端口，所以不可能出现这种情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面提到了五种方案，第一种方案略显粗糙，但是缺陷相对来说较少；第二种方案存在锁文件被意外删除或者进程被<code>kill</code>的风险；第三种方案存在锁文件被意外删除和新进程占用相同进程号的问题；第四种方案还是存在意外删除锁文件的问题；第五种方案则不需要担心锁文件被删除导致任务重复运行的问题。</p><p>目前看起来第五种方案是最优的，不存在缺陷。不过还是得看具体场景，笔者认为第三种、第四种、第五种方案都是有可取之处的，大家还是根据各自的场景选择最适合自己的方案吧。</p><h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ul><li><a href="https://blog.csdn.net/phachon/article/details/52106409" target="_blank" rel="noopener">https://blog.csdn.net/phachon/article/details/52106409</a></li><li><a href="http://bencane.com/2015/09/22/preventing-duplicate-cron-job-executions/" target="_blank" rel="noopener">http://bencane.com/2015/09/22/preventing-duplicate-cron-job-executions/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/cronjob.png&quot; alt=&quot;cronjob&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;code&gt;Cronjob&lt;/code&gt;使用中有很多问题需要注意，前段时间写了一篇文章&lt;a href=&quot;https://www.tony-yin.site/2018/10/29/Why-Crontab-Not-Work/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《为什么 Cronjob 不执行》&lt;/a&gt;，里面谈到了各种会导致&lt;code&gt;cronjob&lt;/code&gt;不执行的因素和解决方案，而本文就&lt;code&gt;cronjob&lt;/code&gt;重复运行的场景，对技术手段、技术方案、具体代码和相互优劣展开详细讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
      <category term="Cronjob" scheme="https://tony-yin.github.io/tags/Cronjob/"/>
    
  </entry>
  
  <entry>
    <title>为什么 crontab 不执行</title>
    <link href="https://tony-yin.github.io/2018/10/29/Why-Crontab-Not-Work/"/>
    <id>https://tony-yin.github.io/2018/10/29/Why-Crontab-Not-Work/</id>
    <published>2018-10-29T06:50:26.000Z</published>
    <updated>2018-12-13T16:40:24.465Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/Why-Crontab-Not_Work.png" alt="Why Crontab Not Work"></center><p>作为<code>linux</code>中的定时任务工具，<code>crontab</code>被广大开发者所热爱和使用。该技术由来已久，相当成熟，但是在真正使用的时候会时不时地发现为什么<code>crontab</code>脚本没有按照预期那样执行？本文以本周笔者遇到一个<code>crontab</code>不能运行的问题为引子，详细地介绍为什么<code>crontab</code>不运行的各种原因。</p><a id="more"></a><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>本周遇到一个<code>crontab</code>不能执行的问题，发现原因后觉得甚是有趣。</p><p>笔者通过一个<code>python</code>脚本向<code>/etc/cron.d</code>目录下的一个文件写入定时任务命令，每分钟调用一个脚本，调用的这个脚本是个<code>python</code>文件，然后发现<code>cron</code>并没有按照预期每分钟执行一次。然后笔者就将原定时任务脚本<code>aaa</code>拷贝了一份，并重新命名为<code>bbb</code>，然后将定时任务中调用脚本改成了执行一个简单的<code>echo</code>命令，然后保存退出，发现<code>bbb</code>是可以正常定时运行的，这时候，笔者就通过<code>file</code>命令想比较一下这两个文件有何不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@tony cron.d]# file *</span><br><span class="line">aaa:     ASCII text, with no line terminators</span><br><span class="line">bbb:     ASCII text</span><br></pre></td></tr></table></figure><p>这个时候我们可以发现<code>aaa</code>文件出现了比较奇怪的标识：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">with no line terminators</span><br></pre></td></tr></table></figure><p>显而易见，这是在说<code>cron</code>脚本中定时命令没有行终止符，导致这个问题是因为该<code>cron</code>脚本由<code>python</code>代码生成时没有添加换行符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;/etc/cron.d/aaa&apos;, &apos;w&apos;) as f:</span><br><span class="line">    f.write(&apos;xxx&apos;)</span><br></pre></td></tr></table></figure><p>然后笔者尝试性地在<code>aaa</code>文件中在定时命令下新增一行后，发现定时任务可以正常运行了。不得不说，这是一个很有意思的问题，<code>crontab</code>居然会因为一个换行符导致定时任务的不运行，后来<code>google</code>了一下发现，<code>crontab</code>的确存在这个机制，具体解释下面会提到。</p><p>在<code>google</code>的同时，在<code>ask unbuntu</code>上发现了这篇文章：<a href="https://askubuntu.com/questions/23009/why-crontab-scripts-are-not-working?page=1&amp;tab=votes#tab-top" target="_blank" rel="noopener">《Why crontab scripts are not working?》</a>，里面很多开发者罗列了他们遇到<code>cron</code>不能正常运行的各种因素，笔者大致浏览了下，发现有遇到过，也有很多并不知道的，所以想把这些因素和解决方案一一罗列下来。</p><h2 id="因素"><a href="#因素" class="headerlink" title="因素"></a>因素</h2><h3 id="因素1：环境变量"><a href="#因素1：环境变量" class="headerlink" title="因素1：环境变量"></a>因素1：环境变量</h3><h4 id="场景及原因"><a href="#场景及原因" class="headerlink" title="场景及原因"></a>场景及原因</h4><p><code>cron</code>中的环境变量和系统的环境变量是不一样的，我们可以通过设置定时脚本将<code>cron</code>中的环境变量打印出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * env &gt; /tmp/env.output</span><br></pre></td></tr></table></figure><p>可以看到<code>cron</code>中的环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">XDG_SESSION_ID=12952</span><br><span class="line">SHELL=/bin/sh</span><br><span class="line">USER=root</span><br><span class="line">PATH=/usr/bin:/bin</span><br><span class="line">PWD=/root</span><br><span class="line">LANG=en_US.UTF-8</span><br><span class="line">SHLVL=1</span><br><span class="line">HOME=/root</span><br><span class="line">LOGNAME=root</span><br><span class="line">XDG_RUNTIME_DIR=/run/user/0</span><br><span class="line">_=/usr/bin/env</span><br></pre></td></tr></table></figure><p>查看系统的环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@tony cron.d]# env</span><br><span class="line">XDG_SESSION_ID=1140</span><br><span class="line">HOSTNAME=tony</span><br><span class="line">TERM=xterm-256color</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">HISTSIZE=1000</span><br><span class="line">USER=root</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/root/bin</span><br><span class="line">MAIL=/var/spool/mail/root</span><br><span class="line">PWD=/etc/cron.d</span><br><span class="line">LANG=en_US.UTF-8</span><br><span class="line">TMUX_PANE=%18</span><br><span class="line">HISTCONTROL=ignoredups</span><br><span class="line">SHLVL=2</span><br><span class="line">HOME=/root</span><br><span class="line">LOGNAME=root</span><br><span class="line">_=/usr/bin/env</span><br><span class="line">OLDPWD=/root</span><br></pre></td></tr></table></figure><p>我们可以看到<code>cron</code>中的环境变量很多都和系统环境变量不一样（<code>cron</code>会忽略<code>/etc/environment</code>文件），尤其是<code>PATH</code>，只有<code>/usr/bin:/bin</code>，也就是说在<code>cron</code>中运行<code>shell</code>命令，如果不是全路径，只能运行<code>/usr/bin</code>或<code>/bin</code>这两个目录中的标准命令，而像<code>/usr/sbin</code>、<code>/usr/local/bin</code>等目录中的非标准命令是不能运行的。</p><p>这个问题笔者也遇到很多次，所以很多非标准命令都选择了全路径，但是这个方法也有问题，因为不同环境的命令所存在的目录是不一样的。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><strong>方案1：</strong></p><p>在<code>cron</code>脚本文件头部声明<code>PATH</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">PATH=/opt/someApp/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line"></span><br><span class="line"># rest of script follows</span><br></pre></td></tr></table></figure><p><strong>方案2：</strong></p><p>在定时脚本调用的脚本头部声明<code>PATH</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PATH=/opt/someApp/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line"></span><br><span class="line">15 1 * * * backupscript --incremental /home /root</span><br></pre></td></tr></table></figure><h3 id="因素2：换行符"><a href="#因素2：换行符" class="headerlink" title="因素2：换行符"></a>因素2：换行符</h3><h4 id="场景及原因-1"><a href="#场景及原因-1" class="headerlink" title="场景及原因"></a>场景及原因</h4><p>这个因素就是笔者引子中提到的，官方解释（<code>man crontab</code>）如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Although cron requires that each entry in a crontab end in a newline character, neither the crontab command nor the cron daemon will detect this error. Instead, the crontab will appear to load normally. However, the command will never run. The best choice is to ensure that your crontab has a blank line at the end.</span><br><span class="line"></span><br><span class="line">4th Berkeley Distribution      29 December 1993     CRONTAB(1)</span><br></pre></td></tr></table></figure><p>简单翻译一下就是：</p><p>尽管<code>crontab</code>要求<code>cron</code>中的每个条目都要以换行符结尾，但<code>crontab</code>命令和<code>cron</code>守护进程都不会检测到这个错误。相反，<code>crontab</code>将正常加载。然而，命令永远不会运行。最好的选择是确保您的<code>crontab</code>在末尾有一个空白行。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>给<code>cron</code>中每个条目下面添加一个空行</p><p><strong>注意：</strong></p><p>除了没了换行符会导致<code>cron</code>中的命令不会运行，即引子中所标识：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">with no line terminators</span><br></pre></td></tr></table></figure><p>但是因为非<code>linux</code>操作系统导致的非<code>\n</code>换行符同样会导致该问题，比如<code>windows</code>的<code>^M</code>、<code>mac</code>的<code>\r</code>等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">with CR line terminators</span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong></p><p><code>windows</code>的话就通过<code>dos2unix</code>命令转换；而<code>mac</code>则可以通过<code>mac2unix</code>来转换，<code>mac2unix</code>也是<code>dos2unix</code>软件中的一部分</p><h4 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h4><ul><li><a href="https://stackoverflow.com/questions/14080306/remove-cr-line-terminators" target="_blank" rel="noopener">remove CR line terminators</a></li></ul><h3 id="因素3：crond-服务"><a href="#因素3：crond-服务" class="headerlink" title="因素3：crond 服务"></a>因素3：crond 服务</h3><h4 id="场景及原因-2"><a href="#场景及原因-2" class="headerlink" title="场景及原因"></a>场景及原因</h4><p>很多时候<code>crond</code>服务未开启，也会导致定时任务不会正常执行。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>查看服务是否运行，如果未运行，启动<code>crond</code>服务即可。</p><p>查看方式有两种：</p><p>1.通过进程查看</p><p><code>pgrep</code>相当于<code>ps -ef | grep</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgrep cron</span><br></pre></td></tr></table></figure><p>2.通过<code>service</code>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service crond status</span><br></pre></td></tr></table></figure><p>启动服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service crond start</span><br></pre></td></tr></table></figure><h3 id="因素4：shell-解释器"><a href="#因素4：shell-解释器" class="headerlink" title="因素4：shell 解释器"></a>因素4：shell 解释器</h3><h4 id="场景及原因-3"><a href="#场景及原因-3" class="headerlink" title="场景及原因"></a>场景及原因</h4><p>从因素<code>1</code>就知道<code>cron</code>环境变量中的<code>SHELL</code>是<code>sh</code>而不是<code>bash</code>，我们知道很多<code>shell</code>命令是可以在<code>bash</code>中正常运行，但是不能在<code>sh</code>中运行的，所以这个因素也会影响定时任务的正常运行。</p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p><strong>方案1：</strong></p><p>将<code>cron</code>中需要执行的命令在<code>sh</code>中执行确认</p><p><strong>方案2：</strong></p><p>将<code>cron</code>中需要执行的命令外面加一个<code>bash shell</code>的封装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c &quot;mybashcommand&quot;</span><br></pre></td></tr></table></figure><p><strong>方案3：</strong></p><p>修改<code>cron</code>中的<code>SHELL</code>环境变量的值，让所有命令都用<code>bash</code>解释器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHELL=/bin/bash</span><br></pre></td></tr></table></figure><p><strong>方案4：</strong></p><p>如果定时任务执行的命令是<code>shell</code>脚本，只要在脚本内添加<code>bash</code>解释器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br></pre></td></tr></table></figure><h3 id="因素5：时区"><a href="#因素5：时区" class="headerlink" title="因素5：时区"></a>因素5：时区</h3><h4 id="场景及原因-4"><a href="#场景及原因-4" class="headerlink" title="场景及原因"></a>场景及原因</h4><p>当修改系统时区后，无论是之前已经存在的<code>cron</code>还是之后新创建的<code>cron</code>，脚本中设置的定时时间都以旧时区为准，比如原来时区是<code>Asia/Shanghai</code>，时间为<code>10:00</code>，然后修改时区为<code>Europe/Paris</code>，时间变为<code>3:00</code>，此时你设置<code>11:00</code>的定时时间，<code>cron</code>会在<code>Asia/Shanghai</code>时区的<code>11:00</code>执行。</p><h4 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h4><p><strong>方案1：</strong></p><p>重启<code>crond</code>服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service crond restart</span><br></pre></td></tr></table></figure><p><strong>方案2：</strong></p><p><code>kill crond</code>进程，因为<code>crond</code>进程是可重生的</p><h3 id="因素6：百分号"><a href="#因素6：百分号" class="headerlink" title="因素6：百分号%"></a>因素6：百分号%</h3><h4 id="场景及原因-5"><a href="#场景及原因-5" class="headerlink" title="场景及原因"></a>场景及原因</h4><p>当<code>cron</code>定时执行命令中，有百分号并且没有转义的时候，<code>cron</code>执行会出错，比如执行以下<code>cron</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 * * * * echo hello &gt;&gt; ~/cron-logs/hourly/test`date &quot;+%d&quot;`.log</span><br></pre></td></tr></table></figure><p>会有如下报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh: -c: line 0: unexpected EOF while looking for matching ``&apos;</span><br><span class="line">/bin/sh: -c: line 1: syntax error: unexpected end of file</span><br></pre></td></tr></table></figure><p>有的日志也会有如下报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(echo) ERROR (getpwnam() failed)</span><br></pre></td></tr></table></figure><p><code>crontab manpage</code>中解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The &quot;sixth&quot; field (the rest of the line) specifies the command to be run. The entire command portion of the line, up to a newline or % character, will be executed by /bin/sh or by the shell specified in the SHELL variable of the cronfile. Percent-signs (%) in the command, unless escaped with backslash (\), will be changed into newline characters, and all data after the first % will be sent to the command as standard input.</span><br></pre></td></tr></table></figure><p>即<code>cron</code>中换行符或<code>%</code>前的命令会被<code>shell</code>解释器执行，但是<code>%</code>会被认为新一行的字符，并且<code>%</code>后所有的数据都会以标准输出的形式发送给命令。</p><h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><p>为百分号做转义，即在<code>%</code>前添加反斜杠<code>\</code></p><h4 id="Refer-1"><a href="#Refer-1" class="headerlink" title="Refer"></a>Refer</h4><ul><li><a href="http://www.pantz.org/software/cron/croninfo.html" target="_blank" rel="noopener">Cron and Crontab usage and examples</a></li><li><a href="https://unix.stackexchange.com/questions/29578/how-can-i-execute-date-inside-of-a-cron-tab-job" target="_blank" rel="noopener">How can I execute date inside of a cron tab job?</a></li></ul><h3 id="因素7：密码过期"><a href="#因素7：密码过期" class="headerlink" title="因素7：密码过期"></a>因素7：密码过期</h3><h4 id="场景及原因-6"><a href="#场景及原因-6" class="headerlink" title="场景及原因"></a>场景及原因</h4><p><code>Linux</code>下新建用户密码过期时间是从<code>/etc/login.defs</code>文件中<code>PASS_MAX_DAYS</code>提取的，普通系统默认就是<code>99999</code>，而有些安全操作系统是<code>90</code>。更改此处，只是让新建的用户默认密码过期时间变化，已有用户密码过期时间仍然不变。</p><p>当用户密码过期也会导致<code>cron</code>脚本执行失败。</p><h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><p>将用户密码有效期设置成永久有效期或者延长有效期</p><p><strong>方案1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chage -M &lt;expire&gt; &lt;username&gt;</span><br></pre></td></tr></table></figure><p><strong>方案2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd -x -1 &lt;username&gt;</span><br></pre></td></tr></table></figure><p><strong>方案3：</strong></p><p>手动修改<code>/etc/login.defs</code>文件中<code>PASS_MAX_DAYS</code>的值</p><h3 id="因素8：权限"><a href="#因素8：权限" class="headerlink" title="因素8：权限"></a>因素8：权限</h3><h4 id="场景及原因-7"><a href="#场景及原因-7" class="headerlink" title="场景及原因"></a>场景及原因</h4><p>很多时候解决方案都是采用<code>root</code>用户执行<code>cron</code>，但是有时候这并不是一个很好的方式。如果采用非<code>root</code>用户执行<code>cron</code>，需要注意很多权限问题，比如<code>cron</code>用户对操作的文件或目录是否存在权限等。</p><p>如果权限不够，<code>cron</code>会拒绝执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service cron restart</span><br><span class="line">grep -i cron /var/log/syslog|tail -2</span><br><span class="line">2013-02-05T03:47:49.283841+01:00 ubuntu cron[49906]: (user) INSECURE MODE (mode 0600 expected) (crontabs/user)</span><br></pre></td></tr></table></figure><h4 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># correct permission</span><br><span class="line">sudo chmod 600 /var/spool/cron/crontabs/user</span><br><span class="line"># signal crond to reload the file</span><br><span class="line">sudo touch /var/spool/cron/crontabs</span><br></pre></td></tr></table></figure><h3 id="因素9：不同平台"><a href="#因素9：不同平台" class="headerlink" title="因素9：不同平台"></a>因素9：不同平台</h3><h4 id="场景及原因-8"><a href="#场景及原因-8" class="headerlink" title="场景及原因"></a>场景及原因</h4><p>一些特殊选项各个平台支持不一样，有的支持，有的不支持，例如<code>2/3</code>、<code>1-5</code>、<code>1,3,5</code></p><h4 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h4><p>需要针对不同平台做兼容性测试</p><h3 id="因素10：不同-cron"><a href="#因素10：不同-cron" class="headerlink" title="因素10：不同 cron"></a>因素10：不同 cron</h3><h4 id="场景及原因-9"><a href="#场景及原因-9" class="headerlink" title="场景及原因"></a>场景及原因</h4><p>将之前运行的<code>Crontab Spec</code>在从一个<code>Crontab</code>文件移动到另一个<code>Crontab</code>文件时可能会崩溃。有时候，原因是你已经将<code>Spec</code>从系统<code>crontab</code>文件转移到用户<code>crontab</code>文件，反之亦然。</p><p><code>cron</code>分为系统<code>cron</code>和用户<code>cron</code>，用户<code>cron</code>指<code>/var/spool/cron/username</code>或<code>/var/spool/crontabs/crontabs/username</code>，系统<code>cron</code>指<br><code>/etc/crontab</code>以及<code>/etc/crontab</code>，这两者是存在部分差异的。</p><p>系统<code>crontab</code>在命令行运行之前有一个额外的字段<code>user</code>。这会导致一些错误，比如你将<code>/etc/crontab</code>中的命令或者<code>/etc/cron.d</code>中的文件移动至用户<code>crontab</code>会报错如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">george; command not found</span><br></pre></td></tr></table></figure></p><p>相反，当发生相反的情况时，<code>cron</code>将显示<code>/usr/bin/restartxyz is not a valid username</code>之类的错误。</p><h4 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a>解决方案</h4><p>当共享系统<code>cron</code>或用户<code>cron</code>时，注意用户的添加和删除。</p><h3 id="因素11：crontable-变量"><a href="#因素11：crontable-变量" class="headerlink" title="因素11：crontable 变量"></a>因素11：crontable 变量</h3><h4 id="场景及原因-10"><a href="#场景及原因-10" class="headerlink" title="场景及原因"></a>场景及原因</h4><p>虽然你可以在<code>crontable</code>里面声明环境变量，但是在下面这种情况定时任务是不会执行的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SOME_DIR=/var/log</span><br><span class="line">MY_LOG_FILE=$&#123;SOME_LOG&#125;/some_file.log</span><br><span class="line"></span><br><span class="line">BIN_DIR=/usr/local/bin</span><br><span class="line">MY_EXE=$&#123;BIN_DIR&#125;/some_executable_file</span><br><span class="line"></span><br><span class="line">0 10 * * * $&#123;MY_EXE&#125; some_param &gt;&gt; $&#123;MY_LOG_FILE&#125;</span><br></pre></td></tr></table></figure><p>这是因为在<code>crontable</code>里面只能声明变量，不能对变量进行操作或者执行其他任何<code>shell</code>命令的，所以上述的<code>shell</code>字符串拼接是不会成功的，所以只能声明变量，然后在命令中引用变量。</p><h4 id="解决方案：-2"><a href="#解决方案：-2" class="headerlink" title="解决方案："></a>解决方案：</h4><p><strong>方案1：</strong> </p><p>直接声明变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SOME_DIR=/var/log</span><br><span class="line">MY_LOG_FILE=/var/log/some_file.log</span><br><span class="line"></span><br><span class="line">BIN_DIR=/usr/local/bin</span><br><span class="line">MY_EXE=/usr/local/bin/some_executable_file</span><br><span class="line"></span><br><span class="line">0 10 * * * $&#123;MY_EXE&#125; some_param &gt;&gt; $&#123;MY_LOG_FILE&#125;</span><br></pre></td></tr></table></figure><p><strong>方案2：</strong></p><p>声明多个变量，在命令中引用拼接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SOME_DIR=/var/log</span><br><span class="line">MY_LOG_FILE=some_file.log</span><br><span class="line"></span><br><span class="line">BIN_DIR=/usr/local/bin</span><br><span class="line">MY_EXE=some_executable_file</span><br><span class="line"></span><br><span class="line">0 10 * * * $&#123;BIN_DIR&#125;/$&#123;MY_EXE&#125; some_param &gt;&gt; $&#123;SOME_DIR&#125;/$&#123;MY_LOG_FILE&#125;</span><br></pre></td></tr></table></figure><h3 id="因素12：GUI"><a href="#因素12：GUI" class="headerlink" title="因素12：GUI"></a>因素12：GUI</h3><h4 id="场景及原因-11"><a href="#场景及原因-11" class="headerlink" title="场景及原因"></a>场景及原因</h4><p>如果你的<code>cronjob</code>调用了相关<code>GUI</code>应用时，你需要告诉它们应该使用什么<code>DISPLAY</code>环境变量，从因素<code>1</code>我们可以知道<code>cron</code>中的环境变量是和系统环境变量不一样的，<code>DISPLAY</code>同样如此，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Firefox launch with cron.</span><br></pre></td></tr></table></figure><h4 id="解决方案-8"><a href="#解决方案-8" class="headerlink" title="解决方案"></a>解决方案</h4><p>声明<code>DISPLAY=:0</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * export DISPLAY=:0 &amp;&amp; &lt;command&gt;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前主要总结了影响<code>cron</code>运行的<code>12</code>种因素，当然肯定还存在其他影响因素，本文将持续更新，希望这些坑能够被广大开发者所熟知。</p><p>大家如果有上述以外导致<code>cron</code>不能正常运行的因素可以在博客下方留言，或者在<code>Github</code>上面提<code>pr</code>，笔者已经将本文在<code>Github</code>上面创建了一个仓库，让我们一起不断完善吧 -。-</p><p><code>Github</code>仓库地址：<a href="https://github.com/tony-yin/Why-Cronjob-Not-Work" target="_blank" rel="noopener">https://github.com/tony-yin/Why-Cronjob-Not-Work</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/Why-Crontab-Not_Work.png&quot; alt=&quot;Why Crontab Not Work&quot;&gt;&lt;/center&gt;

&lt;p&gt;作为&lt;code&gt;linux&lt;/code&gt;中的定时任务工具，&lt;code&gt;crontab&lt;/code&gt;被广大开发者所热爱和使用。该技术由来已久，相当成熟，但是在真正使用的时候会时不时地发现为什么&lt;code&gt;crontab&lt;/code&gt;脚本没有按照预期那样执行？本文以本周笔者遇到一个&lt;code&gt;crontab&lt;/code&gt;不能运行的问题为引子，详细地介绍为什么&lt;code&gt;crontab&lt;/code&gt;不运行的各种原因。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
      <category term="Crontab" scheme="https://tony-yin.github.io/tags/Crontab/"/>
    
  </entry>
  
  <entry>
    <title>Daily Article Vol7(2018/6/1 ~ 2018/6/30)</title>
    <link href="https://tony-yin.github.io/2018/07/01/Daily-Article-Vol7/"/>
    <id>https://tony-yin.github.io/2018/07/01/Daily-Article-Vol7/</id>
    <published>2018-07-01T05:07:06.000Z</published>
    <updated>2018-12-13T16:40:24.424Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/6.png" alt="6"></center><p>这是<code>Daily Article</code>系列文章的第七篇，主要记录了<code>2018/6/1 ~ 2018/6/30</code>之间的阅读记录。</p><a id="more"></a><p>六月份主要做了几件事，一个是基于<code>python</code>实现一个守护进程，从<code>unix</code>实现守护进程的底层原理撸了一遍，加深了对<code>linux</code>底层进程一些概念的了解，正好也接触了“骑着企鹅采树莓”系列文章，讲的很不错，通俗易懂；然后把之前基于<code>pci path</code>寻找逻辑磁盘的物理位置整理了下，研究了一波块设备持久化命名；然后学习了下<code>kvm</code>虚拟化技术，并在此之上研究了下虚拟机迁移技术，这其中包括虚拟机到虚拟机的迁移，<code>kvm</code>虚拟机到<code>vmware</code>虚拟机的迁移，虚拟机到物理机的迁移，物理机到物理机的迁移等等；最后研究了下多路径设备，概念有点混乱，不断地啃资料终于有点明白了。不得不说，这些底层的知识真是又多又复杂，只能慢慢啃，加油咯。</p><ol><li><a href="https://unix.stackexchange.com/questions/86764/understanding-dev-disk-by-folders" target="_blank" rel="noopener">understanding /dev/disk/by- folders</a>(6/1) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/online_storage_reconfiguration_guide/persistent_naming" target="_blank" rel="noopener">PERSISTENT NAMING</a>(6/2) <i class="fa fa-star"></i></li><li><a href="http://fibrevillage.com/storage/578-understanding-device-names-managed-by-the-udev-mechanism" target="_blank" rel="noopener">Understanding Device Names Managed by the udev mechanism</a>(6/3) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">Persistent block device naming</a>(6/4) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://wiki.archlinux.org/index.php/Udev_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E8.AE.BE.E7.BD.AE.E9.9D.99.E6.80.81.E8.AE.BE.E5.A4.87.E5.90.8D" target="_blank" rel="noopener">udev (简体中文)</a>(6/9) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://www.linuxquestions.org/questions/linux-server-73/how-to-find-wwn-for-dev-sdc-917269/" target="_blank" rel="noopener">How to find WWN for /dev/sdc</a>(6/9)</li><li><a href="http://www.cnblogs.com/songyaqi/p/4553069.html9.html/l-anaconda/index.html" target="_blank" rel="noopener">SSO单点登录的实现原理是怎样的</a>(6/10)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/sdk/python/python-6/index.html" target="_blank" rel="noopener">可爱的 Python：Curses 编程</a>(6/10)</li><li><a href="http://blog.51cto.com/830909/1751106" target="_blank" rel="noopener">Django cookie和session</a>(6/10)</li><li><a href="https://www.jianshu.com/p/40ec55c6e614?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">这也许是你看到过的最通俗易懂的ElasticSearch文章了（理论篇）</a>(6/10) <i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="https://elasticsearch.cn/slides/109#page=21" target="_blank" rel="noopener">饿了么在ELasticsearch自动化运维平台和监控平台的应用实践</a>(6/10)</li><li><a href="https://humansky.com/2011/12/accidentally-adding-a-git-submodule/" target="_blank" rel="noopener">ACCIDENTALLY ADDING A GIT SUBMODULE</a>(6/11)</li><li><a href="https://www.jianshu.com/p/4e412f48e820?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">聊聊MySQL、HBase、ES的特点和区别</a>(6/12) <i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="http://www.cnblogs.com/qiaoyihang/p/6262806.html" target="_blank" rel="noopener">行存储和列存储</a>(6/13)</li><li><a href="https://time.geekbang.org/column/article/1610" target="_blank" rel="noopener">【极客时间：左耳听风】洞悉PaaS平台的本质</a>(6/13) <i class="fa fa-star"></i></li><li><a href="https://coolshell.cn/articles/17459.html" target="_blank" rel="noopener">【CoolShell】关于高可用的系统</a>(6/13) <i class="fa fa-star"></i></li><li><a href="https://time.geekbang.org/column/article/301" target="_blank" rel="noopener">【极客时间：左耳听风】编程范式游记（1）- 起源</a>(6/14)<i class="fa fa-star"></i></li><li><a href="https://blog.csdn.net/asware/article/details/4159366" target="_blank" rel="noopener">python fork</a>(6/15)</li><li><a href="https://blog.csdn.net/taiyang1987912/article/details/44850999" target="_blank" rel="noopener">Python实例浅谈之五Python守护进程和脚本单例运行</a>(6/16) <i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="https://www.jianshu.com/p/e3f3d49093ca" target="_blank" rel="noopener">Python实现守护进程</a>(6/18) <i class="fa fa-star"></i></li><li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p14_launching_daemon_process_on_unix.html#id1" target="_blank" rel="noopener">在Unix系统上面启动守护进程</a>(6/19) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://yq.aliyun.com/articles/41477?spm=5176.100240.searchblog.39.HyGU9I" target="_blank" rel="noopener">《APUE》读书笔记—第十三章守护进程</a>(6/19) <i class="fa fa-star"></i><i class="fa fa-star"></i> </li><li><a href="http://www.cnblogs.com/vamei/archive/2012/09/20/2694466.html" target="_blank" rel="noopener">【骑着企鹅采树莓】Linux进程基础</a>(6/20) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="http://www.cnblogs.com/vamei/archive/2012/10/07/2713023.html" target="_blank" rel="noopener">【骑着企鹅采树莓】Linux进程关系</a>(6/20) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://www.cnblogs.com/vamei/p/6415434.html" target="_blank" rel="noopener">【骑着企鹅采树莓】树莓派：一个关于教育的故事</a>(6/21)</li><li><a href="http://www.cnblogs.com/vamei/p/6424666.html" target="_blank" rel="noopener">【骑着企鹅采树莓】树莓派心脏：ARM的逆袭</a>(6/21)  <i class="fa fa-star"></i></li><li><a href="http://www.cnblogs.com/vamei/p/6718942.html" target="_blank" rel="noopener">【骑着企鹅采树莓】树莓派的大脑：Linux</a>(6/22)</li><li><a href="https://my.oschina.net/guol/blog/156607" target="_blank" rel="noopener">Linux策略路由</a>(6/22)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-linux-br1/index.html" target="_blank" rel="noopener">【迁移Linux系统1】如何迁移备份和裸机恢复Linux系统</a>(6/24)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-linux-br2/index.html" target="_blank" rel="noopener">【迁移Linux系统2】利用 KIWI Imaging System 定制裸机恢复光盘）</a>(6/26)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-mgrtvm1/index.html" target="_blank" rel="noopener">【虚拟机迁移技术漫谈1】如何在虚拟机和物理机以及虚拟机和虚拟机之间的迁移系统</a>(6/24)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-mgrtvm2/index.html" target="_blank" rel="noopener">【虚拟机迁移技术漫谈2】KVM虚拟机在物理主机之间迁移的实现</a>(6/24) <i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-mgrtvm3/index.html" target="_blank" rel="noopener">【虚拟机迁移技术漫谈3】迁移 VMware 虚拟机到 KVM</a>(6/25) <i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-kvm/" target="_blank" rel="noopener">【虚拟机迁移技术漫谈4】KVM 虚拟机在 IBM System x 上应用</a>(6/25) <i class="fa fa-star"></i><i class="fa fa-star-half-empty"></i></li><li><a href="https://www.ibm.com/developerworks/cn/aix/library/0808_shenlf_ivm/" target="_blank" rel="noopener">【虚拟机迁移技术漫谈5】在IBM集成虚拟化管理器上进行动态分区迁移</a>(6/26)</li><li><a href="http://www.cnblogs.com/biangbiang/p/3222458.html" target="_blank" rel="noopener">利用Qemu Guest Agent (Qemu-ga) 实现 Openstack 监控平台</a>(6/26)</li><li><a href="http://www.zoues.com/2015/10/13/qemu-guest-agent/" target="_blank" rel="noopener">利用qemu-guest-agent冻结文件系统</a>(6/26)</li><li><a href="http://blog.51cto.com/aishangwei/2124944" target="_blank" rel="noopener">kvm 快照</a>(6/26)</li><li><a href="https://access.redhat.com/solutions/732773" target="_blank" rel="noopener">How to enable QEMU guest agent in KVM</a>(6/26)</li><li><a href="http://www.ruanyifeng.com/blog/2018/06/ddos.html" target="_blank" rel="noopener">DDOS 攻击的防范教程</a>(6/27)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-libvirt/index.html" target="_blank" rel="noopener">Libvirt 虚拟化库剖析</a>(6/27) <i class="fa fa-star"></i></li><li><a href="https://www.ibm.com/developerworks/cn/aix/redbooks/live-mobility/" target="_blank" rel="noopener">IBM 动态分区迁移(Live Partition Mobility)技术-概述</a>(6/27)</li><li><a href="http://www.cnblogs.com/vamei/archive/2012/10/04/2711818.html" target="_blank" rel="noopener">【骑着企鹅采树莓】Linux信号基础</a>(6/27) <i class="fa fa-star"></i></li><li><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/6/html/dm_multipath/mpio_description" target="_blank" rel="noopener">DM-MULTIPATH 概述</a>(6/28)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-devmapper/index.html" target="_blank" rel="noopener">Linux 内核中的 Device Mapper 机制</a>(6/28) <i class="fa fa-star"></i></li><li><a href="https://wsgzao.github.io/post/multipath/" target="_blank" rel="noopener">Multipath 多路径配置实践心得</a>(6/28)</li><li><a href="http://www.cnblogs.com/jyzhao/p/7200585.html" target="_blank" rel="noopener">multipath多路径实验01-构建iSCSI模拟环境</a>(6/30) <i class="fa fa-star"></i></li><li><a href="http://www.cnblogs.com/jyzhao/p/7208620.html" target="_blank" rel="noopener">multipath多路径实验02-配置多路径软件</a>(6/30)</li><li><a href="https://blog.csdn.net/jiaping0424/article/details/51591257" target="_blank" rel="noopener">multipath 路径切换</a>(6/30) <i class="fa fa-star"></i></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/6.png&quot; alt=&quot;6&quot;&gt;&lt;/center&gt;

&lt;p&gt;这是&lt;code&gt;Daily Article&lt;/code&gt;系列文章的第七篇，主要记录了&lt;code&gt;2018/6/1 ~ 2018/6/30&lt;/code&gt;之间的阅读记录。&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
      <category term="Daily-Article" scheme="https://tony-yin.github.io/tags/Daily-Article/"/>
    
  </entry>
  
  <entry>
    <title>块设备持久化命名和多路径</title>
    <link href="https://tony-yin.github.io/2018/06/20/Block-device-persistent-name-and-multipath/"/>
    <id>https://tony-yin.github.io/2018/06/20/Block-device-persistent-name-and-multipath/</id>
    <published>2018-06-20T15:15:26.000Z</published>
    <updated>2018-12-13T16:40:24.408Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/fork-in-the-road.png" alt="persistent name"></center><p>众所周知，我们看到的磁盘通常是<code>/dev/sda</code>，<code>/dev/sdb</code>这样的名称，我们可以通过这些磁盘名称对磁盘进行各种操作，例如挂载，分区和格式化等等。但是，如果你的机器上有不止一个<code>SATA</code>，<code>SCSI</code>或<code>IDE</code>磁盘控制器，那么它们所对应的设备节点将会依随机次序添加。这样就可能导致每次引导时设备的名字如<code>/dev/sda</code>与<code>/dev/sdb</code>互换了，再比如硬盘拔插导致磁盘乱序等等，最终导致系统不可引导、<code>kernel panic</code>、或者设备不可见。持久化命名可以解决这些问题。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>持久化命名，顾名思义即一次性或者是短暂的命名，它是一种长久的并且稳定靠谱的命名方案。与之形成鲜明对比的就是<code>/dev/sda</code>这种非持久化命名，这两种命名方案各有各的用处，本文着重对持久化命名进行介绍。持久化命名方案有四种：<code>by-label</code>、<code>by-uuid</code>、<code>by-id</code>和<code>by-path</code>。对于那些使用<code>GUID</code>分区表（<code>GPT</code>）的磁盘，还有额外的两种方案：<code>by-partlabel</code>和<code>by-partuuid</code>。你也可以使用<code>Udev</code>静态设备名方案，这个我们就不作详细解释。下面我将对每种持久化命名方案进行详细的介绍和讲解，不难发现上面所提到的命名方式在<code>/dev</code>目录下都存在一个与之名字对应的文件夹：</p><h2 id="by-label"><a href="#by-label" class="headerlink" title="by-label"></a>by-label</h2><p><code>label</code>表示标签的意思，几乎每一个文件系统都有一个标签。所有有标签的分区都在<code>/dev/disk/by-label</code>目录中列出。这个目录随着分区标签的变动而被动态地创建和销毁。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /dev/disk/by-label</span><br><span class="line"> </span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 10 May 27 23:31 DATA -&gt; ../../sda3</span><br><span class="line">lrwxrwxrwx 1 root root 10 May 27 23:31 SYSTEM -&gt; ../../sda2</span><br></pre></td></tr></table></figure><p>标签必须是唯一的，标签是文件系统的一个属性，所以无法持久地表示单一磁盘阵列设备。</p><p><strong>注意：</strong><code>label</code>是通过从设备中的内容（即数据）获取，所以如果将该内容拷贝至另一个设备中，我们也可以通过<code>blkid</code>来获取磁盘的<code>label</code>。</p><h2 id="by-uuid"><a href="#by-uuid" class="headerlink" title="by-uuid"></a>by-uuid</h2><p><code>UUID</code>是给每个文件系统唯一标识的一种机制，这个标识是在分区格式化时通过文件系统工具生成，比如<code>mkfs</code>，这个唯一标识可以起到解决冲突的作用。所有<code>GNU/Linux</code>文件系统（包括<code>swap</code>和原始加密设备的<code>LUKS</code>头）都支持<code>UUID</code>。<code>FAT</code>和<code>NTFS</code>文件系统并不支持<code>UUID</code>，但是在<code>/dev/disk/by-uuid</code>目录下还是存在着一个更为简单的<code>UID</code>（唯一标识）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /dev/disk/by-uuid/</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 10 May 27 23:31 0a3407de-014b-458b-b5c1-848e92a327a3 -&gt; ../../sda2</span><br><span class="line">lrwxrwxrwx 1 root root 10 May 27 23:31 b411dc99-f0a0-4c87-9e05-184977be8539 -&gt; ../../sda3</span><br><span class="line">lrwxrwxrwx 1 root root 10 May 27 23:31 CBB6-24F2 -&gt; ../../sda1</span><br><span class="line">lrwxrwxrwx 1 root root 10 May 27 23:31 f9fe0b69-a280-415d-a03a-a32752370dee -&gt; ../../sda4</span><br></pre></td></tr></table></figure><p>使用<code>UUID</code>方法的优点是，名称冲突发生的可能性大大低于使用<code>Label</code>的方式。更深层次地讲，它是在创建文件系统时自动生成的。例如，即使设备插入到另一个系统(可能有一个标签相同的设备)，它仍然是唯一的。</p><p>缺点是<code>uuid</code>使得许多配置文件(例如<code>fstab</code>或<code>crypttab</code>)中的长代码行难以读取和破坏格式。此外，每当一个分区被调整大小或重新格式化时，都会生成一个新的UUID，并且必须(手动)调整配置。</p><h2 id="by-path"><a href="#by-path" class="headerlink" title="by-path"></a>by-path</h2><p>该目录中的条目提供一个符号名称，该符号名称通过用于访问设备的<strong>硬件路径</strong>引用存储设备，首先引用<code>PCI hierachy</code>中的存储控制器，并包括<code>SCSI host</code>、<code>channel</code>、<code>target</code>和<code>LUN</code>号，以及可选的分区号。虽然这些名字比使用<code>major</code>和<code>minor</code>号或<code>sd</code>名字更容易，但必须使用谨慎以确保<code>target</code>号不改变在光纤通道<code>SAN</code>环境中(例如，通过使用持久绑定)，如果一个主机适配器切换到到一个不同的<code>PCI</code>插槽的话这个路径也会随之改变。此外，如果<code>HBA</code>无法探测，或者如果驱动程序以不同的顺序加载，或者系统上安装了新的<code>HBA</code>，那么<code>SCSI</code>主机号都有可能会发生变化。附带路径清单的一个例子是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/disk/by-path/pci-0000:03:00.0-scsi-0:1:0:0</span><br></pre></td></tr></table></figure><p>也许还会带着分区号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/disk/by-path/pci-0000:03:00.0-scsi-0:1:0:0-part1</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 上面说了很多种情况都会导致<code>by-path</code>的值可能发生变化，但是在同一时间来说，<code>by-path</code>的值是和物理设备是唯一对应的，也就是说不管怎么说<code>by-path</code>是对应物理机器上面的某个位置的，根据<code>by-path</code>可以获取对应物理位置的设备。（此前<code>megaraid</code>通过逻辑磁盘获取物理磁盘位置就是根据这个原理）</p><p>对于<code>iSCSI</code>设备，路径/名称映射从目标名称和门户信息映射到<code>sd</code>名称。<br>应用程序通常不适合使用这些基于路径的名称。这是因为这些路径引用可能会更改存储设备，从而可能导致将不正确的数据写入设备。基于路径的名称也不适用于多路径设备，因为基于路径的名称可能被误认为是单独的存储设备，导致不协调的访问和数据的意外修改。</p><p>此外，基于路径的名称是特定于系统的。当设备被多个系统访问时，例如在集群中，这会导致意外的数据更改。</p><h2 id="by-id"><a href="#by-id" class="headerlink" title="by-id"></a>by-id</h2><p>此目录中的条目提供一个符号名称，该符号名称通过唯一标识符(与所有其他存储设备不同)引用存储设备。标识符是设备的属性，但不存储在设备的内容(即数据)中。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dev/disk/by-id/scsi-3600508e000000000ce506dc50ab0ad05</span><br><span class="line">/dev/disk/by-id/wwn-0x600508e000000000ce506dc50ab0ad05</span><br></pre></td></tr></table></figure><p>该<code>id</code>从设备的全局<code>ID</code>（<code>WWID</code>）或设备序列号中获取。<code>/dev/disk/by-id</code>条目也可能包含一个分区号。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dev/disk/by-id/scsi-3600508e000000000ce506dc50ab0ad05-part1</span><br><span class="line">/dev/disk/by-id/wwn-0x600508e000000000ce506dc50ab0ad05-part1</span><br></pre></td></tr></table></figure><p><code>World Wide Identifier</code>（<code>WWID</code>）可用于可靠的识别设备。<code>SCSI</code>标准要求所有<code>SCSI</code>设备提供一个持久的、系统无关的<code>ID</code>。<code>WWID</code>标识符保证对每个存储设备都是唯一的，并且独立于用于访问设备的路径。</p><p>这个标识符可以通过发出<code>SCSI</code>查询来获取设备标识重要厂商数据(第<code>0x83</code>页)或单位序列号(第<code>0x80</code>页)。从这些<code>wwid</code>到当前<code>/dev/sd</code>名称的映射可以在<code>/dev/disk/by-id/</code>目录中维护的符号链接中看到。<br>例如，具有页<code>0x83</code>标识符的设备将具有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scsi-3600508b400105e210000900000490000 -&gt; ../../sda</span><br></pre></td></tr></table></figure><p>或者，具有页<code>0x80</code>标识符的设备将具有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scsi-SSEAGATE_ST373453LW_3HW1RHM6 -&gt; ../../sda</span><br></pre></td></tr></table></figure><p><code>Red Hat Enterprise Linux 5</code>自动维护从基于<code>wwid</code>的设备名称到系统上当前<code>/dev/sd</code>名称的正确映射。应用程序可以使用<code>/dev/ disk/by-id/</code>的链接引用磁盘上的数据，即使设备的路径改变，甚至当从不同系统访问该设备时都是如此。</p><p>但是当设备被插入到硬件控制器的端口时，而这个端口又受另一个子系统控制（即多路径），<code>by-id</code>的值也会改变。多路径设备会在下面详细讲解。</p><h2 id="by-partlabel-amp-amp-by-partuuid"><a href="#by-partlabel-amp-amp-by-partuuid" class="headerlink" title="by-partlabel &amp;&amp; by-partuuid"></a>by-partlabel &amp;&amp; by-partuuid</h2><p>这两个和上面提到的<code>by-label</code>和<code>by-uuid</code>类似，只不过是在<code>GPT</code>磁盘上。</p><h2 id="多路径设备"><a href="#多路径设备" class="headerlink" title="多路径设备"></a>多路径设备</h2><p>所谓多路径设备指的是从一个系统到一个设备存在多个路径，这种现象主要出现在光纤网络的<code>SAN</code>下，主要是做数据链路冗余以达到高可用的效果，<strong>即对应底层一个物理设备，可能存在多个路径表示它</strong>，具体参考<code>refer</code>下面有关文章。</p><p>如果从一个系统到一个设备有多个路径，那么<code>device-mapper-multipath</code>使用<code>WWID</code>来检测它。然后在<code>/dev/mapper/wwid</code>中显示一个“伪设备”，例如<code>/dev/ mapper/3600508b400105df70000000ac0000</code>。</p><p><code>Device-mapper-multipath</code>显示映射到非持久标识符：<code>Host:Channel:Target:LUN</code>， <code>/dev/sd</code>名称，以及<code>major:minor</code>号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3600508b400105df70000e00000ac0000 dm-2 vendor,product </span><br><span class="line">[size=20G][features=1 queue_if_no_path][hwhandler=0][rw] </span><br><span class="line">\_ round-robin 0 [prio=0][active] </span><br><span class="line"> \_ 5:0:1:1 sdc 8:32  [active][undef] </span><br><span class="line"> \_ 6:0:1:1 sdg 8:96  [active][undef]</span><br><span class="line">\_ round-robin 0 [prio=0][enabled] </span><br><span class="line"> \_ 5:0:0:1 sdb 8:16  [active][undef] </span><br><span class="line"> \_ 6:0:0:1 sdf 8:80  [active][undef]</span><br></pre></td></tr></table></figure><p><code>Device-mapper-multipath</code>在系统上自动维护每个基于<code>wwid</code>的设备名称和其对应的<code>/dev/sd</code>名称的正确映射。这些名称即使是在路径发生改变时也是持久的，并且当从不同的系统访问设备时它们仍然是一致的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了方便管理和使用设备，<code>linux</code>操作系统给我们提供了上面这么多持久化命名方式。它们各自有各自的优势和使用场景。<code>by-label</code>和<code>by-uuid</code>都和文件系统相关，<code>by-label</code>是通过读取设备中的内容获取，<code>by-uuid</code>则是随着每次文件系统的创建而创建，所以<code>by-uuid</code>的持久化程度更高一些；持久化程度最高的要属<code>by-path</code>和<code>by-id</code>了，因为它们都是根据物理设备的位置或者信息而和链接做对应的，<code>by-path</code>会因为路径的变化而变化；而<code>by-id</code>则不会因为路径或者系统的改变而改变，它只会在多路径的情况下发生改变。这两个在通过虚拟设备名称寻找物理设备的场景下都十分有用。</p><p>多路径设备则帮助我们在<code>SAN</code>等场景下提高了数据传输的可用性，目前由于网络带宽的发展，它在<code>iscsi</code>场景下也频繁亮相。</p><h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ul><li><a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_%28简体中文%29" target="_blank" rel="noopener">Persistent block device naming</a></li><li><a href="http://fibrevillage.com/storage/578-understanding-device-names-managed-by-the-udev-mechanism" target="_blank" rel="noopener">Understanding Device Names Managed by the udev mechanism</a></li><li><a href="https://wiki.archlinux.org/index.php/Udev_%28简体中文%29#.E8.AE.BE.E7.BD.AE.E9.9D.99.E6.80.81.E8.AE.BE.E5.A4.87.E5.90.8D" target="_blank" rel="noopener">Udev</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/online_storage_reconfiguration_guide/persistent_naming" target="_blank" rel="noopener">PERSISTENT NAMING</a></li><li><a href="https://www.linuxquestions.org/questions/linux-server-73/how-to-find-wwn-for-dev-sdc-917269/" target="_blank" rel="noopener">How to find WWN for /dev/sdc</a></li><li><a href="https://unix.stackexchange.com/questions/86764/understanding-dev-disk-by-folders" target="_blank" rel="noopener">understanding /dev/disk/by- folders</a></li><li><a href="https://blog.csdn.net/jiaping0424/article/details/51591257" target="_blank" rel="noopener">multipath 路径切换</a></li><li><a href="http://www.cnblogs.com/jyzhao/p/7200585.html" target="_blank" rel="noopener">multipath多路径实验01-构建iSCSI模拟环境</a></li><li><a href="http://www.cnblogs.com/jyzhao/p/7208620.html" target="_blank" rel="noopener">multipath多路径实验02-配置多路径软件</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-devmapper/index.html" target="_blank" rel="noopener">Linux 内核中的 Device Mapper 机制</a></li><li><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/6/html/dm_multipath/mpio_description" target="_blank" rel="noopener">DM-MULTIPATH 概述</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/fork-in-the-road.png&quot; alt=&quot;persistent name&quot;&gt;&lt;/center&gt;

&lt;p&gt;众所周知，我们看到的磁盘通常是&lt;code&gt;/dev/sda&lt;/code&gt;，&lt;code&gt;/dev/sdb&lt;/code&gt;这样的名称，我们可以通过这些磁盘名称对磁盘进行各种操作，例如挂载，分区和格式化等等。但是，如果你的机器上有不止一个&lt;code&gt;SATA&lt;/code&gt;，&lt;code&gt;SCSI&lt;/code&gt;或&lt;code&gt;IDE&lt;/code&gt;磁盘控制器，那么它们所对应的设备节点将会依随机次序添加。这样就可能导致每次引导时设备的名字如&lt;code&gt;/dev/sda&lt;/code&gt;与&lt;code&gt;/dev/sdb&lt;/code&gt;互换了，再比如硬盘拔插导致磁盘乱序等等，最终导致系统不可引导、&lt;code&gt;kernel panic&lt;/code&gt;、或者设备不可见。持久化命名可以解决这些问题。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Disk" scheme="https://tony-yin.github.io/tags/Disk/"/>
    
  </entry>
  
  <entry>
    <title>Python Snack 最佳实践</title>
    <link href="https://tony-yin.github.io/2018/06/03/Python-Snack-Best-Practice/"/>
    <id>https://tony-yin.github.io/2018/06/03/Python-Snack-Best-Practice/</id>
    <published>2018-06-03T05:07:06.000Z</published>
    <updated>2018-12-13T16:40:24.453Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/python_snack.jpg" alt="python snack"></center><p>  了解<code>linux</code>的人应该听说过<code>Newt</code>，<code>Newt</code>是一个为<code>RedHat</code>安装程序而设计的基于文本的窗口开发工具，它是由<code>c</code>语言编写并不依赖<code>X</code>包，<code>linux</code>下的<code>dialog</code>和<code>whiptail</code>都是基于它。而我们今天讨论的<code>snack</code>则是<code>Newt</code>提供的<code>python</code>接口，<code>redhat</code>的系统都自带这个模块，本文就如何使用<code>snack</code>制作伪终端页面展开讲解，并配合代码展示实现效果。</p><a id="more"></a><h2 id="用餐介绍"><a href="#用餐介绍" class="headerlink" title="用餐介绍"></a>用餐介绍</h2><p>为啥说是最佳实践呢？因为我使用<code>snack</code>的过程中，上网查阅相关资料，发现有关信息甚少。偶尔几篇文章都是处于<code>API</code>或者<code>Demo</code>的级别，并且讲的都不全，更别说高级扩展功能了。我正好工作需要给我们的一个系统做一个终端部署控制台<code>UI</code>，所以我就使用了<code>python snack</code>来实现，期间不断新需求，不断迭代，从基本页面到增删改查，再到校验、再到配置导入、再到进度条等等，不断的迭代开发让我对<code>snack</code>不断地加深认知，它支持的或不支持的我都想办法一一解决，所以在这把我这段时间的收货进行总结并分享给需要的人。</p><h2 id="上菜单"><a href="#上菜单" class="headerlink" title="上菜单"></a>上菜单</h2><p>本文实践的需求是做一个部署控制台工具，该工具主要分为三个阶段：基础配置、高级配置和部署进度。基础配置页面需要我们创建一些主机，填写一些主机的信息，比如<code>IP</code>、<code>Hostname</code>和<code>Password</code>，然后高级配置我们也需要创建一些主机，不过我们可以复用基础设置的主机，所以我们的工具要支持在高级配置中导入基础配置的功能，在高级配置中我们还有一个全局配置，也就是不限于单个主机的配置（其中具体部署原理和是非，我就不多展开赘述，这不是本文的重点）。最后就是进度条页面，我们可以展示部署的过程阶段和相关时间信息。</p><center><img src="http://cdn.tony-yin.site/deploy_console.gif" alt="deploy console"></center><blockquote><p>项目地址：<a href="https://github.com/tony-yin/Best-practice-of-python-snack" target="_blank" rel="noopener">https://github.com/tony-yin/Best-practice-of-python-snack</a></p></blockquote><h2 id="开胃凉菜"><a href="#开胃凉菜" class="headerlink" title="开胃凉菜"></a>开胃凉菜</h2><h3 id="远古时代"><a href="#远古时代" class="headerlink" title="远古时代"></a>远古时代</h3><p>先上几道凉菜，给大家开开胃。所谓的凉菜就是介绍一下<code>python snack</code>的基础组件，基础组件很多，类似<code>html</code>，主要有：</p><ul><li>Textbox</li><li>TextboxReflowed</li><li>Button</li><li>Compactbutton</li><li>Checkbox</li><li>Listbox</li><li>SingleRadioButton</li><li>Scale</li><li>Entry</li></ul><p>然后就是一些组合组件，也就是基于上述基础组件封装而得到，主要有：</p><ul><li>RadioBar</li><li>ButtonBar</li><li>CheckboxTree</li></ul><p>上面这些组件就是所有的基础组件（组合组件也算基础组件），这些组件最终呈现还需要<code>grid</code>和<code>form</code>这两个组件，<code>grid</code>表示“网格”的意思，跟<code>html</code>中的<code>table</code>类似，由行和列组成，我们的基础组件需要放在网格中来实现页面布局；而<code>form</code>也类似“表单”，我们需要把<code>grid</code>填充到<code>form</code>中，运行后，就可以看到图形化页面了。</p><h3 id="工业革命"><a href="#工业革命" class="headerlink" title="工业革命"></a>工业革命</h3><p>经过上面基础组件的介绍，想必你对<code>snack</code>的组件有了充分的了解，这时候你可以参考文末的<code>refer</code>做几个小<code>demo</code>，做了之后你会发现页面是出来了，emmm… 可是感觉好繁琐哦，很多重复性的代码，而且页面布局也怪怪的，如果要把布局搞好，又需要加很多代码。</p><p>我们把用基础组件的阶段称之为“远古时代”，每做一个<code>window</code>，都得一瓦一砖地慢慢堆砌，这样效率太低了，所以我们急需一波“工业革命”来提高生产力。</p><p><code>python snack</code>似乎考虑到了这个问题，它在上述基础组件之外还提供了<code>dialog</code>相关组件，<code>dialog</code>组件即集大成者，一个<code>dialog</code>组件就是一个<code>window</code>，也就是我们上面所说的<code>form</code>，并且该<code>form</code>中填充了必需的各种基础组件，<code>dialog</code>组件主要有：</p><ul><li>ListboxChoiceWindow</li><li>ButtonChoiceWindow</li><li>EntryWindow</li></ul><h3 id="返璞归真"><a href="#返璞归真" class="headerlink" title="返璞归真"></a>返璞归真</h3><p>当今社会，大家吃惯了大鱼大肉，反而更是想念农村的野味。同理，我们用惯了“工业革命”的产物，发现虽然可用，但是仅仅停留在基础可用级别上，想换换样式，加加自己的定制化需求，都是有限的，完全达不到新需求的技术实现要求。所以，我们不能只知道用别人实现的现成的产物，我们可以尝试着“返璞归真”一下，回归最初的“远古时代”，自己实现一把“工业革命”。所谓的“dialog”组件无非也就是基础组件的封装而已，我们也可以自己实现一套自己的组件库，这个在前端是非常流行的，例如<code>font-awesome</code>、<code>iview</code>、<code>ant-design</code>等等。这里我们自己实现了以下<code>dialog</code>：</p><ul><li>ExtButtonChoiceWindow</li><li>ExtAlert</li><li>ExtCheckboxWindow</li><li>ExtListboxChoiceWindow</li><li>ExtEntryWindow</li><li>ExtPwdEntryWindow</li><li>ExtProgressWindow</li><li>ExtTextWindow</li></ul><p>扩展的功能主要有：</p><ul><li>热键支持扩展</li><li>按钮样式扩展</li><li>布局大小自动化扩展</li><li>暗文输入框扩展</li><li>弹出窗口扩展</li><li>进度条窗口信息展示扩展</li><li>动态展示扩展</li></ul><blockquote><p>扩展组件库地址：<a href="https://github.com/tony-yin/Best-practice-of-python-snack/blob/master/widget_extlib.py" target="_blank" rel="noopener">widget extend library</a></p></blockquote><h2 id="管饱正菜"><a href="#管饱正菜" class="headerlink" title="管饱正菜"></a>管饱正菜</h2><p>凉菜不够，正菜来凑。上面就是把<code>python snack</code>的<code>API</code>罗列了一下，做个小<code>Demo</code>还行，但是距离产品化还很远，接下来我结合我做部署控制台工具的实践经历分享一下几个“正菜”，必须够硬，不接受反驳，不接受批评， O(∩_∩)O ~</p><h3 id="热键"><a href="#热键" class="headerlink" title="热键"></a>热键</h3><p><code>python snack</code>提供了两种帮助用户使用的途径，一种是窗口下方的操作提示栏，另一个就是热键了。热键就是快捷键，比如我们可以敲击键盘上面的<code>ESC</code>键实现页面的返回。我们可以通过调用<code>grid</code>的<code>runOnce</code>接口获取热键的输入，例如<code>hotkey = g.runOnce()</code>，然后我们根据<code>hotkey</code>的值进行判断并执行对应的操作。</p><h3 id="页面切换"><a href="#页面切换" class="headerlink" title="页面切换"></a>页面切换</h3><p>当我们存在多个页面的时候，我们需要页面切换的功能，翻阅文档，并没有发现提供类似的功能。在我们的工具中，页面切换主要有两种方式，一种是点击<code>button</code>，一种是热键，既然没有原生的页面切换接口，我们就根据触发方式手动切换页面。比如我们想实现页面<code>1</code>点击<code>next</code>按钮想跳转页面<code>2</code>，那我们只需要获取<code>button</code>的返回值，判断是否为<code>next</code>，如果是<code>next</code>，直接调用页面<code>2</code>的方法即可，热键同理，即判断热键内容是否为对应热键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ret, button, lb = ExtListboxChoiceWindow(</span><br><span class="line">    screen, </span><br><span class="line">    &apos;Distribute Storage Config&apos;,</span><br><span class="line">    &apos;Distribute Storage Config&apos;,</span><br><span class="line">    ips,</span><br><span class="line">    buttons=(&quot;prev&quot;, &quot;next&quot;, &quot;exit&quot;),</span><br><span class="line">    width=50,</span><br><span class="line">    height=5,</span><br><span class="line">)                                                                                                                                        </span><br><span class="line">if button == &quot;exit&quot; or ret == &quot;ESC&quot;:</span><br><span class="line">    screen.finish()</span><br><span class="line">elif button == &quot;prev&quot;:</span><br><span class="line">    Welcome_Deploy_Window()</span><br><span class="line">elif button == &quot;next&quot;:</span><br><span class="line">    Additional_Config_Window()</span><br><span class="line">elif lb is not None:</span><br><span class="line">    Basic_Host_Window(lb)</span><br></pre></td></tr></table></figure><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><p>增删改查永远是一个软件系统绕不开的基础功能。</p><p><strong>“查”：</strong></p><p>首先是整体查看，我们可以通过一个列表展示所有信息，这时候我们可以用<code>ExtListboxChoiceWindow</code>组件来实现；然后就是单个查看了，我们可能有多条信息，我们想查看单个信息的详细内容时，我们可以通过点击具体的<code>item</code>进入详细信息的<code>dialog</code>，如何实现呢？<code>listbox</code>中有一个<code>current</code>的概念，也就是<code>listbox</code>中每个<code>li</code>的唯一标识，我们可以用列表的<code>index</code>来填充，因为往往列表页面的信息也无非是数组或者是列表的方式，我们获取到当前的<code>current</code>，即获取到数组的索引，然后就是根据索引查值了，我们再调用新增页面，将查到的值赋值到<code>Textbox</code>即可，<code>Textbox</code>有一个<code>setText</code>就是做这个事情的。当然我们的<code>ExtEntryWindow</code>组件也可以做到赋值填充。请参考上述代码中的<code>lb</code>，其实就是<code>listbox</code>的<code>li.current()</code>接口。</p><p><strong>“增”：</strong></p><p>我们可以通过一个新增按钮或者<code>listbox</code>中的一个<code>li</code>作为新增按钮来触发新增操作，点击后出现一个<code>dialog</code>，<code>dialog</code>中有一些<code>Textbox</code>、<code>Radio</code>、<code>Checkbox</code>等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def Basic_Host_Window(current, data=None):</span><br><span class="line">    buttons = [ &apos;save&apos;, &apos;cancel&apos;, &apos;exit&apos;]</span><br><span class="line">    if not data:</span><br><span class="line">        data = [&apos;IP Address:&apos;, &apos;Hostname:&apos;, &apos;Password:&apos;]</span><br><span class="line">        if current != &apos;add&apos;:</span><br><span class="line">            data = get_format_data(Basic_Config[current], BASIC_TYPE)</span><br><span class="line">            buttons.insert(1, &apos;Delete&apos;)</span><br><span class="line"></span><br><span class="line">    host = ExtEntryWindow(</span><br><span class="line">        screen,</span><br><span class="line">        &apos;&#123;&#125; host&apos;.format(&apos;Add&apos; if current == &apos;add&apos; else &apos;Edit&apos;),</span><br><span class="line">        &apos;Please fill storage host info.&apos;,</span><br><span class="line">        data,</span><br><span class="line">        width = 40, </span><br><span class="line">        entryWidth = 40, </span><br><span class="line">        buttons = buttons</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p><strong>“改”：</strong></p><p>修改操作的方法是在<code>list</code>页面选中需要修改的项，然后进入详情页面，可以查看之前创建时填写的信息，也就是我们在“查”中查看单个信息提到的方式，我们所要做的就是在用户点击<code>save</code>按钮的时候，获取用户编辑后的数据，再进行一次修改即可，在我们工具中，此操作就是根据索引修改数组中对应索引的数据而已。</p><p><strong>“删”：</strong></p><p>有增就有删，这边我暂时还没实现批量删除的功能，一方面<code>python snack</code>的支持功能有限，一方面时间有限，所以我只实现了单个删除的功能，在新增和编辑的页面添加一个<code>delete</code>按钮即可，为了提醒用户错删，我们还要加上一个确认提示框。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if host[1] == &quot;delete&quot;:</span><br><span class="line">    button = ExtButtonChoiceWindow(</span><br><span class="line">        screen,</span><br><span class="line">        &apos;Delete host&apos;,</span><br><span class="line">        &apos;Are you sure to delete current host?&apos;</span><br><span class="line">    )</span><br><span class="line">    if button == &quot;ok&quot;:</span><br><span class="line">        del(Basic_Config[current])</span><br><span class="line">    else:</span><br><span class="line">        Basic_Host_Window(current)</span><br></pre></td></tr></table></figure><h3 id="组件扩展"><a href="#组件扩展" class="headerlink" title="组件扩展"></a>组件扩展</h3><p>构建自己的组件库真的很有必要，对于默认的<code>button</code>样式，我真是吐槽到不想再吐槽，它居然还认为自己的<code>border</code>很<code>nice</code>？！所以最终构建自己的组件库的初衷就是想把各个<code>dialog</code>中的<code>button</code>改为<code>compactbutton</code>，没办法，默认的<code>dialog</code>组件不给改呀，所以我们得自己返璞归真一下。</p><p>当然我们做扩展组件库，也不是仅仅因为一个<code>button</code>样式，还有很多新需求都要依赖自己扩展的组件。比如热键，原生<code>dialog</code>无法支持热键；还有进度条的进度时间和任务信息展示；还有<code>Gridform</code>的动态布局等等。具体就不一一介绍了，想深入了解的直接看代码，做个小<code>Demo</code>，一目了然。</p><h2 id="爽口甜菜"><a href="#爽口甜菜" class="headerlink" title="爽口甜菜"></a>爽口甜菜</h2><p>充实的正菜吃饱了，是时候来一波甜菜漱漱口，解解渴了。</p><p>在做进度条页面的时候，想除了显示进度任务完成信息之外，还想显示一下开始时间和花费时间。发现<code>python</code>的<code>time</code>模块比较坑爹，对于时间差的转换支持不行，查阅资料只发现<code>datetime</code>可以将时间差转换为微秒、秒和小时三个单位，但是我想实现时间差的自动转换，也就是<code>60s</code>自动转换为<code>1min</code>，<code>60min</code>转为<code>1h</code>，<code>24h</code>转为<code>1d</code>，超越天为单位的我就不进行转换了，逻辑不难，只是拿出来分享给有需要的人，不必重复造轮子罢了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def get_time_interval(start_time):</span><br><span class="line">    start_time = datetime.fromtimestamp(start_time)</span><br><span class="line">    now_time = datetime.fromtimestamp(time.time())</span><br><span class="line">    interval = (now_time - start_time).seconds</span><br><span class="line">    format_interval = get_format_interval(interval)                                                                                          </span><br><span class="line">    return format_interval</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_format_interval(interval):</span><br><span class="line">    if interval &lt; 60:</span><br><span class="line">        format_interval = &quot;&#123;&#125;s&quot;.format(str(interval))</span><br><span class="line">    elif 60 &lt;= interval &lt; 60*60:</span><br><span class="line">        format_interval = &quot;&#123;&#125;min &#123;&#125;s&quot;.format(</span><br><span class="line">            str(interval/60), str(interval%60))</span><br><span class="line">    elif 60*60 &lt;= interval &lt; 60*60*24:</span><br><span class="line">        format_interval = &quot;&#123;&#125;h &#123;&#125;min &#123;&#125;s&quot;.format(</span><br><span class="line">            str(interval/(60*60)),</span><br><span class="line">            str(interval%(60*60)/60),</span><br><span class="line">            str(interval%(60*60)%60)</span><br><span class="line">        )</span><br><span class="line">    elif 60*60*24 &lt;= interval:</span><br><span class="line">        format_interval = &quot;&#123;&#125;d &#123;&#125;h &#123;&#125;min &#123;&#125;s&quot;.format( </span><br><span class="line">str(interval/(60*60*24)),</span><br><span class="line">            str(interval%(60*60*24)/60*60),</span><br><span class="line">            str(interval%(60*60)/60),</span><br><span class="line">            str(interval%(60*60)%60)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    return format_interval</span><br></pre></td></tr></table></figure><h2 id="用餐总结"><a href="#用餐总结" class="headerlink" title="用餐总结"></a>用餐总结</h2><p>原本只是想做一个终端图形化的进度条页面，但是后续需求越来越多，导致做成了一个部署控制台工具，整个工程开发和优化花了大约两个星期的时间，项目中遇到的很多难点和问题很多都与<code>python snack</code>无关，所以没有做详细解释，就比如上述的甜菜，大家有兴趣的自行翻阅代码即可。</p><p><code>python snack</code>还有很多未知的我没有使用，比如<code>checkbox tree</code>等，但我相信万变不离其宗，有了这次实践，其他组件的使用和扩展应该不会花很多时间，其实做这个东西，我最深的感触就是前端发展的迅速，<code>python snack</code>是<code>2000</code>年初的产物了，很多页面逻辑跟<code>jQuery</code>比起来要弱的多，更别说现在的<code>angular</code>，<code>vue</code>等等了，但是领域不同，毕竟是伪终端页面，能做成这样已经不错了。如果是真正的桌面图形化界面（<code>GUI</code>），有<code>pyqt</code>这种神器，功能貌似很强大。</p><p>我在之前的一个项目中，就使用过<code>python snack</code>做的控制台，当然当时不知道是用这个技术做的，当时觉得蛮牛的，尝试过修改终端文字成汉子，后来没有成功，便不了了之。这次机缘巧合，工作需要做这么一个控制台，在工作中学习和使用自己感兴趣的技术的感觉真是爽呀。工作中运用技术和自己业余时间学习新技术并做个小<code>Demo</code>完全是不一样的，工作中运用会不断有新需求，不断精益求精，不断深入。所以以工作作为平台，实现自己的技术价值，会有很大的成就感，与大家共勉咯。(#^.^#)</p><blockquote><p>完整项目代码地址：<a href="https://github.com/tony-yin/Best-practice-of-python-snack" target="_blank" rel="noopener">https://github.com/tony-yin/Best-practice-of-python-snack</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/python_snack.jpg&quot; alt=&quot;python snack&quot;&gt;&lt;/center&gt;

&lt;p&gt;  了解&lt;code&gt;linux&lt;/code&gt;的人应该听说过&lt;code&gt;Newt&lt;/code&gt;，&lt;code&gt;Newt&lt;/code&gt;是一个为&lt;code&gt;RedHat&lt;/code&gt;安装程序而设计的基于文本的窗口开发工具，它是由&lt;code&gt;c&lt;/code&gt;语言编写并不依赖&lt;code&gt;X&lt;/code&gt;包，&lt;code&gt;linux&lt;/code&gt;下的&lt;code&gt;dialog&lt;/code&gt;和&lt;code&gt;whiptail&lt;/code&gt;都是基于它。而我们今天讨论的&lt;code&gt;snack&lt;/code&gt;则是&lt;code&gt;Newt&lt;/code&gt;提供的&lt;code&gt;python&lt;/code&gt;接口，&lt;code&gt;redhat&lt;/code&gt;的系统都自带这个模块，本文就如何使用&lt;code&gt;snack&lt;/code&gt;制作伪终端页面展开讲解，并配合代码展示实现效果。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
      <category term="Python" scheme="https://tony-yin.github.io/tags/Python/"/>
    
      <category term="Snack" scheme="https://tony-yin.github.io/tags/Snack/"/>
    
      <category term="Console" scheme="https://tony-yin.github.io/tags/Console/"/>
    
  </entry>
  
  <entry>
    <title>Daily Article Vol6(2018/5/1 ~ 2018/5/31)</title>
    <link href="https://tony-yin.github.io/2018/06/01/Daily-Article-Vol6/"/>
    <id>https://tony-yin.github.io/2018/06/01/Daily-Article-Vol6/</id>
    <published>2018-06-01T05:07:06.000Z</published>
    <updated>2018-12-13T16:40:24.423Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/5-2.png" alt="May"></center><p>五月份主要基于<code>python sna</code>实现了一个终端伪图形化界面的部署控制台，提供了填写配置信息、校验信息、导入信息和进度监控等功能，详情请见<a href="http://www.tony-yin.site/2018/06/03/Python-Snack-Best-Practice/" target="_blank" rel="noopener">【Python Snack 最佳实践】</a>。这是我之前一直感兴趣想做的事情，这次正好借助工作的契机对其有了深入的了解和学习，收获颇多。五月份假期多，团建，还有工作进度赶，导致自己的阅读时间受到了影响，大多数阅读都是围绕着工作内容，极客时间这些<code>APP</code>、技术博客和微信公众号的很多技术资源，自己都没有规律地学习。这些都不是借口啦，主要还是陷入吃鸡，不能自拔，哈哈哈。（已经卸了，我这个人容易上瘾然而又有点嫌麻烦，这对我来说是最简单有效的方式）</p><a id="more"></a><p>加入公司两个多月了，工作内容不断增多，难度也不断加大，由起初的合作工作到现在的独立负责某个<code>task</code>，也渐渐地忙了起来，总体来说还是游刃有余，能把自己的工作量<code>cover</code>住，希望自己继续加油。不过，这段时间大多数工作内容跟<code>ceph</code>关系不大，比如<code>ctdb rados</code>、<code>megaraid location</code>、<code>deploy console</code>等，毕竟是做产品，工作内容还是依赖产品需求，不过我还是不希望以后工作内容长期游离于<code>ceph</code>之外，因为今天的期望就是深入<code>ceph</code>，深入存储，如果工作上满足不了我的话，自己课余时间要挤一点时间做做研究了。不过好在现在项目上除了<code>ceph</code>也有很多东西是目前的我所不懂的，有学习的机会也不错，只要每天都能学习到不熟悉的东西便是极好的。除了存储，我们组也在往大数据和检索的方向靠，这两个我也都蛮感兴趣的，最近也稍微了解了下<code>elaticsearch</code>，目前好像很火的样子，六月底南京有一个<code>ES</code>线下沙龙，已经报名参加了，吼吼。</p><p>加油咯 ~</p><ol><li><a href="http://www.voidcn.com/article/p-yvycalqd-brm.html" target="_blank" rel="noopener">Django实现CAS+OAuth2</a>(5/5) <i class="fa fa-star"></i></li><li><a href="https://weibo.com/p/1001603934517592239583?mod=zwenzhang#_loginLayer_1525517479194" target="_blank" rel="noopener">NVMe over Fabric</a>(5/6) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://www.wzxue.com/ceph-librbd-block-library/" target="_blank" rel="noopener">解析Ceph: Librbd–块存储库</a>(5/7)</li><li><a href="https://draveness.me/docker" target="_blank" rel="noopener">Docker 核心技术与实现原理</a>(4)(5/11 ~ 5/13) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://blog.csdn.net/feng88724/article/details/7262514" target="_blank" rel="noopener">【Django】@login_required用法简介</a>(5/14)</li><li><a href="http://www.nowamagic.net/academy/detail/1318909" target="_blank" rel="noopener">request.META里包含了哪些数据？</a>(5/15)</li><li><a href="https://blog.csdn.net/naipeng/article/details/77162764" target="_blank" rel="noopener">CTDB代码流程简要梳理</a>(5/16) <i class="fa fa-star"></i></li><li><a href="https://blog.csdn.net/liuying_1001/article/details/77994642" target="_blank" rel="noopener">ctdb原理介绍</a>(5/17~5/18) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://opstrip.com/2017/06/14/howto-monitor-raidCard-status-with-commandline-MegaCli/" target="_blank" rel="noopener">MegaCli:如何使用命令行监控RAID卡状态</a>(5/18)</li><li><a href="http://www.cnblogs.com/lustralisk/p/pythonProgressBar.html" target="_blank" rel="noopener">Python实现控制台中的进度条</a>(5/21)</li><li><a href="https://coolshell.cn/articles/677.html" target="_blank" rel="noopener">用PYTHON写NCURSES UI</a>(5/22)</li><li><a href="https://blog.csdn.net/naipeng/article/details/77162764" target="_blank" rel="noopener">NEWT 程序设计指南</a>(5/23)</li><li><a href="http://www.wanware.com/tsgdocs/snack.html" target="_blank" rel="noopener">Quick Guide to Python’s Snack Module</a>(5/23)</li><li><a href="http://www.cnblogs.com/Xjng/p/3869869.html" target="_blank" rel="noopener">python在linux制作图形界面（snack）</a>(5/23)</li><li><a href="https://blog.csdn.net/taiyang1987912/article/details/49273601" target="_blank" rel="noopener">python在linux(anaconda)的图形界面（snack）</a>(5/24)</li><li><a href="https://npyscreen.readthedocs.io/introduction.html#example-code" target="_blank" rel="noopener">An introduction to npyscreen</a>(5/24)</li><li><a href="https://helloacm.com/creating-ui-controls-under-linux-shell-console-using-whiptail-utility/" target="_blank" rel="noopener">Creating UI Controls under Linux Shell Console using whiptail Utility</a>(5/25)</li><li><a href="https://www.linuxjournal.com/article/2807" target="_blank" rel="noopener">Dialog: An Introductory Tutorial</a>(5/25)</li><li><a href="https://askubuntu.com/questions/747143/create-a-progress-bar-in-bash" target="_blank" rel="noopener">Create a progress bar in bash</a>(5/25)</li><li><a href="https://www.tecmint.com/monitor-copy-backup-tar-progress-in-linux-using-pv-command/" target="_blank" rel="noopener">How to Monitor Progress of (Copy/Backup/Compress) Data using ‘pv’ Command</a>(5/25)</li><li><a href="http://blog.ihipop.info/2010/10/1736.html" target="_blank" rel="noopener">Python中如何写控制台进度条的整理</a>(5/26) <i class="fa fa-star"></i></li><li><a href="https://www.ibm.com/developerworks/cn/linux/sdk/python/python-6/index.html" target="_blank" rel="noopener">可爱的 Python：Curses 编程</a>(5/26)</li><li><a href="http://wklken.me/posts/2012/02/19/python-ini-configparser.html" target="_blank" rel="noopener">PYTHON读取修改INI配置文件[CONFIGPARSER]</a>(5/31)</li><li><a href="https://www.jianshu.com/p/4202a2051668" target="_blank" rel="noopener">Python 解析配置模块之ConfigParser详解</a>(5/31) <i class="fa fa-star"></i></li><li><a href="http://www.cnblogs.com/huey/p/4334152.html" target="_blank" rel="noopener">Python(2.7.6) ConfigParser - 读写配置文件</a>(5/31)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/5-2.png&quot; alt=&quot;May&quot;&gt;&lt;/center&gt;

&lt;p&gt;五月份主要基于&lt;code&gt;python sna&lt;/code&gt;实现了一个终端伪图形化界面的部署控制台，提供了填写配置信息、校验信息、导入信息和进度监控等功能，详情请见&lt;a href=&quot;http://www.tony-yin.site/2018/06/03/Python-Snack-Best-Practice/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【Python Snack 最佳实践】&lt;/a&gt;。这是我之前一直感兴趣想做的事情，这次正好借助工作的契机对其有了深入的了解和学习，收获颇多。五月份假期多，团建，还有工作进度赶，导致自己的阅读时间受到了影响，大多数阅读都是围绕着工作内容，极客时间这些&lt;code&gt;APP&lt;/code&gt;、技术博客和微信公众号的很多技术资源，自己都没有规律地学习。这些都不是借口啦，主要还是陷入吃鸡，不能自拔，哈哈哈。（已经卸了，我这个人容易上瘾然而又有点嫌麻烦，这对我来说是最简单有效的方式）&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
      <category term="Daily-Article" scheme="https://tony-yin.github.io/tags/Daily-Article/"/>
    
  </entry>
  
  <entry>
    <title>Ctdb Rados（二）：多场景断网高可用</title>
    <link href="https://tony-yin.github.io/2018/05/20/Ctdb-Rados-2/"/>
    <id>https://tony-yin.github.io/2018/05/20/Ctdb-Rados-2/</id>
    <published>2018-05-20T05:07:06.000Z</published>
    <updated>2018-12-13T16:40:24.415Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/ping-600x450.png" alt="ping"></center><p>之前写过一篇文章【<a href="http://www.tony-yin.site/2018/04/20/Ctdb-Rados-All-Banned/" target="_blank" rel="noopener">Ctdb Rados方式导致All Banned的问题</a>】，谈到了当<code>ctdb</code>将<code>recovery lock</code>设置成<code>rados</code>的方式后，断网<code>master</code>节点会造成所有<code>ctdb</code>节点<code>All Banned</code>，主要原因是<code>master</code>意外断网没有释放锁，其他节点无法获取到锁，当时的解决方案是每<code>5</code>分钟检查一次<code>ctdb</code>状态，如果连续两次发生了<code>All Banned</code>的情况，则手动删除<code>lock</code>，这种做法在最近的测试中遇到了一些问题，本文对这些问题进行剖析并对相应的解决方案进行分享。</p><a id="more"></a><blockquote><p>完整代码地址：<a href="https://github.com/tony-yin/Ctdb-Rados-Monitor" target="_blank" rel="noopener">https://github.com/tony-yin/Ctdb-Rados-Monitor</a></p></blockquote><h2 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h2><p>如果基于原来的做法，<code>ctdb</code>发生<code>All Banned</code>的情况，需要十分钟的监控时间加上两分钟左右的<code>recovery</code>时间，也就是说大概需要十二分钟才能恢复<code>ctdb</code>服务，这样看来高可用有点名实其副了，这个也会明显地影响存储业务的正常运行。后来，我们讨论出新的方案：每<code>5s</code>检查一次<code>ctdb</code>的状态，<code>All Banned</code>的次数累计到<code>5</code>次才确定为该故障场景，然后手动删除<code>lock</code>，最终要保证<code>ctdb</code>能够在<code>2min</code>内完成恢复。</p><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p><code>cron tab</code>最短周期只支持分钟级别，所以如何<code>5s</code>检查一次便是一个问题。</p><p>代码是死的，人是活的，虽然<code>cron tab</code>只支持分钟级别，但是我们可以每分钟调用一个脚本，然后在这个脚本中遍历<code>12</code>次，每次调用<code>ctdb monitor</code>脚本，然后<code>sleep 5s</code>，这样就可以达到每<code>5s</code>检查一次<code>ctdb</code>的效果了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ctdb_monitor</span></span><br><span class="line">* * * * * root /etc/ctdb/cron-seconds</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cron-seconds</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for((i=1;i&lt;=12;i++));do</span><br><span class="line">    ../monitor_ctdb</span><br><span class="line">sleep 5</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>这样检查到<code>ctdb</code>发生<code>All Banned</code>情况，只需要花费<code>25s</code>，剩下的就是<code>recovery</code>的时间了。</p><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p>当<code>ctdb master</code>节点的<code>network</code>服务断掉，其他两个节点（我的开发环境是三节点的虚拟机环境）便会选举一个为<code>master</code>节点，然后去获取<code>lock</code>，因为原<code>master</code>没有释放锁，导致所有节点<code>All Banned</code>，即使我们手动删除了锁，但是这时候其他两个节点仍然处于<code>Banned</code>的情况，需要等到<code>Ban Timeout</code>才会再次尝试获取锁并开始恢复过程，这个<code>timeout</code>的时间是<code>300s</code>，即<code>5min</code>，这显然是我们不能接受的，所以我们要在删除<code>lock</code>后，重启所有节点的<code>ctdb</code>服务。</p><p>不过该如何触发该重启操作呢？</p><p>我们在删除<code>lock</code>后将<code>ctdb</code>所有节点的<code>ip</code>作为对象存进<code>rados</code>中，然后在每<code>5s</code>监控的脚本中，查看<code>rados</code>中是否存在本节点的<code>ip</code>对象，如果有，则尝试重启<code>ctdb</code>操作，重启后便删除该对象。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function save_nodes_ip() &#123;</span><br><span class="line">    nodes=$(ctdb listnodes)</span><br><span class="line">    for node in $nodes; do</span><br><span class="line">        echo "$node" &gt; $node</span><br><span class="line">        rados -p rbd put $node $node</span><br><span class="line">        rm -f $node</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function get_current_node_ips() &#123;</span><br><span class="line">    ips=$(/usr/sbin/ip addr | grep "inet " | awk '&#123;print $2&#125;')</span><br><span class="line">    echo $ips</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function monitor_nodes_ip_in_rados() &#123;</span><br><span class="line">    ips=$(get_current_node_ips)</span><br><span class="line">    for ipinfo in $ips; do</span><br><span class="line">        ip=$&#123;ipinfo%/*&#125;</span><br><span class="line">        if $(timeout 10 rados -p rbd ls | grep "$ip" -qw); then</span><br><span class="line">            systemctl restart ctdb</span><br><span class="line">            rados -p rbd rm $ip</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么三个节点的<code>ip</code>都要存入<code>rados</code>，这个是因为原<code>master</code>节点恢复网络后，<code>ctdb</code>服务的状态为<code>failed</code>，同样需要重启<code>ctdb</code>服务才能正常恢复原<code>master</code>节点。 </p><p><strong>注意：</strong></p><p>这边有两个问题，当时浪费了我不少时间，问题不是多么深奥，但是不易发现。。。</p><p>第一个问题便是<code>ips=$(/usr/sbin/ip addr | grep &quot;inet &quot; | awk &#39;{print $2}&#39;)</code>这行代码，原来的写法是<code>ips=$(ip addr | grep &quot;inet &quot; | awk &#39;{print $2}&#39;)</code>，当时发现<code>ip</code>总是获取不到，然后无论是命令行还是脚本运行都可以正常获取到，后来还是同事提醒才发现在<code>crontab</code>脚本中，<code>shell</code>命令默认是<code>/usr/bin/</code>下的，而<code>ip</code>命令则是<code>/usr/sbin/</code>下，所以这里的命令我们需要全路径。（这个需要格外注意！！！被坑的不要不要的。。。）</p><p>第二个问题便是<code>rados -p rbd ls | grep &quot;$ip&quot; -qw</code>这行代码，当时没注意写成了<code>rados -p rbd ls | grep &quot;$ip&quot; -w</code>，发现<code>if</code>判断时常有问题，一开始还以为不能<code>grep</code>数字什么的，后来才发现没有加<code>q</code>，<code>q</code>表示安静模式，不打印任何标准输出，如果有匹配的内容则立即返回状态值0。</p><h2 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h2><p>“断网”这个词不够具体，在实际生产环境中，一个集群中，一般都会有多个网络，就拿本人的<code>ceph</code>集群环境来说（物理机环境，并非前文提及的虚拟机开发环境），<code>ceph</code>有个<code>public network</code>和<code>cluster network</code>，而<code>ctdb</code>也有它的<code>node network</code>和<code>public network</code>，<code>ceph</code>的<code>public</code>和<code>ctdb</code>的<code>public</code>是同一网段，<code>ceph</code>的<code>cluster</code>是单独网段，<code>ctdb</code>的<code>node</code>是单独的网段。所以<code>ctdb master</code>断网可以分为三种情况：</p><ul><li>拔掉<code>ctdb master node</code>网段网线</li><li>拔掉<code>ctdb master public</code>网段网线</li><li>断掉<code>ctdb master network</code>服务</li></ul><p>当拔掉<code>ctdb master public</code>网段网线，这没有什么好说的，<code>ctdb master</code>节点服务还存在，只是<code>master</code>节点上的<code>public address</code>不可用了，会漂移到其他节点上。</p><h3 id="问题1-1"><a href="#问题1-1" class="headerlink" title="问题1"></a>问题1</h3><p>当拔掉<code>ctdb master node</code>网段网线后，<code>master</code>节点仍然有<code>public</code>网卡，（<strong>这里注意</strong>）它仍然可以获取其他<code>ctdb</code>节点的状态，而其他节点却不可以获取它的状态，因为<code>master</code>的<code>node</code>节点<code>ip</code>不存在。所以造成的结果就是原<code>master</code>节点还默认自己是<code>master</code>节点，而其他的节点却又选举出了新的<code>master</code>，我们的脚本因为<code>All Banned</code>手动删除了<code>lock</code>，这时候其他节点可以正常恢复<code>ctdb</code>服务，但是当<code>ctdb master</code>节点断网再恢复后，它还以为自己是<code>master</code>，会不断去获取锁，而原来的锁已经被我们手动删除，这时候新的锁被新的<code>master</code>掌握，所以此时产生脑裂，我们要牺牲原<code>master</code>节点，也就是断网节点，所以需要重启它。这个重启触发机制我们是通过在每次删除<code>lock</code>之后在<code>rados</code>中存入<code>ctdb</code>所有节点的<code>ip</code>作为<code>object</code>（这就是为什么要存入所有节点的<code>ip</code>），然后只要发现有这个<code>object</code>便执行<code>ctdb</code>重启操作，然后便删除这个对象。至于为什么要存所有对象是因为除了原<code>master</code>需要重启之外，另外两个正常节点发生<code>All Banned</code>的情况，默认<code>timeout</code>时间是<code>300s</code>（这个上面也提到过），我们为了减少恢复时间，直接在删除<code>lock</code>后重启<code>ctdb</code>；</p><h2 id="问题2-1"><a href="#问题2-1" class="headerlink" title="问题2"></a>问题2</h2><p>由于现在<code>ctdb</code>的锁是放在<code>rados</code>中，而不是以前的<code>cephfs</code>的方式了。所以当<code>master</code>断网再恢复时，它会不断地去<code>rados</code>获取他原来的锁，这是获取锁的进程越来越多，会阻塞住<code>rados</code>服务，我们可以通过<code>ps -ef | grep rados_helper</code>看到进程不断变多，那么<code>rados</code>服务不能正常读写就影响到我们上一条的机制，不能读<code>rados</code>中是否含有本节点<code>ip</code>的对象，就没办法进行重启操作，那么这样它就会不断地继续获取<code>lock</code>，所以我们在这里又加了一个机制，如果<code>ps -ef | grep rados_helper</code>的数目超过<code>6</code>个，就默认启动重启<code>ctdb</code>服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function monitor_get_lock_timeout() &#123;</span><br><span class="line">    count=$(ps -ef | grep rados_helper | wc -l)</span><br><span class="line">    if [ $count -ge $RADOS_HELPER_PROCESS_MAX ]; then</span><br><span class="line">        systemctl restart ctdb</span><br><span class="line">        update_last_ctdb_restart_time</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h2><p><code>ctdb</code>目前重启的机制有点多，有自身自带的故障重启，也有我们监控脚本的异常情况，很容易发生重复重启，还有可能<code>rados_helper</code>堆积的进程很多，比如<code>20</code>个，我们的脚本是<code>5s</code>一次，也许<code>20</code>个的时候重启了，过<code>5s</code>，进程释放也需要时间，可能此时还有<code>10</code>个，那么大于我们规定的<code>6</code>个，就会继续重启，这种重复重启没有必要，所以我们要加上<code>ctdb</code>重启的周期限定<code>2min</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function get_ctdb_restart_interval() &#123;</span><br><span class="line">    last_time=$(get_ctdb_restart_last_time)</span><br><span class="line">    if [ -z "$last_time" ]; then</span><br><span class="line">        interval=$(expr $RESTART_CTDB_INTERVAL_MAX + 1)</span><br><span class="line">    else</span><br><span class="line">        current_time=$(date +%s)</span><br><span class="line">        interval=$(expr $current_time - $last_time)</span><br><span class="line">    fi</span><br><span class="line">    echo $interval</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑并解决以上提到的问题，基本上可以覆盖以上三种断网的场景了，在监控和管理<code>ctdb</code>的过程中，一定要小心，不能影响到业务正常运行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>生产环境网络结构错综复杂，往往在虚拟机上开发的功能当时好好的，到了物理机上面测试会发生各种问题，此时，我们首先要搞清楚网络拓扑结构，熟悉硬件配置，各网段的作用和相互之间的关联，这样遇到问题我们可以顺藤摸瓜，同样<code>ctdb</code>的原理也需要掌握才能了解它各种行为的触发机制，才能更好的定制化监控和管理。之后我会花点时间好好地研究一下<code>ctdb</code>，然后再单独做分享。</p><blockquote><p>完整代码地址：<a href="https://github.com/tony-yin/Ctdb-Rados-Monitor" target="_blank" rel="noopener">https://github.com/tony-yin/Ctdb-Rados-Monitor</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/ping-600x450.png&quot; alt=&quot;ping&quot;&gt;&lt;/center&gt;

&lt;p&gt;之前写过一篇文章【&lt;a href=&quot;http://www.tony-yin.site/2018/04/20/Ctdb-Rados-All-Banned/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ctdb Rados方式导致All Banned的问题&lt;/a&gt;】，谈到了当&lt;code&gt;ctdb&lt;/code&gt;将&lt;code&gt;recovery lock&lt;/code&gt;设置成&lt;code&gt;rados&lt;/code&gt;的方式后，断网&lt;code&gt;master&lt;/code&gt;节点会造成所有&lt;code&gt;ctdb&lt;/code&gt;节点&lt;code&gt;All Banned&lt;/code&gt;，主要原因是&lt;code&gt;master&lt;/code&gt;意外断网没有释放锁，其他节点无法获取到锁，当时的解决方案是每&lt;code&gt;5&lt;/code&gt;分钟检查一次&lt;code&gt;ctdb&lt;/code&gt;状态，如果连续两次发生了&lt;code&gt;All Banned&lt;/code&gt;的情况，则手动删除&lt;code&gt;lock&lt;/code&gt;，这种做法在最近的测试中遇到了一些问题，本文对这些问题进行剖析并对相应的解决方案进行分享。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Ctdb" scheme="https://tony-yin.github.io/tags/Ctdb/"/>
    
  </entry>
  
  <entry>
    <title>Megaraid 磁盘定位</title>
    <link href="https://tony-yin.github.io/2018/05/12/Megaraid_Location/"/>
    <id>https://tony-yin.github.io/2018/05/12/Megaraid_Location/</id>
    <published>2018-05-12T05:07:06.000Z</published>
    <updated>2018-12-13T16:40:24.442Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/mega_drive-600x450.png" alt="mega drive"></center><p>早前写过一篇【<a href="http://www.tony-yin.site/2018/01/05/RaidCardToolUtils/" target="_blank" rel="noopener">利用Raid卡工具获取逻辑盘是否为SSD</a>】的文章，大概讲述了如何通过<code>raid</code>卡工具判断一个逻辑磁盘对应物理磁盘是否为<code>SSD</code>，当时主要提到了<code>megacli</code>和<code>sas3ircu</code>这两种工具，核心是如何通过<code>raid</code>卡工具定位到逻辑磁盘对应的物理磁盘的位置，当时的方式现在看来在有些场景会存在缺陷。</p><a id="more"></a><p>当时的方案主要是先通过<code>lspci</code>获取<code>raid</code>卡型号，然后找到对应的<code>raid</code>卡型号，紧接着通过<code>lsscsi</code>命令获取逻辑磁盘的<code>targetid</code>，再通过<code>raid</code>卡工具根据<code>targetid</code>定位到对应的物理盘。当时的方案在多<code>controller</code>的场景下存在问题，可能会出现重复<code>target id</code>的情况，所以这时候只能再借助<code>controller id</code>来定位唯一的磁盘了。总而言之，想真正定位逻辑磁盘对应的物理磁盘，就必须要获取到磁盘的<code>controller id</code>，<code>enclosure id</code>和<code>slot number</code>，有了这三个参数，便可以获取该磁盘的信息，或者对该物理磁盘进行点灯、响音和做<code>raid</code>等操作。</p><p>那么，具体如何定位逻辑磁盘的物理位置呢？且看下文分析</p><h2 id="获取-raid-卡信息"><a href="#获取-raid-卡信息" class="headerlink" title="获取 raid 卡信息"></a>获取 raid 卡信息</h2><p>通过<code>lspci</code>命令可以获取到操作系统上所有<code>raid</code>卡信息，我们可以看到每个<code>raid</code>卡最前面都有一串数字，比如第一行是<code>02:00.0</code>，第二行是<code>03:00.0</code>，这里的<code>02</code>和<code>03</code>表示的是<code>raid</code>卡的<code>busid</code>，即<code>raid</code>卡控制器在<code>pci</code>总线上的<code>id</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# lspci | grep "LSI Logic"</span><br><span class="line">02:00.0 RAID bus controller: LSI Logic / Symbios Logic MegaRAID SAS-3 3008 [Fury] (rev 02)</span><br><span class="line">03:00.0 RAID bus controller: LSI Logic / Symbios Logic MegaRAID SAS-3 3108 [Invader] (rev 02)</span><br></pre></td></tr></table></figure><h2 id="获取磁盘-pcipath"><a href="#获取磁盘-pcipath" class="headerlink" title="获取磁盘 pcipath"></a>获取磁盘 pcipath</h2><p>在<code>linux</code>中，一切皆文件，每个文件都有自己的唯一标识，对于磁盘而言，<code>pcipath</code>就是它的唯一标识，<code>pci</code>总线上面有很多控制器，比如<code>scsi</code>控制器，而磁盘又存在于<code>scsi</code>控制器上，所以我们可以在<code>lsscsi</code>命令获取到的<code>scsi</code>设备列表中查看到操作系统上的磁盘信息。</p><p>以<code>sda</code>为例，我们可以在<code>/dev/disk/by-path</code>目录下查看到磁盘的<code>pcipath</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# ll /dev/disk/by-path/</span><br><span class="line">total 4</span><br><span class="line">lrwxrwxrwx 1 root root   9 May 11 10:30 pci-0000:02:00.0-scsi-0:2:0:0 -&gt; ../../sda</span><br><span class="line">lrwxrwxrwx 1 root root  10 May 11 10:30 pci-0000:02:00.0-scsi-0:2:0:0-part1 -&gt; ../../sda1</span><br><span class="line">lrwxrwxrwx 1 root root  10 May 11 10:30 pci-0000:02:00.0-scsi-0:2:0:0-part2 -&gt; ../../sda2</span><br><span class="line">lrwxrwxrwx 1 root root   9 May 11 16:22 pci-0000:02:00.0-scsi-0:2:1:0 -&gt; ../../sdb</span><br><span class="line">lrwxrwxrwx 1 root root   9 May 11 16:22 pci-0000:02:00.0-scsi-0:2:10:0 -&gt; ../../sdk</span><br></pre></td></tr></table></figure><p>由于在<code>linux</code>中，<code>udev</code>是用户态的设备管理，所以我们也可以通过<code>udev</code>获取。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# udevadm info --query=symlink --name=sda</span><br><span class="line">disk/by-id/scsi-36509a4c0ac86790022337b9105005435 disk/by-id/wwn-0x6509a4c0ac86790022337b9105005435 disk/by-path/pci-0000:02:00.0-scsi-0:2:0:0</span><br></pre></td></tr></table></figure><p>这边我们可以得到磁盘<code>sda</code>的<code>pcipath</code>为<code>pci-0000:02:00.0-scsi-0:2:0:0</code>，<code>02</code>就是磁盘的<code>raid</code>卡的<code>bus id</code>，后面的<code>00</code>表示<code>channel id</code>，再后面的<code>0:2:0:0</code>就和<code>lsscsi</code>获取的一样了，其中<code>2</code>就表示<code>target id</code>。</p><p>所以通过<code>bud id</code>，我们可以获取到磁盘对应的<code>raid</code>卡型号，根据对应的<code>raid</code>卡工具操作磁盘。这边我们只讨论<code>megaraid</code>，所以工具也就是<code>megacli</code>了。</p><h2 id="获取-controller-id"><a href="#获取-controller-id" class="headerlink" title="获取 controller id"></a>获取 controller id</h2><p>上面我们获取到了磁盘的<code>target id</code>和对应<code>raid</code>卡的<code>bus id</code>，而对于<code>megacli</code>工具而言，每个<code>raid</code>卡都有一个与之对应的<code>controller</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# /opt/MegaRAID/MegaCli/MegaCli64 -AdpGetPciInfo -aall -NoLog</span><br><span class="line"></span><br><span class="line">PCI information for Controller 0</span><br><span class="line">--------------------------------</span><br><span class="line">Bus Number      : 2</span><br><span class="line">Device Number   : 0</span><br><span class="line">Function Number : 0</span><br><span class="line"></span><br><span class="line">PCI information for Controller 1</span><br><span class="line">--------------------------------</span><br><span class="line">Bus Number      : 3</span><br><span class="line">Device Number   : 0</span><br><span class="line">Function Number : 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exit Code: 0x00</span><br></pre></td></tr></table></figure><p>这边我们可以看到<code>megacli</code>获取到了两个<code>controller</code>，也就对应上面<code>lspci</code>获取到的两张<code>raid</code>卡。细心的朋友可以发现这边有一个<code>Bus Number</code>，分别为<code>2</code>和<code>3</code>，而我们上面获取到了<code>raid</code>卡的<code>bus id</code>分别为<code>02</code>和<code>03</code>，没错，这边的<code>Bus Number</code>和<code>bus id</code>是对应的，只是<code>Bus number</code>没有自动填补成两位数，所以我们可以通过<code>bus id</code>得到<code>sda</code>所对应的<code>controller</code>为<code>0</code>。</p><blockquote><p><strong>注意：</strong><br>原本系统中版本<code>8.07.07</code>的<code>megacli</code>工具获取<code>raid</code>卡信息的时候会存在问题，每次<code>Bus Number</code>都会变化，我们只要升级<code>megacli</code>即可，我这边是把<code>megacli</code>升级到了<code>8.07.14</code>版本。</p><p>安装包地址：<a href="https://github.com/tony-yin/Megaraid_location/blob/master/MegaCli-8.07.14-1.noarch.rpm" target="_blank" rel="noopener">https://github.com/tony-yin/Megaraid_location/blob/master/MegaCli-8.07.14-1.noarch.rpm</a></p></blockquote><h2 id="获取磁盘组"><a href="#获取磁盘组" class="headerlink" title="获取磁盘组"></a>获取磁盘组</h2><p>此时，我们拥有了<code>controller id</code>，可以获取该<code>controller</code>下所有的磁盘组信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# /opt/MegaRAID_new/MegaCli/MegaCli64  -LdPdInfo -a0 -NoLog</span><br><span class="line">Adapter #0</span><br><span class="line"></span><br><span class="line">Number of Virtual Disks: 13</span><br><span class="line">Virtual Drive: 0 (Target Id: 0)</span><br><span class="line">Name                :</span><br><span class="line">RAID Level          : Primary-1, Secondary-0, RAID Level Qualifier-0</span><br><span class="line">Size                : 558.375 GB</span><br><span class="line">Sector Size         : 512</span><br><span class="line">Is VD emulated      : No</span><br><span class="line">Mirror Data         : 558.375 GB</span><br><span class="line">State               : Optimal</span><br><span class="line">Strip Size          : 64 KB</span><br><span class="line">Number Of Drives    : 2</span><br><span class="line">Span Depth          : 1</span><br><span class="line">Default Cache Policy: WriteThrough, ReadAheadNone, Direct, No Write Cache if Bad BBU</span><br><span class="line">Current Cache Policy: WriteThrough, ReadAheadNone, Direct, No Write Cache if Bad BBU</span><br><span class="line">Default Access Policy: Read/Write</span><br><span class="line">Current Access Policy: Read/Write</span><br><span class="line">Disk Cache Policy   : Disk's Default</span><br><span class="line">Encryption Type     : None</span><br><span class="line">Default Power Savings Policy: Controller Defined</span><br><span class="line">Current Power Savings Policy: None</span><br><span class="line">Can spin up in 1 minute: Yes</span><br><span class="line">LD has drives that support T10 power conditions: Yes</span><br><span class="line">LD's IO profile supports MAX power savings with cached writes: No</span><br><span class="line">Bad Blocks Exist: No</span><br><span class="line">Is VD Cached: No</span><br><span class="line">Number of Spans: 1</span><br><span class="line">Span: 0 - Number of PDs: 2</span><br><span class="line"></span><br><span class="line">PD: 0 Information</span><br><span class="line">Enclosure Device ID: 32</span><br><span class="line">Slot Number: 12</span><br><span class="line">Drive's position: DiskGroup: 0, Span: 0, Arm: 0</span><br><span class="line">Enclosure position: 1</span><br><span class="line">Device Id: 12</span><br><span class="line">WWN: 50000398181A974C</span><br><span class="line">Sequence Number: 2</span><br><span class="line">Media Error Count: 0</span><br><span class="line">Other Error Count: 0</span><br><span class="line">Predictive Failure Count: 0</span><br><span class="line">Last Predictive Failure Event Seq Number: 0</span><br><span class="line">PD Type: SAS</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后我们可以根据<code>target id</code>获取对应的磁盘组信息，<code>target id</code>与上面的<code>Target Id</code>所对应，这样我们可以过滤得到唯一的磁盘组信息。这边我们可以看到<code>sda</code>对应<code>Target Id</code>为<code>0</code>的磁盘组，该<code>raid</code>类型为<code>raid1</code>，虚拟磁盘组中有两块物理盘，然后我们可以获取这两块物理盘的<code>enclosure id</code>和<code>slot number</code>，这样再加上前文的<code>controller id</code>，我们就可以完完全全地定位到具体一块磁盘的物理位置。</p><h2 id="一键定位"><a href="#一键定位" class="headerlink" title="一键定位"></a>一键定位</h2><p>针对这种需求，本人根据以上逻辑写了一个简单的脚本可以一键获取磁盘的定位。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# ./get_disk_location.py sda</span><br><span class="line">['0:32:12', '0:32:13']</span><br></pre></td></tr></table></figure><p>这边<code>0:32:12</code>分别表示磁盘的<code>controller id</code>，<code>enclosure id</code>和<code>slot number</code>。</p><blockquote><p>完整代码地址：<a href="https://github.com/tony-yin/Megaraid_location/" target="_blank" rel="noopener">https://github.com/tony-yin/Megaraid_location/</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前的做法大部分场景可行，但是在一些场合偶尔会发现问题，总感觉还是不够靠谱，身边的人还有通过<code>sda</code>，<code>sdb</code>这种排列顺序来查找和<code>megacli</code>中显示磁盘的对应关系的，就更不靠谱了。<code>linux</code>操作系统是可以识别到具体硬件设备的，所以是肯定存在方法识别硬件对应的逻辑设备的，本文通过<code>pcipath</code>获取到设备的唯一标识，然后根据<code>pcipath</code>中的<code>bus id</code>和<code>megacli</code>中的<code>cobtroller</code>建立连接，最后通过<code>target id</code>锁定唯一磁盘组中的磁盘信息。</p><p>通过这种方式，我们不需要肉眼判断，也不需要顾虑部分场景方案不适用，这完全就是操作系统使用的方式，使用这种最基础，最底层的方式实现，真是让人豁然开朗。这跟看源码类似，了解一个功能的背后具体实现，你才知道最正确的姿势，不用去碰，去凑，这种感觉真好。</p><p>给大家推荐一本书《<code>Linux</code>设备驱动程序》，这本书详细讲解了<code>linux</code>中各种设备与驱动的细节，很底层也很枯燥，不过看完后应该会很有收获。希望大家在使用各种已有工具和框架的基础上，多去了解背后的实现机制，这样可以帮助我们更好地实现更深层次的需求。</p><h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ol><li><a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">Persistent block device naming</a></li><li><a href="https://github.com/eLvErDe/hwraid" target="_blank" rel="noopener">hwraid</a></li><li><a href="https://github.com/louwrentius/showtools" target="_blank" rel="noopener">showtools</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-scsi-subsystem/" target="_blank" rel="noopener">Linux SCSI 子系统剖析</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/mega_drive-600x450.png&quot; alt=&quot;mega drive&quot;&gt;&lt;/center&gt;

&lt;p&gt;早前写过一篇【&lt;a href=&quot;http://www.tony-yin.site/2018/01/05/RaidCardToolUtils/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;利用Raid卡工具获取逻辑盘是否为SSD&lt;/a&gt;】的文章，大概讲述了如何通过&lt;code&gt;raid&lt;/code&gt;卡工具判断一个逻辑磁盘对应物理磁盘是否为&lt;code&gt;SSD&lt;/code&gt;，当时主要提到了&lt;code&gt;megacli&lt;/code&gt;和&lt;code&gt;sas3ircu&lt;/code&gt;这两种工具，核心是如何通过&lt;code&gt;raid&lt;/code&gt;卡工具定位到逻辑磁盘对应的物理磁盘的位置，当时的方式现在看来在有些场景会存在缺陷。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Megaraid" scheme="https://tony-yin.github.io/tags/Megaraid/"/>
    
  </entry>
  
  <entry>
    <title>Django CAS Token 解决方案</title>
    <link href="https://tony-yin.github.io/2018/05/02/Django_CAS_Token_Solution/"/>
    <id>https://tony-yin.github.io/2018/05/02/Django_CAS_Token_Solution/</id>
    <published>2018-05-02T05:07:06.000Z</published>
    <updated>2018-12-17T04:37:27.341Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/bottle.png" alt="cas"></center><p><code>CAS</code>单点登录主要是为了解决主系统和子系统的统一登录问题，能够做到任意一个子系统登录成功后，再登录其他子系统后不再需要认证，让用户不用重复地进行登录认证。<code>CAS</code>单点登录的方案很多，并且大多数都是采用<code>session</code>的方式，而本文结合个人实践，着重讨论<code>django cas token</code>的解决方案。</p><a id="more"></a><p>本方案中，<code>cas</code>客户端和服务端都采用了开源项目，服务端是<a href="https://github.com/jbittel/django-mama-cas" target="_blank" rel="noopener">django-mama-cas</a>，而客户端是<a href="https://github.com/mingchen/django-cas-ng" target="_blank" rel="noopener">django-cas-ng</a>。</p><h2 id="CAS-Server"><a href="#CAS-Server" class="headerlink" title="CAS Server"></a>CAS Server</h2><p>服务端相比于客户端要简单地多，根据<code>github</code>步骤一步步下载和配置就好。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django-mama-cas</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">INSTALLED_APPS = (</span><br><span class="line">    <span class="string">'mama_cas'</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重要！，service是client的IP，是个数组，可以在后面添加SERVICE的HOST:PORT。</span></span><br><span class="line">MAMA_CAS_SERVICES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'SERVICE'</span>: <span class="string">'http://127.0.1.1:8000'</span>,</span><br><span class="line">        <span class="string">'CALLBACKS'</span>: [</span><br><span class="line">            <span class="string">'mama_cas.callbacks.user_model_attributes'</span>,     <span class="comment"># 返回除了password的所有Field</span></span><br><span class="line">            <span class="comment"># 'mama_cas.callbacks.user_name_attributes', # 只返回 username</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">'LOGOUT_ALLOW'</span>: <span class="keyword">True</span>,</span><br><span class="line">        <span class="string">'LOGOUT_URL'</span>: <span class="string">'http://127.0.1.1:8000/accounts/callback'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># urls.py</span></span><br><span class="line">url(<span class="string">r''</span>, include(<span class="string">'mama_cas.urls'</span>)),</span><br></pre></td></tr></table></figure><h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><p>首先是一些基本的客户端配置，比如<code>server ip</code>等，但是<code>django-cas-ng</code>默认是通过<code>session</code>的方式认证的，而我们需要通过<code>token</code>的方式认证，所以如果想继续用<code>django-cas-ng</code>来解决问题，那要么查看它是否有原生支持的接口，要么改源码。改源码可能不大友好，所以我优先研究了一下<code>django-cas-ng</code>的原生支持，无意中发现<a href="https://github.com/mingchen/django-cas-ng#view-wrappers-example" target="_blank" rel="noopener">view-wrappers-example</a>可以继承它原生的登录接口做一些封装，而我们完全通过继承原生的登录方法，然后加入我们的<code>token</code>相关代码。所以<code>urls.py</code>里面登录的方法我们写的是我们写在<code>view.py</code>中封装的登录方法，而并非默认的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">INSTALLED_APPS = (</span><br><span class="line">    <span class="comment"># ... other installed apps</span></span><br><span class="line">    <span class="string">'django_cas_ng'</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">AUTHENTICATION_BACKENDS = (</span><br><span class="line">    <span class="string">'django_cas_ng.backends.CASBackend'</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：这是cas server的地址</span></span><br><span class="line">CAS_SERVER_URL = <span class="string">'http://127.0.0.1:8000'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存入所有CAS 服务端返回的user数据。</span></span><br><span class="line">CAS_APPLY_ATTRIBUTES_TO_USER = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># urls.py</span></span><br><span class="line"><span class="keyword">import</span> view <span class="keyword">import</span> *</span><br><span class="line">url(<span class="string">r'^accounts/login$'</span>, cas_login, name=<span class="string">'cas_login'</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">#view.py</span></span><br><span class="line"><span class="keyword">from</span> django_cas_ng <span class="keyword">import</span> views <span class="keyword">as</span> baseviews</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cas_login</span><span class="params">(request, **kwargs)</span>:</span></span><br><span class="line">    r = baseviews.login(request, **kwargs)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.user.is_anonymous():</span><br><span class="line">        token = get_token(request)</span><br><span class="line">        <span class="keyword">if</span> token:</span><br><span class="line">            r.set_cookie(<span class="string">'token'</span>, token)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'Get token error'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'User is anonymous'</span>)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token</span><span class="params">(request, *args, **kwargs)</span>:</span></span><br><span class="line">    user = request.user</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        request_hash = AuthToken.get_request_hash(request)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            token = generate_token()    <span class="comment"># function used to geneate token, this place won't show more detail codes</span></span><br><span class="line">            token.refresh()</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">print</span> e</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> token.key</span><br></pre></td></tr></table></figure><p>生成<code>token</code>的方法我就不详细描述了，这边主要提供了一个思路，我们将<code>django-cas-ng</code>原生的登录方法进行了继承，然后生成<code>token</code>并放到了<code>session</code>当中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要为<code>CAS Token</code>方案提供一个思路，如果集成进已有项目中，肯定会遇到很多细节问题，不过万变不离其宗，我们首先要熟悉手中运用的工具，然后要善于在此基础之上根据自己的定制需求进行开发，多看看文档和源码，每一次可能都会有新的发现。</p><h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ol><li><a href="https://www.jianshu.com/p/d97a3d367037" target="_blank" rel="noopener">使用django-mama-cas快速搭建CAS服务</a></li><li><a href="http://www.voidcn.com/article/p-yvycalqd-brm.html" target="_blank" rel="noopener">Django实现CAS+OAuth2</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/bottle.png&quot; alt=&quot;cas&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;code&gt;CAS&lt;/code&gt;单点登录主要是为了解决主系统和子系统的统一登录问题，能够做到任意一个子系统登录成功后，再登录其他子系统后不再需要认证，让用户不用重复地进行登录认证。&lt;code&gt;CAS&lt;/code&gt;单点登录的方案很多，并且大多数都是采用&lt;code&gt;session&lt;/code&gt;的方式，而本文结合个人实践，着重讨论&lt;code&gt;django cas token&lt;/code&gt;的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Django" scheme="https://tony-yin.github.io/tags/Django/"/>
    
      <category term="CAS" scheme="https://tony-yin.github.io/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>Daily Article Vol 5 - (2018/4/1 ~ 2018/4/30)</title>
    <link href="https://tony-yin.github.io/2018/05/01/Daily-Article-Vol5/"/>
    <id>https://tony-yin.github.io/2018/05/01/Daily-Article-Vol5/</id>
    <published>2018-05-01T02:07:06.000Z</published>
    <updated>2018-12-13T16:40:24.422Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/hello_april_600x450.png" alt="April"></center><p>这是<code>Daily Article</code>系列的第五篇，罗列了<code>2018</code>年<code>4</code>月的阅读清单。</p><a id="more"></a><p>本月是在新公司工作的第一个月，主要做了利用<code>python</code>搭建<code>NAS</code>服务稳定性测试框架、<code>CTDB</code>使用<code>rados object</code>作为<code>lock file</code>、利用<code>django</code>做<code>CAS</code>单点登录。首先<code>python</code>搭建<code>NAS</code>服务稳定性测试框架的工作就是通过<code>python</code>对<code>NAS</code>服务进行连接，并进行读写操作，该框架不需要任何挂载操作便可以对<code>NAS</code>服务进行连接和读写操作，目前支持<code>NFS</code>、<code>CIFS</code>和<code>FTP</code>，具体请参考<a href="http://www.tony-yin.site/2018/04/08/python_nas_stable_test/" target="_blank" rel="noopener">基于Python的NAS稳定性测试框架</a>；然后就是<code>CTDB</code>使用<code>rados object</code>作为<code>lockfile</code>这种方案的实践，期间也遇到了<code>Nodes All Banned</code>这种问题并解决了；最后就是采用<code>django-mama-cas</code>作为服务端，<code>django-cas-ng</code>作为客户端，搭建了一套<code>CAS</code>环境，并对目前的项目进行集成。</p><p>个人课余时间的话，一方面关注的是<code>python</code>和<code>django</code>有关的知识，因为工作中要用到，其次就是围绕着<code>ceph</code>和存储相关知识的了解和学习了。上周在扫盲区的过程中，看到了很久之前了解的<code>nvme over fabric</code>这个概念，然后又去深入地了解了一下。这一了解又引申出了无数的盲区，比如<code>RDMA</code>、<code>nvme</code>、<code>nvme overip</code>、<code>FC</code>等等，而这些技术也很新，文档不多，并且大多数都是很枯燥的，只能逼着自己慢慢地啃下去。感慨技术变革真是日新月异的同时，也感慨扫盲区的速度远远赶不上盲区生成的速度，每天都会有好多自己不知道或者不是特别了解原理的概念，等待着自己去学习和深入。不过呢，也正如之前一位前辈讲过，很多人都觉得这个技术牛逼，那个技术牛逼，不是那么容易学会的，也正是因为这种心态，很多人都不去学习，而很多学习的人即使没有到达最顶峰，比不学的人多了解一点就强一些。所以人生苦短，没事多看看总没坏处。</p><p>碎片时间也会看极客时间上面的专栏，我已经买了两个专栏。从目前的观看效果来说，首先我觉得还是不错的，但是很多内容都是概念上面的东西，仿佛是为了写文章而写文章，缺少落地的东西，经常围绕着一个概念反复强调，我觉得还不如多讲讲具体的场景更容易让别人接受一些。对于我而言，分布式，服务治理，服务分发这些概念和场景我都有经历过，所以我还蛮能接受的，我想很多没有经历过这些开发的童鞋直接看也许会感觉到云里雾里的。但是还是那句话，多看一点总是有好处的，因为很多东西你看了，你没到一定层次是不会了解的，你提前看了，也许之后某一天就会有一种豁然开朗的感觉。但是我们还是要讲究方法的，时间是有限的，我们要在有限的时间学习更多的知识。我认为看这些文章，目的不是为了一步登天，获得什么实质效应，事实上他也不会给你这种回报，我们要做的就是从上面获取一些技术概念、原理和本质，由此作为一个引子，自己找项目，找场景去实践，去深入，光说不练假把式，只有实践了才能深入，然后最好的就是能够在产品中不断运用和学习相关技术了，这样才是最好的学习和掌握。因为很多时间如果固步自封，很多概念你都不知道，更别谈去学习了。最后我会专门整理一篇文章，把我看过的极客时间的文章分享出来，这样可以让一些童鞋免费了解和学习，我这边用的是极客时间提供的分享的功能，也不算违规，每次分享只有十个名额，所以大家先到先得。emmm，看很多同学买课很积极，很多同学却很消极，我觉得前者起码有学习的想法，后者就不谈了，但是针对前者我想说的是，不是花的钱越多就有用的，而是学到手，记到脑子里才属于自己的，希望大家都能不断学习，越变越好，happy everyday！</p><ol><li><a href="https://www.jianshu.com/p/6f67a4b9dad3" target="_blank" rel="noopener">django2.0入门教程第一节</a>(4/2) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://www.jianshu.com/p/b8d73d39f184" target="_blank" rel="noopener">django2.0入门教程第二节</a>(4/2) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://www.jianshu.com/p/2004b8dbebb4" target="_blank" rel="noopener">django2.0入门教程第三节</a>(4/2) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://www.jianshu.com/p/e2a09d2a4a2f" target="_blank" rel="noopener">django2.0入门教程第四节</a>(4/2) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://time.geekbang.org/column/article/ed937b37244d4db63f60e5f00be38fce/share" target="_blank" rel="noopener">【极客时间-左耳听风】：分布式系统关键技术：服务调度</a>(4/3)</li><li><a href="http://www.woshipm.com/data-analysis/872543.html" target="_blank" rel="noopener">数据分析入门：初识数据埋点（一）</a>(4/7) <i class="fa fa-star"></i></li><li><a href="https://www.jianshu.com/p/5b33bbd61c48" target="_blank" rel="noopener">docker初体验</a>(4/7)</li><li><a href="https://www.jianshu.com/p/f43659a58d71" target="_blank" rel="noopener">构建FTP文件传输服务器</a>(4/8)</li><li><a href="https://blog.csdn.net/bear_huangzhen/article/details/41806903?from=singlemessage" target="_blank" rel="noopener">FTP文件传输协议</a>(4/8)</li><li><a href="https://www.jianshu.com/p/05212313d0e2" target="_blank" rel="noopener">ftp实现原理以及抓包分析</a>(4/8)</li><li><a href="https://www.jianshu.com/p/e99519739b5e" target="_blank" rel="noopener">Linux下ftp服务搭建之小试牛刀</a>(4/8)</li><li><a href="https://blog.csdn.net/u014245412/article/details/72286348" target="_blank" rel="noopener">python 操作samba文件服务器</a>(4/10) <i class="fa fa-star"></i></li><li><a href="https://yq.aliyun.com/articles/578927?utm_content=m_45816" target="_blank" rel="noopener">佛系程序员的月薪五万指南</a>(4/12) <i class="fa fa-star"></i></li><li><a href="https://lingxiankong.github.io/2013-12-23-python-setup.html" target="_blank" rel="noopener">关于python中的setup.py</a>(4/13) <i class="fa fa-star"></i></li><li><a href="https://time.geekbang.org/column/article/b307919cc599a82c542ec39e7aa3ddc7/share" target="_blank" rel="noopener">【极客时间-左耳听风】：分布式系统关键技术：流量与数据调度</a>(4/16) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="http://blog.sina.com.cn/s/blog_8c243ea30102uxaw.html" target="_blank" rel="noopener">分布式高可用CTDB方案</a>(4/16)</li><li><a href="https://ceph.com/planet/ctdb使用rados-object作为lock-file/" target="_blank" rel="noopener">CTDB使用rados object作为lock file</a>(4/16) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://blog.csdn.net/naipeng/article/details/75045177" target="_blank" rel="noopener">关于CTDB</a>(4/17)</li><li><a href="http://www.zphj1987.com/2017/04/20/where-is-cephfs-data-store/" target="_blank" rel="noopener">Cephfs的文件存到哪里了</a>(4/21)</li><li><a href="http://blog.jobbole.com/56574/" target="_blank" rel="noopener">最佳日志实践</a>(4/22) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://zhuanlan.zhihu.com/p/27363484" target="_blank" rel="noopener">最佳日志实践（v2.0）</a>(4/23) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="http://www.zphj1987.com/2017/06/09/use-graylog-get-Ceph-status/" target="_blank" rel="noopener">使用日志系统graylog获取Ceph集群状态</a>(4/23) <i class="fa fa-star"></i></li><li><a href="http://www.zphj1987.com/2017/07/13/CEPHFS-op-to-graylog/" target="_blank" rel="noopener">Cephfs 操作输出到日志查询系统</a>(4/23) <i class="fa fa-star"></i></li><li><a href="https://blog.csdn.net/xiaqunfeng123/article/details/56675696?locationNum=1&amp;fps=1" target="_blank" rel="noopener">bluestore调研</a>(4/23) <i class="fa fa-star"></i></li><li><a href="https://zhuanlan.zhihu.com/p/24312755" target="_blank" rel="noopener">Python打包时添加非代码文件的坑</a>(4/24)</li><li><a href="https://www.jianshu.com/p/d910a70dfee7" target="_blank" rel="noopener">cephfs介绍和功能测试</a>(4/24)</li><li><a href="http://xiaqunfeng.cc/2017/01/20/%E5%9D%97%E5%AD%98%E5%82%A8%E7%9A%84%E4%B8%96%E7%95%8C/#more" target="_blank" rel="noopener">块存储的世界</a>(4/24) <i class="fa fa-star"></i></li><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432712108300322c61f256c74803b43bfd65c6f8d0d0000#0" target="_blank" rel="noopener">python virtualenv</a>(4/24) <i class="fa fa-star"></i></li><li><a href="http://stackeye.com/2014/08/rpmbuild-in-action/" target="_blank" rel="noopener">rpmbuild实战</a>(4/25) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://zhuanlan.zhihu.com/p/28492389" target="_blank" rel="noopener">使用RPM方式安装Linux软件</a>(4/25)</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-rpm/index.html" target="_blank" rel="noopener">RPM 打包技术与典型 SPEC 文件分析</a>(4/25) <i class="fa fa-star"></i></li><li><a href="http://mp.weixin.qq.com/s?src=11&amp;timestamp=1524706491&amp;ver=839&amp;signature=nEMLgYwV4GI9Pd19glqGgJS6DR7sfrZesONMDXvpIWz34-KhzcYGK8h*WE7DjAFpXU9NYztsheG7Doy29A2zEC-V2bw*zFNgXbyy5VK2vRBR83sVVudSgxEsbAN0R8iW&amp;new=1" target="_blank" rel="noopener">RDMA(远程直接内存访问)技术浅析</a>(4/26) <i class="fa fa-star"></i></li><li><a href="https://blog.csdn.net/chenhaifeng2016/article/details/78072498?locationNum=4&amp;fps=1" target="_blank" rel="noopener">RDMA技术</a>(4/26) <i class="fa fa-star"></i></li><li><a href="https://www.csdn.net/article/1970-01-01/302809" target="_blank" rel="noopener">Fabric是否代表网络架构的未来？</a> <i class="fa fa-star-half-full"></i></li><li><a href="http://dy.163.com/v2/article/detail/CDG9CD7G05179LAH.html" target="_blank" rel="noopener">2017下一代数据中心网络研究报告</a>(4/27)</li><li><a href="http://book.51cto.com/art/201105/266135.htm" target="_blank" rel="noopener">统一Fabric和互联云</a>(4/27)</li><li><a href="http://net.zol.com.cn/459/4598330.html" target="_blank" rel="noopener">浅谈数据中心网络架构的发展</a>(4/27) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://blog.csdn.net/memblaze_2011/article/details/51820631" target="_blank" rel="noopener">为了部落：NVMe over Fabric诞生记</a> <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="http://www.cnblogs.com/rodenpark/p/6220519.html" target="_blank" rel="noopener">NVMe over Fabrics：概念、应用和实现</a>(4/28)</li><li><a href="https://blog.csdn.net/u010616442/article/details/70773956" target="_blank" rel="noopener">NVME概述</a>(4/28)</li><li><a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1524808998&amp;ver=841&amp;signature=56U4bzWNuWUqlDANFQNBFPkSc2dX-R*HeLL9y7vN*ha-Ph0PrOfhkEPUfB8R*Gy-SLlwFeMqCUKDneUkeDPfpgT-igBpw77SSCr6Hhl9Ul29OsEMtzY1B2-JPQbBd1vH&amp;new=1" target="_blank" rel="noopener">详谈NVMe over Fabric技术发展简史</a>(4/29) <i class="fa fa-star"></i></li><li><a href="http://www.voidcn.com/article/p-yvycalqd-brm.html" target="_blank" rel="noopener">Django实现CAS+OAuth2</a> <i class="fa fa-star"></i></li><li><a href="https://weibo.com/p/1001603934517592239583?mod=zwenzhang#_loginLayer_1525517479194" target="_blank" rel="noopener">NVMe over Fabric</a> <i class="fa fa-star"></i><i class="fa fa-star"></i></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/hello_april_600x450.png&quot; alt=&quot;April&quot;&gt;&lt;/center&gt;

&lt;p&gt;这是&lt;code&gt;Daily Article&lt;/code&gt;系列的第五篇，罗列了&lt;code&gt;2018&lt;/code&gt;年&lt;code&gt;4&lt;/code&gt;月的阅读清单。&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
      <category term="Daily-Article" scheme="https://tony-yin.github.io/tags/Daily-Article/"/>
    
  </entry>
  
  <entry>
    <title>Ctdb Rados方式导致All Banned的问题</title>
    <link href="https://tony-yin.github.io/2018/04/20/Ctdb-Rados-All-Banned/"/>
    <id>https://tony-yin.github.io/2018/04/20/Ctdb-Rados-All-Banned/</id>
    <published>2018-04-20T05:07:06.000Z</published>
    <updated>2018-12-13T16:40:24.416Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/lock.jpg" alt="lock object"></center><p><code>ctdb</code>最近专门为<code>ceph</code>提供了一种<code>raods object</code>作为文件锁的方式，<code>lock file</code>可以放在对象存储中，而不是<code>cephfs</code>，从而大大降低了系统宕机的延时。在此方案的实践中，我们发现<code>master</code>节点宕机会导致严重的<code>All Banned</code>的问题，本文则围绕该问题展开讨论和提供本人的解决方案。</p><a id="more"></a><p>很多系统都在用<code>ctdb</code>做<code>HA</code>，今天我们讨论的是基于<code>cephfs</code>的<code>ctdb HA</code>方案。<code>ctdb</code>的作用是在一个共享文件系统中，当所有节点都访问同一个文件时，<code>ctdb</code>会选举出一个<code>master</code>节点获得<code>lock</code>，我们之前的做法是把这个<code>lock file</code>放在<code>cephfs</code>的共享目录中，但是当其中某个节点<code>down</code>了之后，会导致<code>cephfs</code>这个目录卡死，进一步导致<code>lock file</code>在其他节点都获取不到，只有等到锁超时了之后才能获取到，而这个超时时间默认是<code>300s</code>，再加上<code>ctdb</code>的监控检测和恢复的时间，切换的时间少则十几分钟，多则几十分钟，这对于高可用场景来说无疑是灾难级的。</p><h2 id="具体场景"><a href="#具体场景" class="headerlink" title="具体场景"></a>具体场景</h2><p><code>ctdb</code>的编译和安装我就不说了，大家可以参考磨渣的文章：<a href="http://www.zphj1987.com/2018/01/06/CTDB-use-rados-object-as-lock-file/" target="_blank" rel="noopener">CTDB使用rados object作为lock file</a>。在<code>ceph</code>集群中所有节点安装好<code>ctdb</code>后，起服务后通过<code>systemctl status ctdb</code>可以发现<code>reclock</code>是通过<code>ctdb_mutex_ceph_rados_helper</code>的方式，就说明<code>ctdb rados</code>的方式配置成功了。</p><p>然后我们可以通过<code>rados -p rbd ls</code>也可以看到自己配置的锁存在于<code>rbd pool</code>中。这时我们断电一个<code>slave</code>节点，一分钟左右后可以实现节点切换。但是我们的测试发现当断网<code>master</code>节点的时候，就会造成长时间的卡住，且节点并不会切换。详细查看可以发现断网后，<code>master</code>节点没有释放<code>lock</code>，然后其他的集群节点选举出了<code>master</code>节点后，试图获取锁，但是由于之前的<code>master</code>节点一直没有释放，所以一直获取不到，然后就不停的去获取，<code>ctdb</code>的机制是如果有不断的这种行为，就会让所有节点<code>All Banned</code>。因为<code>slave</code>节点并不拥有锁，所以不存在之前的问题。</p><p>这个问题是比较严重的，因为不存在超时机制，拥有锁的节点断网或者断电，所以不会因为超时就释放锁。所以就会一直就卡着，并且一直实现不了切换节点。这就意味着一旦这种情况发生，客户的业务就会发生中断，这是无法接受的。并且我们也发现了如果使用原来将<code>lock file</code>放在<code>cephfs</code>目录的方式，断网或者断电主节点并不会发生这种情况，后来大概看了下源码大概是因为<code>cephfs</code>自己的机制会强制释放共享目录中文件的锁。</p><p>具体报错如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@tony ~]# ctdb status</span><br><span class="line">Warning: All nodes are banned.</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们的解决方案没有尝试着修改<code>ctdb</code>的源码，而是通过定时监控<code>ctdb</code>的状态。如果是主节点上面的<code>ctdb</code>，并且如果是<code>rados</code>方式的话，每<code>3</code>分钟查看一下<code>ctdb status</code>的状态，如果有连续两次的状态都是<code>All Banned</code>的话，我们就认为目前主节点发生了不释放锁的问题，我们就主动地删除<code>lock object</code>。部分代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">function check_if_master() &#123;</span><br><span class="line">    MASTER_PNN=$(ctdb recmaster)</span><br><span class="line">    CURRENT_PNN=$(ctdb pnn)</span><br><span class="line">    if [ $MASTER_PNN -eq $CURRENT_PNN ]; then</span><br><span class="line">        echo true</span><br><span class="line">    else</span><br><span class="line">        echo false</span><br><span class="line">    fi  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function get_lock_name() &#123;</span><br><span class="line">    LOCK_INFO=$(grep rados $CTDB_CONFIG_FILE | awk '&#123;print $5&#125;')</span><br><span class="line">    LOCK_NAME=$&#123;LOCK_INFO:0:-1&#125;</span><br><span class="line">    echo $LOCK_NAME</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function monitor_lock() &#123;</span><br><span class="line">    STATUS_FILE=/etc/ctdb/status.txt</span><br><span class="line">    CTDB_STATUS=$(ctdb status 2&gt;&amp;1)</span><br><span class="line">    ALL_BANNED="Warning: All nodes are banned."</span><br><span class="line"></span><br><span class="line">    if [ ! -f "$STATUS_FILE" ]; then</span><br><span class="line">        echo "$CTDB_STATUS" &gt; $STATUS_FILE</span><br><span class="line">    else</span><br><span class="line">        if [ "$CTDB_STATUS" = "$ALL_BANNED" ]; then</span><br><span class="line">            LAST_CTDB_STATUS=$(cat $STATUS_FILE)</span><br><span class="line">            if [ "$LAST_CTDB_STATUS" = "$ALL_BANNED" ]; then</span><br><span class="line">                LOCKNAME=$(get_lock_name)</span><br><span class="line">                echo $(date)" Ctdb all nodes banned: Second time" &gt;&gt; /var/log/monitor_ctdb.log</span><br><span class="line">                echo $(date)" Remove ctdb rados lock: "$LOCKNAME &gt;&gt; /var/log/monitor_ctdb.log</span><br><span class="line">                rados -p rbd rm $LOCKNAME </span><br><span class="line">                echo -n "" &gt; $STATUS_FILE</span><br><span class="line">            else</span><br><span class="line">                echo $(date)" Ctdb all nodes banned: First time" &gt;&gt; /var/log/monitor_ctdb.log</span><br><span class="line">                echo "$ALL_BANNED" &gt; $STATUS_FILE</span><br><span class="line">            fi</span><br><span class="line">        else</span><br><span class="line">            echo -n "" &gt; $STATUS_FILE</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTDB_CONFIG_FILE=/etc/sysconfig/ctdb</span><br><span class="line">if $(grep rados $CTDB_CONFIG_FILE -q); then</span><br><span class="line">    if $(check_if_master); then</span><br><span class="line">        monitor_lock</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><blockquote><p>完整代码地址：<code>https://github.com/tony-yin/Ctdb-Rados-Monitor</code></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>也许我的这种做法不是最优方案，希望遇到同样问题的同学可以一起讨论，拥有更好解决方案的可以一起分享。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/lock.jpg&quot; alt=&quot;lock object&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;code&gt;ctdb&lt;/code&gt;最近专门为&lt;code&gt;ceph&lt;/code&gt;提供了一种&lt;code&gt;raods object&lt;/code&gt;作为文件锁的方式，&lt;code&gt;lock file&lt;/code&gt;可以放在对象存储中，而不是&lt;code&gt;cephfs&lt;/code&gt;，从而大大降低了系统宕机的延时。在此方案的实践中，我们发现&lt;code&gt;master&lt;/code&gt;节点宕机会导致严重的&lt;code&gt;All Banned&lt;/code&gt;的问题，本文则围绕该问题展开讨论和提供本人的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Ctdb" scheme="https://tony-yin.github.io/tags/Ctdb/"/>
    
      <category term="Rados" scheme="https://tony-yin.github.io/tags/Rados/"/>
    
      <category term="HA" scheme="https://tony-yin.github.io/tags/HA/"/>
    
  </entry>
  
  <entry>
    <title>基于Python的NAS稳定性测试框架</title>
    <link href="https://tony-yin.github.io/2018/04/08/python_nas_stable_test/"/>
    <id>https://tony-yin.github.io/2018/04/08/python_nas_stable_test/</id>
    <published>2018-04-08T05:07:06.000Z</published>
    <updated>2018-12-13T16:40:24.449Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/nas.jpg" alt="NAS Stable Test"></center><p>最近公司有个集群一直在跑着，领导想要测测它上面<code>NAS</code>服务的稳定性，也就是看看正常持续的读写会不会导致<code>NAS</code>服务异常，这个其实通过<code>fio</code>或者<code>cosbench</code>这类的工具测试起来很容易，但是这样一是没有挑战性，二是比较机械，可扩展性低。比如并行测试、进程保护和异常通知等等这些是机械地运用工具测试所做不到的，所以我们尝试做了一套基于<code>NAS</code>稳定性测试的框架。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>整个测试框架打包和发布都是通过RPM的方式，方便测试人员一键部署。部署之后测试工作由<code>supervisor</code>管理，实时监控后台进程的运行状态，发生异常时可以进行重启等自动化操作。所有读写操作都是通过<code>python</code> 连接NAS服务，无需做任何挂载工作。主要测试工作是通过<code>celery</code>实现任务调度，支持并行多个NAS服务的读写测试，<code>broker</code>和<code>backend store</code>都采用了<code>rabbitmq</code>。后端注册了<code>register</code>、<code>nfs</code>、<code>cifs</code>和<code>ftp</code>四个<code>job</code>，定时每<code>10</code>分钟执行一次，设置最大开启<code>worker</code>数为<code>5</code>个。<code>Job</code>注册进消息队列中后，<code>celery worker</code>会自动去消费，针对服务器中不同的<code>NAS</code>服务进行读写操作，每个任务的执行结果最后都会记录在日志中，出了异常通过邮件通知管理员。</p><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>整个项目的框架图如下：</p><center><img src="http://cdn.tony-yin.site/NAS_Stable_Test%E6%A1%86%E6%9E%B6%E5%9B%BE.png" alt="Nas_Stable_Test架构图"></center><h2 id="NAS服务读写流程"><a href="#NAS服务读写流程" class="headerlink" title="NAS服务读写流程"></a>NAS服务读写流程</h2><p>由于每个<code>NAS</code>服务的测试方式是一致的，所以下面就以单个<code>NAS</code>服务的流程来介绍。首先<code>client</code>端向<code>server</code>的<code>NAS</code>服务端口发起连接，<code>server</code>端接收到<code>client</code>端的请求后建立连接。<code>Client</code>在<code>/tmp</code>目录下生成固定大小<code>1G</code>的文件，并且记录该文件的<code>MD5</code>值，然后将该文件上传至远端NAS服务目录（即对<code>NAS</code>服务进行写操作），上传完成后将该文件从本地删除。接着对之前上传至<code>NAS</code>服务目录的文件进行下载（即对<code>NAS</code>服务进行读操作），下载完成后再次记录文件<code>MD5</code>值，并删除掉远端<code>NAS</code>服务目录对应的文件。最后对两次记录的<code>MD5</code>值进行比较，判断上传和下载的文件是否一致，并将比较结果记录在日志中，再次删除本地下载的文件。<code>NAS</code>服务读写流程图如下：</p><center><img src="http://cdn.tony-yin.site/NAS_Stable_Test%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Nas_Stable_Test流程图"></center><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装libnfs"><a href="#安装libnfs" class="headerlink" title="安装libnfs"></a>安装libnfs</h3><p>通过<code>pip</code>安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install libnfs</span><br></pre></td></tr></table></figure><p>一般会报这个错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libnfs/libnfs_wrap.c:2969:25: fatal error: nfsc/libnfs.h: No such file or directory</span><br></pre></td></tr></table></figure><p>这个错看起来是缺少这个头文件的包，但是通过<code>yum search libnfs</code>是找不到相关的包的，所以我们只能去官网下载<code>rpm</code>包然后在安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 下载rpm</span><br><span class="line">wget http://li.nux.ro/download/nux/dextop/el7/x86_64//libnfs-1.9.8-1.el7.nux.x86_64.rpm</span><br><span class="line">wget http://li.nux.ro/download/nux/dextop/el7/x86_64//libnfs-devel-1.9.8-1.el7.nux.x86_64.rpm</span><br><span class="line">## 安装rpm</span><br><span class="line">yum localinstall libnfs-1.9.8-1.el7.nux.x86_64.rpm</span><br><span class="line">yum localinstall libnfs-devel-1.9.8-1.el7.nux.x86_64.rpm</span><br></pre></td></tr></table></figure><h3 id="安装pysmb"><a href="#安装pysmb" class="headerlink" title="安装pysmb"></a>安装pysmb</h3><p>这个比较简单，直接<code>pip</code>安装就可以了，也没遇到什么问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pysmb</span><br></pre></td></tr></table></figure><h2 id="NAS服务相关代码实现"><a href="#NAS服务相关代码实现" class="headerlink" title="NAS服务相关代码实现"></a>NAS服务相关代码实现</h2><p>这里只贴出部分<code>python</code>连接或者操作具体<code>Nas</code>服务的代码实现，如果想要了解或者贡献整个项目，请关注：<a href="https://github.com/tony-yin/python_nas" target="_blank" rel="noopener">Github python_nas项目</a></p><h3 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h3><h4 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def open(self):</span><br><span class="line">    self.nfs = libnfs.NFS(&apos;nfs://&#123;&#125;&apos;.format(self.mount_point))        </span><br><span class="line">    log.info(&apos;nfs connect successfully!&apos;)</span><br></pre></td></tr></table></figure><h4 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h4><p>这里有个关键点就是分段读写文件，避免内存溢出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def read(self):</span><br><span class="line">log.info(&apos;nfs read start...&apos;)</span><br><span class="line">a = self.nfs.open(&apos;/&#123;&#125;&apos;.format(self.filename), mode=&apos;r&apos;)          </span><br><span class="line">with open(self.download_path, &apos;a&apos;) as f:                          </span><br><span class="line">    while True: </span><br><span class="line">        content = a.read(1024*1024)                               </span><br><span class="line">        if content == &apos;&apos;:</span><br><span class="line">            break</span><br><span class="line">        f.write(content)                                          </span><br><span class="line">a.close()</span><br><span class="line">    log.info(&apos;nfs read end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def write(self, content):                                             </span><br><span class="line">log.info(&apos;nfs write start...&apos;)                                    </span><br><span class="line">a = self.nfs.open(&apos;/&#123;&#125;&apos;.format(self.filename), mode=&apos;w+&apos;)         </span><br><span class="line">a.seek(self.file_size)</span><br><span class="line">a.write(content)</span><br><span class="line">a.close()</span><br><span class="line">log.info(&apos;nfs write end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def delete(self):</span><br><span class="line">    log.info(&apos;nfs file delete start...&apos;)</span><br><span class="line">self.nfs.unlink(&apos;/&#123;&#125;&apos;.format(self.filename))</span><br><span class="line">log.info(&apos;nfs file delete end...&apos;)</span><br></pre></td></tr></table></figure><h3 id="CIFS"><a href="#CIFS" class="headerlink" title="CIFS"></a>CIFS</h3><h4 id="Connect-1"><a href="#Connect-1" class="headerlink" title="Connect"></a>Connect</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def open(self):</span><br><span class="line">    self.smb = SMBConnection(</span><br><span class="line">        self.username,</span><br><span class="line">        self.password,</span><br><span class="line">        self.my_name.encode(&apos;utf-8&apos;),</span><br><span class="line">        self.remote_name.encode(&apos;utf-8&apos;),</span><br><span class="line">        use_ntlm_v2=True</span><br><span class="line">    )</span><br><span class="line">    self.smb.connect(self.host, self.port)</span><br><span class="line">    log.info(&apos;cifs connect successfully!&apos;)</span><br></pre></td></tr></table></figure><h4 id="Read-1"><a href="#Read-1" class="headerlink" title="Read"></a>Read</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def read(self):</span><br><span class="line">    log.info(&apos;cifs read start...&apos;)</span><br><span class="line">    file_obj = open(self.download_path, &apos;wb&apos;)</span><br><span class="line">    self.smb.retrieveFile(</span><br><span class="line">        self.directory,</span><br><span class="line">        self.filename,</span><br><span class="line">        file_obj</span><br><span class="line">    )</span><br><span class="line">    file_obj.close()</span><br><span class="line">    log.info(&apos;cifs read end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Write-1"><a href="#Write-1" class="headerlink" title="Write"></a>Write</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def write(self):</span><br><span class="line">log.info(&apos;cifs write start...&apos;)</span><br><span class="line">file_obj = open(self.client_path, &apos;rb&apos;)</span><br><span class="line">self.smb.storeFile(</span><br><span class="line">    self.directory,</span><br><span class="line">    self.filename,</span><br><span class="line">    file_obj</span><br><span class="line"> )</span><br><span class="line">file_obj.close()</span><br><span class="line">log.info(&apos;cifs write end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Delete-1"><a href="#Delete-1" class="headerlink" title="Delete"></a>Delete</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def delete(self):</span><br><span class="line">log.info(&apos;cifs delete start...&apos;)</span><br><span class="line">self.smb.deleteFiles(&apos;path3&apos;, self.filename)</span><br><span class="line">log.info(&apos;cifs delete end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def close(self):</span><br><span class="line">    self.smb.close()</span><br></pre></td></tr></table></figure><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><h4 id="Connect-2"><a href="#Connect-2" class="headerlink" title="Connect"></a>Connect</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def open(self):</span><br><span class="line">    self.ftp = FTP()</span><br><span class="line">    self.ftp.connect(</span><br><span class="line">        host=self.host.encode(&apos;utf-8&apos;),</span><br><span class="line">        port=self.port.encode(&apos;utf-8&apos;)</span><br><span class="line">    )</span><br><span class="line">    self.ftp.login(self.username, self.password)</span><br><span class="line">    log.info(&apos;ftp connect successfully!&apos;)</span><br></pre></td></tr></table></figure><h4 id="Read-2"><a href="#Read-2" class="headerlink" title="Read"></a>Read</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def read(self):</span><br><span class="line">log.info(&apos;ftp read start...&apos;)                                     </span><br><span class="line">buff_size = 1024</span><br><span class="line">fp = open(self.download_path, &quot;wb&quot;)                               </span><br><span class="line">self.ftp.retrbinary(</span><br><span class="line">    &quot;RETR &#123;&#125;&quot;.format(self.filename),</span><br><span class="line">    fp.write,</span><br><span class="line">    buff_size                                                     </span><br><span class="line">)   </span><br><span class="line">fp.close()</span><br><span class="line">log.info(&apos;ftp read end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Write-2"><a href="#Write-2" class="headerlink" title="Write"></a>Write</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def write(self):</span><br><span class="line">log.info(&apos;ftp write start...&apos;)                                    </span><br><span class="line">buff_size = 1024</span><br><span class="line"> fp = open(self.client_path, &quot;rb&quot;)</span><br><span class="line">self.ftp.storbinary(</span><br><span class="line">    &quot;STOR &#123;&#125;&quot;.format(self.filename),</span><br><span class="line">    fp,</span><br><span class="line">   buff_size</span><br><span class="line">)</span><br><span class="line">fp.close()</span><br><span class="line">log.info(&apos;ftp write end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Delete-2"><a href="#Delete-2" class="headerlink" title="Delete"></a>Delete</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def delete(self):</span><br><span class="line">log.info(&apos;ftp delete start...&apos;)</span><br><span class="line">self.ftp.delete(self.filename)</span><br><span class="line">log.info(&apos;ftp delete end...&apos;)</span><br></pre></td></tr></table></figure><h4 id="Close-1"><a href="#Close-1" class="headerlink" title="Close"></a>Close</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def close(self):</span><br><span class="line">    self.ftp.quit(self.filename)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还有一些其他的<code>API</code>接口就不一一赘述了，具体实现细节大家可以查看<code>github</code>上面的项目代码，具体地址我会在文末贴出。整个项目的核心是通过<code>celery</code>实现任务的调度，还有全程通过<code>python</code>连接和操作<code>nas</code>服务，后续还会不断完善~~~</p><blockquote><p><strong>项目地址：</strong><a href="https://github.com/tony-yin/python_nas" target="_blank" rel="noopener">https://github.com/tony-yin/python_nas</a></p></blockquote><p><br></p><blockquote><p>参考列表：<br><a href="https://pypi.org/project/libnfs/" target="_blank" rel="noopener">python 操作samba文件服务器</a><br><a href="https://blog.csdn.net/u014245412/article/details/72286348" target="_blank" rel="noopener">python libnfs</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/nas.jpg&quot; alt=&quot;NAS Stable Test&quot;&gt;&lt;/center&gt;

&lt;p&gt;最近公司有个集群一直在跑着，领导想要测测它上面&lt;code&gt;NAS&lt;/code&gt;服务的稳定性，也就是看看正常持续的读写会不会导致&lt;code&gt;NAS&lt;/code&gt;服务异常，这个其实通过&lt;code&gt;fio&lt;/code&gt;或者&lt;code&gt;cosbench&lt;/code&gt;这类的工具测试起来很容易，但是这样一是没有挑战性，二是比较机械，可扩展性低。比如并行测试、进程保护和异常通知等等这些是机械地运用工具测试所做不到的，所以我们尝试做了一套基于&lt;code&gt;NAS&lt;/code&gt;稳定性测试的框架。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Python" scheme="https://tony-yin.github.io/tags/Python/"/>
    
      <category term="NAS" scheme="https://tony-yin.github.io/tags/NAS/"/>
    
  </entry>
  
  <entry>
    <title>Daily Article Vol 4 - (2018/3/1 ~ 2018/3/31)</title>
    <link href="https://tony-yin.github.io/2018/04/01/Daily_Article_Vol4/"/>
    <id>https://tony-yin.github.io/2018/04/01/Daily_Article_Vol4/</id>
    <published>2018-04-01T02:13:25.000Z</published>
    <updated>2018-12-13T16:40:24.421Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/2018_march.jpg" alt="Daily Article 3"></center><p>这个月主要因为离职和入职，花费了大量时间和相关的人沟通，还有办理了很多手续，包括找房子和搬家等等。真是忙的焦头烂额，奢侈地给自己放了一个星期的假期。</p><a id="more"></a><p>离开了工作了两年的公司，真是感慨万千。还没毕业就到这家公司实习，然后提前试用、转正。师父耐心的指导，无论是技术上还是生活上都受益匪浅，帮我扎实地掌握了一名软件开发工程师应该具备的技能；钱总作为<code>CTO</code>仿佛身上一直贴着技术控的标签，殊不知竟各项全能，机缘巧合带我做起了<code>Ceph</code>，这一年中不仅从钱总身上学到了很多高新技术，也从每次吃饭饭桌上、下班路上、地铁上倾听他年轻的故事中受益很多，常常听起来热血沸腾。还有很多帮助过我和关心过我的人就不一一点名了。总之，大家都很厉害，也正是因为如此，在我工作的两年中，我能够不断感受到压力，不断进步，并且以后会一直以你们为我的榜样，以后还要多多指教，多交流多切磋。</p><p>入职了新的公司，规模和规范都比原来上了一个档次，正式了许多，上下班都要打卡，一开始不习惯，下班总是忘记。。还有经常开会，要写很多设计和方案，感觉不像以后有师父和钱总这样带我走了，哈哈，但也多了很多参与感，大事小事都可以提出自己的想法，也可以从同事的想法中学习很多。也是巧合，之前网上因博客结缘的一位小伙伴现在和我同组，负责带我熟悉各方面，顿时轻松了很多，他人也很<code>nice</code>，看的出来很热爱技术，身上有很多值得我学习的点，算是一个挺优秀的同龄人了。总体来说，对新公司的印象还是不错的，好好加油吧！</p><p>这个月我买了极客时间上面陈皓老师（左耳朵耗子）的专栏，没买但想看的朋友可以点击我下面分享的链接观看，每个链接都有十个免费的观看圈，先到先到，如果觉得收获很大的话，建议买了看看，受益绝不止这<code>199</code>哦~~~</p><p>新公司任务调度用到了<code>celery</code>框架，感觉还蛮好用的，还在熟悉中…</p><ol><li><a href="http://www.sebastien-han.fr/blog/2015/04/27/ceph-manually-repair-object/" target="_blank" rel="noopener">Ceph: manually repair object</a>(3/2) <i class="fa fa-star"></i><i class="fa fa-star"></i> </li><li><a href="http://blog.csdn.net/younger_china/article/details/75150261" target="_blank" rel="noopener">【分析】Ceph数据一致性检查 - Scrub的介绍</a>(3/5)</li><li><a href="http://blog.csdn.net/younger_china/article/details/75149045" target="_blank" rel="noopener">【分析】Ceph数据一致性检查 - 端到端的数据校验</a>(3/5)</li><li><a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx5d7aad8e7ec33bfd&amp;redirect_uri=https%3A%2F%2Faccount.geekbang.org%2Faccount%2Foauth%2Fcallback%3Ftype%3Dwechatopen%26ident%3D60f4b1%26redirect%3Dhttps%253A%252F%252Ftime.geekbang.org%252Fcolumn%252Farticle%252F45c83454a044f89f8eff69b8a7dbeac3%252Fshare%253Ffailedurl%253Dhttps%253A%252F%252Ftime.geekbang.org%252Fcolumn%252Farticle%252F45c83454a044f89f8eff69b8a7dbeac3%252Fshare&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=d2b1c68fbd5a953da5f04515e46f9b48&amp;connect_redirect=1#wechat_redirect" target="_blank" rel="noopener">洞悉技术的本质，享受科技的乐趣</a>(3/17)</li><li><a href="https://time.geekbang.org/column/article/e3b6ea4c823d2c319bcbce9a1dc23501/share" target="_blank" rel="noopener">程序员如何用技术变现（上）</a>(3/17) <i class="fa fa-star"></i></li><li><a href="https://time.geekbang.org/column/article/c260269c38db5276c17f1be49718f74a/share" target="_blank" rel="noopener">程序员如何用技术变现（下）</a>(3/17)</li><li><a href="https://time.geekbang.org/column/article/70f255c35f7e58cb008e4410659cb39e/share" target="_blank" rel="noopener">Equifax信息泄露始末</a>(3/18)</li><li><a href="https://time.geekbang.org/column/article/3aa6350a995faf76c32e61ba6f7db3e9/share" target="_blank" rel="noopener">从Equifax信息泄露看数据安全</a>(3/18)</li><li><a href="https://time.geekbang.org/column/article/66c547af27e04afd4b7c2f8444d0971f/share" target="_blank" rel="noopener">何为技术领导力</a>(3/18)</li><li><a href="https://time.geekbang.org/column/article/0294f13512d5b6608115a601eb373287/share" target="_blank" rel="noopener">如何拥有技术领导力</a>(3/18)</li><li><a href="https://time.geekbang.org/column/article/5df06f61f6d635f5fc71b27ccc39902d/share" target="_blank" rel="noopener">每个程序员都该知道的事</a>(3/19)</li><li><a href="https://time.geekbang.org/column/article/af44ced83be43d287e728d2eaee10afc/share" target="_blank" rel="noopener">Go语言，Docker和新技术</a>(3/19)</li><li><a href="https://time.geekbang.org/column/article/946c705caf3299894fcc991bc59992de/share" target="_blank" rel="noopener">答疑解惑：渴望、热情和选择</a>(3/20)</li><li><a href="https://time.geekbang.org/column/article/ef3daa17d473e583835df8248082f6fc/share" target="_blank" rel="noopener">如何成为一个大家愿意追随的Leader？</a>(3/20)</li><li><a href="http://blog.51cto.com/hongtengfei/1684809" target="_blank" rel="noopener">NFS服务详细分析</a>(3/21) <i class="fa fa-star"></i></li><li><a href="http://blog.csdn.net/acs713/article/details/7322082" target="_blank" rel="noopener">理解Linux系统/etc/init.d目录和/etc/rc.local脚本</a>(3/21)</li><li><a href="https://time.geekbang.org/column/article/73253891c16c684d3c9dcfd02dfcb54f/share" target="_blank" rel="noopener">分布式系统架构的冰与火</a>(3/21) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://time.geekbang.org/column/article/a3b4de20403567fbdf305bdd4e403026/share" target="_blank" rel="noopener">从亚马逊的实践，谈分布式系统的难点</a>(3/22) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://blog.csdn.net/a18829898663/article/details/71065999" target="_blank" rel="noopener">访问网络文件共享服务-CIFS</a>(3/23) <i class="fa fa-star"></i></li><li><a href="https://www.liaoxuefeng.com/article/00137760323922531a8582c08814fb09e9930cede45e3cc000" target="_blank" rel="noopener">任务调度利器：Celery</a>(3/26)</li><li><a href="https://www.jianshu.com/p/1840035cb510" target="_blank" rel="noopener">异步任务神器 Celery 简明笔记</a>(3/26)</li><li><a href="http://www.open-open.com/lib/view/open1426298834326.html" target="_blank" rel="noopener">Python 并行分布式框架：Celery</a>(3/26) <i class="fa fa-star"></i></li><li><a href="https://www.jianshu.com/p/9c04890615ba" target="_blank" rel="noopener">Redis实现简单消息队列</a>(3/27) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://www.cnblogs.com/davidshen/p/8145984.html" target="_blank" rel="noopener">cifs协议与samba服务</a>(3/28~3/29) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://linuxtoy.org/archives/selinux-introduction.html" target="_blank" rel="noopener">SELinux 入门</a>(3/29)</li><li><a href="http://www.cnblogs.com/shanyou/archive/2013/02/04/2891300.html" target="_blank" rel="noopener">Ring Buffer 有什么特别?</a>(3/29) <i class="fa fa-star"></i></li><li><a href="https://time.geekbang.org/column/article/f9126577b469b13317889a99ea70d2f0/share" target="_blank" rel="noopener">分布式系统的技术栈</a>(3/30) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://time.geekbang.org/column/article/8efeb52c4015735a7ea424e0cff861c1/share" target="_blank" rel="noopener">分布式系统关键技术：全栈监控</a>(3/31) <i class="fa fa-star"></i><i class="fa fa-star"></i></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/2018_march.jpg&quot; alt=&quot;Daily Article 3&quot;&gt;&lt;/center&gt;

&lt;p&gt;这个月主要因为离职和入职，花费了大量时间和相关的人沟通，还有办理了很多手续，包括找房子和搬家等等。真是忙的焦头烂额，奢侈地给自己放了一个星期的假期。&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
      <category term="Daily-Article" scheme="https://tony-yin.github.io/tags/Daily-Article/"/>
    
  </entry>
  
  <entry>
    <title>硬件环境测试环境模拟</title>
    <link href="https://tony-yin.github.io/2018/03/09/Hardware-Test-Tool/"/>
    <id>https://tony-yin.github.io/2018/03/09/Hardware-Test-Tool/</id>
    <published>2018-03-09T06:35:06.000Z</published>
    <updated>2018-12-13T16:40:24.431Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/hardware-600x450.jpg" alt="hardware"></center><p>最近在做一个<code>feature</code>，测试的时候需要硬件环境的支撑。一般我们开发环境都是虚拟机，所以针对这种开发工作的自测无法进行，比如虚拟机上没有物理磁盘，没有<code>raid</code>卡等，为了一个小功能的测试，需要出<code>build</code>，需要硬件环境的部署和安装，这个工作量着实不小。</p><p>往往针对这种情况，作为开发人员可以针对硬件环境的具体需求，尽可能在自己的环境上做模拟，也就是我们俗称的“打桩”。</p><a id="more"></a><p>就拿我这次做的需求来说吧，我想获取磁盘的相关信息，获取方式是通过<code>raid</code>卡工具，可能是<code>megacli</code>，也可能是<code>sas3ircu</code>等等，这个取决于<code>lspci</code>查看<code>raid</code>卡的型号，然后还要通过<code>lsblk</code>和<code>lsscsi</code>工具获取相关信息。</p><p>我的做法是针对这些工具，自己写一个简易的小工具，就比如<code>lsblk</code>我也写一个<code>lsblk</code>的脚本，里面的代码也很简单，先找一个硬件环境，将<code>lsblk</code>读取的内容重定向到文件中，这时候我们自己写的脚本直接去读这个文件就可以了。务必要保证各个软件工具的一致性。</p><p>以<code>lsblk</code>为例，我可能需求两种情况<code>lsblk</code>和<code>lsblk -l</code>：</p><p><code>lsblk</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash                                                        </span></span><br><span class="line"></span><br><span class="line">lsblk_path=$(dirname $0)</span><br><span class="line">if [ $# -eq 0 ]; then</span><br><span class="line">    echo "$(cat $lsblk_path"/lsblk.txt")"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">while getopts ":l" opt; do</span><br><span class="line">    case $opt in  </span><br><span class="line">        l)  </span><br><span class="line">            echo "$(cat $lsblk_path"/lsblk_list.txt")"</span><br><span class="line">            ;;  </span><br><span class="line">        \?) </span><br><span class="line">            echo "Invalid option: -$OPTARG"</span><br><span class="line">            ;;  </span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><code>lsblk.txt</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">NAME     MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT </span><br><span class="line">sda        8:0    0   3.7T  0 disk </span><br><span class="line">├─sda1     8:1    0  30.5M  0 part ar</span><br><span class="line">├─sda2     8:2    0 488.3M  0 part ar</span><br><span class="line">├─sda3     8:3    0  93.1G  0 part /rt</span><br><span class="line">├─sda4     8:4    0   256G  0 part [SWAP]WA</span><br><span class="line">└─sda5     8:5    0   3.3T  0 part /data/osd.0sd</span><br><span class="line">sdb        8:16   0 372.1G  0 disk </span><br><span class="line">└─sdb1     8:17   0 372.1G  0 part ar</span><br><span class="line">sdc        8:32   0   2.7T  0 disk </span><br><span class="line">└─sdc1     8:33   0   2.7T  0 part /data/osd.1sd</span><br><span class="line">sdd        8:48   0   2.7T  0 disk </span><br><span class="line">└─sdd1     8:49   0   2.7T  0 part /data/osd.2sd</span><br><span class="line">sde        8:64   0   2.7T  0 disk </span><br><span class="line">└─sde1     8:65   0   2.7T  0 part /data/osd.3sd</span><br><span class="line">sdf        8:80   0   2.7T  0 disk </span><br><span class="line">└─sdf1     8:81   0   2.7T  0 part /data/osd.11d.</span><br><span class="line">sdg        8:96   0   2.7T  0 disk </span><br><span class="line">└─sdg1     8:97   0   2.7T  0 part /data/osd.12d.</span><br><span class="line">sdh        8:112  0   2.7T  0 disk </span><br><span class="line">└─sdh1     8:113  0   2.7T  0 part ar</span><br><span class="line">sdi        8:128  0   2.7T  0 disk </span><br><span class="line">└─sdi1     8:129  0   2.7T  0 part /data/osd.8sd</span><br><span class="line">sdj        8:144  0   2.7T  0 disk </span><br><span class="line">└─sdj1     8:145  0   2.7T  0 part /data/osd.9sd</span><br><span class="line">sdk        8:160  0   2.7T  0 disk </span><br><span class="line">└─sdk1     8:161  0   2.7T  0 part /data/osd.10d.</span><br><span class="line">sdl        8:176  0   2.7T  0 disk </span><br><span class="line">└─sdl1     8:177  0   2.7T  0 part ar</span><br><span class="line">sdm        8:192  0   2.7T  0 disk </span><br><span class="line">└─sdm1     8:193  0   2.7T  0 part ar</span><br><span class="line">sdn        8:208  0   2.7T  0 disk </span><br><span class="line">└─sdn1     8:209  0   2.7T  0 part ar</span><br><span class="line">sdo        8:224  0   2.7T  0 disk </span><br><span class="line">└─sdo1     8:225  0   2.7T  0 part</span><br><span class="line">sdp        8:240  0   2.7T  0 disk</span><br><span class="line">└─sdp1     8:241  0   2.7T  0 part</span><br><span class="line">sdq       65:0    0   2.7T  0 disk</span><br><span class="line">└─sdq1    65:1    0   2.7T  0 part</span><br><span class="line">sdr       65:16   0   2.7T  0 disk</span><br><span class="line">└─sdr1    65:17   0   2.7T  0 part</span><br><span class="line">sds       65:32   0   2.7T  0 disk</span><br><span class="line">└─sds1    65:33   0   2.7T  0 part</span><br><span class="line">sdt       65:48   0   2.7T  0 disk</span><br><span class="line">└─sdt1    65:49   0   2.7T  0 part</span><br><span class="line">sdu       65:64   0   2.7T  0 disk</span><br><span class="line">└─sdu1    65:65   0   2.7T  0 part</span><br><span class="line">sdv       65:80   0 744.7G  0 disk</span><br><span class="line">├─sdv1    65:81   0    50G  0 part</span><br><span class="line">├─sdv2    65:82   0    50G  0 part</span><br><span class="line">├─sdv3    65:83   0    50G  0 part</span><br><span class="line">├─sdv4    65:84   0    50G  0 part</span><br><span class="line">├─sdv5    65:85   0    50G  0 part</span><br><span class="line">├─sdv6    65:86   0    50G  0 part</span><br><span class="line">├─sdv7    65:87   0    50G  0 part</span><br><span class="line">├─sdv8    65:88   0    50G  0 part</span><br><span class="line">├─sdv9    65:89   0    50G  0 part</span><br><span class="line">├─sdv10   65:90   0    50G  0 part</span><br><span class="line">├─sdv11   65:91   0    50G  0 part</span><br><span class="line">└─sdv12   65:92   0    50G  0 part</span><br></pre></td></tr></table></figure><p><code>lsblk_list.txt</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0   3.7T  0 disk </span><br><span class="line">sda1     8:1    0  30.5M  0 part </span><br><span class="line">sda2     8:2    0 488.3M  0 part </span><br><span class="line">sda3     8:3    0  93.1G  0 part /</span><br><span class="line">sda4     8:4    0   256G  0 part [SWAP]</span><br><span class="line">sda5     8:5    0   3.3T  0 part /data/osd.0</span><br><span class="line">sdb      8:16   0 372.1G  0 disk </span><br><span class="line">sdb1     8:17   0 372.1G  0 part </span><br><span class="line">sdc      8:32   0   2.7T  0 disk </span><br><span class="line">sdc1     8:33   0   2.7T  0 part /data/osd.1</span><br><span class="line">sdd      8:48   0   2.7T  0 disk </span><br><span class="line">sdd1     8:49   0   2.7T  0 part /data/osd.2</span><br><span class="line">sde      8:64   0   2.7T  0 disk </span><br><span class="line">sde1     8:65   0   2.7T  0 part /data/osd.3</span><br><span class="line">sdf      8:80   0   2.7T  0 disk </span><br><span class="line">sdf1     8:81   0   2.7T  0 part /data/osd.11</span><br><span class="line">sdg      8:96   0   2.7T  0 disk </span><br><span class="line">sdg1     8:97   0   2.7T  0 part /data/osd.12</span><br><span class="line">sdh      8:112  0   2.7T  0 disk </span><br><span class="line">sdh1     8:113  0   2.7T  0 part </span><br><span class="line">sdi      8:128  0   2.7T  0 disk </span><br><span class="line">sdi1     8:129  0   2.7T  0 part /data/osd.8</span><br><span class="line">sdj      8:144  0   2.7T  0 disk </span><br><span class="line">sdj1     8:145  0   2.7T  0 part /data/osd.9</span><br><span class="line">sdk      8:160  0   2.7T  0 disk </span><br><span class="line">sdk1     8:161  0   2.7T  0 part /data/osd.10</span><br><span class="line">sdl      8:176  0   2.7T  0 disk </span><br><span class="line">sdl1     8:177  0   2.7T  0 part </span><br><span class="line">sdm      8:192  0   2.7T  0 disk </span><br><span class="line">sdm1     8:193  0   2.7T  0 part </span><br><span class="line">sdn      8:208  0   2.7T  0 disk </span><br><span class="line">sdn1     8:209  0   2.7T  0 part </span><br><span class="line">sdo      8:224  0   2.7T  0 disk </span><br><span class="line">sdo1     8:225  0   2.7T  0 part</span><br><span class="line">sdp      8:240  0   2.7T  0 disk</span><br><span class="line">sdp1     8:241  0   2.7T  0 part</span><br><span class="line">sdq     65:0    0   2.7T  0 disk</span><br><span class="line">sdq1    65:1    0   2.7T  0 part</span><br><span class="line">sdr     65:16   0   2.7T  0 disk</span><br><span class="line">sdr1    65:17   0   2.7T  0 part</span><br><span class="line">sds     65:32   0   2.7T  0 disk</span><br><span class="line">sds1    65:33   0   2.7T  0 part</span><br><span class="line">sdt     65:48   0   2.7T  0 disk</span><br><span class="line">sdt1    65:49   0   2.7T  0 part</span><br><span class="line">sdu     65:64   0   2.7T  0 disk</span><br><span class="line">sdu1    65:65   0   2.7T  0 part</span><br><span class="line">sdv     65:80   0 744.7G  0 disk</span><br><span class="line">sdv1    65:81   0    50G  0 part</span><br><span class="line">sdv2    65:82   0    50G  0 part</span><br><span class="line">sdv3    65:83   0    50G  0 part</span><br><span class="line">sdv4    65:84   0    50G  0 part</span><br><span class="line">sdv5    65:85   0    50G  0 part</span><br><span class="line">sdv6    65:86   0    50G  0 part</span><br><span class="line">sdv7    65:87   0    50G  0 part</span><br><span class="line">sdv8    65:88   0    50G  0 part</span><br><span class="line">sdv9    65:89   0    50G  0 part</span><br><span class="line">sdv10   65:90   0    50G  0 part</span><br><span class="line">sdv11   65:91   0    50G  0 part</span><br><span class="line">sdv12   65:92   0    50G  0 part</span><br></pre></td></tr></table></figure><p>还有一些其他工具我就不详细贴代码了，具体请去<code>github</code>上查看。</p><p>项目地址：<a href="https://github.com/tony-yin/Hardware_Test_Tool" target="_blank" rel="noopener">https://github.com/tony-yin/Hardware_Test_Tool</a></p><p>操作步骤：</p><p>1.下载代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:tony-yin/Hardware_Test_Tool.git</span><br></pre></td></tr></table></figure><p>2.安装工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build install</span><br></pre></td></tr></table></figure><p>3.卸载工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build uninstall</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/hardware-600x450.jpg&quot; alt=&quot;hardware&quot;&gt;&lt;/center&gt;

&lt;p&gt;最近在做一个&lt;code&gt;feature&lt;/code&gt;，测试的时候需要硬件环境的支撑。一般我们开发环境都是虚拟机，所以针对这种开发工作的自测无法进行，比如虚拟机上没有物理磁盘，没有&lt;code&gt;raid&lt;/code&gt;卡等，为了一个小功能的测试，需要出&lt;code&gt;build&lt;/code&gt;，需要硬件环境的部署和安装，这个工作量着实不小。&lt;/p&gt;
&lt;p&gt;往往针对这种情况，作为开发人员可以针对硬件环境的具体需求，尽可能在自己的环境上做模拟，也就是我们俗称的“打桩”。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Test" scheme="https://tony-yin.github.io/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>Daily Article Vol 3 - (2018/2/1 ~ 2018/2/28)</title>
    <link href="https://tony-yin.github.io/2018/03/01/Daily-Article-Vol3/"/>
    <id>https://tony-yin.github.io/2018/03/01/Daily-Article-Vol3/</id>
    <published>2018-03-01T02:13:25.000Z</published>
    <updated>2018-12-13T16:40:24.420Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/february-600x450.jpg" alt="Daily Article 3"></center><p>这段期间，一方面是因为过年，另一方面因为换工作，所以诸事缠身，导致每天阅读学习的量严重受影响，不能保持每天都有固定的时间学习和阅读，还是自己的问题，不应该找借口。之后，不管什么事情，必须要保证每天的学习量和阅读量，养成雷打不动的好习惯。</p><p>这是<code>Daily Article</code>系列的第三篇，罗列了<code>2018</code>年<code>2</code>月的阅读清单。</p><a id="more"></a><hr><ol><li><a href="https://my.oschina.net/u/2460844/blog/669769" target="_blank" rel="noopener">ceph的数据存储之路(10) —–ceph对象存储的ls命令实现及思考</a>(2/1 ~ 2/5) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://python.jobbole.com/82270/" target="_blank" rel="noopener">八大排序算法的 Python 实现</a>(2/6)</li><li><a href="https://georgezhuo.github.io/georgezhuo.github.io/2015/12/22/ceph-message/" target="_blank" rel="noopener">Ceph解析-消息处理模块</a>(2/7) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://www.wzxue.com/ceph-network/" target="_blank" rel="noopener">解析Ceph: 网络层的处理</a>(2/7)</li><li><a href="http://blog.csdn.net/skdkjzz/article/details/41980631" target="_blank" rel="noopener">ceph存储 ceph集群消息处理</a>(2/8)</li><li><a href="https://my.oschina.net/u/2460844/blog/531646" target="_blank" rel="noopener">ceph的数据存储之路(1) —rbd设备介绍</a>(2/11) <i class="fa fa-star"></i></li><li><a href="https://my.oschina.net/u/2460844/blog/531686" target="_blank" rel="noopener">ceph的数据存储之路(2) —– rbd到osd的数据映射</a>(2/11)</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513393&amp;idx=1&amp;sn=c1d6caca8ef9972f1105df982f15bb58&amp;chksm=80d679f2b7a1f0e410fd53691d68a9ada158aac2b8814fe329d6dfed86ee54b68a53eb84cdb0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">张大胖学递归</a>(2/16) <i class="fa fa-star"></i></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513387&amp;idx=1&amp;sn=99665948d0b968cf15c5e7a01ffe166c&amp;chksm=80d679e8b7a1f0febad077b57e8ad73bfb4b08de74814c45e1b1bd61ab4017b5041942403afb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">张大胖的socket</a>(2/17) <i class="fa fa-star"></i></li><li><a href="https://my.oschina.net/u/2460844/blog/532755?p=2&amp;temp=1519178944837#blog-comments-list" target="_blank" rel="noopener">ceph的数据存储之路(4) —– rbd client 端的数据请求处理</a>(2/18~2/20) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513353&amp;idx=1&amp;sn=a5dc69542fae6aabf0fef9b5f5881a9d&amp;chksm=80d679cab7a1f0dc530bd1745c2c9552b739afc701ecb2f8e1eba8624d1fefc2c3cc64cd1d30&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">学习面向对象的令狐冲</a>(2/21) <i class="fa fa-star"></i></li><li><a href="http://mp.weixin.qq.com/s/wyt-0y3lEhewa2cpeILYSQ" target="_blank" rel="noopener">张大胖学数据库</a>(2/22)</li><li><a href="https://mp.weixin.qq.com/s/tSF_w9xUOj3Q2hmOxJkwLg" target="_blank" rel="noopener">数据库村的旺财和小强</a>(2/23) <i class="fa fa-star"></i></li><li><a href="https://my.oschina.net/u/2460844/blog/534390?p=1&amp;temp=1519628036891#blog-comments-list" target="_blank" rel="noopener">ceph的数据存储之路(5) —–osd数据处理</a>(2/24 ~ 2/26) <i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDE0NjUxMQ==&amp;mid=2651256389&amp;idx=1&amp;sn=e11edcce5722853f442b9a7b8211787e&amp;chksm=f2901e65c5e79773c7690f29e35dbd1870a5bfdb92c70541979f5d080d6580e3af9ba85fff66&amp;mpshare=1&amp;scene=23&amp;srcid=0502SazrSPsWnszP3xfdEId4#rd" target="_blank" rel="noopener"> Ceph开发每周谈 Vol 70 | RGW 同步到 AWS S3 | Elastic Search API 整合</a>(2/26)</li><li><a href="http://ceph.com/planet/ceph-osd%E4%BB%8Efilestore-%E8%BD%AC%E6%8D%A2%E5%88%B0-bluestore%E7%9A%84%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">Ceph OSD从filestore 转换到 bluestore的方法</a>(2/27)</li><li><a href="https://my.oschina.net/u/2460844/blog/535007" target="_blank" rel="noopener">ceph的数据存储之路(6) —–pg的创建</a>(2/28)</li><li><a href="https://www.sogou.com/link?url=6IqLFeTuIyjnBL6rnEdhCp_rFXz42FvmEhOk1arvVrbkYalcctcthKCfjFS1STqz" target="_blank" rel="noopener">XSKY在OpenStack场景下的优势</a>(2/28)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/february-600x450.jpg&quot; alt=&quot;Daily Article 3&quot;&gt;&lt;/center&gt;

&lt;p&gt;这段期间，一方面是因为过年，另一方面因为换工作，所以诸事缠身，导致每天阅读学习的量严重受影响，不能保持每天都有固定的时间学习和阅读，还是自己的问题，不应该找借口。之后，不管什么事情，必须要保证每天的学习量和阅读量，养成雷打不动的好习惯。&lt;/p&gt;
&lt;p&gt;这是&lt;code&gt;Daily Article&lt;/code&gt;系列的第三篇，罗列了&lt;code&gt;2018&lt;/code&gt;年&lt;code&gt;2&lt;/code&gt;月的阅读清单。&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
      <category term="Daily-Article" scheme="https://tony-yin.github.io/tags/Daily-Article/"/>
    
  </entry>
  
  <entry>
    <title>Daily Article Vol 2 - (2018/1/1 ~ 2018/1/31)</title>
    <link href="https://tony-yin.github.io/2018/02/01/Daily-Article-Vol2/"/>
    <id>https://tony-yin.github.io/2018/02/01/Daily-Article-Vol2/</id>
    <published>2018-02-01T02:07:06.000Z</published>
    <updated>2018-12-13T16:40:24.419Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/2018-01-600x450.png" alt="Daily Article Vol2"></center><p>这是<code>Daily Article</code>系列的第二篇，罗列了<code>2018</code>年<code>1</code>月的阅读清单。</p><a id="more"></a><ol><li><a href="http://datawarehouse4u.info/OLTP-vs-OLAP.html" target="_blank" rel="noopener">OLTP vs. OLAP</a>(1/2)</li><li><a href="http://blog.csdn.net/zhanghaocore/article/details/9820215" target="_blank" rel="noopener">OLTP和OLAP的区别</a>(1/2)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-31/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 31｜ZetaScale 开源 | DMClock</a>(1/2)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-32/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 32｜Ceph-osd on 4.x 内核异常</a>(1/3)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-33/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 33｜Encode 改进方案</a>(1/3)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-34/" target="_blank" rel="noopener">Ceph开发每周谈Vol 34 | Ceph Days 亚太路演 | Ceph OSD CLASS 支持 LUA 编程</a>(1/3)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-35/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 35 | Ceph Developer Month</a>(1/3)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-36/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 36|Ebay 的 CephFS 使用深度报告</a>(1/4)</li><li><a href="https://www.xsky.com/tec/ceph-weekly-vol-37/" target="_blank" rel="noopener">Ceph开发每周谈 Vol 37｜NVME Over Fabric｜FAST</a>(1/4)</li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665514131&amp;idx=1&amp;sn=a11640045e1458c0e3ba866d23541526&amp;chksm=80d67cd0b7a1f5c6c4dee2cb64b6f173524d443dae8be471bb901eebeec4db5d1773818080b7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">【码农翻身】 浏览器：一个家族的奋斗</a>(1/6) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665514143&amp;idx=1&amp;sn=28ea209c00309e6b93d8d1f76032d7a4&amp;chksm=80d67cdcb7a1f5ca81d8d454a98af56d58b22f6058f100e21ff30e70867ea6e3e922a4f000bf&amp;scene=21%23wechat_redirect" target="_blank" rel="noopener">【码农翻身】 浏览器家族的安全反击战</a>(1/6) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://mp.weixin.qq.com/s/YvYvL0siJT1UhO0tXnYVNA" target="_blank" rel="noopener">【码农翻身】 黑客三兄弟</a>(1/6) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513220&amp;idx=1&amp;sn=bb9c4df63cf6994d6aab9d77a10fe628&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">【码农翻身】 GitHub/Stackoverflow 找工作时有什么用？</a>(1/6)</li><li><a href="https://mp.weixin.qq.com/s/-BMCUuIWYE3O_oC3ZNNJRg" target="_blank" rel="noopener">【码农翻身】 我是一个线程(修订版)</a>(1/7) <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i></li><li><a href="http://www.freeoa.net/osuport/botinstal/instal-compile-linux-ipvs-mod_3170.html" target="_blank" rel="noopener">Linux下安装编译IPVS内核模块</a>(1/8) <i class="fa fa-star"></i></li><li><a href="https://www.tuicool.com/articles/RfmI3u" target="_blank" rel="noopener">How to Repack Deb Files on Debian and Ubuntu</a> <i class="fa fa-star"></i>(1/8)</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665514224&amp;idx=1&amp;sn=5b802dfab658a626a197635cf56c9bac&amp;chksm=80d67cb3b7a1f5a585f778b28ceb88855b140ff090c0d0b00f10e9e9b889c81c20190ba80a06&amp;scene=38#wechat_redirect" target="_blank" rel="noopener">什么是DevOps</a> <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star-half-full"></i>(1/8)</li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=416915373&amp;idx=1&amp;sn=f80a13b099237534a3ef777d511d831a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">我是一个线程</a> <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star-half-full"></i>(1/8)</li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513059&amp;idx=1&amp;sn=a2eaf97d9e3000d15a33681d1b720463&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Javascript: 一个屌丝的逆袭</a> <i class="fa fa-star"></i><i class="fa fa-star"></i>(1/9)</li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513094&amp;idx=1&amp;sn=a2accfc41107ac08d74ec3317995955e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">TCP/IP 之 大明王朝的邮差</a> <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i>(1/9)</li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513375&amp;idx=1&amp;sn=e11745d5cb28fa1f89465f8d0e5fae1a&amp;chksm=80d679dcb7a1f0cadec0a1db45b3fa3f6eabde4a9e56a77acf551fbc1511e6b8f055ee2c97e3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">TCP/IP 之 大明内阁</a> <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i>(1/9)</li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513384&amp;idx=1&amp;sn=82c45e4430618270a744e212d2f57990&amp;chksm=80d679ebb7a1f0fd27fe1814765a0e60b1c293ca4e09403271b4bb3f38f317439956fdca1bc1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">TCP/IP 之 蓟辽督师</a> <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i>(1/10)</li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513017&amp;idx=1&amp;sn=5550ee714abd36d0b580713f673e670b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">CPU 阿甘</a> <i class="fa fa-star"></i>(1/10)</li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513254&amp;idx=1&amp;sn=a4d1912b6259c3e65c0e172fb5a10dbb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">CPU 阿甘之烦恼</a> <i class="fa fa-star"></i>(1/10)</li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NTU2MTQwNA==&amp;mid=2650655754&amp;idx=1&amp;sn=0b03b942ecdb25ef45ea3a9cbff686c3&amp;chksm=beffc6d989884fcf49c79c662162ed7852b17e192b7f40fcda040308eb10b26a9b187f675940&amp;scene=0&amp;key=78733623947167cee9eb37fa8148459e73e455140b258998bf251e0d57524ceaaa6187e820f481781748d004b780efc58804a25dfdf285670ca35369d0e62d2d8e7cd8ca84306d36da7105f9c8042683&amp;ascene=0&amp;uin=MjEzMTAwMzgyNQ%3D%3D&amp;devicetype=iMac+MacBookAir7%2C1+OSX+OSX+10.12.6+build(16G29)&amp;version=12020810&amp;nettype=WIFI&amp;lang=zh_CN&amp;fontScale=100" target="_blank" rel="noopener">开源万岁！2018 年开源技术的 10 大发展趋势</a>(1/10)</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIxMTE0ODU5NQ%3D%3D&amp;mid=2650236979&amp;idx=1&amp;sn=71f07d1741a57f8fd429d76d37fd8a07&amp;chksm=8f5a026fb82d8b7931f95e747224b1049d1b0cf72f72babbf6629e183fa15c72570be4fc7253" target="_blank" rel="noopener">面试过阿里等互联网大公司，我知道了这些套路</a>(1/11)</li><li><a href="https://www.oschina.net/question/2928191_2272289" target="_blank" rel="noopener">访谈 | 鸟哥惠新宸：程序员应该不断提升自身的不可替代性</a>(1/15)</li><li><a href="https://mp.weixin.qq.com/s/_-7C_ZfFfvNKhBQzSB6j4Q" target="_blank" rel="noopener">黑客三兄弟（续）</a> <i class="fa fa-star"></i><i class="fa fa-star"></i>(1/19)</li><li><a href="https://mp.weixin.qq.com/s/vyHlB9pem4rv4htJS9ca6Q" target="_blank" rel="noopener">我是一个网卡</a> <i class="fa fa-star"></i><i class="fa fa-star"></i>(1/20)</li><li><a href="https://mp.weixin.qq.com/s/VyGQ4-Dn4UX2Z0CrCHgUqw" target="_blank" rel="noopener">我是一个路由器</a> <i class="fa fa-star"></i><i class="fa fa-star"></i>(1/21)</li><li><a href="https://mp.weixin.qq.com/s/KtHxMoc1_3sQd4d_MuKKJA" target="_blank" rel="noopener">我是一个进程</a> <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i>(1/22)</li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513289&amp;idx=1&amp;sn=ab19dcad7b1dc217463f155fe106091a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">我是一块硬盘（上）</a> <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star-half-full"></i>(1/22)</li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513292&amp;idx=1&amp;sn=5b1c87dc72a20c92883924080174b16b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">我是一块硬盘（下）</a> <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star-half-full"></i>(1/23)</li><li><a href="https://mp.weixin.qq.com/s/gliuPj9tfZkr9oXQn9re2w" target="_blank" rel="noopener">如何维护一个好的技术博客？</a> <i class="fa fa-star"></i>(1/23)</li><li><a href="https://mp.weixin.qq.com/s/643URs9k_EQIMWGmb35QkQ" target="_blank" rel="noopener">算法分析神器—时间复杂度</a> <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star-half-full"></i>(1/23)</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513299&amp;idx=1&amp;sn=264f4d0891e1b96fb5e356dc7b6c91dc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">我是一个键盘</a> <i class="fa fa-star"></i><i class="fa fa-star"></i> (1/24)</li><li><a href="https://mengkang.net/1129.html" target="_blank" rel="noopener">PHP 面试题 - 如果没有 mb 系列函数，如何切割多字节字符串</a>(1/28)</li><li><a href="http://www.quts.me/ceph-readwrite/" target="_blank" rel="noopener">ceph读写流程分析</a>(1/28)</li><li><a href="https://segmentfault.com/a/1190000013010835" target="_blank" rel="noopener">Token 认证的来龙去脉</a>(1/29) <i class="fa fa-star"></i><i class="fa fa-star-half-full"></i></li><li><a href="https://bean-li.github.io/ceph-read-flow/" target="_blank" rel="noopener">ceph 读流程(1)</a>(1/29) <i class="fa fa-star"></i></li><li><a href="https://mp.weixin.qq.com/s/gI1TjeAYjqgNo4RKqEqF-Q" target="_blank" rel="noopener">一个项目做完以后，不能就让它这么“完”了</a>(1/30)</li><li><a href="https://mp.weixin.qq.com/s/hDKQ1ITzTvi20kTA11xa1g" target="_blank" rel="noopener">科学与星球大战：当科幻遇到现实</a>(1/30) <i class="fa fa-star"></i></li><li><a href="https://bean-li.github.io/ceph-read-2/" target="_blank" rel="noopener">ceph 读流程(2)</a>(1/31) <i class="fa fa-star"></i></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/2018-01-600x450.png&quot; alt=&quot;Daily Article Vol2&quot;&gt;&lt;/center&gt;

&lt;p&gt;这是&lt;code&gt;Daily Article&lt;/code&gt;系列的第二篇，罗列了&lt;code&gt;2018&lt;/code&gt;年&lt;code&gt;1&lt;/code&gt;月的阅读清单。&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
      <category term="Daily-Article" scheme="https://tony-yin.github.io/tags/Daily-Article/"/>
    
  </entry>
  
  <entry>
    <title>实现RBD导出NFS高可用（二）：提供多虚拟IP访问</title>
    <link href="https://tony-yin.github.io/2018/01/28/RBD-HA-2/"/>
    <id>https://tony-yin.github.io/2018/01/28/RBD-HA-2/</id>
    <published>2018-01-28T05:07:06.000Z</published>
    <updated>2018-12-13T16:40:24.456Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://cdn.tony-yin.site/rbd2-600x450.jpg" alt="RBD-HA-2"></center><p>之前分享过一篇<a href="http://www.tony-yin.site/2017/12/07/RBD-HA/" target="_blank" rel="noopener">【通过 Keepalived 实现 Ceph RBD 的高可用】</a>，主要讲解了将<code>RBD</code>导出为<code>NFS</code>，然后通过<code>keepalived</code>实现高可用，保证当提供虚拟<code>IP</code>节点发生故障时，可以自动切换节点，使得业务不发生中断。</p><p>这样可以基本使用<code>RBD</code>代替<code>CephFS</code>对外提供<code>Ceph</code>服务，至于为什么不用<code>CephFS</code>就不多说了，不清楚的可以去看上一篇。虽然说这样可以保证无单点故障，但是有一点还是不如<code>CephFS</code>，那就是<code>CephFS</code>可以实现多节点同时提供服务，而<code>RBD</code>说白了其实同时只有一个节点能提供服务，当客户端流量高的时候，<code>RBD</code>方式的带宽并不能满足需求。就比如都是三个节点，<code>CephFS</code>可以将客户端流量分流到三个节点，而<code>RBD</code>只能用一个节点，而带宽上限又取决与网卡、磁盘和<code>IO</code>等等原因，所以同样的硬件设施<code>RBD</code>的带宽性能是跟不上的，本文就多虚拟<code>IP</code>暴露访问方式进行分享。</p><a id="more"></a><h2 id="CephFS-amp-RBD"><a href="#CephFS-amp-RBD" class="headerlink" title="CephFS &amp; RBD"></a>CephFS &amp; RBD</h2><p>此前的文章我们<code>Ceph</code>集群只有一个<code>RBD image</code>，并且只通过一个<code>vip</code>暴露这个<code>image</code>让客户端通过<code>NFS</code>访问。这与<code>CephFS</code>的差距就在没有充分利用每个节点的资源，所以我们可以大胆设想一下是否可以通过<code>RBD</code>对外提供多个<code>vip</code>，每个节点都能被<code>NFS</code>访问呢？理想很美好，现实很残酷。如果一个<code>RBD</code>对多个节点同时提供读写的话，会导致不一致的后果，现在<code>RBD</code>并不能做到<code>CephFS</code>那样多个节点同时提供服务且保证读写一致。那怎么办呢？</p><p>虽然一个<code>RBD image</code>不能同时被多客户端访问，但是我们是否可以创建多个<code>RBD image</code>，然后利用多个<code>vip</code>对外提供访问呢？这样听起来貌似可行，但是还是存在诸多问题，比如如何暴露多虚拟<code>IP</code>，如何将<code>IP</code>绑定到具体的<code>RBD image</code>，如何保证多<code>RBD image</code>的高可用等等，下文将就这些技术细节进行详细地分析。</p><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>客户端有多种应用场景，对流量要求较高的情况下，我们可以为每一种应用场景都提供一个<code>vip</code>用于<code>NFS</code>方式访问<code>Ceph</code>存储集群。然后每个<code>vip</code>各自对应集群中的一个<code>RBD image</code>，<code>RBD image</code>尽量均匀的分布到各个节点上，这样才能把性能提升到最高，比如集群有三个节点的话，如果暴露三个<code>vip</code>，那么必须要分布到三个不同的节点上，如果要提供四个<code>vip</code>的话，那么前三个<code>vip</code>均匀地分布到三个节点上，第四个<code>vip</code>就在第一个节点上暴露，以此类推，这边说的第一个节点只是我们自己将三个节点进行逻辑上的排序，我们需要通过一些算法确保<code>vip</code>分布均匀，具体看下文分析。</p><h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><p>一般在完成一个<code>feature</code>之前，我们往往需要做一个<code>design</code>，对要做的事情和流程进行设计和评估，这样不但可以梳理流程，使得之后动手的时候思路清晰，更重要的是可以预见一些问题和难点，尽早与 团队成员进行交流，选择最佳方案，防止真正做的时候走弯路。这边涉及的技术点主要有：</p><h3 id="Keepalived暴露多个VIP"><a href="#Keepalived暴露多个VIP" class="headerlink" title="Keepalived暴露多个VIP"></a>Keepalived暴露多个VIP</h3><p><code>keepalived</code>暴露单个<code>vip</code>很常见，具体格式网上都有，而暴露多个<code>vip</code>就要注意一些细节，比如<code>router_id</code>，<code>ins_name</code>，<code>priority</code>等等，对于一个节点而言，它上面<code>keepalived</code>暴露<code>vip</code>的情况完全是由配置文件<code>keepalived.conf</code>所决定的，而对于<code>keepalived.conf</code>而言，一个<code>vip</code>其实就是<code>ins</code>，而<code>ins_name</code>和<code>router_id</code>要求同一个<code>keepalived</code>组内成员相同，我们这边就默认<code>router_id</code>就是<code>vip</code>隔着小数点的四位整数相加的和，而<code>ins_name</code>则是将<code>vip</code>的小数点换成下划线。</p><h3 id="VIP动态均匀分布"><a href="#VIP动态均匀分布" class="headerlink" title="VIP动态均匀分布"></a>VIP动态均匀分布</h3><p><code>vip</code>均匀分布要保证尽可能的均匀，比如三个节点，如果要提供两个<code>vip</code>的话，那就随意挑选两个节点作为<code>vip</code>绑定，如果四个<code>vip</code>的话，则是三个节点各自绑定一个<code>vip</code>后再任意选择一个节点作为第四个<code>vip</code>绑定。我们这边的做法是先将所有节点进行排序，将两个节点作为一个<code>keepalived</code>组，下两个节点为另外一组，假设有三个节点，我们设为<code>1, 2, 3</code>，那么如果要暴露三个<code>vip</code>，我们就需要三个<code>keepalived</code>组，这边三个组分别是<code>1, 2</code>，<code>3, 1</code>和<code>2, 3</code>，然后组内其中第一个节点为<code>master</code>，第二个节点为<code>backup</code>。这样可以基本保证所有<code>vip</code>的均匀分布，具体算法实现参见下文。</p><h3 id="多RBD高可用"><a href="#多RBD高可用" class="headerlink" title="多RBD高可用"></a>多RBD高可用</h3><p>上一篇文章中只有一个<code>RBD</code>，所以高可用就围绕它一个，发生故障后随意切换节点即可，因为我们每个节点都是一个<code>keepalived</code>组的成员。但是如果有多个<code>RBD</code>的话，我们如果随意切换的话，那么<code>RBD</code>分布就会变得不均匀。上文提及的算法可以保证<code>vip</code>的均匀分布，两两节点作为一个<code>keepalived</code>组，这样我们即使一个节点掉了，切换也只会在当前组内切换，而<code>vip</code>一开始绑定节点的时候就根据相应算法保证了每个<code>RBD</code>的均匀分布，所以这边组内切换不会影响分布的均匀性。</p><p>上一篇文章中提过<code>keepalived</code>的机制，当主节点<code>down</code>了，主节点会触发我们自己写的<code>ChangetoBackup.sh</code>，而副节点则会触发<code>ChangetoMaster.sh</code>。之前由于只有一个<code>RBD</code>，所以当时做的比较无脑，<code>ChangetoMaster.sh</code>直接遍历当前节点上面的所有<code>RBD</code>，然后通过之前记录的<code>RBD</code>和<code>UI</code>上创建的<code>目录</code>的映射关系进行挂载，而<code>ChangetoBackup.sh</code>也是一样的<code>umount</code>所有<code>RBD</code>的挂载点。针对目前的多<code>RBD</code>的情况，这样的做法肯定是不行的，因为现在我们一个节点可能是一个或多个<code>vip</code>的<code>master</code>，也可能是另外一个或多个<code>vip</code>的<code>backup</code>，如果我们还是像之前那样一股脑的全部卸载或者挂载，那么造成的后果显而易见，就是业务中断，暴露服务节点紊乱。所以最合理的应该对号入座，一个<code>vip</code>对应一个<code>RBD image</code>，哪个<code>vip</code>出现了问题，作为该<code>vip</code>的<code>master</code>节点，应该只<code>umount</code>该<code>vip</code>绑定<code>RBD</code>所对应的目录，而<code>backup</code>节点应该只<code>mount</code>对应的目录。其他不相关<code>RBD</code>和其对应的目录，我们都不应该有所操作。那么我们只有在触发<code>ChangetoMaster.sh</code>和<code>ChangetoBackup.sh</code>这两个脚本的时候加上“目录”这个参数，具体实现详见下文分析。</p><h3 id="大容量RBD-image的创建和删除"><a href="#大容量RBD-image的创建和删除" class="headerlink" title="大容量RBD image的创建和删除"></a>大容量RBD image的创建和删除</h3><p>我们系统的实现是<code>UI</code>上创建目录，后端<code>daemon</code>轮询根据目录信息做对应的事情，比如前端<code>UI</code>创建了目录，后端就是在创建<code>RBD image</code>，而生产环境上面的容量的要求都是很高的，往往都是几十<code>T</code>，甚至上百<code>T</code>,但是熟悉<code>RBD</code>的朋友都知道创建如此大的<code>RBD image</code>是需要很长的时间的，那这样就不但会影响当前目录能够提供服务的时间，也会阻塞住代码，影响之后目录的创建。之前我们的做法是一开始我们可以创建一个比较小的<code>image</code>，然后我们后台选择在业务不繁忙的时候进行定时扩容，这也可以算是暂时止血了。但是后来测试发现删除<code>image</code>才是真的慢，这边就不像创建那样有曲线救国的方式了，所以这边无论是创建还是删除<code>RBD image</code>我们都不能做成同步的方式了，我们采取了另起一个线程单独做这个事情，不影响后端业务的正常处理。</p><h3 id="快照保证扩容的安全性"><a href="#快照保证扩容的安全性" class="headerlink" title="快照保证扩容的安全性"></a>快照保证扩容的安全性</h3><p>在我们的测试过程中，发现对<code>RBD image</code>扩容会偶尔发生文件系统出错的情况，这种情况是很危险的，一旦文件系统发生问题，并且用<code>e2fsck</code>等工具修复不了的话，那么数据恢复是很困难的，我们必须要保证客户数据的安全性。所以我们用了<code>RBD</code>的<code>snapshot</code>的功能，在每次扩容之前为<code>RBD image</code>做快照，这样即使发生了问题，我们起码可以做到最小程度的损失。</p><h2 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h2><h3 id="Keepalived暴露多个VIP-1"><a href="#Keepalived暴露多个VIP-1" class="headerlink" title="Keepalived暴露多个VIP"></a>Keepalived暴露多个VIP</h3><p>当<code>UI</code>创建一个<code>vip</code>的时候，我们就要加一个<code>ins</code>，以下就是我们添加一个<code>ins</code>的<code>API</code>，本文所有代码都是<code>python</code>写的，大家凑合看吧。（部分代码和接口不是很全，文章尾部将会贴出详细代码的地址）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_keepalived_ins</span><span class="params">(self, vip, folder, state)</span>:</span></span><br><span class="line">    vrrp_ins = <span class="string">"""</span></span><br><span class="line"><span class="string">vrrp_instance VI_&#123;ins_name&#125; &#123;&#123;</span></span><br><span class="line"><span class="string">    state &#123;state&#125;</span></span><br><span class="line"><span class="string">    interface &#123;pubif&#125;</span></span><br><span class="line"><span class="string">    priority &#123;priority&#125;</span></span><br><span class="line"><span class="string">    virtual_router_id &#123;router_id&#125;</span></span><br><span class="line"><span class="string">    advert_int 1</span></span><br><span class="line"><span class="string">    authentication &#123;&#123;</span></span><br><span class="line"><span class="string">        auth_type PASS</span></span><br><span class="line"><span class="string">        auth_pass 1111</span></span><br><span class="line"><span class="string">    &#125;&#125;</span></span><br><span class="line"><span class="string">    track_script &#123;&#123;</span></span><br><span class="line"><span class="string">        chk_nfs</span></span><br><span class="line"><span class="string">    &#125;&#125;</span></span><br><span class="line"><span class="string">    notify_master "/etc/keepalived/ChangeToMaster.sh &#123;folder&#125;"</span></span><br><span class="line"><span class="string">    notify_backup "/etc/keepalived/ChangeToBackup.sh &#123;folder&#125;"</span></span><br><span class="line"><span class="string">    virtual_ipaddress &#123;&#123;</span></span><br><span class="line"><span class="string">        &#123;vip&#125;</span></span><br><span class="line"><span class="string">    &#125;&#125;</span></span><br><span class="line"><span class="string">&#125;&#125;</span></span><br><span class="line"><span class="string">"""</span>.format(ins_name = vip.replace(<span class="string">'.'</span>, <span class="string">'_'</span>).replace(<span class="string">'/'</span>, <span class="string">'_'</span>),</span><br><span class="line">           state = state,</span><br><span class="line">           priority =  <span class="number">200</span> <span class="keyword">if</span> state == <span class="string">"MASTER"</span> <span class="keyword">else</span> <span class="number">100</span>,</span><br><span class="line">           router_id = self.get_router_id(vip),</span><br><span class="line">           pubif = get_public_interface(),</span><br><span class="line">           folder = folder,</span><br><span class="line">           vip = vip)</span><br><span class="line">        <span class="keyword">return</span> vrrp_ins</span><br></pre></td></tr></table></figure><p>这边我们可以看到<code>ins_name</code>和<code>router_id</code>都是根据<code>vip</code>转换成特定格式，标识<code>ins</code>的唯一性。而<code>priority</code>则是根据<code>state</code>来决定，<code>state</code>为<code>master</code>时，<code>priority</code>为<code>200</code>，而<code>backup</code>的<code>priority</code>为<code>100</code>。至于如何获取<code>state</code>，这个涉及到<code>vip</code>均匀算法，后续会讲。</p><h3 id="VIP动态均匀分布-1"><a href="#VIP动态均匀分布-1" class="headerlink" title="VIP动态均匀分布"></a>VIP动态均匀分布</h3><p>假设三个节点，为<code>1, 2, 3</code>，三个<code>vip</code>，为<code>a, b, c</code>，那么最后<code>a</code>对应的节点为<code>1, 2</code>，<code>b</code>对应的节点为<code>3, 1</code>，<code>c</code>对应的节点为<code>2, 3</code>，具体实现算法是先将所有<code>vip</code>进行排序，获取要操作<code>vip</code>的<code>index</code>，然后获取集群内所有节点，然后将上面获取的<code>index</code>乘以<code>2</code>，再对所有节点的个数做余数，然后可以获得一个整数，这个整数就是<code>vip</code>对应<code>master</code>节点在所有节点数组中的<code>index</code>，这种算法大家应该很容易从规律中推算出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_my_state</span><span class="params">(self, vip_idx)</span>:</span></span><br><span class="line">    nodes = get_all_nodes()</span><br><span class="line">    nodes.sort()</span><br><span class="line">    idx = vip_idx * <span class="number">2</span> % len(nodes)</span><br><span class="line">    my_ip = get_public_ip()</span><br><span class="line">    <span class="keyword">if</span> my_ip == nodes[idx]:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'MASTER'</span></span><br><span class="line">    <span class="keyword">elif</span> my_ip == nodes[(idx + <span class="number">1</span>) % len(nodes)]:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'BACKUP'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h3 id="多RBD高可用-1"><a href="#多RBD高可用-1" class="headerlink" title="多RBD高可用"></a>多RBD高可用</h3><p>我们在创建目录的时候，需要获取当前节点是否为<code>master</code>，之前那个只有一个<code>vip</code>，所以当前节点要么是<code>master</code>，要么是<code>backup</code>，但是这边的话，一个节点可能是一个<code>vip</code>的<code>master</code>的同时也可能是另一个<code>vip</code>的<code>backup</code>，所以是否为<code>master</code>是要根据目录而定的。在这边我们在创建目录、删除目录、创建<code>vip</code>和删除<code>vip</code>时，更新一个<code>vip</code>和目录之间的映射关系。这个<code>map</code>我是存在<code>ceph</code>的<code>leveldb</code>中，至于为什么不存在节点本地，是因为这份数据必须要保证所有节点强一致，放在本地节点，可能会因为一些故障原因导致之后内容不一致的情况。</p><p>这边我们要求在创建目录前，必须要存在空闲<code>vip</code>可以提供目录绑定。所以当创建一个<code>vip</code>时，此时应该没有目录需要绑定，我们建立一个<code>key</code>和<code>value</code>都是<code>vip</code>的字典；当创建一个目录的时候，随机找到一个空闲<code>vip</code>进行绑定，建立一个<code>key</code>为<code>vip</code>，<code>value</code>为目录名的字典；当删除<code>vip</code>时，肯定是存在其他空闲<code>vip</code>的，所以在删除原来对应<code>map</code>后，我们要找到其他一个空闲<code>vip</code>与之前删除<code>vip</code>对应的目录进行绑定；当删除目录时，只要将对应关系中的<code>value</code>换成<code>key</code>，也就是对应的<code>vip</code>了。</p><p>有了这个<code>map</code>，我们就可以实时获取目录和<code>vip</code>的信息和之间的对应关系。</p><p><code>vip.py</code></p><p>负责当<code>vip</code>发生变化时，更新<code>ip_folder_map</code>，以及<code>ip_folder_map</code>的读写<code>API</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ip_folder_map</span><span class="params">()</span>:</span></span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    ip_folder_map = LevelDB(<span class="string">"ip_folder_map"</span>)</span><br><span class="line">    result = json.loads(ip_folder_map)[<span class="string">"ip_folder_map"</span>]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_ip_folder_map</span><span class="params">(ip_folder_map)</span>:</span></span><br><span class="line">    ip_folder_map = LevelDB(<span class="string">"ip_folder_map"</span>)</span><br><span class="line">    ip_folder_map.set(json.dumps(&#123;<span class="string">"ip_folder_map"</span>: ip_folder_map&#125;))</span><br><span class="line">    ip_folder_map.save()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_ip_folder_map_by_ip</span><span class="params">(ips)</span>:</span></span><br><span class="line">    ip_folder_map = get_ip_folder_map()</span><br><span class="line">    old_ips = ip_folder_map.keys()</span><br><span class="line">    <span class="keyword">if</span> len(ips) &gt; len(old_ips):</span><br><span class="line">        new_ip = list(set(ips) - set(old_ips))[<span class="number">0</span>]</span><br><span class="line">        ip_folder_map[new_ip] = new_ip</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        del_ip = list(set(old_ips) - set(ips))[<span class="number">0</span>]</span><br><span class="line">        folder = ip_folder_map[del_ip]</span><br><span class="line">        <span class="keyword">del</span> ip_folder_map[del_ip]</span><br><span class="line">        <span class="keyword">if</span> folder != del_ip:</span><br><span class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> ip_folder_map.iteritems():</span><br><span class="line">                <span class="keyword">if</span> k == v:</span><br><span class="line">                    ip_folder_map[k] = folder</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">    set_ip_folder_map(ip_folder_map)</span><br></pre></td></tr></table></figure><p><code>folder.py</code></p><p>负责当<code>folder</code>发生变化时，更新<code>ip_folder_map</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vip</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_ip_folder_map_by_folder</span><span class="params">(folder, type)</span>:</span></span><br><span class="line">    ip_folder_map = vip.get_ip_folder_map()</span><br><span class="line">    folder = get_folder_path(folder)</span><br><span class="line">    <span class="keyword">if</span> type == <span class="string">"add"</span>:</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> ip_folder_map.iteritems():</span><br><span class="line">            <span class="keyword">if</span> k == v:</span><br><span class="line">                ip_folder_map[k] = folder</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elif</span> type == <span class="string">"delete"</span>:</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> ip_folder_map.iteritems():</span><br><span class="line">            <span class="keyword">if</span> v == folder:</span><br><span class="line">                ip_folder_map[k] = k</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    vip.set_ip_folder_map(ip_folder_map)</span><br></pre></td></tr></table></figure><p>上面说了在切换节点的时候，需要传递目录参数，保证只操作对应目录。而脚本是静态的，目录确是动态的，所以我们需要在目录或者<code>vip</code>发生变化的时候对原来的<code>keepalived.conf</code>进行更新，添加目录参数。也就是说当<code>vip</code>发生变化时，我们根据当前<code>vip</code>选择添加或者减少<code>ins</code>，并且更新每个<code>ins</code>调用脚本后面追加的参数；而<code>folder</code>发生变化时，<code>vip</code>调用脚本后面追加的参数也需要更新，要么是<code>vip</code>，要么是<code>folder</code>。这边也需要用到上面的<code>ip_folder_map</code>，因为每个<code>ins</code>就是一个<code>vip</code>，而每个<code>vip</code>对应一个<code>folder</code>。所以我们这边当目录或者<code>vip</code>发生变化时，会根据<code>ip_folder_map</code>更新<code>keepalived.conf</code>，具体实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_keepalived_conf</span><span class="params">(self)</span>:</span></span><br><span class="line">        kconf = <span class="string">"""global_defs &#123;</span></span><br><span class="line"><span class="string">    notification_email &#123;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    router_id NFS_HA_112</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">vrrp_script chk_nfs &#123;</span></span><br><span class="line"><span class="string">    script "/etc/keepalived/check_nfs.sh"</span></span><br><span class="line"><span class="string">    interval 2</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">        vips = self.ip_folder_map.keys()</span><br><span class="line">        vips.sort()</span><br><span class="line">        <span class="keyword">for</span> vip, folder <span class="keyword">in</span> self.ip_folder_map.items():</span><br><span class="line">            vip_idx = vips.index(vip)</span><br><span class="line">            state = self.get_my_state(vip_idx)</span><br><span class="line">            <span class="keyword">if</span> state <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                kconf += self.add_keepalived_ins(vip, folder, state)</span><br><span class="line">        <span class="keyword">with</span> open(KEEPALIVED_CONF_PATH, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.writelines(kconf)</span><br><span class="line">        do_shell(<span class="string">'service keepalived reload'</span>)</span><br></pre></td></tr></table></figure><p>下面是添加一个<code>ins</code>的模板，上面也贴过代码，至于这边再次贴一遍的目的是想侧重展示一下脚本后面参数的动态变化的实现方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_keepalived_ins</span><span class="params">(self, vip, folder, state)</span>:</span></span><br><span class="line">        vrrp_ins = <span class="string">"""</span></span><br><span class="line"><span class="string">vrrp_instance VI_&#123;ins_name&#125; &#123;&#123;</span></span><br><span class="line"><span class="string">    state &#123;state&#125;</span></span><br><span class="line"><span class="string">    interface &#123;pubif&#125;</span></span><br><span class="line"><span class="string">    priority &#123;priority&#125;</span></span><br><span class="line"><span class="string">    virtual_router_id &#123;router_id&#125;</span></span><br><span class="line"><span class="string">    advert_int 1</span></span><br><span class="line"><span class="string">    authentication &#123;&#123;</span></span><br><span class="line"><span class="string">        auth_type PASS</span></span><br><span class="line"><span class="string">        auth_pass 1111</span></span><br><span class="line"><span class="string">    &#125;&#125;</span></span><br><span class="line"><span class="string">    track_script &#123;&#123;</span></span><br><span class="line"><span class="string">        chk_nfs</span></span><br><span class="line"><span class="string">    &#125;&#125;</span></span><br><span class="line"><span class="string">    notify_master "/etc/keepalived/ChangeToMaster.sh &#123;folder&#125;"</span></span><br><span class="line"><span class="string">    notify_backup "/etc/keepalived/ChangeToBackup.sh &#123;folder&#125;"</span></span><br><span class="line"><span class="string">    virtual_ipaddress &#123;&#123;</span></span><br><span class="line"><span class="string">        &#123;vip&#125;</span></span><br><span class="line"><span class="string">    &#125;&#125;</span></span><br><span class="line"><span class="string">&#125;&#125;</span></span><br><span class="line"><span class="string">"""</span>.format(ins_name = vip.replace(<span class="string">'.'</span>, <span class="string">'_'</span>).replace(<span class="string">'/'</span>, <span class="string">'_'</span>),</span><br><span class="line">           state = state,</span><br><span class="line">           priority =  <span class="number">200</span> <span class="keyword">if</span> state == <span class="string">"MASTER"</span> <span class="keyword">else</span> <span class="number">100</span>,</span><br><span class="line">           router_id = self.get_router_id(vip),</span><br><span class="line">           pubif = get_public_interface(),</span><br><span class="line">           folder = folder,</span><br><span class="line">           vip = vip)</span><br><span class="line">        <span class="keyword">return</span> vrrp_ins</span><br></pre></td></tr></table></figure><p>触发脚本：</p><p><code>ChangetoMaster.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">folder=<span class="string">"<span class="variable">$(dirname $1)</span>/<span class="variable">$(basename $1)</span>"</span></span><br><span class="line">fname=$(basename <span class="variable">$folder</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$folder</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> $(mount | grep -q <span class="string">"<span class="variable">$folder</span> "</span>); <span class="keyword">then</span></span><br><span class="line">        umount -f <span class="variable">$folder</span> &gt; /dev/null</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    device=$(rbd showmapped | awk <span class="string">'/image_'</span><span class="variable">$fname</span><span class="string">' / &#123;print $5&#125;'</span>)</span><br><span class="line">    <span class="keyword">if</span> [ -b <span class="string">"<span class="variable">$device</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        mount <span class="variable">$device</span> <span class="variable">$folder</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">service nfs-kernel-server restart</span><br></pre></td></tr></table></figure><p><code>ChangetoBackup.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">folder=<span class="variable">$1</span></span><br><span class="line">service nfs-kernel-server stop</span><br><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$folder</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> $(mount | grep -q <span class="string">"<span class="variable">$folder</span> "</span>); <span class="keyword">then</span></span><br><span class="line">        umount -f <span class="variable">$folder</span> &gt; /dev/null</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">service nfs-kernel-server start</span><br></pre></td></tr></table></figure><h3 id="大容量RBD-image的创建和删除-1"><a href="#大容量RBD-image的创建和删除-1" class="headerlink" title="大容量RBD image的创建和删除"></a>大容量RBD image的创建和删除</h3><p>在另外一个端口另起一个线程，通过异步的方式实现，主要利用<code>python</code>的<code>rpyc</code>模块实现，忧郁项目保密性等原因，只贴上部分关键代码，给大家提供一些思路。</p><p>以删除<code>RBD image</code>为例，调用<code>remove_image</code>方法，进入装饰器，从而在新现成做删除操作，不再阻塞之前进程的流程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rbd_background</span><span class="params">()</span>:</span></span><br><span class="line">    conn = connect(<span class="string">'localhost'</span>, RBD_PORT)</span><br><span class="line">    module = conn.modules[<span class="string">'rbd_utils'</span>]</span><br><span class="line">    async_func = rpyc.<span class="keyword">async</span>(getattr(module, func_name))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> async_func</span><br><span class="line">    </span><br><span class="line"><span class="meta">@rbd_utils.rbd_background</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_image</span><span class="params">(pool, image)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            logger.info(<span class="string">'rbd &#123;&#125; delete start'</span>.format(image))</span><br><span class="line">            do_shell(<span class="string">'rbd rm &#123;&#125;/&#123;&#125; &gt;&gt; /var/log/rbd_rm.log'</span>.format(pool, image))</span><br><span class="line">            logger.info(<span class="string">'rbd &#123;&#125; delete finish'</span>.format(image))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            logger.error(<span class="string">'rbd &#123;&#125; delete error'</span>.format(image))</span><br><span class="line">            time.sleep(<span class="number">30</span>)</span><br></pre></td></tr></table></figure><h3 id="快照保证扩容的安全性-1"><a href="#快照保证扩容的安全性-1" class="headerlink" title="快照保证扩容的安全性"></a>快照保证扩容的安全性</h3><p>首先介绍一下定时扩容的脚本：</p><p><code>monitor_rbd.sh</code>：当<code>RBD image</code>可利用空间小于<code>50%</code>或者小于<code>50T</code>时，扩容<code>50T</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> convert_to_MB()</span><br><span class="line">&#123;</span><br><span class="line">    size=<span class="variable">$1</span></span><br><span class="line">    unit=<span class="variable">$&#123;size:(-1):1&#125;</span></span><br><span class="line">    nr=<span class="variable">$&#123;size/$unit/&#125;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$unit</span> <span class="keyword">in</span></span><br><span class="line">        (k|K|\)) <span class="built_in">echo</span> <span class="string">"<span class="variable">$nr</span> / 1024"</span> | bc;;</span><br><span class="line">        (m|M|\)) <span class="built_in">echo</span> <span class="string">"<span class="variable">$nr</span>"</span>;;</span><br><span class="line">        (g|G|\)) <span class="built_in">echo</span> <span class="string">"<span class="variable">$nr</span> * 1024"</span> | bc;;</span><br><span class="line">        (t|T|\)) <span class="built_in">echo</span> <span class="string">"<span class="variable">$nr</span> * 1024 * 1024"</span> | bc;;</span><br><span class="line">        (p|P|\)) <span class="built_in">echo</span> <span class="string">"<span class="variable">$nr</span> * 1024 * 1024 * 1024"</span> | bc;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">"Error: cannot convert to MB: <span class="variable">$size</span>"</span>;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> get_available_size()</span><br><span class="line">&#123;</span><br><span class="line">    disk=<span class="variable">$1</span></span><br><span class="line">    unit_size=$(convert_to_MB <span class="string">'50T'</span>)</span><br><span class="line">    </span><br><span class="line">    disk_size=$(df -h | grep <span class="variable">$disk</span> | awk <span class="string">'&#123;print $2&#125;'</span>)</span><br><span class="line">    disk_size=$(convert_to_MB <span class="variable">$disk_size</span>)</span><br><span class="line">    pool=$(rbd showmapped | grep <span class="variable">$disk</span> | awk <span class="string">'&#123;print $2&#125;'</span>)</span><br><span class="line">    available_pool_size=$(ceph df | grep <span class="variable">$pool</span> | awk <span class="string">'&#123;print $5&#125;'</span>)</span><br><span class="line">    available_pool_size=$(convert_to_MB <span class="variable">$available_pool_size</span>)</span><br><span class="line">    <span class="keyword">if</span> [ $(<span class="built_in">echo</span> <span class="string">"<span class="variable">$available_pool_size</span> &lt; <span class="variable">$unit_size</span>"</span> | bc) -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">        new_size=$(<span class="built_in">echo</span> <span class="string">"<span class="variable">$disk_size</span> + <span class="variable">$available_pool_size</span>"</span> | bc)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        new_size=$(<span class="built_in">echo</span> <span class="string">"<span class="variable">$disk_size</span> + <span class="variable">$unit_size</span>"</span> | bc)</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;new_size%.*&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> check_and_enlarge_disk()</span><br><span class="line">&#123;</span><br><span class="line">    disk=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$disk</span>"</span> = <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Error: You must specify the disk name"</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Checking the disk [/dev/<span class="variable">$disk</span>] ..."</span></span><br><span class="line">    <span class="keyword">if</span> ! rbd showmapped | grep -q <span class="variable">$disk</span>; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Error: Cannot find the disk [<span class="variable">$disk</span>]"</span></span><br><span class="line">        <span class="built_in">return</span> 2</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    disk_usage=$(df | grep <span class="variable">$disk</span> | awk <span class="string">'&#123;print $5&#125;'</span>)</span><br><span class="line">    available_disk_size=$(df | grep <span class="variable">$disk</span> | awk <span class="string">'&#123;print $4&#125;'</span>)</span><br><span class="line">    available_disk_size=$(convert_to_MB <span class="string">"<span class="variable">$&#123;available_disk_size&#125;</span>k"</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"  The disk use% is <span class="variable">$&#123;disk_usage&#125;</span>"</span></span><br><span class="line">    disk_usage=<span class="variable">$&#123;disk_usage/\%/&#125;</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$disk_usage</span> -lt 50 -a <span class="variable">$available_disk_size</span> -gt 1024 * 1024 * 50 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'Less then 50% use and more then 50TB available space left, just quit'</span></span><br><span class="line">        <span class="built_in">return</span> 0</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'Enlarging the disk ...'</span></span><br><span class="line">    new_size=$(get_available_size <span class="variable">$disk</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"  the new size is <span class="variable">$&#123;new_size&#125;</span>MB"</span></span><br><span class="line">    pool=$(rbd showmapped | grep <span class="variable">$disk</span> | awk <span class="string">'&#123;print $2&#125;'</span>)</span><br><span class="line">    image=$(rbd showmapped | grep <span class="variable">$disk</span> | awk <span class="string">'&#123;print $3&#125;'</span>)</span><br><span class="line">    rbd resize --size <span class="variable">$new_size</span> -p <span class="variable">$pool</span> <span class="variable">$image</span></span><br><span class="line">    sleep 3</span><br><span class="line">    resize2fs /dev/<span class="variable">$&#123;disk&#125;</span> <span class="string">"<span class="variable">$&#123;new_size&#125;</span>M"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Done"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">disks=$(lsblk | grep rbd | awk <span class="string">'&#123;print $1&#125;'</span>)</span><br><span class="line"><span class="keyword">for</span> disk <span class="keyword">in</span> <span class="variable">$disks</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"=============================================="</span></span><br><span class="line">check_and_enlarge_disk <span class="string">"<span class="variable">$disk</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"=============================================="</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>这边我们采用<code>ceph</code>提供的原生<code>python</code>的接口，完成<code>RBD</code>的定时快照的创建和删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> rados</span><br><span class="line"><span class="keyword">import</span> rbd</span><br><span class="line"><span class="keyword">from</span> folder <span class="keyword">import</span> get_all_folder_info</span><br><span class="line"><span class="keyword">from</span> vip <span class="keyword">import</span> get_ip_folder_map</span><br><span class="line"></span><br><span class="line">CEPH_CONF = <span class="string">'/etc/ceph/ceph.conf'</span></span><br><span class="line">MAX_SNAP_COUNT = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_snap</span><span class="params">(pool, rbd_image)</span>:</span></span><br><span class="line">    now = time.localtime()</span><br><span class="line">    snap = time.strftime(<span class="string">"%Y_%m_%d_%H_%M_%S"</span>, now)</span><br><span class="line">    <span class="keyword">with</span> rados.Rados(conffile=CEPH_CONF) <span class="keyword">as</span> cluster:</span><br><span class="line">        <span class="keyword">with</span> cluster.open_ioctx(str(pool)) <span class="keyword">as</span> ioctx:</span><br><span class="line">            <span class="keyword">with</span> rbd.Image(ioctx, rbd_image) <span class="keyword">as</span> image:</span><br><span class="line">                image.create_snap(snap)</span><br><span class="line">                </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_images</span><span class="params">()</span>:</span></span><br><span class="line">    pubif = get_public_interface()</span><br><span class="line">    pub_ips = do_cmd(<span class="string">"ip addr show &#123;&#125; | awk '/inet/ &#123;&#123;print $2&#125;&#125;'"</span>.format(pubif)).split()</span><br><span class="line">    vip_folders = get_ip_folder_map(gwgroup)</span><br><span class="line">    my_folders = []</span><br><span class="line">    <span class="keyword">for</span> pip <span class="keyword">in</span> pub_ips:</span><br><span class="line">        <span class="keyword">if</span> pip <span class="keyword">in</span> vip_folders <span class="keyword">and</span> pip != vip_folders[pip]:</span><br><span class="line">            my_folders.append(os.path.basename(vip_folders[pip]))</span><br><span class="line">    folders = get_all_folder_info()</span><br><span class="line">    images = []</span><br><span class="line">    <span class="keyword">for</span> folder <span class="keyword">in</span> folders:</span><br><span class="line">        <span class="keyword">if</span> folder <span class="keyword">in</span> my_folders:</span><br><span class="line">            images.append(&#123;</span><br><span class="line">                <span class="string">'image'</span>: <span class="string">'image_&#123;&#125;'</span>.format(folder),</span><br><span class="line">                <span class="string">'pool'</span>: folders[folder][<span class="string">'pool'</span>]</span><br><span class="line">            &#125;)</span><br><span class="line">    <span class="keyword">return</span> images</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_old_snap</span><span class="params">(pool, rbd_image)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> rados.Rados(conffile=CEPH_CONF) <span class="keyword">as</span> cluster:</span><br><span class="line">        <span class="keyword">with</span> cluster.open_ioctx(str(pool)) <span class="keyword">as</span> ioctx:</span><br><span class="line">            <span class="keyword">with</span> rbd.Image(ioctx, rbd_image) <span class="keyword">as</span> image:</span><br><span class="line">                snaps = sorted(image.list_snaps(), key=<span class="keyword">lambda</span> snap: snap[<span class="string">'name'</span>])</span><br><span class="line">                <span class="keyword">if</span> len(snaps) &gt; MAX_SNAP_COUNT:</span><br><span class="line">                    <span class="keyword">for</span> snap <span class="keyword">in</span> snaps[<span class="number">0</span>:len(snaps)-MAX_SNAP_COUNT]:</span><br><span class="line">                        image.remove_snap(snap[<span class="string">'name'</span>])</span><br><span class="line">                        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    images = get_images()</span><br><span class="line">    <span class="keyword">for</span> image <span class="keyword">in</span> images:</span><br><span class="line">        create_snap(image[<span class="string">'pool'</span>], image[<span class="string">'image'</span>])</span><br><span class="line">        remove_old_snap(image[<span class="string">'pool'</span>], image[<span class="string">'image'</span>])</span><br><span class="line">        device = do_shell(<span class="string">"rbd showmapped | awk '/&#123;&#125;[ \t]*&#123;&#125;/ &#123;&#123;print $5&#125;&#125;'"</span>.format(image[<span class="string">'pool'</span>], image[<span class="string">'image'</span>]))</span><br><span class="line">        do_shell(<span class="string">'/usr/local/bin/monitor_rbd.sh &#123;&#125;'</span>.format(os.path.basename(device)))</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>内容和代码都比较多，其实每一个技术点都可以单独拿出来写一篇，但是我觉得这是一个完整<code>feature</code>，想让大家能够代入，了解到完成这样一个<code>feature</code>周边需要支持的各种技术点和注意点，一个<code>feature</code>往往是经过不断迭代和维护，很多实现方法也随着时间和应用场景不断发生变化。</p><p>完成这样一个<code>feature</code>，我也是反复修改，就比如异步实现<code>RBD image</code>的创建和删除，很多场景在生产环境和测试环境中的 情况是完全不一样的，比如我开发的时候创建的<code>image</code>都是<code>1G</code>的，当然很快，也不能存在什么阻塞的问题，也遇到很多问题和想不通的地方，感谢我的同事和前辈提供的帮助和启发。</p><p>最后，衷心希望<code>ceph</code>能够早日将<code>CephFS</code>完善，保证其在生产环境中的稳定性和性能。这样我们也就不用绞尽脑汁这般曲线救国了，哈哈。</p><p>最后的最后，贴上部分代码地址，由于项目保密性等原因，我只能贴出比较关键的代码，大家请见谅，我觉得这些代码应该足够了，足够给大家提供一个思路了，其实往往思路比代码更重要，相信很多人的实现方式要比我更加优秀呢！</p><blockquote><p>代码地址：<a href="https://github.com/tony-yin/Multi_RBD_HA" target="_blank" rel="noopener">https://github.com/tony-yin/Multi_RBD_HA</a></p></blockquote><p>如果大家觉得有帮助的话，欢迎<code>Star</code>哦 ~(≧▽≦)/~</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://cdn.tony-yin.site/rbd2-600x450.jpg&quot; alt=&quot;RBD-HA-2&quot;&gt;&lt;/center&gt;

&lt;p&gt;之前分享过一篇&lt;a href=&quot;http://www.tony-yin.site/2017/12/07/RBD-HA/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【通过 Keepalived 实现 Ceph RBD 的高可用】&lt;/a&gt;，主要讲解了将&lt;code&gt;RBD&lt;/code&gt;导出为&lt;code&gt;NFS&lt;/code&gt;，然后通过&lt;code&gt;keepalived&lt;/code&gt;实现高可用，保证当提供虚拟&lt;code&gt;IP&lt;/code&gt;节点发生故障时，可以自动切换节点，使得业务不发生中断。&lt;/p&gt;
&lt;p&gt;这样可以基本使用&lt;code&gt;RBD&lt;/code&gt;代替&lt;code&gt;CephFS&lt;/code&gt;对外提供&lt;code&gt;Ceph&lt;/code&gt;服务，至于为什么不用&lt;code&gt;CephFS&lt;/code&gt;就不多说了，不清楚的可以去看上一篇。虽然说这样可以保证无单点故障，但是有一点还是不如&lt;code&gt;CephFS&lt;/code&gt;，那就是&lt;code&gt;CephFS&lt;/code&gt;可以实现多节点同时提供服务，而&lt;code&gt;RBD&lt;/code&gt;说白了其实同时只有一个节点能提供服务，当客户端流量高的时候，&lt;code&gt;RBD&lt;/code&gt;方式的带宽并不能满足需求。就比如都是三个节点，&lt;code&gt;CephFS&lt;/code&gt;可以将客户端流量分流到三个节点，而&lt;code&gt;RBD&lt;/code&gt;只能用一个节点，而带宽上限又取决与网卡、磁盘和&lt;code&gt;IO&lt;/code&gt;等等原因，所以同样的硬件设施&lt;code&gt;RBD&lt;/code&gt;的带宽性能是跟不上的，本文就多虚拟&lt;code&gt;IP&lt;/code&gt;暴露访问方式进行分享。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="NFS" scheme="https://tony-yin.github.io/tags/NFS/"/>
    
      <category term="HA" scheme="https://tony-yin.github.io/tags/HA/"/>
    
      <category term="RBD" scheme="https://tony-yin.github.io/tags/RBD/"/>
    
      <category term="Keepalived" scheme="https://tony-yin.github.io/tags/Keepalived/"/>
    
  </entry>
  
</feed>
