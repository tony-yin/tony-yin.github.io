<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tony&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tony-yin.github.io/"/>
  <updated>2017-12-11T07:10:35.229Z</updated>
  <id>https://tony-yin.github.io/</id>
  
  <author>
    <name>Tony</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阅读感悟：《白夜行》</title>
    <link href="https://tony-yin.github.io/2017/12/10/Into-Withe-Night/"/>
    <id>https://tony-yin.github.io/2017/12/10/Into-Withe-Night/</id>
    <published>2017-12-10T11:57:34.000Z</published>
    <updated>2017-12-11T07:10:35.229Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/white_go.jpg" alt="Into White Night"></center><p>阅读周期：2017/12/08 ~ 2017/12/10<br>阅读评分：4.9<br>阅读人群：还是成年的人看着好一点，不大适合未成年人</p><blockquote><p>我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。我从来就没有太阳，所以不怕失去。</p></blockquote><a id="more"></a><p>之前一直在看技术书，这周末想稍微放松一下自己，翻了翻买了许久却没阅读的《白夜行》，之前听身边很多人称赞过这本书，果然看了就没停的下来，花了两天直接拉满读完。。。</p><p>坊间传言这是东野圭吾写的最好的一本书，我只看过《嫌疑人x的献身》，对比那个的话我觉得这一本更加细腻和深远。</p><p>看完了这本书，我去看了很多的书评，各有各的见解，并且都很有道理，我想这就是东野圭吾的厉害支持了，真正厉害的推理小说，不是作者在推理，而是最后是读者在推理。</p><p>对我个人而言，这本书最大的亮眼之处，就是作者重来不主动把某件事情说明，而是留下种种线索，相关关联，埋下伏笔，这样就导致永远没有一个确定性的答案，作者在意的也许不是具体的场景和手段，他着重刻画的是人性的本质、作恶的动机和灵魂的交融。</p><p>回过头一看，全书亮司与雪穗的生活宛如两条平行线，男女主角之间竟然没有任何对白，也没有交待任何他们见面的情节。书最后亮司突然死了，故事也很突然就这样结束了。让人反应不过来，因为她的太阳失去了。亮司承担了所有的罪恶，为了想让她生活在阳光下。</p><p>很多人都在讨论桐源和雪穗之间的关系，大多数人都认为他们是深爱着的。我个人觉得他们或许有爱，但是更多的是相互依靠和相互依附，也就是双方都是彼此的灵魂，活下去的羁绊，我觉得这是和单单的爱情是不一样的，否则他们大可以在一起，他们有的是钱，完全可以隐性瞒名的私奔。</p><p>我觉得桐源应该更爱雪穗一些，比如一直在他身边守护着她，最后关头为了保住她选择自杀，还有就是只有和她ML的时候才不会迟泄（这个在夕子那个宾馆的章节可以看出），但是桐源尊重雪穗，他只是一直在她身边守护着，永远不会过分打扰她的生活，即使她和别的男人恋爱，即使结婚，即使离婚再结婚，在他心里，雪穗永远是最重要的，满足她想要的和想做的是他一生的追求。桐源一直是作恶的执行者，雪穗背后的指使者，很多读者都为桐源不值，觉得他为了雪穗付出了那么多，最后得到确是冷漠的不回头，其实他并不后悔，看到《嫌疑人x的献身》的同学都知道最后时刻男主多希望女主也能像这边的女主雪穗一样头也不回地离开，这样他的付出才是值得的。桐源对典子应该也是有感情的，从他愿意带她去大阪，跟她讲童年时光，不过这种感情是建立在先利用之后感情培养出来的，但是在桐源心中雪穗永远是最重要的，即使典子获取桐源所有的爱情，当要做出选择的时候，我相信桐源还是选择雪穗吧，因为我觉得在他心中爱情远没有他和雪穗之间的羁绊重要，他们之间的关系关乎到灵魂和生死，他们是对方相互的太阳。</p><blockquote><p>曾经拥有的东西被夺走，并不代表就会回到原来没有那种东西的时候。                    —典子</p></blockquote><p>而雪穗难道对桐源没感情吗？我想肯定有，但是他们俩成为互相羁绊的时间太小了，才十一二岁，在太早的时间双方互相守护秘密，更像是相互保护，少了爱情的起源，所以她们也不知道双方之间是不是爱，雪穗说过她不知道如何去爱一个人，这个人说的可能是高工城，可能是一成，也有可能是桐源，桐源和雪穗经常就是在实行某个行动需要对方配合帮忙的时候才会聚头，比如夕子的那件事，雪穗肯定是通过手或者嘴帮助桐源完成了SJ，但是雪穗从来没有为高工城做过这样的事情，桐源在雪穗的心目中的位置可见一斑。但是也许她自己都不确定这是不是爱情，就像高工城内心的疑问一样，总感觉这份感情里面掺杂了很多其他东西。而雪穗对一诚或许在感情上面和别的人有一些不同，但是这也仅仅是有一点点不同，除了感情我觉得还有一个原因，雪穗不喜欢被别人无视，当大学社团一诚喜欢江利子忽略雪穗时，这让她感觉到嫉妒了，她一直认为自己是完美的，是所有人的焦点所在。</p><p>很多人都在愤怒雪穗最后的冷漠，上面我也说了，除了桐源希望用自己的生命保全雪穗之外，雪穗的行为是头也不回的离去，要知道雪穗在此之前无论是生母、养母、前夫等等，都表现出自己的伤心，唯独这次雪穗没有表现正常，也算是她的失误了，我想她不仅因为是失去了她的太阳觉得无助，最重要的是他也不敢面对这个现实，她面对谁都可以表演的很好，但是除了桐源，她做不到，也许她过不了多久也会选择离开这个世界，要么就永远在白夜中度过。。。</p><p>店已打烊女主确上楼而不是离开，是否会意味着要与亮一同结束在梦魇开始的地方？</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/white_go.jpg&quot; alt=&quot;Into White Night&quot;&gt;&lt;/center&gt;

&lt;p&gt;阅读周期：2017/12/08 ~ 2017/12/10&lt;br&gt;阅读评分：4.9&lt;br&gt;阅读人群：还是成年的人看着好一点，不大适合未成年人&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。我从来就没有太阳，所以不怕失去。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
  </entry>
  
  <entry>
    <title>故障修复：文件系统导致OSD启动失败</title>
    <link href="https://tony-yin.github.io/2017/12/08/Filesystem-Bug-Fix/"/>
    <id>https://tony-yin.github.io/2017/12/08/Filesystem-Bug-Fix/</id>
    <published>2017-12-08T12:54:16.000Z</published>
    <updated>2017-12-10T12:59:19.652Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/bugfix.png" alt="Bug fix"></center><p>记一次因为文件系统导致<code>OSD</code>无法启动的故障修复。</p><a id="more"></a><h2 id="集群状况："><a href="#集群状况：" class="headerlink" title="集群状况："></a>集群状况：</h2><p><code>Cluster</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">root@gigabyte:~# ceph -s</div><div class="line">    cluster de3627bb-c748-4623-8cb1-b88c646ff5d5</div><div class="line">     health HEALTH_WARN 42 pgs degraded; 1 pgs down; 1 pgs peering; 17 pgs recovering; 25 pgs recovery_wait; 359 pgs stale; 42 pgs stuck degraded; 1 pgs stuck inactive; 359 pgs stuck stale; 244 pgs stuck unclean; recovery 6665/163785 objects degraded (4.069%); 6665/163785 unfound (4.069%); 2/23 in osds are down</div><div class="line">     monmap e1: 1 mons at &#123;erxdl=10.16.180.28:6789/0&#125;, election epoch 2, quorum 0 erxdl</div><div class="line">     mdsmap e654: 1/1/1 up &#123;0=irlhy=up:active&#125;</div><div class="line">     osdmap e218: 23 osds: 21 up, 23 in</div><div class="line">      pgmap v8943: 7936 pgs, 16 pools, 639 GB data, 159 kobjects</div><div class="line">            105 GB used, 76827 GB / 76933 GB avail</div><div class="line">            6665/163785 objects degraded (4.069%); 6665/163785 unfound (4.069%)</div><div class="line">                 359 stale+active+clean</div><div class="line">                 201 active+remapped</div><div class="line">                7333 active+clean</div><div class="line">                  25 active+recovery_wait+degraded</div><div class="line">                  17 active+recovering+degraded</div><div class="line">                   1 down+peering</div></pre></td></tr></table></figure><p><code>OSD</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">root@test:/data# ceph osd tree</div><div class="line"># idweighttype nameup/downreweight</div><div class="line">-382.29pool 4T</div><div class="line">-482.29host test1</div><div class="line">00osd.0up    1</div><div class="line">83.578osd.8up    1</div><div class="line">173.578osd.17up    1</div><div class="line">53.578osd.5up    1    </div><div class="line">...</div><div class="line">...</div><div class="line">163.578osd.16up    1</div><div class="line">103.578osd.10up    1</div><div class="line">153.578osd.15up    1</div><div class="line">130osd.13down1</div></pre></td></tr></table></figure><p>由上可知：<code>osd.0</code>和<code>osd.13</code>已经被集群剔除，并且权重变为了<code>0</code></p><h2 id="报错日志："><a href="#报错日志：" class="headerlink" title="报错日志："></a>报错日志：</h2><h3 id="报错1："><a href="#报错1：" class="headerlink" title="报错1："></a>报错1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">2017-12-06 10:18:05.180802 7f4809ae07c0 -1 osd.13 234 set_disk_tp_priority(22) Invalid argument: osd_disk_thread_ioprio_class is  but only the following values are allowed: idle, be or rt</div><div class="line"></div><div class="line">2017-12-06 10:10:44.974634 7f4cbcfff700 -1 os/FileStore.cc: In function &apos;virtual int FileStore::read(coll_t, const ghobject_t&amp;, uint64_t, size_t, ceph::bufferlist&amp;, bool)&apos; thread 7f4cbcfff700</div><div class="line"></div><div class="line">2017-12-06 10:10:44.972299 os/FileStore.cc: 2851: FAILED assert(allow_eio || !m_filestore_fail_eio || got != -5)</div></pre></td></tr></table></figure><h3 id="报错2"><a href="#报错2" class="headerlink" title="报错2:"></a>报错2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">2017-12-06 10:32:56.602065 7f576071b7c0  0 genericfilestorebackend(/ceph/osd.13) detect_features: FIEMAP ioctl is supported and appears to work</div><div class="line"></div><div class="line">2017-12-06 10:32:56.602095 7f576071b7c0  0 genericfilestorebackend(/ceph/osd.13) detect_features: FIEMAP ioctl is disabled via &apos;filestore fiemap&apos; config option</div><div class="line"> </div><div class="line">2017-12-06 10:32:56.620337 7f576071b7c0  0 genericfilestorebackend(/ceph/osd.13) detect_features: syncfs(2) syscall fully supported (by glibc and kernel)</div><div class="line"></div><div class="line">2017-12-06 10:32:56.739219 7f576071b7c0  0 filestore(/ceph/osd.13) limited size xattrs</div></pre></td></tr></table></figure><h3 id="报错3："><a href="#报错3：" class="headerlink" title="报错3："></a>报错3：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">2017-12-06 10:16:32.442815 7f06cddf2700 -1 journal aio to 1398235136~434176 got (5) Input/output error</div><div class="line"></div><div class="line">2017-12-06 10:16:32.443787 7f06cddf2700 -1 os/FileJournal.cc: In function &apos;void FileJournal::write_finish_thread_entry()&apos; thread 7f06cddf2700</div><div class="line"></div><div class="line">2017-12-06 10:16:32.442867 os/FileJournal.cc: 1383: FAILED assert(0 == &quot;unexpected aio error&quot;)</div></pre></td></tr></table></figure><h3 id="报错4："><a href="#报错4：" class="headerlink" title="报错4："></a>报错4：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">2017-12-06 00:52:33.814785 7fb24be877c0 -1 filestore(/ceph/osd.13) FileStore::mount: unable to access basedir &apos;/ceph/osd.0&apos;: (30) Read-only file system</div><div class="line"></div><div class="line">2017-12-06 00:52:33.814801 7fb24be877c0 -1 osd.13 0 OSD:init: unable to mount object store</div><div class="line"></div><div class="line">2017-12-06 00:52:33.814806 7fb24be877c0 -1 ^[[0;31m ** ERROR: osd init failed: (30) Read-only file system</div></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>首先我们肯定是要尝试把<code>OSD</code>起来嘛，所以要做的就是先给<code>osd</code>加权重，接着加入集群，最后再启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ceph osd crush add osd.0 3.578 host=test1</div><div class="line">ceph osd in osd.0</div><div class="line">service ceph start osd.0</div><div class="line"></div><div class="line">ceph osd crush add osd.13 3.578 host=test1</div><div class="line">ceph osd in osd.13</div><div class="line">service ceph start osd.13</div></pre></td></tr></table></figure><p>这时候发现<code>OSD</code>还是起不来，我们就去看<code>osd.0</code>和<code>osd.13</code>的<code>log</code>，也就会发现以上一系列的报错日志，错误较多；</p><p><code>filesystem</code>出现较多<code>limited size xattrs</code>这一行引起了我的注意，由于此环境<code>osd</code>用的文件系统是<code>ext4</code>，而<code>ext4</code>对存储<code>xattr</code>的大小有限制，使得OSD信息不能安全的保存。</p><p>所以在<code>ceph</code>中如果<code>osd</code>采用<code>ext4</code>文件系统时，需要在配置项里面加入相关配置实现用<code>omap</code>来存储<code>xattr</code>，而<code>xfs</code>文件系统由于对<code>xattr</code>的存储是足够的，所以不存在这个问题。</p><p>所以解决这个问题有三个方案：</p><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><p>更改文件系统，将<code>ext4</code>改成<code>xfs</code></p><h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p>文件系统还是采用<code>ext4</code>，配置让<code>Ceph filestore</code>中的<code>omap</code>存储<code>xattr</code>，在<code>/etc/ceph/ceph.conf</code>中<code>global section</code>或<code>osd section</code>中插入一行以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">filestore xattr use omap = true</div></pre></td></tr></table></figure><h3 id="方案3"><a href="#方案3" class="headerlink" title="方案3"></a>方案3</h3><p>限制对象的长度大小，同样是修改<code>ceph.conf</code>，在<code>global section</code>或者<code>osd section</code>中加入以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">osd max object name len = 256 </div><div class="line">osd max object namespace len = 64</div></pre></td></tr></table></figure><p>然后再次重启以下对应的<code>osd</code>服务就OK了！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在<code>Ceph</code>中如果用<code>ext4</code>文件系统的话，一定要注意配置将<code>xattr</code>存在<code>omap</code>中。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/bugfix.png&quot; alt=&quot;Bug fix&quot;&gt;&lt;/center&gt;

&lt;p&gt;记一次因为文件系统导致&lt;code&gt;OSD&lt;/code&gt;无法启动的故障修复。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Bugfix" scheme="https://tony-yin.github.io/tags/Bugfix/"/>
    
  </entry>
  
  <entry>
    <title>通过 Keepalived 实现 Ceph RBD 的高可用</title>
    <link href="https://tony-yin.github.io/2017/12/07/RBD-HA/"/>
    <id>https://tony-yin.github.io/2017/12/07/RBD-HA/</id>
    <published>2017-12-06T16:25:31.000Z</published>
    <updated>2017-12-07T06:47:35.572Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/HA.jpg" alt="HA"></center><p>由于<code>Cephfs</code>很不稳定，并且性能差，很难达到用户在性能上的需求，所以<code>Cephfs</code>也难以应用于生产环境之上。而<code>RBD</code>可以说是一直非常稳定的存储接口方案，用户可以将<code>image</code>挂载到客户端进行访问读写，然而很多用户不愿意在本地安装<code>Ceph</code>客户端，所以我们常常需要自己封装一层，给客户端暴露出一个通用的接口进行访问，现在一般都是默认用<code>NFS</code>，所以本文就<code>Ceph RBD</code>如何实现高可用暴露<code>NFS</code>给客户端访问进行分享。</p><a id="more"></a><h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><blockquote><p><code>Linux Distribution</code> : <code>ubuntu</code><br><code>Ceph</code> : <code>Giant</code><br><code>Keepalived</code> : <code>v1.2.2</code><br>集群信息 ：三节点，<code>IP</code>分别为<code>192.168.1.111</code>，<code>192.168.1.112</code>，<code>192.168.1.113</code></p></blockquote><h2 id="Keepalived-简介"><a href="#Keepalived-简介" class="headerlink" title="Keepalived 简介"></a>Keepalived 简介</h2><p>建议先简单了解一些<code>keepalived</code>的机制再看下面的内容~</p><blockquote><p><code>Keepalived</code>的作用是检测集群中服务器的状态，如果有一台服务器死机，或工作出现故障，<code>Keepalived</code>将检测到，并将有故障的服务器从集群中剔除，当服务器工作正常后<code>Keepalived</code>自动将服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉，需要人工做的只是修复故障的服务器。</p></blockquote><p>下面从网上找了几张图片，方便大家理解一下其原理和机制：</p><h3 id="Keepalived-内部结构："><a href="#Keepalived-内部结构：" class="headerlink" title="Keepalived 内部结构："></a>Keepalived 内部结构：</h3><center><img src="http://ow0mgad6r.bkt.clouddn.com/keepalived_space.png" alt="keepalive layer"></center><h3 id="双机热备："><a href="#双机热备：" class="headerlink" title="双机热备："></a>双机热备：</h3><center><img src="http://ow0mgad6r.bkt.clouddn.com/keepalived_two_host.png" alt="keepalive two host master and backup"></center><h3 id="负载均衡、应用分层："><a href="#负载均衡、应用分层：" class="headerlink" title="负载均衡、应用分层："></a>负载均衡、应用分层：</h3><center><img src="http://ow0mgad6r.bkt.clouddn.com/keepalived_layer.png" alt="keepalive layer"></center><h3 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h3><p>已下摘录自：<a href="http://blog.csdn.net/love_is_simple/article/details/47903527" target="_blank" rel="external">http://blog.csdn.net/love_is_simple/article/details/47903527</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">global_defs &#123;</div><div class="line">   notification_email &#123;</div><div class="line">     sai@localhost # 报警邮件接收人的地址</div><div class="line">   &#125;</div><div class="line">   notification_email_from root@localhost # 发送报警邮件发件人地址</div><div class="line">   smtp_server 127.0.0.1# 发送邮件的服务器地址</div><div class="line">   smtp_connect_timeout 30# 邮件超时时间(可以根据自己的需求进行设定)</div><div class="line">   router_id LVS_DEVEL# 一个实例的标识地址(可以有多个实例但不能相同)</div><div class="line">&#125;</div><div class="line">vrrp_script monitor_nginx &#123;</div><div class="line">  script “/root/scripts/monitor_nginx.sh”#根据自己的实际路径放置脚本文件</div><div class="line">  interval 1# 脚本执行间隔</div><div class="line">Weight -5#脚本结果导致的优先级变更:5表示优先级加5；-5表示优先级减5</div><div class="line">&#125;</div><div class="line">vrrp_instance VI_1 &#123;# 虚拟路由器自己的名字</div><div class="line">    state MASTER# 设置服务器模式，当前为主节点,master端</div><div class="line">    interface eth0# 实例网卡,也就是提供服务的网卡，来发送vrrp通告</div><div class="line">    virtual_router_id 51# 设置vrid,这里非常重要,相同的vrid为一个组,他决定,它将决定多播的MAC地址.（建议不要使用默认地址,以免发生冲突）</div><div class="line">    priority 100#  设置本节点的优先级,优先级高的为master</div><div class="line">    advert_int 1# 检查间隔,默认为1秒</div><div class="line">    authentication &#123;</div><div class="line">        auth_type PASS# 认证方式,可以是pass或者AH两种认证方式</div><div class="line">        auth_pass 1111# 认证密码</div><div class="line">    &#125;</div><div class="line">    virtual_ipaddress &#123;# 设置vip,虚拟ip地址(实现高可用,转移的vip地址)</div><div class="line">        10.0.1.230# 此地址并不存在,当成为主节点时,此ip地址将会自动生成</div><div class="line">&#125;</div><div class="line">script_track &#123;</div><div class="line">monitor_nginx  #跟踪这个monitor_nginx脚本;就是不断去检查这个脚本</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="RBD-导出-NFS"><a href="#RBD-导出-NFS" class="headerlink" title="RBD 导出 NFS"></a>RBD 导出 NFS</h3><p>首先我们要实现<code>RBD</code>导出<code>NFS</code>功能，毕竟只有先能让客户端通过<code>NFS</code>访问后端存储，然后才有必要谈后端存储集群的高可用方案。</p><p>我们需要在<code>Ceph Server</code>集群创建<code>RBD image</code>；然后在三个节点上都建立<code>RBD Map</code>关系，最终只会有一个块设备被<code>mount</code>，其余两个既用于占位（防止多<code>image</code>的情况下造成节点间块设备名称不一致），又是为了作为备机在主机发生故障时转换角色，挂载当前节点的块设备。</p><p>接着在三个节点上分别在指定目录下创建目录，本文是在<code>/vol/</code>目录下创建目录，比如创建目录<code>/vol/ec</code>，这个目录就是块设备对应的挂载目录。</p><p>如果有童鞋对<code>rbd</code>导出<code>nfs</code>过程有兴趣的话，具体请参考：<a href="http://www.tony-yin.top/2017/10/31/RBD-Mount-NFS/" target="_blank" rel="external">使用NFS挂载RBD</a>。</p><h3 id="Keepalived-实现-HA"><a href="#Keepalived-实现-HA" class="headerlink" title="Keepalived 实现 HA"></a>Keepalived 实现 HA</h3><p>我们后端存储集群最终只会暴露出一个接口或者说是一个<code>IP</code>，<code>keepalived</code>中有<code>VIP</code>这种配置可以支持，所以我们需要在三个节点上配置<code>keepalived.conf</code>文件，然后启动<code>keepalived</code>所有节点会选举一个<code>master</code>节点并暴露虚拟<code>IP</code>。</p><p>然后我们在<code>master</code>节点上将块设备挂载到之前创建的目录<code>/vol/ec</code>，同步信息至<code>/ect/exports</code>，可以通过<code>showmount -e vip</code>可以发现<code>/vol/ec</code>已经暴露到了<code>vip</code>上，客户端便可以通过<code>NFS</code>将上一步创建的目录<code>/vol/ec</code>挂载到本地目录，比如<code>/client_ec</code>；</p><p>这时候客户端已经可以通过虚拟<code>IP</code>对<code>RBD image</code>进行读写了，但是如果这时候<code>master</code>节点<code>down</code>了咋办呢？</p><p>为了防止集群中主节点不能给<code>client</code>提供访问，我们需要实现高可用，也就是当主节点<code>down</code>了后，集群自动切换主机，并且针对<code>RBD</code>做自动相应挂载操作，让用户无感知访问存储后端。</p><p>我们需要配置<code>keepalived.conf</code>，当节点角色转为<code>backup</code>时，触发停止<code>NFS</code>并卸载暴露目录等操作；当节点角色转为<code>master</code>时，触发挂载<code>RBD image</code>并启动<code>NFS</code>等操作；定时检查当前<code>NFS</code>，一旦<code>NFS</code>服务停止了，尝试重启，如果重启失败，停止<code>keepalived</code>服务触发节点角色切换等等。</p><p>这些操作对用户来说是无感知的，我们还可以针对<code>keepalived</code>做相关邮件配置提醒服务器发生故障等等。</p><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><h4 id="搭建-Ceph-集群"><a href="#搭建-Ceph-集群" class="headerlink" title="搭建 Ceph 集群"></a>搭建 Ceph 集群</h4><p>这个就不多说了，基本操作。</p><h4 id="安装-Keepalived"><a href="#安装-Keepalived" class="headerlink" title="安装 Keepalived"></a>安装 Keepalived</h4><p>本位基于<code>ubuntu</code>，<code>redhat</code>派可以转换成对应的命令再操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-get install libpopt-dev     // 安装依赖</div><div class="line">apt-get install keepalived</div></pre></td></tr></table></figure><h3 id="RBD-导出"><a href="#RBD-导出" class="headerlink" title="RBD 导出"></a>RBD 导出</h3><h4 id="创建-image"><a href="#创建-image" class="headerlink" title="创建 image"></a>创建 image</h4><p>这里默认在<code>test1 pool</code>中创建<code>1G</code>的<code>image</code>，请根据自己的场景转换大小，生产环境一般都要几十<code>T</code>，甚至上百<code>T</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd create --size 1024 -p test1 image_ec</div></pre></td></tr></table></figure><h4 id="建立-map-关系"><a href="#建立-map-关系" class="headerlink" title="建立 map 关系"></a>建立 map 关系</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rbd map -p test1 image_ec</div><div class="line"># 输出块设备名称： /dev/rbd0</div></pre></td></tr></table></figure><h4 id="为块设备格式化文件系统"><a href="#为块设备格式化文件系统" class="headerlink" title="为块设备格式化文件系统"></a>为块设备格式化文件系统</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkfs.ext4 -i 400000 /dev/rbd0</div></pre></td></tr></table></figure><h4 id="将块设备挂载到本地目录"><a href="#将块设备挂载到本地目录" class="headerlink" title="将块设备挂载到本地目录"></a>将块设备挂载到本地目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount -o noatime,user_xattr /dev/rbd0 /vol/ec</div></pre></td></tr></table></figure><h3 id="配置-Keepalived"><a href="#配置-Keepalived" class="headerlink" title="配置 Keepalived"></a>配置 Keepalived</h3><h4 id="配置-VIP"><a href="#配置-VIP" class="headerlink" title="配置 VIP"></a>配置 VIP</h4><p><code>VIP</code>必须是当前集群不存在的<code>ip</code>，通过将配置个节点上<code>keepalived.conf</code>，为<code>virtual_ipaddress</code>选项添加<code>IP</code>，我这边用的是<code>192.168.1.13/24</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">virtual_ipaddress &#123;</div><div class="line">    192.168.1.13/24</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="配置优先级和网卡"><a href="#配置优先级和网卡" class="headerlink" title="配置优先级和网卡"></a>配置优先级和网卡</h4><p>三个节点的角色都配置为<code>BACKUP</code>，并且配置<code>nopreempt</code>，这样就可以实现不抢占模式，当主节点<code>down</code>恢复后不会抢占成为主节点，对我而言哪个是主节点并不重要，频繁切换反而会造成客户端延时。我这边的对外网卡是<code>eth0</code>，<code>priority</code>是真正决定一开始初始化选举<code>master</code>的因素，最大值的节点是<code>master</code>节点，一旦切换角色，这个值并不会改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vrrp_instance VI_1 &#123;</div><div class="line">    state BACKUP</div><div class="line">    interface eth0</div><div class="line">    priority 100</div><div class="line">    nopreempt</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="配置角色切换后触发相关操作"><a href="#配置角色切换后触发相关操作" class="headerlink" title="配置角色切换后触发相关操作"></a>配置角色切换后触发相关操作</h4><p>当主机<code>down</code>之后，如果没有关机，角色转换为<code>backup</code>后需要做卸载相关操作；而之前的备机如今成为了主机，也要做挂载等相关操作，这些需求我们可以通过配置<code>keepalived</code>，当角色转换时触发相关脚本，这里的配置就表示当节点角色切换为了<code>master</code>时则需要执行<code>/etc/keepalived/ChangeToMaster.sh</code>，角色切换为<code>backup</code>则会执行<code>/etc/keepalived/ChangeToBackup.sh</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vrrp_instance VI_1 &#123;</div><div class="line">    notify_master &quot;/etc/keepalived/ChangeToMaster.sh&quot; </div><div class="line">    notify_backup &quot;/etc/keepalived/ChangeToBackup.sh&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="配置定时检测-NFS-状态"><a href="#配置定时检测-NFS-状态" class="headerlink" title="配置定时检测 NFS 状态"></a>配置定时检测 NFS 状态</h4><p>如果一旦<code>NFS</code>服务断了，我们不及时处理的话，客户端就可以明显地感知到无法读写了。所以我们需要定时不断检测<code>NFS</code>的状态，这个也可以通过配置<code>track_script</code>选项执行某个脚本并指定间隔时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">vrrp_script chk_nfs &#123;</div><div class="line">    script &quot;/etc/keepalived/check_nfs.sh&quot;       # 调用脚本</div><div class="line">    interval 2      # 设置间隔时间为 2s</div><div class="line">&#125;</div><div class="line">vrrp_instance VI_1 &#123;</div><div class="line">    track_script &#123;</div><div class="line">        chk_nfs     # 调用上面的chk_nfs函数</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="整个配置文件内容"><a href="#整个配置文件内容" class="headerlink" title="整个配置文件内容"></a>整个配置文件内容</h4><p>暂时还是比较精简的，邮件什么的都没配置，<code>keepalived</code>还是可以做很多事情的，有兴趣的童鞋可以深入研究</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">global_defs &#123;</div><div class="line">    notification_email &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    router_id NFS_HA_222</div><div class="line">&#125;</div><div class="line"></div><div class="line">vrrp_script chk_nfs &#123;</div><div class="line">    script &quot;/etc/keepalived/check_nfs.sh&quot;</div><div class="line">    interval 2</div><div class="line">&#125;</div><div class="line"></div><div class="line">vrrp_instance VI_1 &#123;</div><div class="line">    #state MASTER</div><div class="line">    state BACKUP</div><div class="line">    interface eth0</div><div class="line">    priority 100</div><div class="line">    virtual_router_id 100</div><div class="line">    advert_int 1</div><div class="line">    authentication &#123;</div><div class="line">        auth_type PASS</div><div class="line">        auth_pass 1111</div><div class="line">    &#125;</div><div class="line">    track_script &#123;</div><div class="line">        chk_nfs</div><div class="line">    &#125;</div><div class="line">    nopreempt</div><div class="line">    notify_master &quot;/etc/keepalived/ChangeToMaster.sh&quot;</div><div class="line">    notify_backup &quot;/etc/keepalived/ChangeToBackup.sh&quot;</div><div class="line">    virtual_ipaddress &#123;</div><div class="line">        192.168.1.13/24</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="相关脚本"><a href="#相关脚本" class="headerlink" title="相关脚本"></a>相关脚本</h4><blockquote><p>大家可以手动从下面复制，也可以去我的<code>github</code>上面获取，欢迎点赞！</p><p>地址： <a href="https://github.com/tony-yin/ceph_scripts#keepalived" target="_blank" rel="external">https://github.com/tony-yin/ceph_scripts#keepalived</a></p></blockquote><p>这些脚本都是针对我当前环境的，需要针对自己的环境和需求进行相应更改</p><p><code>ChangeToBackup.sh</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">service nfs-kernel-server stop</div><div class="line">for folder in $(ls /vol)</div><div class="line">do</div><div class="line">    if $(mount | grep $folder -q); then</div><div class="line">        umount -f /vol/$folder</div><div class="line">    fi</div><div class="line">done</div></pre></td></tr></table></figure><p><code>ChangeToMaster.sh</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="keyword">for</span> folder <span class="keyword">in</span> $(ls /vol)</div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="keyword">if</span> $(mount | grep <span class="variable">$folder</span> -q); <span class="keyword">then</span></div><div class="line">        umount /vol/<span class="variable">$folder</span> &gt; /dev/null</div><div class="line">    <span class="keyword">fi</span></div><div class="line">    device=$(grep <span class="variable">$folder</span> /etc/block_map -w | awk <span class="string">'&#123;print $1&#125;'</span>)</div><div class="line">    mount <span class="variable">$device</span> /vol/<span class="variable">$folder</span></div><div class="line"><span class="keyword">done</span></div><div class="line">service nfs-kernel-server start</div></pre></td></tr></table></figure><p><code>check_nfs.sh</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line">vip=$(grep -A 1 virtual_ipaddress /etc/keepalived/keepalived.conf | grep -v virtual_ipaddress | tr -d [:blank:] | cut -d <span class="string">'/'</span> -f 1)</div><div class="line"><span class="keyword">if</span> ! /sbin/ip addr | grep -q <span class="variable">$vip</span>; <span class="keyword">then</span></div><div class="line">    <span class="built_in">exit</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="comment"># check nfs service</span></div><div class="line">/sbin/service nfs-kernel-server status &gt;/dev/null</div><div class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></div><div class="line">    <span class="comment"># abnormal, try to restart the nfs service</span></div><div class="line">    /sbin/service nfs-kernel-server restart</div><div class="line">    /sbin/service nfs-kernel-server status &gt;/dev/null</div><div class="line">    <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></div><div class="line">        <span class="comment"># still abnormal</span></div><div class="line">        <span class="keyword">for</span> folder <span class="keyword">in</span> $(ls /vol)</div><div class="line">        <span class="keyword">do</span></div><div class="line">            <span class="keyword">if</span> $(mount | grep <span class="variable">$folder</span> -q); <span class="keyword">then</span></div><div class="line">                umount -f /vol/<span class="variable">$folder</span></div><div class="line">            <span class="keyword">fi</span></div><div class="line">        <span class="keyword">done</span></div><div class="line">        <span class="comment"># stop keepalived service</span></div><div class="line">        /sbin/service keepalived stop</div><div class="line">    <span class="keyword">fi</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure><p>配置完后，分别在三个节点上执行<code>service keepalived restart</code>重启服务，然后分别在三个节点上执行<code>ip addr</code>查看<code>IP</code>情况，可以发现<code>VIP</code>暴露在了<code>node2</code>上，说明我这里<code>node2</code>在<code>keepalived.conf</code>里面配置<code>priority</code>的值是最大的</p><p><code>node1</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root@node1:/etc/keepalived# ip addr</div><div class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN </div><div class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</div><div class="line">    inet 127.0.0.1/8 scope host lo</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 1000</div><div class="line">    link/ether 00:50:56:aa:70:4e brd ff:ff:ff:ff:ff:ff</div><div class="line">    inet 192.168.1.111/24 brd 192.168.1.255 scope global eth0</div><div class="line">       valid_lft forever preferred_lft forever</div></pre></td></tr></table></figure><p><code>node2</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">root@node2:/etc# ip addr</div><div class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN </div><div class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</div><div class="line">    inet 127.0.0.1/8 scope host lo</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 1000</div><div class="line">    link/ether 00:50:56:aa:61:26 brd ff:ff:ff:ff:ff:ff</div><div class="line">    inet 192.168.1.112/24 brd 192.168.1.255 scope global eth0</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">    inet 192.168.1.13/24 scope global secondary eth0</div><div class="line">       valid_lft forever preferred_lft forever</div></pre></td></tr></table></figure><p><code>node3</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root@node3:~# ip addr</div><div class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN </div><div class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</div><div class="line">    inet 127.0.0.1/8 scope host lo</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 1000</div><div class="line">    link/ether 00:50:56:aa:a9:13 brd ff:ff:ff:ff:ff:ff</div><div class="line">    inet 192.168.1.113/24 brd 192.168.1.255 scope global eth0</div><div class="line">       valid_lft forever preferred_lft forever</div></pre></td></tr></table></figure><h3 id="客户端通过-NFS-访问-RBD"><a href="#客户端通过-NFS-访问-RBD" class="headerlink" title="客户端通过 NFS 访问 RBD"></a>客户端通过 NFS 访问 RBD</h3><p>客户端检查<code>VIP</code>对外暴露接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@tony /]# showmount -e 192.168.1.13</div><div class="line">Export list for 192.168.1.13:</div><div class="line">/vol/ec1 *</div></pre></td></tr></table></figure><p>将<code>server</code>端挂载块设备的目录<code>/vol/ec1</code>再次挂载到客户端上的<code>ec1</code>目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@tony /]# mkdir ec1</div><div class="line">[root@tony /]# mount -o rw,hard,intr -t nfs 192.168.1.13:/vol/ec1 /ec1</div><div class="line">[root@tony /]# cd ec1</div><div class="line">[root@tony ec1]# ls</div><div class="line">lost+found      # 此时是没有数据的</div></pre></td></tr></table></figure><p>我们可以测试一下读写，先看下读，比如我们在<code>node2</code>的<code>/vol/ec1</code>目录下写一个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@node2:/vol/ec1# ls</div><div class="line">lost+found</div><div class="line">root@node2:/vol/ec1# echo &apos;hello&apos; &gt; hello.txt</div></pre></td></tr></table></figure><p>然后客户端查看<code>/ec1</code>目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@tony ec1]# ls</div><div class="line">hello.txt  lost+found</div><div class="line">[root@tony ec1]# cat hello.txt </div><div class="line">hello</div></pre></td></tr></table></figure><p>接下来测写，我们可以在客户端写一个文件，然后到服务端查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@tony ec1]# echo &apos;i am client&apos; &gt; client.txt</div><div class="line">[root@tony ec1]# ls</div><div class="line">client.txt  hello.txt  lost+found</div></pre></td></tr></table></figure><p>服务端查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@node2:/vol/ec1# ls</div><div class="line">client.txt  hello.txt  lost+found</div><div class="line">root@node2:/vol/ec1# cat client.txt </div><div class="line">i am client</div></pre></td></tr></table></figure><p>ok，读写正常，目前为止客户端访问后端存储集群一切顺利！</p><h3 id="测试高可用"><a href="#测试高可用" class="headerlink" title="测试高可用"></a>测试高可用</h3><p>分三个测试：</p><ul><li>手动停止主机<code>NFS</code></li><li>手动停止主机<code>Keepalived</code></li><li>手动关机主机</li></ul><h4 id="手动停止主机-NFS"><a href="#手动停止主机-NFS" class="headerlink" title="手动停止主机 NFS"></a>手动停止主机 NFS</h4><p>这个主要是测试<code>check_nfs.sh</code>这个脚本是否在实时监控<code>NFS</code>状态，可以看到刚<code>stop</code>再次查看状态已经是<code>running</code>了，本测试通过~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@node2:/vol/ec1# service nfs-kernel-server stop</div><div class="line"> * Stopping NFS kernel daemon                                                                                                                                                         [ OK ] </div><div class="line"> * Unexporting directories for NFS kernel daemon...                                                                                                                                   [ OK ] </div><div class="line">root@node2:/vol/ec1# service nfs-kernel-server status</div><div class="line">nfsd running</div></pre></td></tr></table></figure><h4 id="手动停止主机-Keepalived"><a href="#手动停止主机-Keepalived" class="headerlink" title="手动停止主机 Keepalived"></a>手动停止主机 Keepalived</h4><p>手动停止主机<code>node2</code>的<code>keepalived</code>服务，发现<code>VIP</code>已经在<code>node2</code>上面消失不见</p><p><code>node2</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">root@node2:/vol/ec1# service keepalived stop</div><div class="line"> * Stopping keepalived keepalived                                                                                                                                                     [ OK ] </div><div class="line">root@node2:/vol/ec1# ip addr</div><div class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN </div><div class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</div><div class="line">    inet 127.0.0.1/8 scope host lo</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 1000</div><div class="line">    link/ether 00:50:56:aa:61:26 brd ff:ff:ff:ff:ff:ff</div><div class="line">    inet 192.168.1.112/24 brd 192.168.1.255 scope global eth0</div><div class="line">       valid_lft forever preferred_lft forever</div></pre></td></tr></table></figure><p>我们可以在<code>node1</code>发现了上面消失不见得<code>VIP</code>，可知如今角色发生了改变，<code>node1</code>已经成为了新的<code>master</code>节点</p><p><code>node1</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># 出现了 VIP：192.168.1.13/24</div><div class="line">root@node1:/etc/keepalived# ip addr</div><div class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN </div><div class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</div><div class="line">    inet 127.0.0.1/8 scope host lo</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 1000</div><div class="line">    link/ether 00:50:56:aa:70:4e brd ff:ff:ff:ff:ff:ff</div><div class="line">    inet 192.168.1.111/24 brd 192.168.1.255 scope global eth0</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">    inet 192.168.1.13/24 scope global secondary eth0</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line"># 查看node1的/vol/ec1目录     </div><div class="line">root@node1:/etc/keepalived# ls /vol/ec1</div><div class="line">client.txt  hello.txt  lost+found</div><div class="line"># 查看mount信息</div><div class="line">root@node1:/etc/keepalived# mount</div><div class="line">/dev/sda3 on / type ext4 (rw,errors=remount-ro)</div><div class="line">/dev/sdb2 on /data/osd.0 type ext4 (rw,noatime,user_xattr)</div><div class="line">nfsd on /proc/fs/nfsd type nfsd (rw)</div><div class="line">...</div><div class="line">/dev/rbd0 on /vol/ec1 type ext4 (rw)</div></pre></td></tr></table></figure><p>此时我们可以再次测试一下读写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># 新的主机读</div><div class="line">root@node1:/etc/keepalived# ls /vol/ec1</div><div class="line">client.txt  hello.txt  lost+found</div><div class="line"></div><div class="line"># 新的主机写</div><div class="line">root@node1:/etc/keepalived# echo &apos;new service 111&apos; &gt; /vol/ec1/new_server.txt</div><div class="line">root@node1:/etc/keepalived# ls /vol/ec1</div><div class="line">client.txt  hello.txt  lost+found  new_server.txt</div><div class="line"></div><div class="line"># 客户端读</div><div class="line">[root@tony ec1]# ls</div><div class="line">client.txt  hello.txt  lost+found  new_server.txt</div><div class="line">[root@tony ec1]# cat new_server.txt</div><div class="line">new service 111</div><div class="line"></div><div class="line"># 客户端写</div><div class="line">[root@tony ec1]# echo &apos;hello new server&apos; &gt; hello_new_server.txt</div><div class="line"># 可以看到刚刚客户端写的文件</div><div class="line">root@node1:/vol/ec1# ls</div><div class="line">client.txt  hello_new_server.txt  hello.txt  lost+found  new_server.txt</div></pre></td></tr></table></figure><p>ok，本测试通过~</p><h4 id="手动关机主机"><a href="#手动关机主机" class="headerlink" title="手动关机主机"></a>手动关机主机</h4><p>关闭主机<code>node1</code>，稍等片刻，确定完全关闭再测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">root@node1:/vol# reboot</div><div class="line"></div><div class="line">Broadcast message from root@node1</div><div class="line">(/dev/pts/3) at 9:16 ...</div><div class="line"></div><div class="line">The system is going down for reboot NOW!</div></pre></td></tr></table></figure><p>等待完全关闭，我们在<code>node3</code>上看到了<code>VIP</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">root@node3:~# ip addr</div><div class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN </div><div class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</div><div class="line">    inet 127.0.0.1/8 scope host lo</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 1000</div><div class="line">    link/ether 00:50:56:aa:a9:13 brd ff:ff:ff:ff:ff:ff</div><div class="line">    inet 192.168.1.113/24 brd 192.168.1.255 scope global eth0</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">    inet 192.168.1.13/24 scope global secondary eth0</div><div class="line">       valid_lft forever preferred_lft forever</div></pre></td></tr></table></figure><p>客户端读写测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 客户端读</div><div class="line">[root@tony ec1]# ls</div><div class="line">client.txt  hello_new_server.txt  hello.txt  lost+found  new_server.txt</div><div class="line"># 客户端写</div><div class="line">[root@tony ec1]# echo &apos;reboot&apos; &gt;  reboot.txt</div><div class="line">[root@tony ec1]# ls</div><div class="line">client.txt  hello_new_server.txt  hello.txt  lost+found  new_server.txt  reboot.txt</div></pre></td></tr></table></figure><p><code>node3</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@node3:~# ls /vol/ec1</div><div class="line">client.txt  hello_new_server.txt  hello.txt  lost+found  new_server.txt  reboot.txt</div><div class="line">root@node3:~# cat /vol/ec1/reboot.txt </div><div class="line">reboot</div></pre></td></tr></table></figure><p>ok，本测试通过~</p><h3 id="测试小结"><a href="#测试小结" class="headerlink" title="测试小结"></a>测试小结</h3><p>通过上面三个测试，我们已经基本确保了<code>keepalived</code>会保证集群中主机发生异常时还是可以很好地对外提供服务，并且真正地做到了高可用，低延时，高可靠。</p><h2 id="QA-环节"><a href="#QA-环节" class="headerlink" title="QA 环节"></a>QA 环节</h2><p>因为我实现这个<code>RBD</code>高可用是在我们项目中做的，我们项目中<code>UI</code>上可以创建共享目录，但是之前都是用的<code>cephfs</code>实现的，而我做的就是将<code>cephfs</code>方式使用<code>RBD</code>替代，大家应该都清楚作为<code>POSIX</code>文件接口的<code>cephfs</code>内部已经做好了很多事情，它可以将所有节点挂载的目录做到真正的共享，也就是共享目录三个目录都有，改一个其他两个都会随之而改变，而不是像我们<code>RBD</code>同时只会针对某一个主机访问。</p><p>而<code>RBD</code>替换的话必然存在很多困难和问题，在这里我就以<code>QA</code>问答的方式分享一下我实现过程中遇到的种种问题和别人提出的需求。</p><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>问：如何通过代码实现三个节点都做相关操作的，比如创建<code>image</code>和目录等等？</p><p>答：我们项目是这样实现的，将前端<code>UI</code>的增删改查（比如创建或删除目录等）和后端具体实现共享目录业务分离，也就是说前端只负责做这些信息的增删改查，对应的后端也只是负责这些信息的增删改查，所以用户会即时收到反馈。而真正做事的是在共享业务后端，这个和<code>UI</code>对应的后端做事有所区别，这边共享业务后端是做成了一个<code>Daemon</code>每隔几秒就会去扫描<code>UI</code>后端存储数据是否变化，发生了变化就会做相关操作，比如多了一个文件夹就要创建<code>image</code>等，删除一个文件夹也要做一系列的事情。</p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>问：如何判断哪个节点是<code>master</code>？</p><p>答：这个很简单，就通过<code>ip addr</code>命令查找<code>VIP</code>就好了，不能通过配置文件中的<code>priority</code>来判断，因为即使角色切换，那个值也不会变化的，也就是说即使<code>priority</code>是最大值也有可能当前节点不是主节点，这里要注意的是不能仅仅是包含<code>VIP</code>，而是要精确匹配才行，比如<code>VIP</code>是<code>192.168.1.12</code>，如果此时还有个<code>192.168.1.123</code>，如果只是字符串包含的话，那这个也会被匹配，所以要精确匹配。</p><h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><p>问：创建文件夹后端实现的逻辑是什么样的？</p><p>答：后端<code>Daemon</code>当扫描存储的目录信息相比于上一次扫描时新增的话，那么后端就会做事情了。首先我们要判断是否为主节点，如果是主节点，那么就创建<code>image</code>，然后做<code>Map</code>，接着就要<code>format</code>文件系统，创建目录，然后再做挂载。这时候要注意其他两个备节点也要做<code>rbd map</code>操作，这样做的原因，一是为了占位，比如当创建的项目多了之后，<code>backup</code>节点再<code>map</code>的时候顺序会乱掉，二是为了当主机<code>down</code>，备机转换为<code>master</code>后要找同样的块设备挂载，比如都是<code>/dev/rbd0</code></p><h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h3><p>问：删除文件夹后端实现的逻辑是什么样的？</p><p>答：扫描当前目录少于上一次扫描的目录，那么就针对这些目录，主节点要先<code>umount</code>，再<code>umap</code>，然后<code>rm image</code>，最后删除目录，对于备节点的话就<code>umap</code>，然后再删除目录就好</p><h3 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h3><p>问：三个节点的<code>Daemon</code>可能执行的顺序不一样，不一定是主节点先执行，那么这个时候备节点将无法<code>map</code>，同理很有可能在删除<code>image</code>的时候，别的节点的<code>image</code>都还没<code>unmap</code>，这样的话<code>image</code>是会删除失败的，这里怎么处理节点间的冲突呢？</p><p>答：</p><p>首先是创建目录，这时候主节点我们已经做得比较好了，主要担心备节点<code>map</code>的时候<code>image</code>还没有创建，那么我们这边就要判断一下，如果<code>image</code>还不在指定<code>pool</code>中，那么就要设置当前目录情况还为上一次的目录信息，这样下一次扫描代码就会又以为有新目录了，那么该段代码就会又执行一次，此时应该成功了，反正只要成功的时候才会把当前目录信息更改为最新的目录信息。</p><p>再来说删除目录，这个和创建<code>map</code>不同的地方在于，我要删除<code>image</code>的时候，我无法知道这个<code>image</code>还有没有和其他节点有<code>map</code>关系，所以我们只有尝试去删除，这边加一个异常捕获，因为<code>rm image</code>报错我们不处理的话会造成代码出错，所以外面包一层异常，这样就可以和上面类似的操作了。这边要注意的是一旦发生异常，我们还必须要在<code>map</code>回去，否则我们无法获取<code>pool</code>等信息了，因为我们是通过<code>rbd showmapped</code>来获取相关信息的。</p><h3 id="问题6"><a href="#问题6" class="headerlink" title="问题6"></a>问题6</h3><p>问：请问<code>keepalived</code>如何做自动化的？</p><p>答：由于<code>keepalived</code>也比较简单，三个配置文件相关配置信息都配一样的，我们要做的就是网卡和<code>VIP</code>，网卡的话我们就从项目中获取<code>public ip</code>，而<code>VIP</code>就是<code>UI</code>上面配置的，然后读写文件就好了。</p><h3 id="问题7"><a href="#问题7" class="headerlink" title="问题7"></a>问题7</h3><p>问：一旦节点关机的话，下次开机后块设备就会没了，我们该如何做呢？</p><p>答：这个问题的确存在，所以我们要提前将对应关系存在文件中，下次开机的时候根据文件然后对应做<code>map</code>工作</p><h3 id="问题8"><a href="#问题8" class="headerlink" title="问题8"></a>问题8</h3><p>问：多个块设备的时候，<code>keepalived</code>触发的脚本如何做？</p><p>答：其实这个的做法我已经暴露在上面我分享的三个脚本里面了，要做的就是遍历<code>/vol</code>目录下的所有目录或者所有<code>rbd*</code>，这边要注意的就是<code>/vol/</code>或者指定目录下存在的必须只有创建的共享目录。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过<code>keepalived</code>初步实现了<code>RBD</code>的高可用，简单地替代了<code>cephfs</code>导出<code>NFS</code>，针对<code>cephfs</code>性能不行的问题，应该有很多小伙伴有这种需求，希望这篇文章能给大家带来一些思路和帮助</p><p>之后，我会尝试研究<code>CTDB</code>做高可用，因为<code>keepalived</code>由于比较简单，所以功能也就比较局限了。然后本文只有<code>NFS</code>，后续应该还会有<code>smb</code>，<code>iscsi</code>等等</p><p>通过本文，我对<code>RBD</code>和高可用的认识又深入了一些，其实本文涉及到的技术还是比较简单的，还有很多更复杂、更牛逼的高可用方案，这里不禁要说一句，后端还是有意思呀！（相比于前端而言），起码对我来说是这样的，以后会不断精进这些技术，加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/HA.jpg&quot; alt=&quot;HA&quot;&gt;&lt;/center&gt;

&lt;p&gt;由于&lt;code&gt;Cephfs&lt;/code&gt;很不稳定，并且性能差，很难达到用户在性能上的需求，所以&lt;code&gt;Cephfs&lt;/code&gt;也难以应用于生产环境之上。而&lt;code&gt;RBD&lt;/code&gt;可以说是一直非常稳定的存储接口方案，用户可以将&lt;code&gt;image&lt;/code&gt;挂载到客户端进行访问读写，然而很多用户不愿意在本地安装&lt;code&gt;Ceph&lt;/code&gt;客户端，所以我们常常需要自己封装一层，给客户端暴露出一个通用的接口进行访问，现在一般都是默认用&lt;code&gt;NFS&lt;/code&gt;，所以本文就&lt;code&gt;Ceph RBD&lt;/code&gt;如何实现高可用暴露&lt;code&gt;NFS&lt;/code&gt;给客户端访问进行分享。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="RBD" scheme="https://tony-yin.github.io/tags/RBD/"/>
    
      <category term="HA" scheme="https://tony-yin.github.io/tags/HA/"/>
    
      <category term="Keepalived" scheme="https://tony-yin.github.io/tags/Keepalived/"/>
    
  </entry>
  
  <entry>
    <title>Cephx 实战演练</title>
    <link href="https://tony-yin.github.io/2017/11/30/Cephx-practice/"/>
    <id>https://tony-yin.github.io/2017/11/30/Cephx-practice/</id>
    <published>2017-11-30T03:04:04.000Z</published>
    <updated>2017-11-30T03:10:00.441Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/cephx-600x450.jpg" alt="cephx"></center><p>本文就阅读完<a href="http://www.xuxiaopang.com/2017/08/23/easy-ceph-CephX/" target="_blank" rel="external">徐小胖的大话Cephx</a>后，针对一些猜测和疑惑进行了实战演练，对原文的一些说法和结论进行了验证，并进行了一系列的扩展的思考猜想和总结。最后收获满满，不仅对原文的一些结论进行了验证，也发现了其中的一些问题，更多的是自己动手后一些奇妙的场景和发现。</p><a id="more"></a><p>本文实战任务和完成情况如下：</p><ul><li style="list-style: none"><input type="checkbox" checked> 删除<code>client.admin.keyring</code></li><li style="list-style: none"><input type="checkbox" checked> 修改<code>cephx</code>配置</li><li style="list-style: none"><input type="checkbox" checked> 修改<code>Monitor keyring</code></li><li style="list-style: none"><input type="checkbox" checked> 修改<code>OSD keyring</code></li><li style="list-style: none"><input type="checkbox" checked> 修改<code>client.admin.keyring</code>，通过<code>Mon</code>找回正确的<code>keyring</code></li><li style="list-style: none"><input type="checkbox" checked> <code>Mon Cap</code></li><li style="list-style: none"><input type="checkbox" checked> <code>OSD Cap</code></li><li style="list-style: none"><input type="checkbox" checked> 删除所有<code>keyring</code>文件再恢复</li><li style="list-style: none"><input type="checkbox" checked> 删除<code>ceph.conf</code>再恢复</li><li style="list-style: none"><input type="checkbox"> 关闭<code>CephX</code>后不重启<code>OSD</code></li><li style="list-style: none"><input type="checkbox" checked> 通过<code>osd.keyring</code>访问集群</li><li style="list-style: none"><input type="checkbox"> 配置只能访问一个<code>RBD</code>的用户权限</li></ul><h2 id="删除-client-admin-keyring"><a href="#删除-client-admin-keyring" class="headerlink" title="删除 client.admin.keyring"></a>删除 client.admin.keyring</h2><p>主节点开始存在<code>keyring</code>，可以正常访问集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">[root@node1 ceph]# ls</div><div class="line">ceph.bootstrap-mds.keyring  ceph.bootstrap-osd.keyring  ceph.client.admin.keyring  ceph-deploy-ceph.log  rbdmap</div><div class="line">ceph.bootstrap-mgr.keyring  ceph.bootstrap-rgw.keyring  ceph.conf                  ceph.mon.keyring</div><div class="line">[root@node1 ceph]# ceph -s</div><div class="line">  cluster:</div><div class="line">    id:     99480db2-f92f-481f-b958-c03c261918c6</div><div class="line">    health: HEALTH_WARN</div><div class="line">            no active mgr</div><div class="line">            Reduced data availability: 281 pgs inactive, 65 pgs down, 58 pgs incomplete</div><div class="line">            Degraded data redundancy: 311/771 objects degraded (40.337%), 439 pgs unclean, 316 pgs degraded, 316 pgs undersized</div><div class="line">            application not enabled on 3 pool(s)</div><div class="line">            clock skew detected on mon.node2, mon.node3</div><div class="line"> </div><div class="line">  services:</div><div class="line">    mon:     3 daemons, quorum node1,node2,node3</div><div class="line">    mgr:     no daemons active</div><div class="line">    osd:     6 osds: 5 up, 5 in</div><div class="line">    rgw:     1 daemon active</div><div class="line">    rgw-nfs: 1 daemon active</div><div class="line"> </div><div class="line">  data:</div><div class="line">    pools:   10 pools, 444 pgs</div><div class="line">    objects: 257 objects, 36140 kB</div><div class="line">    usage:   6256 MB used, 40645 MB / 46901 MB avail</div><div class="line">    pgs:     63.288% pgs not active</div><div class="line">             311/771 objects degraded (40.337%)</div><div class="line">             158 undersized+degraded+peered</div><div class="line">             158 active+undersized+degraded</div><div class="line">             65  down</div><div class="line">             58  incomplete</div><div class="line">             5   active+clean+remapped</div></pre></td></tr></table></figure><p>将<code>keyring</code>文件移动到其他地方，相当于删除了<code>keyring</code>，这时访问集群报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@node1 ceph]# mv ceph.client.admin.keyring /tmp/</div><div class="line">[root@node1 ceph]# ls</div><div class="line">ceph.bootstrap-mds.keyring  ceph.bootstrap-mgr.keyring  ceph.bootstrap-osd.keyring  ceph.bootstrap-rgw.keyring  ceph.conf  ceph-deploy-ceph.log  ceph.mon.keyring  rbdmap</div><div class="line">[root@node1 ceph]# ceph -s</div><div class="line">2017-11-23 18:07:48.685028 7f63f6935700 -1 auth: unable to find a keyring on /etc/ceph/ceph.client.admin.keyring,/etc/ceph/ceph.keyring,/etc/ceph/keyring,/etc/ceph/keyring.bin,: (2) No such file or directory</div><div class="line">2017-11-23 18:07:48.685094 7f63f6935700 -1 monclient: ERROR: missing keyring, cannot use cephx for authentication</div><div class="line">2017-11-23 18:07:48.685098 7f63f6935700  0 librados: client.admin initialization error (2) No such file or directory</div><div class="line">[errno 2] error connecting to the cluster</div></pre></td></tr></table></figure><p>再拷贝回来又可以访问集群了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[root@node1 ceph]# mv /tmp/ceph.client.admin.keyring ./</div><div class="line">[root@node1 ceph]# ceph -s</div><div class="line">  cluster:</div><div class="line">    id:     99480db2-f92f-481f-b958-c03c261918c6</div><div class="line">    health: HEALTH_WARN</div><div class="line">            no active mgr</div><div class="line">            Reduced data availability: 281 pgs inactive, 65 pgs down, 58 pgs incomplete</div><div class="line">            Degraded data redundancy: 311/771 objects degraded (40.337%), 439 pgs unclean, 316 pgs degraded, 316 pgs undersized</div><div class="line">            application not enabled on 3 pool(s)</div><div class="line">            clock skew detected on mon.node2, mon.node3</div></pre></td></tr></table></figure><p><code>node3</code>由于<code>/etc/ceph/</code>目录下没有<code>keyring</code>文件，所以也无法连接集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@node3 ceph]# ls</div><div class="line">ceph.conf  ceph-deploy-ceph.log  rbdmap</div><div class="line">[root@node3 ceph]# ceph -s</div><div class="line">2017-11-23 17:59:16.659034 7fbe34678700 -1 auth: unable to find a keyring on /etc/ceph/ceph.client.admin.keyring,/etc/ceph/ceph.keyring,/etc/ceph/keyring,/etc/ceph/keyring.bin,: (2) No such file or directory</div><div class="line">2017-11-23 17:59:16.659085 7fbe34678700 -1 monclient: ERROR: missing keyring, cannot use cephx for authentication</div><div class="line">2017-11-23 17:59:16.659089 7fbe34678700  0 librados: client.admin initialization error (2) No such file or directory</div><div class="line">[errno 2] error connecting to the cluster</div></pre></td></tr></table></figure><p><strong>结论：</strong></p><blockquote><p>当<code>ceph.conf</code>中的<code>auth</code>配置为<code>cephx</code>的时候，访问集群是需要秘钥文件的</p></blockquote><h2 id="修改-cephx-配置"><a href="#修改-cephx-配置" class="headerlink" title="修改 cephx 配置"></a>修改 cephx 配置</h2><p>在<code>node3</code>节点上的<code>/etc/ceph/</code>目录下操作，首先将<code>ceph.client.admin.keyring</code>文件删除，然后将<code>auth</code>配置从<code>cephx</code>改为<code>none</code>，然后先重启<code>monitor</code>，再重启<code>osd</code>，这时候依然不可以访问集群，因为<code>cephx</code>是面向整个集群的，而不是某个节点，接下来需要在其他节点做一样的操作，更改<code>cephx</code>为<code>none</code>，然后重启<code>monitor</code>和<code>osd</code>，这时候便可以在没有<code>keyring</code>文件的情况下访问集群了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"># 删除keyring文件</div><div class="line">[root@node3 ~]# cd /etc/ceph/</div><div class="line">[root@node3 ceph]# ls</div><div class="line">ceph.client.admin.keyring  ceph.conf  ceph-deploy-ceph.log  rbdmap</div><div class="line">[root@node3 ceph]# mv ceph.client.admin.keyring /tmp/</div><div class="line"># 更改cephx配置</div><div class="line">[root@node3 ceph]# cat ceph.conf </div><div class="line">[global]</div><div class="line">fsid = 99480db2-f92f-481f-b958-c03c261918c6</div><div class="line">mon_initial_members = node1, node2, node3</div><div class="line">mon_host = 192.168.1.58,192.168.1.61,192.168.1.62</div><div class="line">auth_cluster_required = cephx</div><div class="line">auth_service_required = cephx</div><div class="line">auth_client_required = cephx</div><div class="line"></div><div class="line">public network = 192.168.1.0/24</div><div class="line">mon clock drift allowed = 2</div><div class="line">mon clock drift warn backoff = 30</div><div class="line">[root@node3 ceph]# vim ceph.conf </div><div class="line">[root@node3 ceph]# cat ceph.conf </div><div class="line">[global]</div><div class="line">fsid = 99480db2-f92f-481f-b958-c03c261918c6</div><div class="line">mon_initial_members = node1, node2, node3</div><div class="line">mon_host = 192.168.1.58,192.168.1.61,192.168.1.62</div><div class="line">auth_cluster_required = none</div><div class="line">auth_service_required = none</div><div class="line">auth_client_required = none</div><div class="line"></div><div class="line">public network = 192.168.1.0/24</div><div class="line">mon clock drift allowed = 2</div><div class="line">mon clock drift warn backoff = 30</div><div class="line">[root@node3 ceph]# systemctl restart ceph-mon</div><div class="line">ceph-mon@               ceph-mon@node3.service  ceph-mon.target         </div><div class="line">[root@node3 ceph]# systemctl restart ceph-mon</div><div class="line">ceph-mon@               ceph-mon@node3.service  ceph-mon.target         </div><div class="line">[root@node3 ceph]# systemctl restart ceph-mon.target</div><div class="line">[root@node3 ceph]# systemctl restart ceph-osd.target</div><div class="line"># 更改单个节点配置后依然不可以访问集群</div><div class="line">[root@node3 ceph]# ceph -s</div><div class="line">2017-11-27 23:05:23.022571 7f5200c2f700  0 librados: client.admin authentication error (95) Operation not supported</div><div class="line">[errno 95] error connecting to the cluster</div><div class="line"># 相应的更改其他几个节点并重启，便又可以正常访问集群了</div><div class="line">[root@node3 ceph]# ceph -s</div><div class="line">  cluster:</div><div class="line">    id:     99480db2-f92f-481f-b958-c03c261918c6</div><div class="line">    health: HEALTH_WARN</div><div class="line">    ...</div></pre></td></tr></table></figure><p><strong>结论：</strong></p><blockquote><p>当<code>auth</code>配置为<code>cephx</code>的时候访问集群必须要借助秘钥文件，而当<code>auth</code>配置为<code>none</code>的时候，不再需要秘钥文件就可以访问集群了。（<strong>更改配置需要集群所有节点都做才可以生效，而不是单一节点</strong>）</p></blockquote><h2 id="删除monitor秘钥"><a href="#删除monitor秘钥" class="headerlink" title="删除monitor秘钥"></a>删除monitor秘钥</h2><p><code>/etc/ceph</code>和<code>/var/lib//ceph/mon/ceph-node1</code>各有一个<code>mon keyring</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@node1 ceph-node1]# cd /etc/ceph/</div><div class="line">[root@node1 ceph]# ls</div><div class="line">ceph.bootstrap-mds.keyring  ceph.bootstrap-osd.keyring  ceph.client.admin.keyring  ceph-deploy-ceph.log  rbdmap</div><div class="line">ceph.bootstrap-mgr.keyring  ceph.bootstrap-rgw.keyring  ceph.conf                  ceph.mon.keyring</div><div class="line">[root@node1 ceph]# cd /var/lib/ceph/mon/ceph-node1/</div><div class="line">[root@node1 ceph-node1]# ls</div><div class="line">done  keyring  kv_backend  store.db  systemd</div></pre></td></tr></table></figure></p><p>先删除<code>/etc/ceph/ceph-mon.keyring</code>，还是可以访问集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[root@node1 ceph]# rm ceph.mon.keyring </div><div class="line">rm: remove regular file ‘ceph.mon.keyring’? y</div><div class="line">[root@node1 ceph]# systemctl restart ceph-mon@node1.service </div><div class="line">[root@node1 ceph]# ceph -s</div><div class="line">  cluster:</div><div class="line">    id:     99480db2-f92f-481f-b958-c03c261918c6</div><div class="line">    health: HEALTH_WARN</div><div class="line">            no active mgr</div><div class="line">            Reduced data availability: 281 pgs inactive, 65 pgs down, 58 pgs incomplete</div><div class="line">            Degraded data redundancy: 311/771 objects degraded (40.337%), 439 pgs unclean, 316 pgs degraded, 316 pgs undersized</div><div class="line">            application not enabled on 3 pool(s)</div><div class="line">            clock skew detected on mon.node2</div><div class="line">...</div><div class="line">...</div></pre></td></tr></table></figure><p>再删除<code>/var/lib/ceph/mon/ceph-node1/keyring</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@node1 ceph-node1]# rm keyring </div><div class="line">rm: remove regular file ‘keyring’? y</div><div class="line">[root@node1 ceph-node1]# systemctl restart ceph-mon@node1.service </div><div class="line">[root@node1 ceph-node1]# ceph -s</div></pre></td></tr></table></figure><p>访问集群一直<code>timeount</code>，查看<code>log</code>文件发现<code>Mon</code>初始化失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2017-11-24 00:33:55.812955 7fa16f995e40 -1 auth: error reading file: /var/lib/ceph/mon/ceph-node1/keyring: can&apos;t open /var/lib/ceph/mon/ceph-node1/keyring: (2) No such file or directory</div><div class="line">2017-11-24 00:33:55.812991 7fa16f995e40 -1 mon.node1@-1(probing) e1 unable to load initial keyring /etc/ceph/ceph.mon.node1.keyring,/etc/ceph/ceph.keyring,/etc/ceph/keyring,/etc/ceph/keyring.bin,</div><div class="line">2017-11-24 00:33:55.812999 7fa16f995e40 -1 failed to initialize</div></pre></td></tr></table></figure><p>ok，那我们再试试将<code>/var/lib/ceph/mon/ceph-node1/keyring</code>删除，将<code>etc/ceph/ceph.mon.keyring</code>拷贝回来，这时候意外发生了，居然<code>mon</code>初始化失败</p><p><strong>结论：</strong></p><blockquote><p><code>Monitor</code>启动是需要<code>keyring</code>文件进行秘钥认证的，并且这个文件必须是<code>/var/lib/ceph/mon/ceph-node1/</code>目录下的，<code>/etc/ceph/</code>目录下的<code>ceph.mon.keyring</code>并不起作用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@node1 ceph-node1]# rm keyring </div><div class="line">rm: remove regular file ‘keyring’? y</div><div class="line">[root@node1 ceph]# ls</div><div class="line">ceph.bootstrap-mds.keyring  ceph.bootstrap-osd.keyring  ceph.client.admin.keyring  ceph-deploy-ceph.log  rbdmap</div><div class="line">ceph.bootstrap-mgr.keyring  ceph.bootstrap-rgw.keyring  ceph.conf                  ceph.mon.keyring  </div><div class="line">[root@node1 ceph]# ceph -s</div><div class="line">// timeout</div><div class="line">...</div></pre></td></tr></table></figure><p><code>mon.log</code>中的现象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2017-11-24 00:44:26.534865 7ffaf5117e40 -1 auth: error reading file: /var/lib/ceph/mon/ceph-node1/keyring: can&apos;t open /var/lib/ceph/mon/ceph-node1/keyring: (2) No such file or directory</div><div class="line">2017-11-24 00:44:26.534901 7ffaf5117e40 -1 mon.node1@-1(probing) e1 unable to load initial keyring /etc/ceph/ceph.mon.node1.keyring,/etc/ceph/ceph.keyring,/etc/ceph/keyring,/etc/ceph/keyring.bin,</div><div class="line">2017-11-24 00:44:26.534916 7ffaf5117e40 -1 failed to initialize</div></pre></td></tr></table></figure><p>至此，我们可以得出结论<code>monitor</code>初始化的时候依赖的文件是<code>/var/lib/ceph/mon/ceph-node1/keyring</code>而不是<code>/etc/ceph/ceph.mon.keyring</code></p><h2 id="修改-Mon-keyring"><a href="#修改-Mon-keyring" class="headerlink" title="修改 Mon keyring"></a>修改 Mon keyring</h2><h3 id="原始的-keyring"><a href="#原始的-keyring" class="headerlink" title="原始的 keyring"></a>原始的 keyring</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@node1 ceph-node1]# cat keyring </div><div class="line">[mon.]</div><div class="line">key = AQCo7fdZAAAAABAAQOysx+Yxbno/2N8W1huZFA==</div><div class="line">caps mon = &quot;allow *&quot;</div><div class="line">[root@node1 ceph-node1]# ceph auth get mon.</div><div class="line">exported keyring for mon.</div><div class="line">[mon.]</div><div class="line">key = AQCo7fdZAAAAABAAQOysx+Yxbno/2N8W1huZFA==</div><div class="line">caps mon = &quot;allow *&quot;</div></pre></td></tr></table></figure><h3 id="将中间的五个A替换成了五个C"><a href="#将中间的五个A替换成了五个C" class="headerlink" title="将中间的五个A替换成了五个C"></a>将中间的五个A替换成了五个C</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@node1 ceph-node1]# vim keyring </div><div class="line">[root@node1 ceph-node1]# cat keyring </div><div class="line">[mon.]</div><div class="line">key = AQCo7fdZCCCCCBAAQOysx+Yxbno/2N8W1huZFA==</div><div class="line">caps mon = &quot;allow *&quot;</div></pre></td></tr></table></figure><h3 id="重启查看-Mon-keyring"><a href="#重启查看-Mon-keyring" class="headerlink" title="重启查看 Mon keyring"></a>重启查看 Mon keyring</h3><p>理想结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@node1 ceph-node1]# systemctl restart ceph-mon.target</div><div class="line">[root@node1 ceph-node1]# ceph auth get mon.</div><div class="line">exported keyring for mon.</div><div class="line">[mon.]</div><div class="line">key = AQCo7fdZCCCCCBAAQOysx+Yxbno/2N8W1huZFA==</div><div class="line">caps mon = &quot;allow *&quot;</div></pre></td></tr></table></figure><p>令人疑惑的现实：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">[root@node1 ceph]# ceph auth get mon.</div><div class="line">exported keyring for mon.</div><div class="line">[mon.]</div><div class="line">key = AQCo7fdZAAAAABAAQOysx+Yxbno/2N8W1huZFA==</div><div class="line">caps mon = &quot;allow *&quot;</div><div class="line">[root@node1 ceph]# ceph auth get mon.</div><div class="line">exported keyring for mon.</div><div class="line">[mon.]</div><div class="line">key = AQCo7fdZAAAAABAAQOysx+Yxbno/2N8W1huZFA==</div><div class="line">caps mon = &quot;allow *&quot;</div><div class="line">[root@node1 ceph]# ceph auth get mon.</div><div class="line">exported keyring for mon.</div><div class="line">[mon.]</div><div class="line">key = AQCo7fdZCCCCCBAAQOysx+Yxbno/2N8W1huZFA==</div><div class="line">caps mon = &quot;allow *&quot;</div><div class="line">[root@node1 ceph]# ceph auth get mon.</div><div class="line">exported keyring for mon.</div><div class="line">[mon.]</div><div class="line">key = AQCo7fdZCCCCCBAAQOysx+Yxbno/2N8W1huZFA==</div><div class="line">caps mon = &quot;allow *&quot;</div><div class="line">[root@node1 ceph]# ceph auth get mon.</div><div class="line">exported keyring for mon.</div><div class="line">[mon.]</div><div class="line">key = AQCo7fdZCCCCCBAAQOysx+Yxbno/2N8W1huZFA==</div><div class="line">caps mon = &quot;allow *&quot;</div><div class="line">[root@node1 ceph]# ceph auth get mon.</div><div class="line">exported keyring for mon.</div><div class="line">[mon.]</div><div class="line">key = AQCo7fdZCCCCCBAAQOysx+Yxbno/2N8W1huZFA==</div><div class="line">caps mon = &quot;allow *&quot;</div><div class="line">[root@node1 ceph]# ceph auth get mon.</div><div class="line">exported keyring for mon.</div><div class="line">[mon.]</div><div class="line">key = AQCo7fdZCCCCCBAAQOysx+Yxbno/2N8W1huZFA==</div><div class="line">caps mon = &quot;allow *&quot;</div><div class="line">[root@node1 ceph]# ceph auth get mon.</div><div class="line">exported keyring for mon.</div><div class="line">[mon.]</div><div class="line">key = AQCo7fdZCCCCCBAAQOysx+Yxbno/2N8W1huZFA==</div><div class="line">caps mon = &quot;allow *&quot;</div><div class="line">[root@node1 ceph]# ceph auth get mon.</div><div class="line">exported keyring for mon.</div><div class="line">[mon.]</div><div class="line">key = AQCo7fdZCCCCCBAAQOysx+Yxbno/2N8W1huZFA==</div><div class="line">caps mon = &quot;allow *&quot;</div><div class="line">[root@node1 ceph]# ceph auth get mon.</div><div class="line">exported keyring for mon.</div><div class="line">[mon.]</div><div class="line">key = AQCo7fdZAAAAABAAQOysx+Yxbno/2N8W1huZFA==</div><div class="line">caps mon = &quot;allow *&quot;</div></pre></td></tr></table></figure><p>可以看到一会是修改之前的<code>keyring</code>，一会是修改之后的<code>keyring</code>，那遇到这种问题，我们就通过<code>log</code>观察如何获取<code>keyring</code>的</p><p><code>node1</code>的<code>mon.log</code>中日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">2017-11-24 09:30:08.697047 7f9b73e09700  0 mon.node1@0(leader) e1 handle_command mon_command(&#123;&quot;prefix&quot;: &quot;auth get&quot;, &quot;entity&quot;: &quot;mon.&quot;&#125; v 0) v1</div><div class="line">2017-11-24 09:30:08.697106 7f9b73e09700  0 log_channel(audit) log [INF] : from=&apos;client.? 192.168.1.58:0/1169357136&apos; entity=&apos;client.admin&apos; cmd=[&#123;&quot;prefix&quot;: &quot;auth get&quot;, &quot;entity&quot;: &quot;mon.&quot;&#125;]: dispatch</div><div class="line">2017-11-24 09:30:10.020571 7f9b73e09700  0 mon.node1@0(leader) e1 handle_command mon_command(&#123;&quot;prefix&quot;: &quot;auth get&quot;, &quot;entity&quot;: &quot;mon.&quot;&#125; v 0) v1</div><div class="line">2017-11-24 09:30:10.020641 7f9b73e09700  0 log_channel(audit) log [INF] : from=&apos;client.? 192.168.1.58:0/2455152702&apos; entity=&apos;client.admin&apos; cmd=[&#123;&quot;prefix&quot;: &quot;auth get&quot;, &quot;entity&quot;: &quot;mon.&quot;&#125;]: dispatch</div><div class="line">2017-11-24 09:30:11.393391 7f9b73e09700  0 mon.node1@0(leader) e1 handle_command mon_command(&#123;&quot;prefix&quot;: &quot;auth get&quot;, &quot;entity&quot;: &quot;mon.&quot;&#125; v 0) v1</div><div class="line">2017-11-24 09:30:11.393452 7f9b73e09700  0 log_channel(audit) log [INF] : from=&apos;client.? 192.168.1.58:0/1704778092&apos; entity=&apos;client.admin&apos; cmd=[&#123;&quot;prefix&quot;: &quot;auth get&quot;, &quot;entity&quot;: &quot;mon.&quot;&#125;]: dispatch</div><div class="line">2017-11-24 09:30:12.669987 7f9b73e09700  0 mon.node1@0(leader) e1 handle_command mon_command(&#123;&quot;prefix&quot;: &quot;auth get&quot;, &quot;entity&quot;: &quot;mon.&quot;&#125; v 0) v1</div><div class="line">2017-11-24 09:30:12.670049 7f9b73e09700  0 log_channel(audit) log [INF] : from=&apos;client.? 192.168.1.58:0/275069695&apos; entity=&apos;client.admin&apos; cmd=[&#123;&quot;prefix&quot;: &quot;auth get&quot;, &quot;entity&quot;: &quot;mon.&quot;&#125;]: dispatch</div><div class="line">2017-11-24 09:30:14.113077 7f9b73e09700  0 mon.node1@0(leader) e1 handle_command mon_command(&#123;&quot;prefix&quot;: &quot;auth get&quot;, &quot;entity&quot;: &quot;mon.&quot;&#125; v 0) v1</div><div class="line">2017-11-24 09:30:14.113147 7f9b73e09700  0 log_channel(audit) log [INF] : from=&apos;client.? 192.168.1.58:0/3800873459&apos; entity=&apos;client.admin&apos; cmd=[&#123;&quot;prefix&quot;: &quot;auth get&quot;, &quot;entity&quot;: &quot;mon.&quot;&#125;]: dispatch</div><div class="line">2017-11-24 09:30:15.742038 7f9b73e09700  0 mon.node1@0(leader) e1 handle_command mon_command(&#123;&quot;prefix&quot;: &quot;auth get&quot;, &quot;entity&quot;: &quot;mon.&quot;&#125; v 0) v1</div><div class="line">2017-11-24 09:30:15.742106 7f9b73e09700  0 log_channel(audit) log [INF] : from=&apos;client.? 192.168.1.58:0/1908944728&apos; entity=&apos;client.admin&apos; cmd=[&#123;&quot;prefix&quot;: &quot;auth get&quot;, &quot;entity&quot;: &quot;mon.&quot;&#125;]: dispatch</div><div class="line">2017-11-24 09:30:17.629681 7f9b73e09700  0 mon.node1@0(leader) e1 handle_command mon_command(&#123;&quot;prefix&quot;: &quot;auth get&quot;, &quot;entity&quot;: &quot;mon.&quot;&#125; v 0) v1</div><div class="line">2017-11-24 09:30:17.629729 7f9b73e09700  0 log_channel(audit) log [INF] : from=&apos;client.? 192.168.1.58:0/2193002591&apos; entity=&apos;client.admin&apos; cmd=[&#123;&quot;prefix&quot;: &quot;auth get&quot;, &quot;entity&quot;: &quot;mon.&quot;&#125;]: dispatch</div></pre></td></tr></table></figure><p><code>node2</code>的<code>mon.log</code>中日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">2017-11-24 09:29:23.799402 7fdb3c0ae700  0 log_channel(audit) log [INF] : from=&apos;client.? 192.168.1.58:0/4284881078&apos; entity=&apos;client.admin&apos; cmd=[&#123;&quot;prefix&quot;: &quot;auth get&quot;, &quot;entity&quot;: &quot;mon.&quot;&#125;]: dispatch</div><div class="line">2017-11-24 09:29:26.030516 7fdb3c0ae700  0 mon.node2@1(peon) e1 handle_command mon_command(&#123;&quot;prefix&quot;: &quot;auth get&quot;, &quot;entity&quot;: &quot;mon.&quot;&#125; v 0) v1</div><div class="line">2017-11-24 09:29:26.030588 7fdb3c0ae700  0 log_channel(audit) log [INF] : from=&apos;client.? 192.168.1.58:0/4157525590&apos; entity=&apos;client.admin&apos; cmd=[&#123;&quot;prefix&quot;: &quot;auth get&quot;, &quot;entity&quot;: &quot;mon.&quot;&#125;]: dispatch</div><div class="line">2017-11-24 09:29:38.637677 7fdb3c0ae700  0 mon.node2@1(peon) e1 handle_command mon_command(&#123;&quot;prefix&quot;: &quot;auth get&quot;, &quot;entity&quot;: &quot;mon.&quot;&#125; v 0) v1</div><div class="line">2017-11-24 09:29:38.637748 7fdb3c0ae700  0 log_channel(audit) log [INF] : from=&apos;client.? 192.168.1.58:0/4028820259&apos; entity=&apos;client.admin&apos; cmd=[&#123;&quot;prefix&quot;: &quot;auth get&quot;, &quot;entity&quot;: &quot;mon.&quot;&#125;]: dispatch</div></pre></td></tr></table></figure><p><strong>结论：</strong></p><ul><li><code>Monitor</code>的秘钥哪怕被修改过了，也不会影响<code>Monitor</code>的启动，也就是说<code>Monitor</code>启动时只要存在秘钥文件就好，内容忽略并不重要</li><li><code>Monitor</code>启动的时候读取秘钥文件是随机的，并不一定是当前节点的，具体选择机制需要后期去看源代码了</li></ul><h2 id="修改OSD-keyring和修复"><a href="#修改OSD-keyring和修复" class="headerlink" title="修改OSD keyring和修复"></a>修改OSD keyring和修复</h2><p><code>OSD</code>启动的时候需要秘钥才可以登录集群，这个秘钥会存在<code>Monitor</code>的数据库中，所以登录的时候就会拿本地的<code>keyring</code>和存在<code>Monitor</code>中的<code>keyring</code>相匹配，正确的话才可以启动成功。</p><p>下面我们将本地的<code>OSD keyring</code>故意改错，然后重启<code>OSD</code>查看效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># 更改秘钥文件</div><div class="line">[root@node3 ceph]# cd /var/lib/ceph/osd/ceph-2</div><div class="line">[root@node3 ceph-2]# ls</div><div class="line">activate.monmap  active  block  bluefs  ceph_fsid  fsid  keyring  kv_backend  magic  mkfs_done  ready  systemd  type  whoami</div><div class="line">[root@node3 ceph-2]# cat keyring </div><div class="line">[osd.2]</div><div class="line">key = AQCp8/dZ4BHbHxAA/GXihrjCOB+7kZJfgnSy+Q==</div><div class="line">[root@node3 ceph-2]# vim keyring </div><div class="line">[root@node3 ceph-2]# cat keyring </div><div class="line">[osd.2]</div><div class="line">key = BBBp8/dZ4BHbHxAA/GXihrjCOB+7kZJfgnSy+Q==</div><div class="line">[root@node3 ceph-2]# systemctl restart ceph-osd</div><div class="line">ceph-osd@           ceph-osd@2.service  ceph-osd@5.service  ceph-osd.target     </div><div class="line">[root@node3 ceph-2]# systemctl restart ceph-osd</div><div class="line">ceph-osd@           ceph-osd@2.service  ceph-osd@5.service  ceph-osd.target     </div><div class="line">[root@node3 ceph-2]# systemctl restart ceph-osd@2.service</div><div class="line"># 重启后发现OSD的状态时down</div><div class="line">[root@node3 ceph-2]# ceph osd tree | grep osd.2</div><div class="line"> 2   hdd 0.00980         osd.2    down  1.00000 1.00000</div></pre></td></tr></table></figure><p>查看日志，发现<code>init</code>失败，原因是<code>auth</code>认证出错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2017-11-27 23:52:18.069207 7fae1e8d2d00 -1 auth: error parsing file /var/lib/ceph/osd/ceph-2/keyring</div><div class="line">2017-11-27 23:52:18.069285 7fae1e8d2d00 -1 auth: failed to load /var/lib/ceph/osd/ceph-2/keyring: (5) Input/output error</div><div class="line">...</div><div class="line">2017-11-27 23:52:41.232803 7f58d15ded00 -1  ** ERROR: osd init failed: (5) Input/output error</div></pre></td></tr></table></figure><p>我们可以通过查询<code>Monitor</code>数据库获取正确的<code>keyring</code>，将错误的<code>keyring</code>修正过来再重启<code>OSD</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># 查询Monitor数据库中的osd keyring</div><div class="line">[root@node3 ceph-2]# ceph auth get osd.2</div><div class="line">exported keyring for osd.2</div><div class="line">[osd.2]</div><div class="line">key = AQCp8/dZ4BHbHxAA/GXihrjCOB+7kZJfgnSy+Q==</div><div class="line">caps mgr = &quot;allow profile osd&quot;</div><div class="line">caps mon = &quot;allow profile osd&quot;</div><div class="line">caps osd = &quot;allow *&quot;</div><div class="line"># 修正keyring</div><div class="line">[root@node3 ceph-2]# vim keyring </div><div class="line">[root@node3 ceph-2]# cat keyring </div><div class="line">[osd.2]</div><div class="line">key = AQCp8/dZ4BHbHxAA/GXihrjCOB+7kZJfgnSy+Q==</div><div class="line">[root@node3 ceph-2]# systemctl restart ceph-osd@2.service </div><div class="line"># 重启OSD后可以发现osd.2状态已经变为up</div><div class="line">[root@node3 ceph-2]# ceph osd tree | grep osd.2</div><div class="line"> 2   hdd 0.00980         osd.2      up  1.00000 1.00000</div></pre></td></tr></table></figure><p><strong>结论：</strong></p><blockquote><p><code>OSD</code>启动需要正确的<code>keyring</code>，错误的话则无法启动成功，正确的<code>keyring</code>会被存在<code>Monitor</code>的数据库中</p></blockquote><h2 id="修改Client-keyring和修复"><a href="#修改Client-keyring和修复" class="headerlink" title="修改Client keyring和修复"></a>修改Client keyring和修复</h2><p>之前我们通过删除<code>client keyring</code>验证了当<code>auth=cephx</code>的时候，客户端需要<code>keyring</code>才可以访问集群，那么它是像<code>Monitor</code>一样内容不被<code>care</code>还是和<code>OSD</code>一样需要精确匹配<code>keyring</code>呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># 修改ceph.client.admin.keyring</div><div class="line">[root@node3 ceph-2]# cd /etc/ceph/</div><div class="line">[root@node3 ceph]# ls</div><div class="line">ceph.client.admin.keyring  ceph.conf  ceph-deploy-ceph.log  rbdmap</div><div class="line">[root@node3 ceph]# cat ceph.client.admin.keyring </div><div class="line">[client.admin]</div><div class="line">key = AQDL7fdZWaQkIBAAsFhvFVQYqSeM/FVSY6o8TQ==</div><div class="line">[root@node3 ceph]# vim ceph.client.admin.keyring </div><div class="line">[root@node3 ceph]# cat ceph.client.admin.keyring </div><div class="line">[client.admin]</div><div class="line">key = BBBB7fdZWaQkIBAAsFhvFVQYqSeM/FVSY6o8TQ==</div><div class="line"># 访问集群出错</div><div class="line">[root@node3 ceph]# ceph -s</div><div class="line">2017-11-28 00:06:05.771604 7f3a69ccf700 -1 auth: error parsing file /etc/ceph/ceph.client.admin.keyring</div><div class="line">2017-11-28 00:06:05.771622 7f3a69ccf700 -1 auth: failed to load /etc/ceph/ceph.client.admin.keyring: (5) Input/output error</div><div class="line">2017-11-28 00:06:05.771634 7f3a69ccf700  0 librados: client.admin initialization error (5) Input/output error</div><div class="line">[errno 5] error connecting to the cluster</div></pre></td></tr></table></figure><p>可以看出访问集群需要正确的<code>keyring</code>，这时候如何修复呢？大家应该能够猜到，它和<code>OSD</code>的原理是一样的，正确的<code>keyring</code>也存在与<code>Monitor</code>的数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"># 直接获取client.admin出错</div><div class="line">[root@node3 ceph]# ceph auth get client.admin</div><div class="line">2017-11-28 00:08:19.159073 7fcabb297700 -1 auth: error parsing file /etc/ceph/ceph.client.admin.keyring</div><div class="line">2017-11-28 00:08:19.159079 7fcabb297700 -1 auth: failed to load /etc/ceph/ceph.client.admin.keyring: (5) Input/output error</div><div class="line">2017-11-28 00:08:19.159090 7fcabb297700  0 librados: client.admin initialization error (5) Input/output error</div><div class="line">[errno 5] error connecting to the cluster</div><div class="line"># 需要加上monitor的keyring文件才可以获取client.admin.keyring</div><div class="line">[root@node3 ceph]# ceph auth get client.admin --name mon. --keyring /var/lib/ceph/mon/ceph-node3/keyring</div><div class="line">exported keyring for client.admin</div><div class="line">[client.admin]</div><div class="line">key = AQDL7fdZWaQkIBAAsFhvFVQYqSeM/FVSY6o8TQ==</div><div class="line">caps mds = &quot;allow *&quot;</div><div class="line">caps mgr = &quot;allow *&quot;</div><div class="line">caps mon = &quot;allow *&quot;</div><div class="line">caps osd = &quot;allow *&quot;</div><div class="line"># 修正keyring</div><div class="line">[root@node3 ceph]# vim ceph</div><div class="line">ceph.client.admin.keyring  ceph.conf                  ceph-deploy-ceph.log       </div><div class="line">[root@node3 ceph]# vim ceph.client.admin.keyring </div><div class="line">[root@node3 ceph]# cat ceph.client.admin.keyring </div><div class="line">[client.admin]</div><div class="line">key = AQDL7fdZWaQkIBAAsFhvFVQYqSeM/FVSY6o8TQ==</div><div class="line"># 访问集群成功</div><div class="line">[root@node3 ceph]# ceph -s</div><div class="line">  cluster:</div><div class="line">    id:     99480db2-f92f-481f-b958-c03c261918c6</div><div class="line">    health: HEALTH_WARN</div><div class="line">    ...</div></pre></td></tr></table></figure><p>出现了令人惊奇的一幕，就是上面通过<code>ceph auth</code>获取<code>OSD</code>的<code>keyring</code>可以正常获取，而获取<code>client.admin.keyring</code>却要加上<code>monitor.keyring</code>，原因可以从报错信息看出，<code>ceph auth</code>需要以客户端连接集群为前提。</p><p>结论：</p><blockquote><p><code>Client</code>访问集群和<code>OSD</code>一样，需要正确的<code>keyring</code>与存在<code>Monitor</code>数据库中对应的<code>keyring</code>相匹配，并且当<code>client.admin.keyring</code><br>不正确时，通过<code>ceph auth</code>读取<code>keyring</code>的时候需要加上<code>monitor keyring</code>的选项</p></blockquote><h2 id="Mon-Caps"><a href="#Mon-Caps" class="headerlink" title="Mon Caps"></a>Mon Caps</h2><h3 id="r-权限"><a href="#r-权限" class="headerlink" title="r 权限"></a>r 权限</h3><p><code>Monior</code>的<code>r</code>权限就是拥有读权限，对应的读权限都有哪些操作？在这里的读权限其实就是拥有读取<code>Monitor</code>数据库中信息的权限，<code>MON</code>作为集群的状态维护者，其数据库(<code>/var/lib/ceph/mon/ceph-$hostname/store.db</code>)内保存着集群这一系列状态图(<code>Cluster Map</code>)，这些<code>Map</code>包含但不限于：</p><ul><li><code>CRUSH Map</code></li><li><code>OSD Map</code></li><li><code>MON Map</code></li><li><code>MDS Map</code></li><li><code>PG Map</code></li></ul><p>所以接下来我们可以创建一个新的只拥有读权限的用户，进行相关操作验证读权限具体拥有哪些权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">ceph auth get-or-create client.mon_r mon &apos;allow r&apos; &gt;&gt; /root/key</div><div class="line">[root@node3 ceph]# ceph auth get client.mon_r</div><div class="line">exported keyring for client.mon_r</div><div class="line">[client.mon_r]</div><div class="line">key = AQABvRxaBS6BBhAAz9uwjYCT4xKavJhobIK3ig==</div><div class="line">caps mon = &quot;allow r&quot;</div><div class="line"></div><div class="line">ceph --name client.mon_r --keyring /root/key -s      // ok</div><div class="line"></div><div class="line">ceph --name client.mon_r --keyring /root/key osd crush dump     // ok</div><div class="line">ceph --name client.mon_r --keyring /root/key osd getcrushmap -o crushmap.map        // ok</div><div class="line"></div><div class="line">ceph --name client.mon_r --keyring /root/key osd dump       // ok</div><div class="line">ceph --name client.mon_r --keyring /root/key osd tree       // ok</div><div class="line">ceph --name client.mon_r --keyring /root/key osd stat       // ok</div><div class="line"></div><div class="line">ceph --name client.mon_r --keyring /root/key pg dump        // ok</div><div class="line">ceph --name client.mon_r --keyring /root/key pg stat        // ok</div></pre></td></tr></table></figure><p>尝试了下两个写操作，都显示报错权限拒绝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@node3 ceph]# rados --name client.mon_r --keyring /root/key -p testpool put crush crushmap.map</div><div class="line">error putting testpool/crush: (1) Operation not permitted</div><div class="line"></div><div class="line">[root@node3 ceph]# ceph --name client.mon_r --keyring /root/key osd out osd.0</div><div class="line">Error EACCES: access denied</div></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>虽然上面有<code>osd</code>和<code>pg</code>等信息，但是这些都隶属于<code>crush map</code>的范畴中，所以这些状态数据都是从<code>Monitor</code>获取的</p><p><strong>结论：</strong></p><blockquote><p><code>Monitor</code>的读权限对应的是从<code>Monitor</code>数据库获取一系列的<code>Map</code>信息，具体的上面也都讲的很详细了，并且该权限只能读取状态信息，不能获取具体数据信息，且不能进行<code>OSD</code>等守护进程写操作</p></blockquote><h3 id="w-权限"><a href="#w-权限" class="headerlink" title="w 权限"></a>w 权限</h3><p><code>w</code>权限必须配合<code>r</code>权限才会有效果，否则，单独<code>w</code>权限执行指令时，是会一直<code>access denied</code>的。所以我们在测试<code>w</code>权限时，需要附加上<code>r</code>权限才行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph auth get-or-create client.mon_rw mon &apos;allow rw&apos; &gt;&gt; /root/key</div></pre></td></tr></table></figure><p>而<code>w</code>权限就可以做一些对组件的非读操作了，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># 踢出OSD</div><div class="line">ceph osd out</div><div class="line"># 删除OSD</div><div class="line">ceph osd rm </div><div class="line"># 修复PG</div><div class="line">ceph pg repair</div><div class="line"># 替换CRUSH</div><div class="line">ceph osd setcrushmap</div><div class="line"># 删除MON</div><div class="line">ceph mon rm</div><div class="line">...</div><div class="line"># 还有很多操作，就不一一赘述</div></pre></td></tr></table></figure><p><strong>结论：</strong></p><blockquote><p><code>Mon</code>的<code>r</code>权限可以读取集群各个组件的状态，但是不能修改状态，而<code>w</code>权限是可以做到的</p></blockquote><p><strong>注意：</strong></p><blockquote><p>这里的<code>w</code>权限能做到的写权限也只是修改组件的状态，但是并不包括对集群对象的读写权限，因为这些组件状态信息是存在<code>Mon</code>，而对象信息是存在<code>OSD</code>里面的，而这里的<code>w</code>权限也只是<code>Mon</code>的写权限，所以也很好理解了。</p></blockquote><h3 id="x-权限"><a href="#x-权限" class="headerlink" title="x 权限"></a>x 权限</h3><p><code>MON</code>的<code>x</code>权限很局限，因为这个权限仅仅和<code>auth</code>相关，比如<code>ceph auth list</code>，<code>ceph auth get</code> 之类的指令，和<code>w</code>权限类似，<code>x</code>权限也需要<code>r</code>权限组合在一起才能有效力：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># 用上面创建拥有rw权限的用户访问auth list后auth报错</div><div class="line">[root@node3 ~]# ceph --name client.mon_rw --keyring /root/key auth list</div><div class="line">2017-11-28 21:28:10.620537 7f0d15967700  0 librados: client.mon_rw authentication error (22) Invalid argument</div><div class="line">InvalidArgumentError does not take keyword arguments</div><div class="line"># 创建rw权限的用户访问auth list成功</div><div class="line">[root@node3 ~]# ceph --name client.mon_rx --keyring /root/key auth list</div><div class="line">installed auth entries:</div><div class="line"></div><div class="line">osd.0</div><div class="line">key: AQDaTgBav2MgDBAALE1GEEfbQN73xh8V7ISvFA==</div><div class="line">caps: [mgr] allow profile osd</div><div class="line">caps: [mon] allow profile osd</div><div class="line">caps: [osd] allow *</div><div class="line">...</div><div class="line">...</div></pre></td></tr></table></figure><p>这边需要注意的是徐小胖的原文应该是笔误，他是用的<code>client.mon.rw</code>访问的，所以说实践可以发现很多光看发现不了的东西</p><p><strong>结论：</strong></p><blockquote><p><code>x</code>权限也需要和<code>r</code>权限搭配才有效果，该权限只能处理与<code>auth</code>相关的操作</p></blockquote><h3 id="权限"><a href="#权限" class="headerlink" title="* 权限"></a>* 权限</h3><p>这没什么好说的，猜也能猜到了，就是拥有<code>rwx</code>所有权限</p><h2 id="OSD-Caps"><a href="#OSD-Caps" class="headerlink" title="OSD Caps"></a>OSD Caps</h2><p>这一章需要研究一波再发出来</p><h2 id="丢失所有秘钥的再恢复"><a href="#丢失所有秘钥的再恢复" class="headerlink" title="丢失所有秘钥的再恢复"></a>丢失所有秘钥的再恢复</h2><p>如果所有秘钥全部删除，是否真的能恢复？所有秘钥包括</p><ul><li><code>MON</code> ： <code>/var/lib/ceph/mon/ceph-$hostname/keyring</code></li><li><code>OSD</code> ： <code>/var/lib/ceph/osd/ceph-$hostname/keyring</code></li><li><code>Client</code> ：<code>/etc/ceph/ceph.client.admin.keyring</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># 删除 mon keyring</div><div class="line">[root@node1 ceph-node1]# mv keyring /root/</div><div class="line"># 删除 ceph.conf</div><div class="line">[root@node1 ceph-node1]# mv /etc/ceph/ceph.conf /root/</div><div class="line"># 删除 client.admin.keyring</div><div class="line">[root@node1 ceph-node1]# mv /etc/ceph/ceph.client.admin.keyring /root</div><div class="line"># 尝试访问集群报错</div><div class="line">[root@node1 ceph-node1]# ceph -s</div><div class="line">2017-11-29 23:57:14.195467 7f25dc4cc700 -1 Errors while parsing config file!</div><div class="line">2017-11-29 23:57:14.195571 7f25dc4cc700 -1 parse_file: cannot open /etc/ceph/ceph.conf: (2) No such file or directory</div><div class="line">2017-11-29 23:57:14.195579 7f25dc4cc700 -1 parse_file: cannot open ~/.ceph/ceph.conf: (2) No such file or directory</div><div class="line">2017-11-29 23:57:14.195580 7f25dc4cc700 -1 parse_file: cannot open ceph.conf: (2) No such file or directory</div><div class="line">Error initializing cluster client: ObjectNotFound(&apos;error calling conf_read_file&apos;,)</div><div class="line"># 尝试获取auth list报错</div><div class="line">[root@node1 ceph-node1]# ceph auth list</div><div class="line">2017-11-29 23:57:27.037435 7f162c5a7700 -1 Errors while parsing config file!</div><div class="line">2017-11-29 23:57:27.037450 7f162c5a7700 -1 parse_file: cannot open /etc/ceph/ceph.conf: (2) No such file or directory</div><div class="line">2017-11-29 23:57:27.037452 7f162c5a7700 -1 parse_file: cannot open ~/.ceph/ceph.conf: (2) No such file or directory</div><div class="line">2017-11-29 23:57:27.037453 7f162c5a7700 -1 parse_file: cannot open ceph.conf: (2) No such file or directory</div><div class="line">Error initializing cluster client: ObjectNotFound(&apos;error calling conf_read_file&apos;,)</div></pre></td></tr></table></figure><p>ok，下面开始修复：</p><h3 id="伪造-Mon-keyring"><a href="#伪造-Mon-keyring" class="headerlink" title="伪造 Mon keyring"></a>伪造 Mon keyring</h3><p>在<code>ceph</code>中除了<code>mon.</code>用户以外的的账户密码都保存在<code>Mon</code>的数据库<code>leveldb</code>中，但是<code>mon.</code> 用户的信息并没有保存在数据库里，而是在<code>MON</code>启动时读取<code>Mon</code>目录下的<code>keyring</code> 文件得到的，这也是我们之前验证后得到的结论。所以，我们可以随便伪造一个<code>keyring</code>，放到<code>Mon</code> 目录下去。然后同步到各个<code>Mon</code>节点，然后重启三个<code>Mon</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[root@node1 ceph-node1]# cd /var/lib/ceph/mon/ceph-node1/</div><div class="line">[root@node1 ceph-node1]# ls</div><div class="line">done  kv_backend  store.db  systemd</div><div class="line">[root@node1 ceph-node1]# vim keyring</div><div class="line"># 伪造 keyring，可以看到里面还有tony的字样，可以看出明显是伪造的</div><div class="line">[root@node1 ceph-node1]# cat keyring </div><div class="line">[mon.]</div><div class="line">key = AQCtonyZAAAAABAAQOysx+Yxbno/2N8W1huZFA==</div><div class="line">caps mon = &quot;allow *&quot;</div><div class="line"># 重启 mon</div><div class="line">[root@node1 ceph-node1]# service ceph-mon@node1 restart</div><div class="line">Redirecting to /bin/systemctl restart  ceph-mon@node1.service</div></pre></td></tr></table></figure><p>可以看到效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># monitor log显示mon.node1@0初始化成功，并被选举成了monitor leader</div><div class="line">2017-11-30 00:15:04.042157 7f8c4e28a700  0 log_channel(cluster) log [INF] : mon.node1 calling new monitor election</div><div class="line">2017-11-30 00:15:04.042299 7f8c4e28a700  1 mon.node1@0(electing).elector(934) init, last seen epoch 934</div><div class="line">2017-11-30 00:15:04.048498 7f8c4e28a700  0 log_channel(cluster) log [INF] : mon.node1 calling new monitor election</div><div class="line">2017-11-30 00:15:04.048605 7f8c4e28a700  1 mon.node1@0(electing).elector(937) init, last seen epoch 937, mid-election, bumping</div><div class="line">2017-11-30 00:15:04.078454 7f8c4e28a700  0 log_channel(cluster) log [INF] : mon.node1@0 won leader election with quorum 0,1,2</div></pre></td></tr></table></figure><p><strong>注意（很重要）：</strong></p><blockquote><p>虽然说<code>mon</code>在启动的时候读取对应的<code>keyring</code>，不在乎内容的正确性，但是不代表这个<code>keyring</code>可以胡乱修改。也就是说这个<code>keyring</code>是要<strong>符合某种规范和格式的</strong>，在实践过程我发现<code>keyring</code>前三位必须为大写的<code>AQC</code>，当然还有其他的格式要求，比如结尾是否必须要是<code>==</code>？长度是否是固定的？这个格式要求可能很多，我没有时间一个一个手动无脑验证，这个可以日后查看源码了解实现思路，有兴趣的童鞋可以试试，说不定可以发现很有趣的现象。当然说了这么多是否意味着很难伪造呢？这个我们也不必担心，最好的做法是从别的集群的<code>Mon keyring</code>拷贝一份过来就可以了，自己胡乱伪造启动会报错如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2017-11-29 23:49:50.134137 7fcab3e23700 -1 cephx: cephx_build_service_ticket_blob failed with error invalid key</div><div class="line">2017-11-29 23:49:50.134140 7fcab3e23700  0 mon.node1@0(probing) e1 ms_get_authorizer failed to build service ticket</div><div class="line">2017-11-29 23:49:50.134393 7fcab3e23700  0 -- 192.168.1.58:6789/0 &gt;&gt; 192.168.1.61:6789/0 conn(0x7fcacd15d800 :-1 s=STATE_CONNECTING_WAIT_CONNECT_REPLY_AUTH pgs=0 cs=0 l=0).handle_connect_reply connect got BADAUTHORIZER</div></pre></td></tr></table></figure><p>###　还原 ceph.conf</p><p>没有<code>/etc/ceph/ceph.conf</code>这个文件，我们是没法执行<code>ceph</code>相关指令的，所以我们需要尽可能的还原它。首先<code>fsid</code>可以通过去任意<code>osd</code>目录（<code>/var/lib/ceph/osd/ceph-$num/</code>）读取<code>ceph-fsid</code>文件获得，然后<code>mon_initial_members</code>和<code>mon_host</code>代表着集群每个节点的<code>hostname</code>和<code>ip</code>，这些都是我们知道的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"># 还原 ceph.conf</div><div class="line">[root@node1 ceph-node1]# cat /var/lib/ceph/osd/ceph-0/ceph_fsid </div><div class="line">99480db2-f92f-481f-b958-c03c261918c6</div><div class="line">[root@node1 ceph-node1]# vim /etc/ceph/ceph.conf</div><div class="line">[root@node1 ceph-node1]# cat /etc/ceph/ceph.conf</div><div class="line">[global]</div><div class="line">fsid = 99480db2-f92f-481f-b958-c03c261918c6</div><div class="line">mon_initial_members = node1, node2, node3</div><div class="line">mon_host = 192.168.1.58,192.168.1.61,192.168.1.62</div><div class="line">auth_cluster_required = cephx</div><div class="line">auth_service_required = cephx</div><div class="line">auth_client_required = cephx</div><div class="line"></div><div class="line">public network = 192.168.1.0/24</div><div class="line"></div><div class="line"># 通过 mon keyring 访问集群状态成功</div><div class="line">[root@node1 ceph-node1]# ceph -s --name mon. --keyring /var/lib/ceph/mon/ceph-node1/keyring</div><div class="line">  cluster:</div><div class="line">    id:     99480db2-f92f-481f-b958-c03c261918c6</div><div class="line">    health: HEALTH_OK</div><div class="line"> </div><div class="line">  services:</div><div class="line">    mon: 3 daemons, quorum node1,node2,node3</div><div class="line">    mgr: node1_mgr(active)</div><div class="line">    osd: 6 osds: 6 up, 6 in</div></pre></td></tr></table></figure><h3 id="恢复-ceph-client-keyring"><a href="#恢复-ceph-client-keyring" class="headerlink" title="恢复 ceph.client.keyring"></a>恢复 ceph.client.keyring</h3><p>有了<code>Mon keyring</code>，并且可以执行<code>ceph</code>指令，那么我们就可以通过<code>ceph auth get</code>去<code>Monitor leveldb</code>获取任意<code>keyring</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"># 通过 Mon 获取 client.admin.keyring</div><div class="line">[root@node1 ceph-node1]# ceph --name mon. --keyring /var/lib/ceph/mon/ceph-node1/keyring auth get client.admin</div><div class="line">exported keyring for client.admin</div><div class="line">[client.admin]</div><div class="line">key = AQDL7fdZWaQkIBAAsFhvFVQYqSeM/FVSY6o8TQ==</div><div class="line">caps mds = &quot;allow *&quot;</div><div class="line">caps mgr = &quot;allow *&quot;</div><div class="line">caps mon = &quot;allow *&quot;</div><div class="line">caps osd = &quot;allow *&quot;</div><div class="line"># 创建 /etc/ceph/ceph.client.admin.keyring，并将上面内容更新到该文件</div><div class="line">[root@node1 ceph-node1]# vim /etc/ceph/ceph.client.admin.keyring</div><div class="line">[root@node1 ceph-node1]# cat /etc/ceph/ceph.client.admin.keyring</div><div class="line">[client.admin]</div><div class="line">key = AQDL7fdZWaQkIBAAsFhvFVQYqSeM/FVSY6o8TQ==</div><div class="line">caps mds = &quot;allow *&quot;</div><div class="line">caps mgr = &quot;allow *&quot;</div><div class="line">caps mon = &quot;allow *&quot;</div><div class="line">caps osd = &quot;allow *&quot;</div><div class="line"></div><div class="line"># 用默认 ceph -s 测试一下，发现可以正常访问了</div><div class="line"></div><div class="line">[root@node1 ceph-node1]# ceph -s</div><div class="line">  cluster:</div><div class="line">    id:     99480db2-f92f-481f-b958-c03c261918c6</div><div class="line">    health: HEALTH_OK</div><div class="line"> </div><div class="line">  services:</div><div class="line">    mon: 3 daemons, quorum node1,node2,node3</div><div class="line">    mgr: node1_mgr(active)</div><div class="line">    osd: 6 osds: 6 up, 6 in</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先感谢徐小胖给我提供了<code>cephx</code>方面的思路，希望日后多出好文，我也在不断地拜读这些优质文章。这篇文章花了我很长时间，大家从日志的时间可以看出来，跨度已经有好几天了，很多实践真的不是一蹴而就的，需要反复的尝试和思考才能得到最后的成功。<code>Ceph</code>还是要多动手，看别人文章是好事，但是记得要加以实践，否则再好的文章也只是想当然，作者说什么你就跟着他的思路走，你永远不知道别人一句简短的话语和结论的背后花了多少时间去推敲和实践，你看起来一条命令执行成功或者在某一步执行某个命令那也许是别人失败了无数次总结出来的。所以我们要自己实践去验证，除了可以验证原文的观点正确与否，往往可以发现一些其他有用的知识。</p><p>经历这次总结，收获满满，我对<code>cephx</code>的理解又上了一个层次。本文就<code>cephx</code>在不同组件中的角色扮演和依赖关系进行梳理，然后再对各组件的<code>cap</code>进行了研究，最后针对各个<code>keyring</code>的恢复给出了详细的指南和步骤。然后还剩两项任务没有完成，等有空进行完善！</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/cephx-600x450.jpg&quot; alt=&quot;cephx&quot;&gt;&lt;/center&gt;

&lt;p&gt;本文就阅读完&lt;a href=&quot;http://www.xuxiaopang.com/2017/08/23/easy-ceph-CephX/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;徐小胖的大话Cephx&lt;/a&gt;后，针对一些猜测和疑惑进行了实战演练，对原文的一些说法和结论进行了验证，并进行了一系列的扩展的思考猜想和总结。最后收获满满，不仅对原文的一些结论进行了验证，也发现了其中的一些问题，更多的是自己动手后一些奇妙的场景和发现。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Cephx" scheme="https://tony-yin.github.io/tags/Cephx/"/>
    
  </entry>
  
  <entry>
    <title>阅读感悟：《Ceph Cookbook》</title>
    <link href="https://tony-yin.github.io/2017/11/26/read-ceph-cookbook/"/>
    <id>https://tony-yin.github.io/2017/11/26/read-ceph-cookbook/</id>
    <published>2017-11-26T14:52:45.000Z</published>
    <updated>2017-11-26T15:55:54.593Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/cookbook-600x450.png" alt="ceph cookbook"></center><p>阅读周期：2017/10/15 ～ 2017/11/26<br>阅读人群：拥有<code>ceph</code>基础知识想进阶的同学<br>阅读评分：4.8</p><p>这本书和之前一本《ceph分布式存储学习指南》是同一个作者：卡兰.辛格。是<code>ceph</code>界最先出版的学习书籍了，对他表示崇高的敬意和感谢。这本书绝不是上一本书的复制品，我觉得我的运气很好，先阅读了上一本然后才看的这一本，没错，在我看来这本书是上一本的进阶版，内容更加饱满和细致。很多方面还是讲解的比较全面的，而不是笼统的说那些道理，基本上每个章节都可以让读者进行实战代码演练。这本书让我对<code>cookbook</code>系列的书籍有着很好的印象。</p><a id="more"></a><h2 id="第1章-Ceph介绍和其他"><a href="#第1章-Ceph介绍和其他" class="headerlink" title="第1章 Ceph介绍和其他"></a>第1章 Ceph介绍和其他</h2><p>第1章没什么好说的，就是传统的介绍和与其他存储做比较。然后第一章还把<code>ceph</code>的部署也插入了进来，估计是不想浪费过多的章节讲解这么基础的 东西吧，嗯，很棒。</p><h2 id="第2章-使用Ceph块存储"><a href="#第2章-使用Ceph块存储" class="headerlink" title="第2章 使用Ceph块存储"></a>第2章 使用Ceph块存储</h2><p>哇，我只想说讲的太全面了，第一本讲解的方式永远是三个存储方式放在一起介绍一下，而这本书是每一个存储方式分了一章。从讲解块设备的创建、映射、调整、快照、克隆到和<code>openstack</code>的集成，面面俱到，为了阐述<code>rbd</code>是<code>openstack</code>的最佳匹配，分别就<code>openstack</code>的<code>glance</code>、<code>cinder</code>和<code>nova</code>讲解了详细的对接挂载方式，过程是可以自己实操的。</p><h2 id="第3章-使用Ceph对象存储"><a href="#第3章-使用Ceph对象存储" class="headerlink" title="第3章 使用Ceph对象存储"></a>第3章 使用Ceph对象存储</h2><p>这一章除了讲解老一套的<code>rados</code>网关配置与<code>S3</code>和<code>Swift</code>对接之外，还讲了<code>rados</code>网关和<code>openstack keystone</code>的集成。最大的特色是讲解了<code>radosgw</code>多区域网关配置和测试，无限逼近线上大规模生产环境的场景。最后就<code>RGW</code>创建文件同步和共享服务进行了介绍，干货多多。</p><h2 id="第4章-使用Ceph文件系统"><a href="#第4章-使用Ceph文件系统" class="headerlink" title="第4章 使用Ceph文件系统"></a>第4章 使用Ceph文件系统</h2><p>借着<code>cephfs</code>介绍了<code>mds</code>一番，然后讲解了多种访问<code>cephfs</code>的方式，然后就是熟悉的将<code>cephfs</code>导出为<code>nfs</code>，这算是很常见的场景了，但是据我所知目前<code>ceph</code>版本的<code>cephfs</code>的性能堪忧，以至于用的比较多的还是<code>rbd</code>，希望<code>ceph</code>可以在之后的版本中将<code>cephfs</code>做的越开越好。最后介绍了<code>ceph-dokan</code>的<code>cephfs</code>的<code>windows</code>客户端，很牛逼，还在持续迭代中。还介绍了如何使得<code>cephfs</code>替换<code>hdfs</code>，这个我之前在<code>ceph</code>线下沙龙南京站听那位中兴的工程师讲的<code>cephfs</code>和<code>hadoop</code>的恋爱史印象非常深刻，讲的蛮好的。</p><h2 id="第5章-用Calamari监控Ceph集群"><a href="#第5章-用Calamari监控Ceph集群" class="headerlink" title="第5章 用Calamari监控Ceph集群"></a>第5章 用Calamari监控Ceph集群</h2><p>先科普了一下各大监控命令和手段，然后介绍了<code>Calamari</code>这个工具的编译和搭建，这个工具主要就是一个<code>dashboard</code>，并不是那种能在<code>UI</code>上操作和管理集群的工具，并且已经很久没再更新了，用于生产环境的请注意，自己玩玩倒是还可以。</p><h2 id="第6章-操作和管理Ceph集群"><a href="#第6章-操作和管理Ceph集群" class="headerlink" title="第6章 操作和管理Ceph集群"></a>第6章 操作和管理Ceph集群</h2><p>先是介绍了两种方式管理各种守护进程和服务。然后讲解了横向扩展和纵向扩展。最后介绍了集群的升级。</p><h2 id="第7章-深入Ceph"><a href="#第7章-深入Ceph" class="headerlink" title="第7章 深入Ceph"></a>第7章 深入Ceph</h2><p>这一章蛮重要的，首先讲解了<code>crush</code>的机制和算法，然后介绍了<code>ceph</code>的身份验证，也就是<code>cephx</code>，最后结合<code>crush</code>和<code>pg</code>创建了定制化的<code>osd</code>和<code>pool</code>。</p><h2 id="第8章-Ceph生产计划和性能优化"><a href="#第8章-Ceph生产计划和性能优化" class="headerlink" title="第8章 Ceph生产计划和性能优化"></a>第8章 Ceph生产计划和性能优化</h2><p>这本书在讲解这一部分明显要比上本书要全面的多，分别针对操作系统、<code>osd</code>、<code>filestore</code>、<code>cilent</code>等性能优化给出参数配置建议。然后介绍了纠删码的各种插件，配了结构图很好理解，最后还是缓存分层，做了测试，更能清楚了了解分层的原理。</p><h2 id="第9章-Ceph虚拟存储管理器（VSM）"><a href="#第9章-Ceph虚拟存储管理器（VSM）" class="headerlink" title="第9章 Ceph虚拟存储管理器（VSM）"></a>第9章 Ceph虚拟存储管理器（VSM）</h2><p>这个工具就要比上面提到的<code>calamari</code>之类的工具要强得多了，不仅有<code>dashboard</code>可以监控集群，还可以操作和管理集群，还有牛逼的是升级<code>ceph</code>方面，你也只需要修改配置要升级版本的网址，便可以实现自动升级，这是<code>intel</code>开发并提供开源的一款产品，值得去尝试一番。</p><h2 id="第10章"><a href="#第10章" class="headerlink" title="第10章"></a>第10章</h2><p>同样的基准测试，不一样的味道。这一章提供了<code>n</code>多种的方式。有<code>dd</code>，有<code>rados bench</code>，有<code>rados load-gen</code>，<code>rdb bench-write</code>和<code>fio</code>等等。从测试网络，池，块设备和模拟负载应有尽有，关键这些都是<code>ceph</code>自带的除了<code>fio</code>。然后介绍了<code>ceph daemon</code>和<code>ceph tell</code>两个高校操作手段，最后介绍了使用<code>Ansible</code>部署<code>Ceph</code>，它可以通过配置文件配置集群信息而搭建集群，也就是说不需要手动的一个一个创建了，这样就显得很高效了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>ceph</code>已经看完两本书了，按理来说不应该再是那种一无所知的小白了，我觉得我缺少的还是大量的实践，所以之后我会对着这两本书照着例子再把代码敲一遍加深印象，然后对<code>ceph</code>应该会有另一番理解吧。接下来的进阶路线应该是中兴出版的《ceph原理和源码分析》了把，这本今年才出版的书我已经入手了，看了第一章，总体觉得还是蛮深入的，大量的源码，需要一定的知识铺垫，正好之后我也有看<code>ceph</code>源码和提供贡献的想法，所以正好那这本书过渡一下，加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/cookbook-600x450.png&quot; alt=&quot;ceph cookbook&quot;&gt;&lt;/center&gt;

&lt;p&gt;阅读周期：2017/10/15 ～ 2017/11/26&lt;br&gt;阅读人群：拥有&lt;code&gt;ceph&lt;/code&gt;基础知识想进阶的同学&lt;br&gt;阅读评分：4.8&lt;/p&gt;
&lt;p&gt;这本书和之前一本《ceph分布式存储学习指南》是同一个作者：卡兰.辛格。是&lt;code&gt;ceph&lt;/code&gt;界最先出版的学习书籍了，对他表示崇高的敬意和感谢。这本书绝不是上一本书的复制品，我觉得我的运气很好，先阅读了上一本然后才看的这一本，没错，在我看来这本书是上一本的进阶版，内容更加饱满和细致。很多方面还是讲解的比较全面的，而不是笼统的说那些道理，基本上每个章节都可以让读者进行实战代码演练。这本书让我对&lt;code&gt;cookbook&lt;/code&gt;系列的书籍有着很好的印象。&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
  </entry>
  
  <entry>
    <title>阅读感悟：《Ceph分布式存储学习指南》</title>
    <link href="https://tony-yin.github.io/2017/11/26/read-ceph-guide/"/>
    <id>https://tony-yin.github.io/2017/11/26/read-ceph-guide/</id>
    <published>2017-11-26T14:50:08.000Z</published>
    <updated>2017-11-26T15:55:04.969Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/book-rocket-600x450.png" alt="ceph guide"></center><p>阅读周期：2017/9/5 ～ 2017/10/7<br>阅读人群：入门ceph的研发或者运维<br>阅读评分：4.7</p><p>这本书不到两百页，但是也讲解了<code>ceph</code>的方方面面。对于入门<code>ceph</code>来说，看官网文档是必要的，但是很多时候官方文档太基础，太零散了，而这样一本书籍就可以弥补这样的缺陷，它把所有组件进行总结和概括，并且进行了实战例子的演示。</p><a id="more"></a><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul><li>第1章 Ceph存储介绍</li><li>第2章 Ceph实战部署</li><li>第3章 Ceph架构和组件</li><li>第4章 Ceph内部构件</li><li>第5章 Ceph部署</li><li>第6章 Ceph存储配置</li><li>第7章 Ceph操作及管理</li><li>第8章 监控Ceph集群</li><li>第9章 Ceph与Openstack的集成</li><li>第10章 Ceph性能调优和基准测试</li></ul><h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><h3 id="第1章"><a href="#第1章" class="headerlink" title="第1章"></a>第1章</h3><p>第1章主要介绍了一下<code>ceph</code>的特点和历史发展，通过与<code>raid</code>，其他存储相比较得出自身的优势和特色，然后着眼于未来的一些设计和解决方案。最后针对<code>ceph</code>三大存储接口：块存储、文件系统存储和对象存储进行了介绍。</p><h3 id="第2章"><a href="#第2章" class="headerlink" title="第2章"></a>第2章</h3><p>这一章其实就是利用<code>ceph-deploy</code>手动搭建集群的一个演示，后续章节还会有相应的补充</p><h3 id="第3章"><a href="#第3章" class="headerlink" title="第3章"></a>第3章</h3><p>第3章重点讲解了<code>ceph</code>的几大组件，<code>rados</code>存储网关，<code>osd</code> 讲的比较多，也是应该的，毕竟是存储的核心，首先对比了目前主流三个文件系统的优劣，然后对日志进行了科普，顺带讲解了一下不推荐在<code>ceph</code>集群中采用<code>raid</code>的原因。之后就是一些<code>osd</code>，<code>monitor</code>和<code>mds</code>的基础命令了。</p><h3 id="第4章"><a href="#第4章" class="headerlink" title="第4章"></a>第4章</h3><p>如果说上一章主要讲的是<code>osd</code>，<code>monitor</code>，<code>mds</code>的话，那么这一章很符合标题内部构件，对应讲解的是<code>pg</code>，<code>crush</code>，对象和<code>pool</code>。<code>pg</code>是对象的载体，<code>pg</code>的状态往往决定着集群的状态，徐小胖有一篇文章叫大话<code>pg</code>讲的挺简单明了的，其实写一个数据然后查看一下存储目录结构就知道七七八八了。<code>ceph</code>池是存储对象的逻辑分区，用户可以根据自己的需求定制池的类型和规则。比如副本池还是<code>EC</code>池，也可以为<code>pool</code>定制<code>crush rule</code>。</p><h3 id="第5章"><a href="#第5章" class="headerlink" title="第5章"></a>第5章</h3><p>这一章也是部署，跟第2章不同的是这一章不用<code>ceph-deploy</code>工具而采用了手工部署的方式。这样做可能要做的事情多一点，繁琐一些，但是会更灵活一些，因为<code>ceph-deploy</code>这种自动化的工具往往存在局限性，比较适用于测试环境，并不适用于生产环境。往往生产环境需要做很多的定制化的改变。最后还讲解了一些如何进行<code>ceph</code>升级。</p><h3 id="第6章"><a href="#第6章" class="headerlink" title="第6章"></a>第6章</h3><p>这一章干货满满，分别就块设备，文件系统和对象存储进行了讲解，还是挺全面的，建议一边看书一边实践，这些命令还是要多用，否则很快也会忘记。目前<code>rbd</code>还是<code>ceph</code>最稳定的存储方式，相比<code>cephfs</code>而言他的性能、稳定和快照复制等功能都做的很全面了。<code>cephfs</code>虽然越来越被更多的应用内嵌，但是还是不能应用与生产环境之上。最后介绍了一下<code>rados</code>网关配置分别和<code>s3</code>，<code>swift</code>对接的流程。</p><h3 id="第7章"><a href="#第7章" class="headerlink" title="第7章"></a>第7章</h3><p>这一章主要介绍了如何运行和管理集群里面的守护进程和相关服务。然后就集群扩容和所容等扩展操作进行了讲解。最后重点讲解了如何管理<code>crushmap</code>，通过配置确定集群存储的结构，定制<code>pool</code>的规则等等。</p><h3 id="第8章"><a href="#第8章" class="headerlink" title="第8章"></a>第8章</h3><p>这一章对应标题讲解了一系列的监控命令，有<code>osd</code>，有<code>pg</code>，还有<code>mon</code>等等。最后引入了一些开源的监控软件，比如<code>kraken</code>，<code>ceph-dash</code>和<code>Calamari</code>，讲的比较简洁，想要具体了解还需要自己动手去搭建，不过貌似有一些已经长时间不维护了，建议动手前看一下。</p><h3 id="第9章"><a href="#第9章" class="headerlink" title="第9章"></a>第9章</h3><p>这一章主要讲<code>ceph</code>和<code>openstack</code>的完美集成，不过讲的也很简洁，其实就是了解歌大概情况，我觉得这对刚入门的小白来说挺好的，讲得太细也没什么用，反而云里雾里的，其实这本书对我最大的帮助就是了解了存储和<code>ceph</code>大概是个什么情况，然后知道了一些命令的用法和应用场景。第一遍熟悉一下就可以了，然后之后可以在深入，否则第一次接触就搞<code>openstack</code>这种高级玩意估计吃不消呢。</p><h3 id="第10章"><a href="#第10章" class="headerlink" title="第10章"></a>第10章</h3><p>最后一章先分别对软件和硬件的性能调优提出了建议，这个东西我觉得还是得到生产环境中不断尝试，虚拟机的话没有任何参考建议。然后集群优化分别介绍了<code>osd</code>，<code>filestore</code>和客户端的相关参数，这个我们可以熟悉一下，自己没事动手改改，看看效果。然后针对<code>ec</code>和缓存分层进行了一些介绍，也是局限于基本够用的层面上。最后介绍了<code>rados bench</code>这个基准测试工具。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这本书专为入门而生，就是在官网文档的基础之上进行规整和总结，如果看不下去官网文档的可以尝试这个，书很薄，很快就可以看完了，看完大概就对<code>ceph</code>没那么陌生了，还是一个比较不错的入门书籍。如果已经了解<code>ceph</code>一段时间的朋友我就不是很推荐了。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/book-rocket-600x450.png&quot; alt=&quot;ceph guide&quot;&gt;&lt;/center&gt;

&lt;p&gt;阅读周期：2017/9/5 ～ 2017/10/7&lt;br&gt;阅读人群：入门ceph的研发或者运维&lt;br&gt;阅读评分：4.7&lt;/p&gt;
&lt;p&gt;这本书不到两百页，但是也讲解了&lt;code&gt;ceph&lt;/code&gt;的方方面面。对于入门&lt;code&gt;ceph&lt;/code&gt;来说，看官网文档是必要的，但是很多时候官方文档太基础，太零散了，而这样一本书籍就可以弥补这样的缺陷，它把所有组件进行总结和概括，并且进行了实战例子的演示。&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
  </entry>
  
  <entry>
    <title>阅读感悟：《Python编程快速上手---让繁琐工作自动化》</title>
    <link href="https://tony-yin.github.io/2017/11/26/read-python-automation/"/>
    <id>https://tony-yin.github.io/2017/11/26/read-python-automation/</id>
    <published>2017-11-26T14:45:48.000Z</published>
    <updated>2017-11-26T15:54:05.204Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/python-automation-600x450.jpg" alt="python automation"></center><blockquote><p>阅读感悟这个系列是针对每次阅读一本书后，先对全本书内容进行整体的总结和评价，然后针对每一章节进行具体分析，分享一下自己从中的收获，这样不但可以在看完整本书后对全书有个完整的加深回顾，还可以对没有阅读过本书的人提供经验和建议或者跟同样阅读过的伙伴相互交流，交换感悟和经验。</p></blockquote><ul><li>阅读周期：2017/7/15 ～ 2017/10/7</li><li>阅读人群：无语言基础的小白，有其他语言基础让入门<code>python</code>的，熟练<code>python</code>想深入学习的请勿下手</li><li>阅读评分：4.7</li></ul><a id="more"></a><p>大家都知道其实一本书可能并不是很贵，一般都是几十元，就算是本烂书对大家的经济损失来说其实并不是很严重，最关键的就是时间了，在这个压力山大和节奏飞快的时代，时间无疑是最宝贵的，所以很多时候我买书之前都会很仔细的看下评论，我个人是比较喜欢买书的，一般会选择在亚马逊上面购买，对比京东而言的话我觉得他的优惠策略更加直接，不需要抢什么券什么的，还有他的物流非常快，最多隔天就到了，包装也很精致，很少出现盗版书这种情况，最后也是最重要的是相比京东而言亚马逊书籍评论更加贴切一些，往往京东一本书下面会有上千条评论，你很少会看到负面的评价，而亚马逊就不一样了，一般评论的都是骨灰级读者了，一旦评论都是很认真并且很全面的，所以也很难得在亚马逊上面看到全五星的书籍。</p><p>这本书是我入门<code>python</code>的第一本书，在此之前我有<code>C</code>，<code>Java</code>和<code>PHP</code>的语言经验。无论是在阅读这本书的过程中还是看完了之后，我都有一种庆幸感，那就是我当初选择这本书真的没错。在阅读前三章的时候，我一度觉得这本书太浅了，这主要可能因为我有其他语言基础，而这本书面对的读者不仅仅有语言基础的，而他这么做对那种小白来说就非常<code>nice</code>了。</p><p>这本书给我最深的印象可以概括为四个字：深入浅出。就是在讲的很细致的同时，同时也会配有一些深入的内容。全本书的最大特色莫过于插图和<code>demo</code>了。一般的书一般是以代码围绕着讲解，而这本书的话往往是通过一些小项目或者小例子讲解一些概念和用法。第一部分主要讲解了语言的基础概念和<code>python</code>重要的数据结构：列表和字典。第二部分主要讲解了自动化知识，就比较深入了，具体比如正则表达式、对文件的操作、调试技巧、获取<code>web</code>信息、处理<code>excel</code>文件、处理<code>pdf</code>和<code>word</code>文档、处理<code>CSV</code>文件和<code>JSON</code>数据、计划任务、邮件和短信、操作图像和操作鼠标和键盘。掌握了列表、字典和字符串这些数据结构就可以进行基础的<code>python</code>编程了，然后学习了正则表达式和文件操作后，就可以很轻松了写一些自动化脚本了。从<code>web</code>抓取信息这一章是专门为喜爱爬虫的小伙伴准备的，提供了很多有用的工具和手段。之后还有对各种类型文件的操作，操作图像这一章我也很喜欢，准备之后做一个小项目，因为我个人对好看的图片很有兴趣。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul><li>第一部分 Python编程基础<ul><li>第1章 python基础</li><li>第2章 控制流</li><li>第3章 函数</li><li>第4章 列表</li><li>第5章 字典和结构化数据</li><li>第6章 字符串操作</li></ul></li><li>第二部分<ul><li>第7章 模式匹配与正则表达式</li><li>第8章 读写文件</li><li>第9章 组织文件</li><li>第10章 调试</li><li>第11章 从Web抓取信息</li><li>第12章 处理Excel电子表格</li><li>第13章 处理PDF和Word文档</li><li>第14章 处理CSV文件和JSON数据</li><li>第15章 保持时间、计划任务和启动程序</li><li>第16章 发送电子邮件和短信</li><li>第17章 操作图像</li><li>第18章 用GUI自动化控制键盘和鼠标</li></ul></li></ul><h2 id="章节分析"><a href="#章节分析" class="headerlink" title="章节分析"></a>章节分析</h2><h3 id="第1章、第2章和第3章"><a href="#第1章、第2章和第3章" class="headerlink" title="第1章、第2章和第3章"></a>第1章、第2章和第3章</h3><p>这3章对我来说没什么好说的，就是一些语言基础，比如字符串拼接啊，控制流啊，函数什么的，对没有语言基础的小伙伴来说非常的贴心和容易理解，老司机的话可以快速阅读或者略过。</p><h3 id="第4章"><a href="#第4章" class="headerlink" title="第4章"></a>第4章</h3><p>列表是<code>python</code>比较有特色的数据结构了，操作起来非常的方便。这一章分别阐述了获取列表、操作列表（merge、copy、delete）、列表循环和多重赋值技巧。然后就是一些深入的操作技巧了，比如排序、插入和删除。最后引入了字符串和元组和列表加以比较，讲解了可变类型、转换类型、传递引用和深拷贝等，总的来说还是很实用。</p><h3 id="第5章、第6章"><a href="#第5章、第6章" class="headerlink" title="第5章、第6章"></a>第5章、第6章</h3><p>首先围绕字典讲解了一些基本的<code>API</code>，然后通过很好的棋盘建模模拟了字典的数据结构，很形象。字符串的话也差不多一样。</p><h3 id="第7章"><a href="#第7章" class="headerlink" title="第7章"></a>第7章</h3><p>相比其他语言的正则来说，我觉得<code>python</code>的正则表达式无论是理解还是使用上面还算是比较简单的。先讲解了单个匹配和全局匹配，然后针对邮件，电话等常见场景给出了例子。</p><h3 id="第8章"><a href="#第8章" class="headerlink" title="第8章"></a>第8章</h3><p>先讲解了<code>os</code>模块很多有用的<code>API</code>，大多数都是跟文件和目录有关，然后讲解了文件的读写操作，其中提到了<code>shelve</code>模块，这个在需要确保文件保密的场景非常有用。最后通过一个小例子讲解了<code>pyperclip</code>模块如何进行剪切板操作。</p><h3 id="第9章"><a href="#第9章" class="headerlink" title="第9章"></a>第9章</h3><p>讲解了通过<code>shutil</code>模块复制文件和文件夹、移动、重命名、永久删除和安全删除。然后讲解了围绕<code>zipfile</code>模块相应的操作。</p><h3 id="第10章"><a href="#第10章" class="headerlink" title="第10章"></a>第10章</h3><p>断言给我的印象比较深，还有<code>python</code>自带的<code>IDLE</code>的调试器的使用，我本人平时基本上是在<code>linux</code>下<code>vim</code>工作，所以这个工具平时也用不到，以后可以在<code>windows</code>下尝试一下。</p><h3 id="第11章"><a href="#第11章" class="headerlink" title="第11章"></a>第11章</h3><p>这一章学习到了很多通过<code>python</code>取获取<code>web</code>信息的手段，这会在爬虫的时候很受用。比如通过<code>webbrowser</code>模块启动浏览器；通过<code>request</code>模块下载网页；通过<code>BeautifulSoup</code>模块解析<code>html</code>，这个模块非常强，简直和<code>js</code>操作<code>html</code>相媲美。</p><h3 id="第12章、第13章、第14章"><a href="#第12章、第13章、第14章" class="headerlink" title="第12章、第13章、第14章"></a>第12章、第13章、第14章</h3><p>这三章分别针对<code>excel</code>、<code>pdf</code>、<code>word</code>、<code>csv</code>和<code>json</code>类型的文件或数据格式进行操作。对<code>excel</code>的支持还蛮强的，但是<code>pdf</code>和<code>word</code>的话就或多或少可能有问题，这个就不赘述了，用到的时候再查就好了。</p><h3 id="第15章、第16章、第18章"><a href="#第15章、第16章、第18章" class="headerlink" title="第15章、第16章、第18章"></a>第15章、第16章、第18章</h3><p>这几章没什么好说的<br>第15章主要讲解了保持时间、计划任务和启动程序等功能<br>第16章主要讲解了消息通知，包括了邮件和短信接口<br>第18章主要讲解了如何通过<code>python</code>控制键盘和鼠标，其中比较有意思的就是控制键盘原生不存在的一些特殊字符</p><h3 id="第17章"><a href="#第17章" class="headerlink" title="第17章"></a>第17章</h3><p><code>python</code>操作图像还是蛮好用的，本章主要讲解了对图片的裁剪，旋转，改变像素等，后续我会做一个小项目，通过<code>python</code>对图片进行一些操作，顺便深入了解一下这部分的知识。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一篇阅读总结感觉写的并不是很好，篇幅虽然还算长，但是感觉内容并不是很饱满，很多地方略显啰嗦。想了一下，之后可以把每一章的具体分析放在平时，每阅读完一章节就可以进行总结了，然后读完全本书就进行一个整体总结就可以了，这样每一章的总结就更加细致了，就不用读完全本书的时候再去回忆，这样效率很低。最后我会在之后有空的情况下分别做一个<code>python</code>的爬虫项目和一个操作图像的项目。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/python-automation-600x450.jpg&quot; alt=&quot;python automation&quot;&gt;&lt;/center&gt;

&lt;blockquote&gt;
&lt;p&gt;阅读感悟这个系列是针对每次阅读一本书后，先对全本书内容进行整体的总结和评价，然后针对每一章节进行具体分析，分享一下自己从中的收获，这样不但可以在看完整本书后对全书有个完整的加深回顾，还可以对没有阅读过本书的人提供经验和建议或者跟同样阅读过的伙伴相互交流，交换感悟和经验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;阅读周期：2017/7/15 ～ 2017/10/7&lt;/li&gt;
&lt;li&gt;阅读人群：无语言基础的小白，有其他语言基础让入门&lt;code&gt;python&lt;/code&gt;的，熟练&lt;code&gt;python&lt;/code&gt;想深入学习的请勿下手&lt;/li&gt;
&lt;li&gt;阅读评分：4.7&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="read" scheme="https://tony-yin.github.io/categories/read/"/>
    
    
      <category term="Read" scheme="https://tony-yin.github.io/tags/Read/"/>
    
      <category term="Python" scheme="https://tony-yin.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>博客主题 shadow</title>
    <link href="https://tony-yin.github.io/2017/11/19/hexo-theme-shadow/"/>
    <id>https://tony-yin.github.io/2017/11/19/hexo-theme-shadow/</id>
    <published>2017-11-19T14:45:52.000Z</published>
    <updated>2017-11-26T15:58:09.824Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/do_blog_600x450.png" alt="blog theme shadow"></center><p>使用了<a href="http://geeksblog.cc/" target="_blank" rel="external">black-blue</a>主题一段时间后，有些地方不符合我个人的审美和习惯，然后自己偶尔改了一些，久而久之还改了不少东西，为了方便存档和以后持续更新，就打造一个自己的专属主题：<a href="https://github.com/tony-yin/hexo-theme-shadow" target="_blank" rel="external">hexo-theme-shadow</a>，大家可以去<a href="http://www.tony-yin.top/" target="_blank" rel="external">我的博客</a>看下实际效果</p><p>如果大家有任何批评和建议，随时可以在<code>github</code>上面提出<code>PR</code>，要是觉得主题还不错的话，欢迎留下你的<code>star</code>哦 ^_^</p><a id="more"></a><p>具体如何配置主题和搭建博客这些基础通用的东西我就不讲了，这边我主要罗列一下我已经更新和以后可能要做的功能点</p><h2 id="已经更新的功能"><a href="#已经更新的功能" class="headerlink" title="已经更新的功能"></a>已经更新的功能</h2><ul><li>添加左侧栏<code>segmentfault</code>小图标</li><li>更新<code>requirejs</code>源为<code>https</code>，避免<code>https</code>网站引入<code>http</code>脚本时浏览器告警</li><li>更新<code>jquery</code>源为<code>https</code>，避免<code>https</code>网站引入<code>http</code>脚本时浏览器告警</li><li>更新<code>baidu</code>分享源到本地，避免<code>https</code>网站引入<code>http</code>脚本时浏览器告警</li><li>更新<code>markdown code</code>的风格，具体参见博客<ul><li>更改了全局的代码颜色样式</li><li>原来项目编号中的代码样式是白色的，很丑陋，也进行了相应的更新</li></ul></li><li>将头像从懒加载改为了直接加载，懒加载头像需要很长时间，用户体验很差</li></ul><h2 id="待更新的功能"><a href="#待更新的功能" class="headerlink" title="待更新的功能"></a>待更新的功能</h2><ul><li>网站背景音乐</li><li>代码块样式修改，每个代码块上面有个蓝色的条条很不好看</li><li>三级、四级和五级标题样式</li><li>链接样式</li><li>评论</li><li>赞和打赏</li></ul><p>如果大家有什么建议或者问题，可以在<code>github</code>上面提<code>issue</code>或者<code>PR</code>，也可以通过邮箱联系到我</p><p><code>github</code>地址： <code>https://github.com/tony-yin/hexo-theme-shadow</code><br>邮箱地址： <code>1241484989@qq.com</code></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/do_blog_600x450.png&quot; alt=&quot;blog theme shadow&quot;&gt;&lt;/center&gt;

&lt;p&gt;使用了&lt;a href=&quot;http://geeksblog.cc/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;black-blue&lt;/a&gt;主题一段时间后，有些地方不符合我个人的审美和习惯，然后自己偶尔改了一些，久而久之还改了不少东西，为了方便存档和以后持续更新，就打造一个自己的专属主题：&lt;a href=&quot;https://github.com/tony-yin/hexo-theme-shadow&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo-theme-shadow&lt;/a&gt;，大家可以去&lt;a href=&quot;http://www.tony-yin.top/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;我的博客&lt;/a&gt;看下实际效果&lt;/p&gt;
&lt;p&gt;如果大家有任何批评和建议，随时可以在&lt;code&gt;github&lt;/code&gt;上面提出&lt;code&gt;PR&lt;/code&gt;，要是觉得主题还不错的话，欢迎留下你的&lt;code&gt;star&lt;/code&gt;哦 ^_^&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="博客" scheme="https://tony-yin.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>LVM动态扩展</title>
    <link href="https://tony-yin.github.io/2017/11/14/LVM-Space-Expansion/"/>
    <id>https://tony-yin.github.io/2017/11/14/LVM-Space-Expansion/</id>
    <published>2017-11-14T02:35:39.000Z</published>
    <updated>2017-11-22T01:38:24.571Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/work-for-love-600x450.png" alt="LVM Space Expansion"></center><p>在平时的开发工作中，经常会创建磁盘不足够大的虚拟机，然后往集群里面写一些数据导致磁盘满了。手动编辑虚拟机的磁盘大小是不会文件系统识别的，大多数同学只能无奈的重新装<code>OS</code>，这里我介绍一种基于<code>LVM</code>实现动态的方式。</p><a id="more"></a><h2 id="LVM了解"><a href="#LVM了解" class="headerlink" title="LVM了解"></a>LVM了解</h2><p><code>LVM</code>是逻辑盘卷管理（<code>LogicalVolumeManager</code>）的简称，它是<code>Linux</code>环境下对磁盘分区进行管理的一种机制，<code>LVM</code>是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。通过LVM系统管理员可以轻松管理磁盘分区，如：将若干个磁盘分区连接为一个整块的卷组（<code>volumegroup</code>），形成一个存储池。管理员可以在卷组上随意创建逻辑卷组（<code>logicalvolumes</code>），并进一步在逻辑卷组上创建文件系统。管理员通过<code>LVM</code>可以方便的调整存储卷组的大小，并且可以对磁盘存储按照组的方式进行命名、管理和分配。</p><h2 id="查看分区"><a href="#查看分区" class="headerlink" title="查看分区"></a>查看分区</h2><p>当前默认只有一个采用<code>lvm</code>的分区，一开始<code>sda</code>磁盘容量为<code>16G</code>，后来发现不够用了，编辑磁盘大小为<code>50G</code>，但是可以发现这<code>50G</code>并没有起到扩展分区容量的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[root@tony-play ~]# df -h</div><div class="line">Filesystem            Size  Used Avail Use% Mounted on</div><div class="line">/dev/mapper/vg_tonyplay-lv_root</div><div class="line">                       14G  3.4G  9.6G  26% /</div><div class="line">tmpfs                 1.9G   72K  1.9G   1% /dev/shm</div><div class="line">/dev/sda1             477M   42M  410M  10% /boot</div><div class="line"></div><div class="line">[root@tony-play ~]# lsblk</div><div class="line">NAME                           MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0                             11:0    1 1024M  0 rom  </div><div class="line">sda                              8:0    0   50G  0 disk </div><div class="line">├─sda1                           8:1    0  500M  0 part /boot</div><div class="line">└─sda2                           8:2    0 15.5G  0 part </div><div class="line">  ├─vg_tonyplay-lv_root (dm-0) 253:0    0 13.9G  0 lvm  /</div><div class="line">  └─vg_tonyplay-lv_swap (dm-1) 253:1    0  1.6G  0 lvm  [SWAP]</div></pre></td></tr></table></figure><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>可以通过新增一块其他磁盘来扩容，我这边采取的是增大当前磁盘的容量实现扩容。</p><p>有时候因为系统设备处于繁忙状态，所以分区需要重启后才会生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">[root@tony-play ~]# fdisk /dev/sda</div><div class="line">WARNING: DOS-compatible mode is deprecated. It&apos;s strongly recommended to</div><div class="line">         switch off the mode (command &apos;c&apos;) and change display units to</div><div class="line">         sectors (command &apos;u&apos;).</div><div class="line">Command (m for help): n</div><div class="line">Command action</div><div class="line">    e   extended</div><div class="line">    p   primary partition (1-4)</div><div class="line">p</div><div class="line">Partition number (1-4): 3</div><div class="line">First cylinder (2089-6527, default 2089):   // 直接回车，用默认值就可以了</div><div class="line">Using default value 2089</div><div class="line">Last cylinder, +cylinders or +size&#123;K,M,G&#125; (2089-6527, default 6527):    // 直接回车，用默认值就可以了</div><div class="line">Using default value 6527</div><div class="line">Command (m for help): w</div><div class="line">The partition table has been altered!</div><div class="line"></div><div class="line"># 可以看到新建的分区sda3已结被创建出来了，采取默认值会将剩余所有空间都分到分区中</div><div class="line">[root@tony-play ~]# lsblk</div><div class="line">NAME                           MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0                             11:0    1 1024M  0 rom  </div><div class="line">sda                              8:0    0   50G  0 disk </div><div class="line">├─sda1                           8:1    0  500M  0 part /boot</div><div class="line">├─sda2                           8:2    0 15.5G  0 part </div><div class="line">│ ├─vg_tonyplay-lv_root (dm-0) 253:0    0 13.9G  0 lvm  /</div><div class="line">│ └─vg_tonyplay-lv_swap (dm-1) 253:1    0  1.6G  0 lvm  [SWAP]</div><div class="line">└─sda3                           8:3    0   34G  0 part</div></pre></td></tr></table></figure><h2 id="查看当前文件系统"><a href="#查看当前文件系统" class="headerlink" title="查看当前文件系统"></a>查看当前文件系统</h2><p>当前文件系统为<code>ext4</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@tony-play ~]# mount</div><div class="line">/dev/mapper/vg_tonyplay-lv_root on / type ext4 (rw)</div><div class="line">proc on /proc type proc (rw)</div><div class="line">sysfs on /sys type sysfs (rw)</div><div class="line">devpts on /dev/pts type devpts (rw,gid=5,mode=620)</div><div class="line">tmpfs on /dev/shm type tmpfs (rw,rootcontext=&quot;system_u:object_r:tmpfs_t:s0&quot;)</div><div class="line">/dev/sda1 on /boot type ext4 (rw)</div><div class="line">none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)</div></pre></td></tr></table></figure><h2 id="为新分区创建文件系统"><a href="#为新分区创建文件系统" class="headerlink" title="为新分区创建文件系统"></a>为新分区创建文件系统</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">[root@tony-play ~]# sudo mkfs.ext4 /dev/sda3</div><div class="line">mke2fs 1.41.12 (17-May-2010)</div><div class="line">Filesystem label=</div><div class="line">OS type: Linux</div><div class="line">Block size=4096 (log=2)</div><div class="line">Fragment size=4096 (log=2)</div><div class="line">Stride=0 blocks, Stripe width=0 blocks</div><div class="line">2228224 inodes, 8912727 blocks</div><div class="line">445636 blocks (5.00%) reserved for the super user</div><div class="line">First data block=0</div><div class="line">Maximum filesystem blocks=4294967296</div><div class="line">272 block groups</div><div class="line">32768 blocks per group, 32768 fragments per group</div><div class="line">8192 inodes per group</div><div class="line">Superblock backups stored on blocks: </div><div class="line">    32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, </div><div class="line">    4096000, 7962624</div><div class="line"></div><div class="line">Writing inode tables: done                            </div><div class="line">Creating journal (32768 blocks): done</div><div class="line">Writing superblocks and filesystem accounting information: done</div><div class="line"></div><div class="line">This filesystem will be automatically checked every 39 mounts or</div><div class="line">180 days, whichever comes first.  Use tune2fs -c or -i to override.</div></pre></td></tr></table></figure><h2 id="查看卷组信息"><a href="#查看卷组信息" class="headerlink" title="查看卷组信息"></a>查看卷组信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[root@tony-play ~]# vgdisplay</div><div class="line">  --- Volume group ---</div><div class="line">  VG Name               vg_tonyplay     // 卷组名在下面扩展中会用到</div><div class="line">  System ID             </div><div class="line">  Format                lvm2</div><div class="line">  Metadata Areas        1</div><div class="line">  Metadata Sequence No  3</div><div class="line">  VG Access             read/write</div><div class="line">  VG Status             resizable</div><div class="line">  MAX LV                0</div><div class="line">  Cur LV                2</div><div class="line">  Open LV               2</div><div class="line">  Max PV                0</div><div class="line">  Cur PV                1</div><div class="line">  Act PV                1</div><div class="line">  VG Size               15.51 GiB</div><div class="line">  PE Size               4.00 MiB</div><div class="line">  Total PE              3970</div><div class="line">  Alloc PE / Size       3970 / 15.51 GiB</div><div class="line">  Free  PE / Size       0 / 0   </div><div class="line">  VG UUID               Y9usSM-nDU5-ZAUd-Y3Te-u5Pd-uFBr-gcYHf0</div></pre></td></tr></table></figure><h2 id="创建新物理卷"><a href="#创建新物理卷" class="headerlink" title="创建新物理卷"></a>创建新物理卷</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@tony-play ~]# pvcreate /dev/sda3</div><div class="line">  Physical volume &quot;/dev/sda3&quot; successfully created</div></pre></td></tr></table></figure><h2 id="扩展到卷组"><a href="#扩展到卷组" class="headerlink" title="扩展到卷组"></a>扩展到卷组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vgextend vg_tonyplay /dev/sda3  // 卷组名在查看卷组信息中</div><div class="line">  Volume group &quot;vg_tonyplay&quot; successfully extended</div></pre></td></tr></table></figure><h2 id="查看逻辑分区"><a href="#查看逻辑分区" class="headerlink" title="查看逻辑分区"></a>查看逻辑分区</h2><p><code>/dev/vg_tonyplay/lv_root</code>就是根分区，也是我们要扩展的分区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">[root@tony-play ~]# lvdisplay </div><div class="line">  --- Logical volume ---</div><div class="line">    LV Path                /dev/vg_tonyplay/lv_root   // 根分区</div><div class="line">    LV Name                lv_root</div><div class="line">    VG Name                vg_tonyplay</div><div class="line">    LV UUID                IPd7lm-Sx8g-pe7k-llNL-j1wc-mbA2-2cAdsy</div><div class="line">    LV Write Access        read/write</div><div class="line">    LV Creation host, time tony-play, 2017-04-10 17:58:53 -0400</div><div class="line">    LV Status              available</div><div class="line">    # open                 1</div><div class="line">    LV Size                13.91 GiB</div><div class="line">    Current LE             3561</div><div class="line">    Segments               1</div><div class="line">    Allocation             inherit</div><div class="line">    Read ahead sectors     auto</div><div class="line">    - currently set to     256</div><div class="line">    Block device           253:0</div><div class="line"></div><div class="line">    --- Logical volume ---</div><div class="line">    LV Path                /dev/vg_tonyplay/lv_swap</div><div class="line">    LV Name                lv_swap</div><div class="line">    VG Name                vg_tonyplay</div><div class="line">    LV UUID                qX637q-iD6i-8blp-hmmS-MvLy-xZ0y-b4D0BF</div><div class="line">    LV Write Access        read/write</div><div class="line">    LV Creation host, time tony-play, 2017-04-10 17:59:07 -0400</div><div class="line">    LV Status              available</div><div class="line">    # open                 1</div><div class="line">    LV Size                1.60 GiB</div><div class="line">    Current LE             409</div><div class="line">    Segments               1</div><div class="line">    Allocation             inherit</div><div class="line">    Read ahead sectors     auto</div><div class="line">    - currently set to     256</div><div class="line">    Block device           253:1</div></pre></td></tr></table></figure><h2 id="扩展容量到逻辑分区"><a href="#扩展容量到逻辑分区" class="headerlink" title="扩展容量到逻辑分区"></a>扩展容量到逻辑分区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@tony-play ~]# lvextend /dev/vg_tonyplay/lv_root /dev/sda3</div><div class="line">  Size of logical volume vg_tonyplay/lv_root changed from 13.91 GiB (3561 extents) to 47.91 GiB (12264 extents).</div><div class="line">  Logical volume lv_root successfully resized</div></pre></td></tr></table></figure><h2 id="刷新逻辑分区容量使扩展生效"><a href="#刷新逻辑分区容量使扩展生效" class="headerlink" title="刷新逻辑分区容量使扩展生效"></a>刷新逻辑分区容量使扩展生效</h2><p><code>ext4</code>用<code>resize2fs</code>，<code>xfs</code>用<code>xfs_growfs</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@tony-play ~]# resize2fs /dev/vg_tonyplay/lv_root</div><div class="line">resize2fs 1.41.12 (17-May-2010)</div><div class="line">Filesystem at /dev/vg_tonyplay/lv_root is mounted on /; on-line resizing required</div><div class="line">old desc_blocks = 1, new_desc_blocks = 3</div><div class="line">Performing an on-line resize of /dev/vg_tonyplay/lv_root to 12558336 (4k) blocks.</div><div class="line">The filesystem on /dev/vg_tonyplay/lv_root is now 12558336 blocks long.</div></pre></td></tr></table></figure><h2 id="查看逻辑分区容量"><a href="#查看逻辑分区容量" class="headerlink" title="查看逻辑分区容量"></a>查看逻辑分区容量</h2><p>可以发现<code>/dev/mapper/vg_tonyplay-lv_root</code>已经从开始的<code>14G</code>扩展到了<code>48G</code>。ok，这就说明大功告成了，再也不用通过重装系统这种蹩脚的方式扩容了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@tony-play ~]# df -h</div><div class="line">Filesystem            Size  Used Avail Use% Mounted on</div><div class="line">/dev/mapper/vg_tonyplay-lv_root</div><div class="line">                       48G  3.4G   42G   8% /</div><div class="line">tmpfs                 1.9G   72K  1.9G   1% /dev/shm</div><div class="line">/dev/sda1             477M   42M  410M  10% /boot</div></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，<code>lvm</code>扩容工作的过程应该是比较清楚了，之后有机会的话我会再补充一下<code>LVM</code>的压缩、删除等操作过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/work-for-love-600x450.png&quot; alt=&quot;LVM Space Expansion&quot;&gt;&lt;/center&gt;

&lt;p&gt;在平时的开发工作中，经常会创建磁盘不足够大的虚拟机，然后往集群里面写一些数据导致磁盘满了。手动编辑虚拟机的磁盘大小是不会文件系统识别的，大多数同学只能无奈的重新装&lt;code&gt;OS&lt;/code&gt;，这里我介绍一种基于&lt;code&gt;LVM&lt;/code&gt;实现动态的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Linux" scheme="https://tony-yin.github.io/tags/Linux/"/>
    
      <category term="LVM" scheme="https://tony-yin.github.io/tags/LVM/"/>
    
  </entry>
  
  <entry>
    <title>Ceph 编译（Giant版本）</title>
    <link href="https://tony-yin.github.io/2017/11/14/Ceph-Compile/"/>
    <id>https://tony-yin.github.io/2017/11/14/Ceph-Compile/</id>
    <published>2017-11-14T01:30:29.000Z</published>
    <updated>2017-11-30T03:09:12.602Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/ceph-600x450.png" alt="Ceph Compile"></center><p>如今入门<code>Ceph</code>的时候，大家一般用<code>ceph-deploy</code>工具比较多，这个工具的确很强大，很方便，对应的也就是很无脑。如果之后想深入<code>Ceph</code>或者想在生产环境中部署<code>Ceph</code>的话，就得熟悉<code>Ceph</code>源码编译了。这对我们熟悉<code>Ceph</code>的<code>feature</code>的变化，<code>component</code>的相互关系以及围绕<code>Ceph</code>各种定制化扩展都大有裨益。本文就笔者<code>Ceph</code>源码编译过程和遇到的问题作出分享，希望有人能够得益于此。</p><a id="more"></a><h2 id="环境声明"><a href="#环境声明" class="headerlink" title="环境声明"></a>环境声明</h2><ul><li>OS： Centos 6.8</li><li>Ceph： Giant</li></ul><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><h3 id="指定-giant-分支"><a href="#指定-giant-分支" class="headerlink" title="指定 giant 分支"></a>指定 giant 分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone -b giant git://github.com/ceph/ceph.git</div></pre></td></tr></table></figure><h3 id="下载子模块"><a href="#下载子模块" class="headerlink" title="下载子模块"></a>下载子模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git submodule update --init --recursive</div></pre></td></tr></table></figure><p>这一步我始终更新不了，尝试了一些办法未果，所以就去直接手动下载了源码，这个问题以后有时间看下</p><h2 id="预检"><a href="#预检" class="headerlink" title="预检"></a>预检</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd ceph </div><div class="line">./autogen.sh </div><div class="line">./configure</div></pre></td></tr></table></figure><h3 id="Autogen"><a href="#Autogen" class="headerlink" title="Autogen"></a>Autogen</h3><p>这一步会频繁的报错一些<code>m4</code>文件没有，这需要我们手动创建这些<code>m4</code>文件夹即可，</p><p>一开始我在<code>ceph</code>根目录创建了<code>m4</code>文件夹，并生成了包括<code>acx_pthread.m4</code>在内的文件，但是还是报错：<code>acx_pthread.m4 not exist</code>，后来发现这时候已经<strong>切换目录</strong>了，不止一个地方需要<code>m4</code>文件夹，一共有这几个地方需要手动创建目录：<code>mkdir m4</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">./src/rocksdb/m4</div><div class="line">./src/gtest/m4</div><div class="line">./src/erasure-code/jerasure/jerasure/m4</div><div class="line">./src/erasure-code/jerasure/gf-complete/m4</div><div class="line">./m4</div></pre></td></tr></table></figure><p>如果还是报错一些文件不存在，并且通过上述方法不能自行初始化生成的话，可以从网上或者已经编译过的<code>ceph</code>环境拷贝过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">报错：umdefined macro</div></pre></td></tr></table></figure><p>下载地址：<a href="https://www.gnu.org/software/autoconf-archive/ax_check_classpath.html#ax_check_classpath" target="_blank" rel="external">https://www.gnu.org/software/autoconf-archive/ax_check_classpath.html#ax_check_classpath</a></p><h3 id="Configure"><a href="#Configure" class="headerlink" title="Configure"></a>Configure</h3><p>这一步是编译过程中可能出错的次数最多的，因为可能会因为你的环境缺少相应的包不断报错。不过数量虽多，解决起来还是比较容易的，就根据报错的缺包对应下载安装就好了，下面我先给出一个所有包的安装步骤，然后再针对每个报错环节给出具体的解决方案</p><h4 id="总体解决方案"><a href="#总体解决方案" class="headerlink" title="总体解决方案"></a>总体解决方案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 1. 通过yum安装所有可以安装的包</div><div class="line">yum install -y yasm libuuid-devel libblkid-devel libudev-devel cryptopp-devel fuse-devel libunwind-devel libedit-devel libatomic_ops-devel snappy-devel leveldb-devel libaio-devel xfsprogs-devel boost*</div><div class="line"></div><div class="line"># 2. 部分yum不能安装的可以通过rpm安装</div><div class="line">wget https://github.com/gperftools/gperftools/releases/download/gperftools-2.2.1/gperftools-2.2.1.tar.gz</div><div class="line">tar -zxvf gperftools-2.2.1.tar.g</div><div class="line">cd gperftools-2.2.1</div><div class="line">./configure</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure><h4 id="具体解决方案"><a href="#具体解决方案" class="headerlink" title="具体解决方案"></a>具体解决方案</h4><p>1.yasm</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yasm command not found</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install yasm -y</div></pre></td></tr></table></figure><p>2.libuuid</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: libuuid not found</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install libuuid-devel -y</div></pre></td></tr></table></figure><p>3.libblkid</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: blkid/blkid.h not found (libblkid-dev, libblkid-devel)</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install libblkid-devel -y</div></pre></td></tr></table></figure><p>4.libudev</p><p>报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: libudev.h not found (libudev-dev, libudev-devel)</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install libudev-devel -y</div></pre></td></tr></table></figure><p>5.crypto</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: no suitable crypto library found</div></pre></td></tr></table></figure><p> 解决：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install cryptopp-devel -y</div></pre></td></tr></table></figure><p> 6.fuse</p><p> 报错：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: no FUSE found (use --without-fuse to disable)</div></pre></td></tr></table></figure><p> 解决：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install fuse-devel -y</div></pre></td></tr></table></figure><p> 7.tcmalloc</p><p> 报错：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: no tcmalloc found (use --without-tcmalloc to disable)</div></pre></td></tr></table></figure><p> 解决：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 1. 需要先安装libunwind-devel，被gperftools依赖</div><div class="line"> yum install libunwind-devel -y</div><div class="line"></div><div class="line"># 2. 安装tcmalloc（yum无法安装，需要通过rpm的方式）</div><div class="line">wget https://github.com/gperftools/gperftools/releases/download/gperftools-2.2.1/gperftools-2.2.1.tar.gz</div><div class="line">tar -zxvf gperftools-2.2.1.tar.g</div><div class="line">cd gperftools-2.2.1</div><div class="line">./configure</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure><p>8.libedit</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: No usable version of libedit found.</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install  libedit-devel -y</div></pre></td></tr></table></figure><p>9.libatomic-ops</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: no libatomic-ops found (use --without-libatomic-ops to disable)</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install libatomic_ops-devel  -y</div></pre></td></tr></table></figure><p>10.libsnappy</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: libsnappy not found</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">yum install snappy-devel -y</div><div class="line"></div><div class="line">or </div><div class="line"></div><div class="line">wget ftp://195.220.108.108/linux/centos/6.9/os/x86_64/Packages/snappy-devel-1.1.0-1.el6.x86_64.rpm</div><div class="line">rpm -ivh snappy-devel-1.1.0-1.el6.x86_64.rpm</div></pre></td></tr></table></figure><p>11.libleveldb</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: libleveldb not found</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install leveldb-devel</div></pre></td></tr></table></figure><p>12.libaio</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: libaio not found</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install libaio-devel -y</div></pre></td></tr></table></figure><p>13.libxfs</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">configure: error: xfs/xfs.h not found (--without-libxfs to disable)</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install xfsprogs-devel</div></pre></td></tr></table></figure><p>14.boost</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Can&apos;t find boost spirit headers</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install boost* -y</div></pre></td></tr></table></figure><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>机器配置不好的话，编译需要时间比较长。可以使用<code>make -j</code>增加并发度，<code>4</code>表示同时执行的<code>make</code>方法数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make -j4</div><div class="line">make install（可选）</div></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>ceph</code>手动源码编译遇到的问题还是蛮多的，如果不自己动手经历一下的话很多东西都不知道，当然这都是经验的积累，不断地锻炼自己解决问题的能力，要学会见招拆招，通过问题发现原理和本质。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/ceph-600x450.png&quot; alt=&quot;Ceph Compile&quot;&gt;&lt;/center&gt;

&lt;p&gt;如今入门&lt;code&gt;Ceph&lt;/code&gt;的时候，大家一般用&lt;code&gt;ceph-deploy&lt;/code&gt;工具比较多，这个工具的确很强大，很方便，对应的也就是很无脑。如果之后想深入&lt;code&gt;Ceph&lt;/code&gt;或者想在生产环境中部署&lt;code&gt;Ceph&lt;/code&gt;的话，就得熟悉&lt;code&gt;Ceph&lt;/code&gt;源码编译了。这对我们熟悉&lt;code&gt;Ceph&lt;/code&gt;的&lt;code&gt;feature&lt;/code&gt;的变化，&lt;code&gt;component&lt;/code&gt;的相互关系以及围绕&lt;code&gt;Ceph&lt;/code&gt;各种定制化扩展都大有裨益。本文就笔者&lt;code&gt;Ceph&lt;/code&gt;源码编译过程和遇到的问题作出分享，希望有人能够得益于此。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="编译" scheme="https://tony-yin.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>通过ganesha-nfs导出Ceph为NFS（Luminous）</title>
    <link href="https://tony-yin.github.io/2017/11/08/Ceph-NFS-Ganesha/"/>
    <id>https://tony-yin.github.io/2017/11/08/Ceph-NFS-Ganesha/</id>
    <published>2017-11-08T15:15:26.000Z</published>
    <updated>2017-11-30T03:09:29.197Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/ganesha-600x450.png" alt="ganesha"></center><p>自从<code>Jewel</code>版本，<code>nfs-ganesha</code>开始支持<code>ceph</code>，并且把对接点选择了<code>rados</code>。<code>Ganesha</code>支持两种方式将<code>Ceph</code>导出为<code>NFS</code>，一种通过<code>RGW</code>，一种通过<code>CephFS</code>，通过<code>FSAL</code>模块 连接到<code>RGW</code>或者<code>CephFS</code>， 其中，<code>FSAL_RGW</code>调用<code>librgw2</code>将<code>NFS</code>协议转义为<code>S3</code>协议再通过<code>RGW</code>存入到<code>Ceph</code>中，<code>FSAL_CEPH</code> 调用<code>libcephfs1</code>将<code>NFS</code>转义为<code>Cephfs</code>协议再存入到<code>Ceph</code> 中。所以需要额外安装这两个包。</p><p>本文就<code>Luminous</code>版本的<code>ceph</code>基于<code>ganesha</code>导出<code>nfs</code>部署，并且测试一下<code>rgw</code>和<code>cephfs</code>的性能。<a href="http://www.xuxiaopang.com/2017/03/27/ganesha-nfs-deploy/#more" target="_blank" rel="external">@徐小胖</a>已经就<code>jewel</code>版本的过程进行了大致的讲解，我这边主要分享一下我遇到他文章没提到的和<code>Luminous</code>场景导致的问题。</p><a id="more"></a><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><ul><li><a href="http://www.xuxiaopang.com/2017/03/27/ganesha-nfs-deploy/#more" target="_blank" rel="external">通过ganesha-nfs将 Ceph 导出为 NFS</a></li><li><a href="http://blog.csdn.net/younger_china/article/details/73432726" target="_blank" rel="external">RGW+Ganesha环境部署</a></li></ul><h2 id="环境声明"><a href="#环境声明" class="headerlink" title="环境声明"></a>环境声明</h2><ul><li>os： centos7</li><li>ceph： luminous</li><li>nfs-gnesha： <strong>v2.5 stable</strong>（important）</li></ul><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>一些编译需要的公共库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install gcc git cmake autoconf libtool bison flex doxygen openssl-devel gcc-c++ krb5-libs krb5-devel libuuid-devel nfs-utils -y</div></pre></td></tr></table></figure><p><code>ubuntu</code>的我也试了一下，主要有以下几个包不同：</p><ul><li><code>gcc-c++</code>   -&gt;   <code>g++</code></li><li><code>libuuid-devel</code> -&gt;  <code>uuid-dev</code></li><li><code>nfs-utils</code>   -&gt;  <code>nfs-kernel-server</code> </li></ul><p>如果要生成<code>FSAL_RGW</code>模块，需要安装<code>librgw2-devel</code>（我装的<code>librgw-devel</code>也可以<code>work</code>，看了<code>so</code>文件发现就是<code>2</code>，只是建立了映射关系，这个看了源码知道了是因为<code>K</code>版本对<code>librgw</code>编译这块做了升级，加了<code>2</code>标识一下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install librgw2-devel -y</div></pre></td></tr></table></figure><p>如果要生成<code>FSAL_CEPH</code>模块，需要安装<code>libcephfs1-devel</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install libcephfs1-devel -y</div></pre></td></tr></table></figure><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p>上面两篇文章一个下载的是<code>v2.3 stable</code>，一个是<code>v2.4 stable</code>，两个我都试过，都会在<code>make</code>到<code>80%</code>左右的时候报错，应该是源码版本和库的版本有冲突导致的，这个问题耽误我挺长时间的，后来猜想可能是版本问题，尝试了一下<code>v2.5 stable</code>的源码就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone -b V2.5-stable https://github.com/nfs-ganesha/nfs-ganesha.git --recursive</div></pre></td></tr></table></figure><p><strong>注意：（重要）</strong></p><p>最近我同事根据这篇文档部署<code>nfs-ganesha</code>的时候，发现之后<code>cmake</code>的操作后<code>USE_FSAL_RGW</code>始终是<code>OFF</code>的状态，一开始检查了一下环境发现<code>ganesha</code>是<code>v2.5</code>，然后<code>ceph</code>也是<code>L</code>版本，<code>centos</code>也是<code>7</code>。</p><p>报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">local RGW version is 1.1.4 not suitable match, but required latest RGW version is 1.1.6</div></pre></td></tr></table></figure><p>很好理解，就是我们安装的<code>RGW</code>达不到<code>nfs-ganesha</code>的要求，首先我们尝试去安装新的版本，但是<code>yum</code>的源已经配置了<code>luminous</code>，并且网上搜索了一圈并没有找到更新的。</p><p>ok，那就第二步，那就找原因同样的环境为啥我可以成功？而这位同事却不行？莫非因为我帅？不能这么逆天吧^_^ （明明可以靠脸吃饭，偏偏靠才华，哎……）</p><p>言归正传，通过报错信息查看源代码？定位到了报错文件<code>src/CMakeLists.txt</code>，然后代码中对<code>RGW</code>的版本要求也的确是<code>1.1.6</code>，回过头再看我之前下载下来的源代码，怪异的现象发生了，我代码中对<code>RGW</code>的版本要求只有<code>1.1.3</code>，此时我的第一反应就是应该这个文件被修改过导致两份代码不一样，出于本能直接上了<code>github</code>，果不其然，发现了<code>mattbenjamin</code>同学在<code>10</code>月<code>17</code>号在<code>v2.5</code>的分支上提交了一个<code>commit</code>针对<code>RGW</code>版本做出了修改！具体参看<a href="https://github.com/nfs-ganesha/nfs-ganesha/commit/8d039cd139ea1dcfbe316b7e93e96efe755669ef" target="_blank" rel="external">commit详情</a>，而这位贡献者几乎同时也在<code>ceph</code>提交了相关代码。这样想想就说得通了，我在搭建<code>nfs-ganesha</code>的时候恰好是在他提交之前的，所以我本地<code>RGW</code>本地版本是<code>1.1.4</code>是比要求版本<code>1.1.3</code>要高的，虽然不是完全<code>match</code>，但是也基本符合了要求，而我这位同事脸就比较黑了。。。</p><p>那该怎么解决这个问题呢？</p><p>有两种解决方案：</p><ol><li>手动编译<code>Luminous Ceph</code>把最新的<code>RGW</code>包编译出来，因为现在这个资源还没被公开分享出来；</li><li>克隆这个改动之前的代码</li></ol><p>这么看来第二种更为简单一些，我们也是采用的这种方式，<code>git clone v2.5 stable</code>后，然后<code>git checkout</code>恰当的版本号即可。</p><p><strong>总结：</strong></p><p>其实直接<code>clone</code>实时的代码这是不合理的，因为你不知道他什么时候会更新。正确的方式是我们应该找到稳定的<code>release</code>版本，<code>nfs-ganesha</code>也有提供<a href="https://github.com/nfs-ganesha/nfs-ganesha/releases" target="_blank" rel="external">一系列的release</a>，而我们通过查看<code>2.5 tree</code>上面的<code>commit</code>信息，可以知道<code>RGW</code>的改动是介于<code>2.5.3</code>和<code>2.5.4</code>之间的，所以我们下载<code>2.5.3</code>较为合适，下载地址在<a href="https://github.com/nfs-ganesha/nfs-ganesha/releases/tag/V2.5.3" target="_blank" rel="external">这里</a>。</p><p>这边还需要注意一个问题，这边<code>release</code>包下载下来你会发现<code>libntrirpc</code>这个文件夹没有内容，出现这个问题是因为<code>libntrirpc</code>对应的也是一个<code>git</code>仓库，我们需要去<a href="https://github.com/nfs-ganesha/nfs-ganesha/tree/next/src" target="_blank" rel="external">ntrirpc</a>手动克隆，然后通过<code>nfs-ganesha</code>的目录发现对<code>ntrirpc</code>的版本要求是<code>fadcbde</code>（这些都是上<code>github</code>可以看到的），我们需要做的就是在下载下来的<code>ntrirpc</code>目录下切到<code>fadcbde</code>这个<code>commit</code>上，并把当前的内容拷贝到<code>nfs-ganesha</code>的<code>libntrirpc</code>目录下。</p><p>实在搞不定的童鞋，我提供一个我克隆的<code>nfs-ganesha</code>的代码包，你们可以对比一下，这个我是可以成功部署的</p><p>附：我的<code>nfs-ganesha</code><a href="http://ovv1r40we.bkt.clouddn.com/nfs-ganesha.tar.gz" target="_blank" rel="external">下载地址</a></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译<code>nfs-ganesha</code>， <strong>注意打开对应的模块：</strong></p><ul><li>如果需要生成<code>FSAL_RGW</code>模块，则在编译选项中添加： <code>-DUSE_FSAL_RGW=ON</code></li><li>如果需要生成<code>FSAL_CEPH</code>模块，则在编译选项中添加： <code>-DUSE_FSAL_CEPH=ON</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd src/</div><div class="line">mkdir build</div><div class="line">cd /build/</div><div class="line">cmake -DUSE_FSAL_RGW=ON -DUSE_FSAL_CEPH=ON ../</div></pre></td></tr></table></figure><p><code>cmake</code>的过程中会有以下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">-- Looking for ceph_ll_lookup_root in cephfs - found</div><div class="line">-- Found cephfs libraries: /usr/lib64/libcephfs.so</div><div class="line">-- Found CEPHFS: /usr/include  </div><div class="line">-- Looking for rgw_mount in rgw</div><div class="line">-- Looking for rgw_mount in rgw - found</div><div class="line">-- Found rgw libraries: /usr/lib64/librgw.so</div><div class="line">-- Found RGW: /usr (found suitable version &quot;1.1&quot;, minimum required is &quot;1.1&quot;) </div><div class="line">...</div><div class="line">-- USE_FSAL_CEPH = ON</div><div class="line">-- USE_FSAL_CEPH_MKNOD = OFF</div><div class="line">-- USE_FSAL_CEPH_SETLK = OFF</div><div class="line">-- USE_FSAL_CEPH_LL_LOOKUP_ROOT = ON</div><div class="line">-- USE_FSAL_RGW = ON</div></pre></td></tr></table></figure><p>这一步，很重要，很多时候会因为没有装好的<code>librgw2-devel</code>或者<code>libcephfs1-devel</code>导致这边的<code>USE_FSAL_RGW</code>或者<code>USE_FSAL_CEPH</code>状态为<code>OFF</code></p><p><strong>确保，确保，确保：</strong> <code>-- USE_FSAL_CEPH</code>为<code>ON</code>，以及<code>-- USE_FSAL_RGW</code>为<code>ON</code>。</p><p>如果是<code>OFF</code>，请检查下<code>librgw2-devel</code>或者<code>libcephfs1-devel</code>是否有安装，如果这两个包都已经安装了，还显示为<code>OFF</code>， 可以尝试下清空编译目录：<code>rm -rf build/*</code>，再进行编译，如果依旧为 <code>OFF</code>，可以尝试下删除所有的<code>Ceph</code>包，再重新<code>yum install ceph librgw2-devel libcephfs1-devel -y</code>。</p><p>编译和安装，在<code>build</code>目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure><blockquote><p>PS:<br>在<code>make install</code>生成的输出中，可以看到:</p><p>– Up-to-date: /usr/share/doc/ganesha/config_samples/rgw.conf<br>…<br>– Up-to-date: /usr/share/doc/ganesha/config_samples/ceph.conf</p><p>这两个文件就是配置将<code>RGW</code>和<code>CephFS</code>配置为<code>ganesha-nfs</code>的配置模板。</p></blockquote><h2 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h2><p>注意<code>Path</code>后面的路径需要加引号，<code>rgw</code>替换成创建<code>S3</code>用户生成的用户信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">cat /etc/ganesha/ganesha.conf</div><div class="line">EXPORT</div><div class="line">&#123;</div><div class="line">        Export_ID=1;</div><div class="line">        Path = &quot;/&quot;;</div><div class="line">        Pseudo = /cephfs;</div><div class="line">        Access_Type = RW;</div><div class="line">        NFS_Protocols = 4;</div><div class="line">        Transport_Protocols = TCP;</div><div class="line">        FSAL &#123;</div><div class="line">                Name = CEPH;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">EXPORT</div><div class="line">&#123;</div><div class="line">        Export_ID=2;</div><div class="line">        Path = &quot;/&quot;;</div><div class="line">        Pseudo = /rgw;</div><div class="line">        Access_Type = RW;</div><div class="line">        Squash = No_root_squash;</div><div class="line">        NFS_Protocols = 4;</div><div class="line">        Transport_Protocols = TCP;</div><div class="line">        FSAL &#123;</div><div class="line">                Name = RGW;</div><div class="line">                User_Id = &quot;admin&quot;;</div><div class="line">                Access_Key_Id =&quot;1MWH3LWM1BS4ZF4HN5IH&quot;;</div><div class="line">                Secret_Access_Key = &quot;cuObxYgtl1lJgqNxOIpENycVqXfxLxZ8z5IXDM0O&quot;;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">RGW &#123;</div><div class="line">    ceph_conf = &quot;/etc/ceph/ceph.conf&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="启动-Ganesha"><a href="#启动-Ganesha" class="headerlink" title="启动 Ganesha"></a>启动 Ganesha</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ganesha.nfsd -f /etc/ganesha/ganesha.conf -L /var/log/nfs-ganesha.log -N NIV_DEBUG</div></pre></td></tr></table></figure><p>如果一切顺利，你应该可以看到<code>ganesha.nfsd</code> 进程在那，如果进程不在，那么查看<code>Log</code>，记得在启动进程前，关闭所有<code>CephX</code>配置。</p><p><strong>重要</strong>：<code>librgw init failed (-5)</code> 解决方法</p><p>报错内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RGW-1 : nfs-ganesha-2232083[main] create_export :FSAL :CRIT :RGW module: librgw init failed (-5)</div><div class="line">RGW-1 : nfs-ganesha-2232083[main] mdcache_fsal_create_export :FSAL :MAJ :Failed to call create_export on underlying FSAL</div></pre></td></tr></table></figure><p>经过多次尝试，包括在<code>ganesha.conf</code>内添加<code>init_args</code>指定秘钥和<code>Ceph</code>的用户，<code>ganesha-nfs</code> 均无法启动，报的错如标题，解决方法就是关闭<code>CephX</code>，将<code>/etc/ceph/ceph.conf</code>内的三个 <code>cephx</code>改为<code>none</code>，然后重启<code>ceph-mon</code>，<code>ceph-osd</code>，<code>ceph-radosgw</code>，<code>ceph-mds</code> 进程，再启动<code>ganesha-nfs</code>，即可正常运行。</p><p><strong>需要注意的是：</strong></p><p>当你在当前节点上，关闭<code>cephx</code>后，你用<code>ceph -s</code>查看集群状态时，这时候会报错说明由于没有<code>auth</code>认证导致无法连接集群，所以我当时试了很久，尽管<code>nfs-ganesha</code>已经运行了，但是<code>mount</code>都没有成功<code>export</code>，查看<code>log</code>才发现原来在<code>init</code>配置的时候就失败了，导致这个问题的原因是我只关闭了一个节点的<code>cephx</code>，所以需要做的就是将集群内所有节点的<code>cephx</code>全部关闭，然后集群就可以正常访问了，并且<code>nfs-ganesha</code>也不会因为<code>cephx</code>导致加载配置出错</p><h2 id="Check-Export"><a href="#Check-Export" class="headerlink" title="Check Export"></a>Check Export</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@node1 build]# showmount -e  </div><div class="line">Export list for node1:  </div><div class="line">/ (everyone)  </div><div class="line">/ (everyone)</div></pre></td></tr></table></figure><h2 id="挂载-NFS"><a href="#挂载-NFS" class="headerlink" title="挂载 NFS"></a>挂载 NFS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@node1 mnt]# mount -t nfs4 192.168.1.1:/  /mnt/ceph/  </div><div class="line">root@node1 mnt]# ls ceph/*  </div><div class="line">ceph/cephfs:  </div><div class="line">test  </div><div class="line">   </div><div class="line">ceph/rgw:  </div><div class="line">my-new-bucket</div></pre></td></tr></table></figure><p>说明<code>CephFS</code>和<code>RGW</code>都已经正常对接。<br>如果，你所使用的<code>admin</code>用户名下有很多的桶，那么这些桶都会以<code>/mnt/rgw/xxbucket</code>的结构显示出来，如果你在<code>/mnt/rgw/</code>下建立的一个目录，那么就相当于通过<code>RGW</code>建立了一个桶，所以，你执行<code>touch /mnt/rgw/123</code>是会报错的，因为不符合<code>S3</code>的对象必须位于桶内的规定，简单点说，就是把<code>/mnt/rgw/</code>和<code>S3</code>的根目录一一对应即可。</p><p>同样，<code>CephFS</code>内的内容都会显示在<code>/mnt/cephfs/</code>目录下。可以开始愉快的玩耍了！！</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/ganesha-600x450.png&quot; alt=&quot;ganesha&quot;&gt;&lt;/center&gt;

&lt;p&gt;自从&lt;code&gt;Jewel&lt;/code&gt;版本，&lt;code&gt;nfs-ganesha&lt;/code&gt;开始支持&lt;code&gt;ceph&lt;/code&gt;，并且把对接点选择了&lt;code&gt;rados&lt;/code&gt;。&lt;code&gt;Ganesha&lt;/code&gt;支持两种方式将&lt;code&gt;Ceph&lt;/code&gt;导出为&lt;code&gt;NFS&lt;/code&gt;，一种通过&lt;code&gt;RGW&lt;/code&gt;，一种通过&lt;code&gt;CephFS&lt;/code&gt;，通过&lt;code&gt;FSAL&lt;/code&gt;模块 连接到&lt;code&gt;RGW&lt;/code&gt;或者&lt;code&gt;CephFS&lt;/code&gt;， 其中，&lt;code&gt;FSAL_RGW&lt;/code&gt;调用&lt;code&gt;librgw2&lt;/code&gt;将&lt;code&gt;NFS&lt;/code&gt;协议转义为&lt;code&gt;S3&lt;/code&gt;协议再通过&lt;code&gt;RGW&lt;/code&gt;存入到&lt;code&gt;Ceph&lt;/code&gt;中，&lt;code&gt;FSAL_CEPH&lt;/code&gt; 调用&lt;code&gt;libcephfs1&lt;/code&gt;将&lt;code&gt;NFS&lt;/code&gt;转义为&lt;code&gt;Cephfs&lt;/code&gt;协议再存入到&lt;code&gt;Ceph&lt;/code&gt; 中。所以需要额外安装这两个包。&lt;/p&gt;
&lt;p&gt;本文就&lt;code&gt;Luminous&lt;/code&gt;版本的&lt;code&gt;ceph&lt;/code&gt;基于&lt;code&gt;ganesha&lt;/code&gt;导出&lt;code&gt;nfs&lt;/code&gt;部署，并且测试一下&lt;code&gt;rgw&lt;/code&gt;和&lt;code&gt;cephfs&lt;/code&gt;的性能。&lt;a href=&quot;http://www.xuxiaopang.com/2017/03/27/ganesha-nfs-deploy/#more&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@徐小胖&lt;/a&gt;已经就&lt;code&gt;jewel&lt;/code&gt;版本的过程进行了大致的讲解，我这边主要分享一下我遇到他文章没提到的和&lt;code&gt;Luminous&lt;/code&gt;场景导致的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="NFS-Ganesha" scheme="https://tony-yin.github.io/tags/NFS-Ganesha/"/>
    
      <category term="NFS" scheme="https://tony-yin.github.io/tags/NFS/"/>
    
      <category term="Luminous" scheme="https://tony-yin.github.io/tags/Luminous/"/>
    
  </entry>
  
  <entry>
    <title>RGW 安装和创建</title>
    <link href="https://tony-yin.github.io/2017/11/08/Ceph-RGW/"/>
    <id>https://tony-yin.github.io/2017/11/08/Ceph-RGW/</id>
    <published>2017-11-08T15:11:59.000Z</published>
    <updated>2017-11-30T03:09:45.077Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/gateway-600x450.png" alt="Ceph RGW"></center><p>本文通过<code>ceph-deploy</code>安装和创建<code>RGW</code>，然后分别创建<code>S3</code>和<code>Swift</code>接口并提供了相应的方案。</p><p><code>Ceph RGW</code>基于<code>librados</code>，是为应用提供<code>RESTful</code>类型的对象存储接口。<code>RGW</code>提供两种类型的接口：</p><ul><li>S3：兼容<code>Amazon S3 RESTful API</code></li><li>Swift：兼容<code>OpenStack Swift API</code></li></ul><p><code>S3</code>和<code>Swift API</code>共享同一个命名空间，所以可以使用两种<code>API</code>访问相同的数据。</p><a id="more"></a><p>参考链接: <a href="http://blog.csdn.net/younger_china/article/details/73410918" target="_blank" rel="external">Ceph：创建RGW</a></p><h2 id="部署-RGW"><a href="#部署-RGW" class="headerlink" title="部署 RGW"></a>部署 RGW</h2><h3 id="进入-ceph-目录"><a href="#进入-ceph-目录" class="headerlink" title="进入 ceph 目录"></a>进入 ceph 目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd /etc/ceph</div></pre></td></tr></table></figure><h3 id="安装-ceph-object-gateway"><a href="#安装-ceph-object-gateway" class="headerlink" title="安装 ceph object gateway"></a>安装 ceph object gateway</h3><p>我这边是<code>node1</code>，根据<code>hostname</code>对号入座就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy install --rgw node1</div></pre></td></tr></table></figure><h3 id="Gather-keys"><a href="#Gather-keys" class="headerlink" title="Gather keys"></a>Gather keys</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy gatherkeys node1</div></pre></td></tr></table></figure><h3 id="创建-rgw-实例"><a href="#创建-rgw-实例" class="headerlink" title="创建 rgw 实例"></a>创建 rgw 实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy rgw create node1</div></pre></td></tr></table></figure><h3 id="Ceph-CLI"><a href="#Ceph-CLI" class="headerlink" title="Ceph CLI"></a>Ceph CLI</h3><p><code>Ceph CLI</code>工具需要在管理员模式下运行，因此需要执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy admin node1</div></pre></td></tr></table></figure><h3 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h3><p>一旦<code>RGW</code>开始运行，就可以通过端口<code>7480</code>（如果没有修改的话）来访问。如：<br><code>http://node1:7480</code>，如果<code>RGW</code>运行正常，它应该返回类似的信息： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">This XML file does not appear to have any style information associated with it. The document tree is shown below.</div><div class="line">&lt;ListAllMyBucketsResult xmlns=&quot;http://s3.amazonaws.com/doc/2006-03-01/&quot;&gt;</div><div class="line">&lt;Owner&gt;</div><div class="line">&lt;ID&gt;anonymous&lt;/ID&gt;</div><div class="line">&lt;DisplayName/&gt;</div><div class="line">&lt;/Owner&gt;</div><div class="line">&lt;Buckets/&gt;</div><div class="line">&lt;/ListAllMyBucketsResult&gt;</div></pre></td></tr></table></figure><h2 id="创建-S3-用户"><a href="#创建-S3-用户" class="headerlink" title="创建 S3 用户"></a>创建 S3 用户</h2><p>想正常的访问<code>RGW</code>，需要创建相应的<code>RGW</code>用户，并赋予相应的权限，<code>radosgw-admin</code>命令实现了这些功能。</p><p>其中<code>keys</code>中的<code>user</code>，<code>access_key</code>和<code>secret_key</code>用于之后的<code>S3</code>接口访问确认</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">[root@node1 ~]# radosgw-admin user create --uid=&quot;admin&quot; --display-name=&quot;First user&quot;</div><div class="line">2017-11-08 16:51:39.883217 7fb6868fac40  0 WARNING: detected a version of libcurl which contains a bug in curl_multi_wait(). enabling a workaround that may degrade performance slightly.</div><div class="line">&#123;</div><div class="line">    &quot;user_id&quot;: &quot;admin&quot;,</div><div class="line">    &quot;display_name&quot;: &quot;First user&quot;,</div><div class="line">    &quot;email&quot;: &quot;&quot;,</div><div class="line">    &quot;suspended&quot;: 0,</div><div class="line">    &quot;max_buckets&quot;: 1000,</div><div class="line">    &quot;auid&quot;: 0,</div><div class="line">    &quot;subusers&quot;: [],</div><div class="line">    &quot;keys&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;user&quot;: &quot;admin&quot;,</div><div class="line">            &quot;access_key&quot;: &quot;1MWH3LWM1BS4ZF4HN5IH&quot;,</div><div class="line">            &quot;secret_key&quot;: &quot;cuObxYgtl1lJgqNxOIpENycVqXfxLxZ8z5IXDM0O&quot;</div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    &quot;swift_keys&quot;: [],</div><div class="line">    &quot;caps&quot;: [],</div><div class="line">    &quot;op_mask&quot;: &quot;read, write, delete&quot;,</div><div class="line">    &quot;default_placement&quot;: &quot;&quot;,</div><div class="line">    &quot;placement_tags&quot;: [],</div><div class="line">    &quot;bucket_quota&quot;: &#123;</div><div class="line">        &quot;enabled&quot;: false,</div><div class="line">        &quot;check_on_raw&quot;: false,</div><div class="line">        &quot;max_size&quot;: -1,</div><div class="line">        &quot;max_size_kb&quot;: 0,</div><div class="line">        &quot;max_objects&quot;: -1</div><div class="line">    &#125;,</div><div class="line">    &quot;user_quota&quot;: &#123;</div><div class="line">        &quot;enabled&quot;: false,</div><div class="line">        &quot;check_on_raw&quot;: false,</div><div class="line">        &quot;max_size&quot;: -1,</div><div class="line">        &quot;max_size_kb&quot;: 0,</div><div class="line">        &quot;max_objects&quot;: -1</div><div class="line">    &#125;,</div><div class="line">    &quot;temp_url_keys&quot;: [],</div><div class="line">    &quot;type&quot;: &quot;rgw&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="创建-Swift-用户"><a href="#创建-Swift-用户" class="headerlink" title="创建 Swift 用户"></a>创建 Swift 用户</h2><p><code>Swift</code>用户是作为子用户<code>subuser</code>被创建的，执行以下命令：</p><p>其中<code>swift_keys</code>中的<code>user</code>和<code>secret_key</code>用于之后的<code>swift</code>接口访问确认</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">[root@node1 ~]# radosgw-admin subuser create --uid=admin --subuser=admin:swift --access=full</div><div class="line">2017-11-08 16:55:05.371174 7fb4cbfc2c40  0 WARNING: detected a version of libcurl which contains a bug in curl_multi_wait(). enabling a workaround that may degrade performance slightly.</div><div class="line">&#123;</div><div class="line">    &quot;user_id&quot;: &quot;admin&quot;,</div><div class="line">    &quot;display_name&quot;: &quot;First user&quot;,</div><div class="line">    &quot;email&quot;: &quot;&quot;,</div><div class="line">    &quot;suspended&quot;: 0,</div><div class="line">    &quot;max_buckets&quot;: 1000,</div><div class="line">    &quot;auid&quot;: 0,</div><div class="line">    &quot;subusers&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;id&quot;: &quot;admin:swift&quot;,</div><div class="line">            &quot;permissions&quot;: &quot;full-control&quot;</div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    &quot;keys&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;user&quot;: &quot;admin&quot;,</div><div class="line">            &quot;access_key&quot;: &quot;1MWH3LWM1BS4ZF4HN5IH&quot;,</div><div class="line">            &quot;secret_key&quot;: &quot;cuObxYgtl1lJgqNxOIpENycVqXfxLxZ8z5IXDM0O&quot;</div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    &quot;swift_keys&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;user&quot;: &quot;admin:swift&quot;,</div><div class="line">            &quot;secret_key&quot;: &quot;PKRXACd8Ysgx7MCTjd9gHnL3sdpJ2J6wsuy2IS0P&quot;</div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    &quot;caps&quot;: [],</div><div class="line">    &quot;op_mask&quot;: &quot;read, write, delete&quot;,</div><div class="line">    &quot;default_placement&quot;: &quot;&quot;,</div><div class="line">    &quot;placement_tags&quot;: [],</div><div class="line">    &quot;bucket_quota&quot;: &#123;</div><div class="line">        &quot;enabled&quot;: false,</div><div class="line">        &quot;check_on_raw&quot;: false,</div><div class="line">        &quot;max_size&quot;: -1,</div><div class="line">        &quot;max_size_kb&quot;: 0,</div><div class="line">        &quot;max_objects&quot;: -1</div><div class="line">    &#125;,</div><div class="line">    &quot;user_quota&quot;: &#123;</div><div class="line">        &quot;enabled&quot;: false,</div><div class="line">        &quot;check_on_raw&quot;: false,</div><div class="line">        &quot;max_size&quot;: -1,</div><div class="line">        &quot;max_size_kb&quot;: 0,</div><div class="line">        &quot;max_objects&quot;: -1</div><div class="line">    &#125;,</div><div class="line">    &quot;temp_url_keys&quot;: [],</div><div class="line">    &quot;type&quot;: &quot;rgw&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="测试-S3-接口"><a href="#测试-S3-接口" class="headerlink" title="测试 S3 接口"></a>测试 S3 接口</h2><p>需要创建一个<code>python</code>测试脚本来测试<code>S3</code>访问。该脚本会连接<code>RGW</code>，创建一个<code>bucket</code>并打印输出所有的<code>bucket</code>。其中，变量<code>access_key</code>和<code>secret_access</code>的值，来自于创建<code>S3</code>用户命令时，<code>radosgw-admin</code>命令返回的<code>keys-&gt;access_key</code>和<code>keys-&gt;secret_key</code>。</p><h3 id="安装-python-boto库"><a href="#安装-python-boto库" class="headerlink" title="安装 python-boto库"></a>安装 python-boto库</h3><p>执行以下步骤，首先安装<code>python-boto</code>库，该库用于连接<code>S3</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y python-boto</div></pre></td></tr></table></figure><h3 id="创建脚本"><a href="#创建脚本" class="headerlink" title="创建脚本"></a>创建脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python  </div><div class="line"># -*- coding:utf-8 -*-  </div><div class="line"></div><div class="line">import boto.s3.connection  </div><div class="line">   </div><div class="line">access_key = &apos;1MWH3LWM1BS4ZF4HN5IH&apos;     </div><div class="line">secret_key =&apos;cuObxYgtl1lJgqNxOIpENycVqXfxLxZ8z5IXDM0O&apos;  </div><div class="line">conn = boto.connect_s3(  </div><div class="line">        aws_access_key_id=access_key,  </div><div class="line">        aws_secret_access_key=secret_key,  </div><div class="line">        host=&apos;&#123;hostname&#125;&apos;,port=&#123;port&#125;,  </div><div class="line">        is_secure=False,calling_format=boto.s3.connection.OrdinaryCallingFormat(),  </div><div class="line">        )  </div><div class="line">   </div><div class="line">bucket = conn.create_bucket(&apos;my-new-bucket&apos;)  </div><div class="line">for bucket in conn.get_all_buckets():  </div><div class="line">    print&quot;&#123;name&#125; &#123;created&#125;&quot;.format(  </div><div class="line">            name=bucket.name,  </div><div class="line">            created=bucket.creation_date,  </div><div class="line">            )</div></pre></td></tr></table></figure><p>需要将上面的<code>{hostname}</code>替换成对应的<code>hostname</code>或者<code>IP</code>,例如<code>192.168.1.1</code>；将<code>{port}</code>替换成<code>RGW</code>运行的端口，默认为<code>7480</code>；前者为字符串，后者为数字</p><h3 id="执行脚本测试"><a href="#执行脚本测试" class="headerlink" title="执行脚本测试"></a>执行脚本测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@node1 ceph]# python s3test.py </div><div class="line">my-new-bucket 2017-11-01T10:58:53.670Z</div></pre></td></tr></table></figure><h2 id="测试-Swift-接口"><a href="#测试-Swift-接口" class="headerlink" title="测试 Swift 接口"></a>测试 Swift 接口</h2><h3 id="安装相关软件包"><a href="#安装相关软件包" class="headerlink" title="安装相关软件包"></a>安装相关软件包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pip installpython-setuptools    </div><div class="line">pip installpython-swiftclient</div></pre></td></tr></table></figure><h3 id="命令行访问"><a href="#命令行访问" class="headerlink" title="命令行访问"></a>命令行访问</h3><p>替换<code>{ip}</code>，<code>{port}</code>和<code>{swift_secret_key}</code>，其中<code>{swift_secret_key}</code>为创建<code>Swift</code>用户时，<code>radosgw-admin</code>命令返回的<code>swift_keys-&gt;secret_key</code>的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swift -A http://&#123;ip&#125;:&#123;port&#125;/auth/1.0 -Utestuser:swift -K &apos;&#123;swift_secret_key&#125;&apos; list</div></pre></td></tr></table></figure><p>正常输出应该如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@node1 ceph]# swift -Ahttp://192.168.1.1:7480/auth/1.0 -U admin:swift -K &apos;PKRXACd8Ysgx7MCTjd9gHnL3sdpJ2J6wsuy2IS0P&apos; list  </div><div class="line">my-new-bucket</div></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>ceph-deploy</code>命令，大大地简化了对<code>Ceph</code>集群和<code>RGW的</code>安装和配置，可以很快速的搭建测试环境，达到测试效果，但如果要在生产环境中应用的话，可能需要手动做一些配置就，不能完全依赖<code>ceph-deploy</code>了。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/gateway-600x450.png&quot; alt=&quot;Ceph RGW&quot;&gt;&lt;/center&gt;

&lt;p&gt;本文通过&lt;code&gt;ceph-deploy&lt;/code&gt;安装和创建&lt;code&gt;RGW&lt;/code&gt;，然后分别创建&lt;code&gt;S3&lt;/code&gt;和&lt;code&gt;Swift&lt;/code&gt;接口并提供了相应的方案。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ceph RGW&lt;/code&gt;基于&lt;code&gt;librados&lt;/code&gt;，是为应用提供&lt;code&gt;RESTful&lt;/code&gt;类型的对象存储接口。&lt;code&gt;RGW&lt;/code&gt;提供两种类型的接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S3：兼容&lt;code&gt;Amazon S3 RESTful API&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Swift：兼容&lt;code&gt;OpenStack Swift API&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;S3&lt;/code&gt;和&lt;code&gt;Swift API&lt;/code&gt;共享同一个命名空间，所以可以使用两种&lt;code&gt;API&lt;/code&gt;访问相同的数据。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="RGW" scheme="https://tony-yin.github.io/tags/RGW/"/>
    
  </entry>
  
  <entry>
    <title>使用NFS挂载RBD</title>
    <link href="https://tony-yin.github.io/2017/10/31/RBD-Mount-NFS/"/>
    <id>https://tony-yin.github.io/2017/10/31/RBD-Mount-NFS/</id>
    <published>2017-10-31T14:45:25.000Z</published>
    <updated>2017-11-30T03:10:23.246Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ovv1r40we.bkt.clouddn.com/rbd-london-christmas-600x450.jpg" alt="RBD"></center><p><strong>具体场景</strong></p><ul><li>在<code>Server</code>端创建<code>RBD</code>块设备并挂载到某个目录，然后在<code>Client</code>端通过<code>NFS</code>将<code>Server</code>端之前说的目录再挂载到本地，就可以实现在客户端写文件通过<code>NFS</code>到<code>Server</code>端的块设备上</li><li>这波操作的目的是因为测试<code>EC</code>性能时，<code>Ceph</code>版本还是<code>Hammer</code>，<code>CephFS</code>不是很稳定，性能不行，所以想用<code>RBD</code>的方式取代，但是<code>Hammer</code>版本中<code>EC</code>是只支持<code>RGW</code>的，并不支持<code>CephFS</code>和<code>RBD</code>，至于这个场景具体流程之后会在其他文章分享</li><li>这波操作在之前<code>Ceph</code>的<code>Hammer</code>版本做过，这次是要在新版本<code>Luminous</code>上实践，由于遇到了很多问题，大部分都是新版本缘故引入的，故与大家分享</li></ul><blockquote><p>PS：<code>Luminous</code>新版本提供了新的<code>NFS</code>的处理方式，不再需要用这种老式的<code>RBD</code>的手段，之后也会在其他文章分享出来</p></blockquote><a id="more"></a><h2 id="Hammer版本"><a href="#Hammer版本" class="headerlink" title="Hammer版本"></a>Hammer版本</h2><p>操作步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">1. 使用RBD方式导出NFS，步骤如下：</div><div class="line"></div><div class="line">1.1 create RBD block device image (size unit: MB)</div><div class="line"># rbd create --size 1024 ec-pool/test_image</div><div class="line"></div><div class="line">1.2 map RBD device</div><div class="line"># rbd map ec-pool/test_image</div><div class="line"></div><div class="line">[Optional] check mapped device</div><div class="line"># rbd showmapped</div><div class="line"></div><div class="line">1.3 create filesystem on the device</div><div class="line"># mkfs.ext4 /dev/rbd0</div><div class="line"></div><div class="line">1.4 mount it,</div><div class="line"># mkdir -p /vol/test_image</div><div class="line"># mount /dev/rbd0 /vol/test_image/</div><div class="line"></div><div class="line">1.5 export it, modify the /etc/exports</div><div class="line"># cat /etc/exports</div><div class="line">/vol/test_image *(rw,async,no_subtree_check,no_root_squash)</div><div class="line"># service nfs-kernel-server restart</div><div class="line"># exportfs -r</div><div class="line"></div><div class="line">1.6 check mount info for NFS server</div><div class="line"># showmount -e 192.168.1.167</div><div class="line"></div><div class="line">2. 在客户端以nfs方式mount上述导出的文件夹</div><div class="line"># mount -t nfs 192.168.1.167:/vol/test_image /mnt</div></pre></td></tr></table></figure><h2 id="Luminous版本"><a href="#Luminous版本" class="headerlink" title="Luminous版本"></a>Luminous版本</h2><h3 id="Create-RBD-image"><a href="#Create-RBD-image" class="headerlink" title="Create RBD image"></a>Create RBD image</h3><p>之前<code>EC Pool</code>只能为<code>RGW</code>服务 ，直到<code>Luminous</code>版本，<code>EC Pool</code>也可以应用在<code>RBD</code>和<code>CephFS</code>，并且增加了<code>data-pool</code>这样的新特性，具体请参考官网：<a href="http://docs.ceph.com/docs/luminous/rados/operations/erasure-code/#erasure-coding-with-overwrites" target="_blank" rel="external">http://docs.ceph.com/docs/luminous/rados/operations/erasure-code/#erasure-coding-with-overwrites</a></p><p>所以创建<code>image</code>的方式也有所改变</p><h4 id="Enable-ec-overwrites"><a href="#Enable-ec-overwrites" class="headerlink" title="Enable ec overwrites"></a>Enable ec overwrites</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd pool set ec_pool allow_ec_overwrites true</div></pre></td></tr></table></figure><h4 id="Create-pool-and-image"><a href="#Create-pool-and-image" class="headerlink" title="Create pool and image"></a>Create pool and image</h4><p>由于<code>EC</code>不支持<code>omap</code>，所以在<code>CephFS</code>或者<code>RBD</code>场景使用<code>EC</code>时，需要将<code>data</code>存在<code>EC Pool</code>中，将<code>metadata</code>存在<code>Replicated Pool</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 创建pool</div><div class="line">ceph osd pool create ec-pool 12 12 erasure  // ec pool, store data</div><div class="line">ceph osd pool create md-pool 12 12 replicated   // replicated pool, store metadata</div><div class="line">ceph osd pool create ssd-pool 12 12 replicated  // replicated pool, used as cache pool</div><div class="line">// 创建image</div><div class="line">rbd create --size 1024 --data-pool ec-pool md-pool/test_image</div></pre></td></tr></table></figure><h3 id="Map-RBD"><a href="#Map-RBD" class="headerlink" title="Map RBD"></a>Map RBD</h3><p>这一步之前的操作是<code>rbd map ec-pool/test_image</code>，所以当前需要执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd map md-pool/test_image</div></pre></td></tr></table></figure><p>但是一直<code>timeout</code>，通过查看<code>dmesg</code>和网上资料发现是因为<code>linux kernel</code>版本太低，所以升级了一下内核到<code>4.3</code>版本之后就可以<code>work</code>了</p><p>升级内核版本请参考：</p><blockquote><ul><li><a href="http://www.jianshu.com/p/66a724a1f3af" target="_blank" rel="external">内核版本过低导致RBD Feature不支持</a></li><li><a href="http://xiaqunfeng.cc/2017/06/06/ceph-rbd-map-failed/" target="_blank" rel="external">RBD Feature</a></li></ul></blockquote><h3 id="Check-map"><a href="#Check-map" class="headerlink" title="Check map"></a>Check map</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd showmapped</div></pre></td></tr></table></figure><h3 id="Create-filesystem-on-RBD"><a href="#Create-filesystem-on-RBD" class="headerlink" title="Create filesystem on RBD"></a>Create filesystem on RBD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkfs.ext4 /dev/rbd0</div></pre></td></tr></table></figure><h3 id="Mount"><a href="#Mount" class="headerlink" title="Mount"></a>Mount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir -p /vol/test_image</div><div class="line">mount /dev/rbd0 /vol/test_image/</div></pre></td></tr></table></figure><h3 id="Modify-export-for-nfs-on-server"><a href="#Modify-export-for-nfs-on-server" class="headerlink" title="Modify export for nfs on server"></a>Modify export for nfs on server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vim /etc/exports</div><div class="line">/vol/test_image *(rw,async,no_subtree_check,no_root_squash) // Modify it to /etc/exports</div></pre></td></tr></table></figure><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><h5 id="Install-NFS-on-server-and-client"><a href="#Install-NFS-on-server-and-client" class="headerlink" title="Install NFS on server and client"></a>Install NFS on server and client</h5><p><code>Server</code>端执行一下操作</p><h5 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install nfs-utils rpcbind</div></pre></td></tr></table></figure><h5 id="Start-service"><a href="#Start-service" class="headerlink" title="Start service"></a>Start service</h5><p><code>nfs</code>依赖<code>rpcbind</code>，所以必须先启动<code>rpcbind</code>，这很重要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">service rpcbind start</div><div class="line">service nfs start</div><div class="line">exportfs -r</div></pre></td></tr></table></figure><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><p>客户端也执行以上操作，假设客户端<code>ip</code>为<code>192.168.1.1</code>，服务端为<code>192.168.1.2</code></p><h5 id="Check-mount"><a href="#Check-mount" class="headerlink" title="Check mount"></a>Check mount</h5><p>查看是否可以挂载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">showmount -e 192.168.1.2</div></pre></td></tr></table></figure><h5 id="Mount-server-to-client"><a href="#Mount-server-to-client" class="headerlink" title="Mount server to client"></a>Mount server to client</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount -t nfs 192.168.1.2:/vol/test_image /mnt</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>遇到的主要问题</p><ul><li><code>EC Pool</code>创建<code>image</code>因为新版本改动</li><li><code>rbd map</code>因为<code>linux kernel</code>版本低</li><li><code>nfs</code>因为<code>nfs</code>在<code>rpcbind</code>前启动</li></ul><p>希望帮助大家尽量少些踩坑 ~~~</p><p>作者： Tony<br>日期： 2017-10-31 22:33</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ovv1r40we.bkt.clouddn.com/rbd-london-christmas-600x450.jpg&quot; alt=&quot;RBD&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;具体场景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;Server&lt;/code&gt;端创建&lt;code&gt;RBD&lt;/code&gt;块设备并挂载到某个目录，然后在&lt;code&gt;Client&lt;/code&gt;端通过&lt;code&gt;NFS&lt;/code&gt;将&lt;code&gt;Server&lt;/code&gt;端之前说的目录再挂载到本地，就可以实现在客户端写文件通过&lt;code&gt;NFS&lt;/code&gt;到&lt;code&gt;Server&lt;/code&gt;端的块设备上&lt;/li&gt;
&lt;li&gt;这波操作的目的是因为测试&lt;code&gt;EC&lt;/code&gt;性能时，&lt;code&gt;Ceph&lt;/code&gt;版本还是&lt;code&gt;Hammer&lt;/code&gt;，&lt;code&gt;CephFS&lt;/code&gt;不是很稳定，性能不行，所以想用&lt;code&gt;RBD&lt;/code&gt;的方式取代，但是&lt;code&gt;Hammer&lt;/code&gt;版本中&lt;code&gt;EC&lt;/code&gt;是只支持&lt;code&gt;RGW&lt;/code&gt;的，并不支持&lt;code&gt;CephFS&lt;/code&gt;和&lt;code&gt;RBD&lt;/code&gt;，至于这个场景具体流程之后会在其他文章分享&lt;/li&gt;
&lt;li&gt;这波操作在之前&lt;code&gt;Ceph&lt;/code&gt;的&lt;code&gt;Hammer&lt;/code&gt;版本做过，这次是要在新版本&lt;code&gt;Luminous&lt;/code&gt;上实践，由于遇到了很多问题，大部分都是新版本缘故引入的，故与大家分享&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;PS：&lt;code&gt;Luminous&lt;/code&gt;新版本提供了新的&lt;code&gt;NFS&lt;/code&gt;的处理方式，不再需要用这种老式的&lt;code&gt;RBD&lt;/code&gt;的手段，之后也会在其他文章分享出来&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="NFS" scheme="https://tony-yin.github.io/tags/NFS/"/>
    
      <category term="RBD" scheme="https://tony-yin.github.io/tags/RBD/"/>
    
  </entry>
  
  <entry>
    <title>Python Profiler</title>
    <link href="https://tony-yin.github.io/2017/10/10/Python-Profiler/"/>
    <id>https://tony-yin.github.io/2017/10/10/Python-Profiler/</id>
    <published>2017-10-10T13:46:24.000Z</published>
    <updated>2017-11-22T01:39:43.232Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ovv1r40we.bkt.clouddn.com/publicenemyno1-600x400.png" alt="Python Profiler"></center><p><code>OSD</code>启用过程耗时较长，需要进行性能优化。期间通过<code>python profilers</code>对代码进行性能分析和数据统计，有坑，有收获，总而言之，这是一个不错的工具</p><a id="more"></a><h2 id="Profilers简介"><a href="#Profilers简介" class="headerlink" title="Profilers简介"></a>Profilers简介</h2><p><code>python profilers</code>内置的主要有三种<code>cprofile</code>, <code>profile</code>和<code>hotshot</code>,<code>cprofile</code>是基于<code>profile</code>之上做的扩展，性能要比后者好很多，所以我用的就是<code>cprofile</code></p><p>更详细的介绍可以查看官网，<code>python profilers</code>的好处在于不用看教程，只要看着官网简短的概述，就能掌握其使用方法</p><ul><li><a href="https://docs.python.org/2/library/profile.html" target="_blank" rel="external">Python Profile</a></li><li><a href="http://www.cnblogs.com/btchenguang/archive/2012/02/03/2337112.html" target="_blank" rel="external">关于Python Profilers性能分析器</a></li></ul><h2 id="Cprofile快速使用"><a href="#Cprofile快速使用" class="headerlink" title="Cprofile快速使用"></a>Cprofile快速使用</h2><h3 id="官网例子"><a href="#官网例子" class="headerlink" title="官网例子"></a>官网例子</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cProfile</div><div class="line"><span class="keyword">import</span> re</div><div class="line">cProfile.run(<span class="string">'re.compile("foo|bar")'</span>)</div></pre></td></tr></table></figure><h4 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">197 function calls (192 primitive calls) in 0.002 seconds</div><div class="line">Ordered by: standard name</div><div class="line">ncalls  tottime  percall  cumtime  percall filename:lineno(function)</div><div class="line">     1    0.000    0.000    0.001    0.001 &lt;string&gt;:1(&lt;module&gt;)</div><div class="line">     1    0.000    0.000    0.001    0.001 re.py:212(compile)</div><div class="line">     1    0.000    0.000    0.001    0.001 re.py:268(_compile)</div><div class="line">     1    0.000    0.000    0.000    0.000 sre_compile.py:172(_compile_charset)</div><div class="line">     1    0.000    0.000    0.000    0.000 sre_compile.py:201(_optimize_charset)</div><div class="line">     4    0.000    0.000    0.000    0.000 sre_compile.py:25(_identityfunction)</div><div class="line">   3/1    0.000    0.000    0.000    0.000 sre_compile.py:33(_compile)</div></pre></td></tr></table></figure><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><center><img src="http://images.cnblogs.com/cnblogs_com/btchenguang/201202/201202031502512968.png" alt="cprofile"></center><h2 id="Cprofile深入"><a href="#Cprofile深入" class="headerlink" title="Cprofile深入"></a>Cprofile深入</h2><p>上面的基本用法可以在脚本中测试某个语句或者函数，然后打印到控制台。<code>cprofile</code>也可以将结果输出到文件中，这是比较常见的做法，因为打印到控制台，第一不能保存结果，第二如果数据量多没法全部浏览，并且影响阅读效果。而放在文件中还可以对结果进行按需排序、筛选等操作</p><h3 id="输出文件"><a href="#输出文件" class="headerlink" title="输出文件"></a>输出文件</h3><ol><li>参数方式</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cProfile</div><div class="line"><span class="keyword">import</span> re</div><div class="line">cProfile.run(<span class="string">'re.compile("foo|bar")'</span>, <span class="string">'restats'</span>)</div></pre></td></tr></table></figure><ol><li>CLI方式</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python -m cProfile [-o output_file] [-s sort_order] myscript.py</div></pre></td></tr></table></figure><h2 id="Cprofile优雅使用"><a href="#Cprofile优雅使用" class="headerlink" title="Cprofile优雅使用"></a>Cprofile优雅使用</h2><p>上述方式可以使得<code>cprofile</code>在一些测试环境中受用，但是在一些复杂的环境中不能很好的<code>work</code>。由于<code>cprofile</code>是根据<code>python</code>在每个事件中存放的<code>hook</code>进行性能分析，所以在<code>cprofile.run()</code>的时候，要保证他就是最上层，他是调用的源头。</p><p>但是实际场景中，我们经常会对一些<code>API</code>中的某个方法进行性能分析，如果在被调用处使用<code>cprofile</code>，会出现变量或者模块<code>undefined</code>的现象，模块不能识别还可以在<code>run</code>方法中引入，然后通过分号分隔，例如<code>cprofile.run(import re, re.compile(&quot;foo|bar&quot;))</code>，具体可以参考这篇文章：<a href="http://ju.outofmemory.cn/entry/46805" target="_blank" rel="external">Python Profile 工具性能分析</a></p><p>变量无法识别更是让人头疼，所以为了达到测试效果，你会不得不修改一些并不是很少量的源代码，并且测一个方法就要搞一次很麻烦。还有一些多进程或者跨机器的场景导致代码异步执行，这样<code>cprofile</code>更不能达到用户的需求</p><p>还好我们可以通过<code>python</code>装饰器的机制来做，这样既不用改动源代码，也可以很方便的切换函数分析</p><h3 id="装饰器接口"><a href="#装饰器接口" class="headerlink" title="装饰器接口"></a>装饰器接口</h3><p>这里要注意设置全局变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PROFILING=y</div></pre></td></tr></table></figure><p>接口定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cProfile</div><div class="line"><span class="keyword">import</span> pstats</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="comment"># 性能分析装饰器定义</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_cprofile</span><span class="params">(filename)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">profiled_func</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">            <span class="comment"># Flag for do profiling or not.</span></div><div class="line">            DO_PROF = os.getenv(<span class="string">"PROFILING"</span>)</div><div class="line">            <span class="keyword">if</span> DO_PROF:</div><div class="line">                profile = cProfile.Profile()</div><div class="line">                profile.enable()</div><div class="line">                result = func(*args, **kwargs)</div><div class="line">                profile.disable()</div><div class="line">                <span class="comment"># Sort stat by internal time.</span></div><div class="line">                sortby = <span class="string">"tottime"</span></div><div class="line">                ps = pstats.Stats(profile).sort_stats(sortby)</div><div class="line">                ps.dump_stats(filename)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                result = func(*args, **kwargs)</div><div class="line">            <span class="keyword">return</span> result</div><div class="line">        <span class="keyword">return</span> profiled_func</div><div class="line">    <span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure><h3 id="分析使用"><a href="#分析使用" class="headerlink" title="分析使用"></a>分析使用</h3><p>这时候只需要在调用的函数上面加一个装饰器即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@do_cprofile('filename')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></div></pre></td></tr></table></figure><h2 id="pstats分析工具"><a href="#pstats分析工具" class="headerlink" title="pstats分析工具"></a>pstats分析工具</h2><p><code>pstats</code>可以根据<code>cprofile</code>生成的文件进行排序、筛选等处理，呈现更主要的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pstats</div><div class="line"> </div><div class="line"><span class="comment"># 创建Stats对象</span></div><div class="line">p = pstats.Stats(<span class="string">"result.out"</span>)</div><div class="line"> </div><div class="line"><span class="comment"># strip_dirs(): 去掉无关的路径信息</span></div><div class="line"><span class="comment"># sort_stats(): 排序，支持的方式和上述的一致</span></div><div class="line"><span class="comment"># print_stats(): 打印分析结果，可以指定打印前几行</span></div><div class="line"> </div><div class="line"><span class="comment"># 和直接运行cProfile.run("test()")的结果是一样的</span></div><div class="line">p.strip_dirs().sort_stats(<span class="number">-1</span>).print_stats()</div><div class="line"> </div><div class="line"><span class="comment"># 按照函数名排序，只打印前3行函数的信息, 参数还可为小数,表示前百分之几的函数信息 </span></div><div class="line">p.strip_dirs().sort_stats(<span class="string">"name"</span>).print_stats(<span class="number">3</span>)</div><div class="line"> </div><div class="line"><span class="comment"># 按照运行时间和函数名进行排序</span></div><div class="line">p.strip_dirs().sort_stats(<span class="string">"cumulative"</span>, <span class="string">"name"</span>).print_stats(<span class="number">0.5</span>)</div><div class="line"> </div><div class="line"><span class="comment"># 如果想知道有哪些函数调用了sum_num</span></div><div class="line">p.print_callers(<span class="number">0.5</span>, <span class="string">"sum_num"</span>)</div><div class="line"> </div><div class="line"><span class="comment"># 查看test()函数中调用了哪些函数</span></div><div class="line">p.print_callees(<span class="string">"test"</span>)</div></pre></td></tr></table></figure><p>上述代码摘自：<a href="http://xianglong.me/article/analysis-python-application-performance-using-cProfile/" target="_blank" rel="external">使用cProfile分析Python程序性能</a>，原文还提供了<code>pstats</code>命令行交互工具方式</p><h2 id="图形可视化"><a href="#图形可视化" class="headerlink" title="图形可视化"></a>图形可视化</h2><p>上面的命令行界面的确是有点反人类，不易一下子清晰地分析性能瓶颈，有很多图形可视化工具可以帮助我们生成简洁明了的图片</p><p>工具有：</p><ul><li>gprof2dot</li><li>vprof</li><li>RunSnakeRun</li><li>KCacheGrind &amp; pyprof2calltree</li></ul><p>最终我选择了<code>gprof2dot</code>，比较符合我的口味</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我的机器是<code>ubuntu</code>，其他类型机器找对应方式，具体参考：<a href="https://github.com/jrfonseca/gprof2dot" target="_blank" rel="external">Github gprof2dot</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-get install python graphviz</div><div class="line">pip install gprof2dot</div></pre></td></tr></table></figure><p>注意：</p><p>如果<code>pip</code>安装软件包报错：’Cannot fetch index base URL  <a href="http://pypi.python.org/simple/" target="_blank" rel="external">http://pypi.python.org/simple/</a>‘</p><p>解决办法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1. windows下创建/%user%/pip/pop.ini，并添加以下内容。</div><div class="line">[global]  </div><div class="line">index-url=http://pypi.douban.com/simple/</div><div class="line">2. linux创建文件~/.pip/pip.conf，并添加一下内容。</div><div class="line">[global]  </div><div class="line">index-url=http://pypi.douban.com/simple/</div><div class="line">3. 再次使用pip安装相应的包即可。</div></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>根据<code>cpofile</code>输出的文件生成图片，这边输出的文件名为<code>osd.out</code>，生成的图片名为<code>osd.png</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gprof2dot -f pstats osd.out | dot -Tpng -o osd.png</div></pre></td></tr></table></figure><p>具体参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/24495603/" target="_blank" rel="external">Python优化第一步: 性能分析实践</a>，写的很好，也很具体</p><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p>这是我进行性能分析产生的两张图</p><p>Picture 1：</p><center><img src="http://ovv1r40we.bkt.clouddn.com/enable_osd3.png" alt="enable_osd1"></center><p>Picture 2：</p><center><img src="http://ovv1r40we.bkt.clouddn.com/enable_osd3-2.png" alt="enable_osd2"></center><h2 id="继续深入"><a href="#继续深入" class="headerlink" title="继续深入"></a>继续深入</h2><ul><li><code>pstats</code>深入了解</li><li><code>gprof2dot</code>深入了解</li><li>其他的可视化工具</li></ul><p>不过最终的目的都是通过性能分析找到性能瓶颈，然后进行优化，适合自己的就好</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ovv1r40we.bkt.clouddn.com/publicenemyno1-600x400.png&quot; alt=&quot;Python Profiler&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;code&gt;OSD&lt;/code&gt;启用过程耗时较长，需要进行性能优化。期间通过&lt;code&gt;python profilers&lt;/code&gt;对代码进行性能分析和数据统计，有坑，有收获，总而言之，这是一个不错的工具&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Profile" scheme="https://tony-yin.github.io/tags/Profile/"/>
    
      <category term="Python" scheme="https://tony-yin.github.io/tags/Python/"/>
    
      <category term="性能优化" scheme="https://tony-yin.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>启用OSD性能剖析脚本</title>
    <link href="https://tony-yin.github.io/2017/10/10/Enable-OSD-Profile-Script/"/>
    <id>https://tony-yin.github.io/2017/10/10/Enable-OSD-Profile-Script/</id>
    <published>2017-10-10T13:34:16.000Z</published>
    <updated>2017-11-22T01:36:36.295Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ovv1r40we.bkt.clouddn.com/pozza-600x450.png" alt="Profile"></center><p>针对<code>OSD</code>启用过程缓慢进行性能剖析，用到了一系列的脚本，例如批量创建<code>OSD</code>,批量启用<code>OSD</code>,<code>Cprofile</code>装饰器接口等</p><a id="more"></a><p><code>docprofile.py</code>：提供<code>cprofiler</code>的装饰器接口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cProfile</div><div class="line"><span class="keyword">import</span> pstats</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_cprofile</span><span class="params">(filename)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">profiled_func</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">            <span class="keyword">print</span> filename</div><div class="line">            <span class="comment"># Flag for do profiling or not.</span></div><div class="line">            DO_PROF = os.getenv(<span class="string">"PROFILING"</span>)</div><div class="line">            <span class="keyword">if</span> DO_PROF:</div><div class="line">                profile = cProfile.Profile()</div><div class="line">                profile.enable()</div><div class="line">                result = func(*args, **kwargs)</div><div class="line">                profile.disable()</div><div class="line">                <span class="comment"># Sort stat by internal time.</span></div><div class="line">                sortby = <span class="string">"cum"</span></div><div class="line">                ps = pstats.Stats(profile).sort_stats(sortby)</div><div class="line">                ps.dump_stats(filename)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                result = func(*args, **kwargs)</div><div class="line">            <span class="keyword">return</span> result</div><div class="line">        <span class="keyword">return</span> profiled_func</div><div class="line">    <span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure><p><code>pstat.py</code>：用于处理生成的<code>cprofiler</code>文件，做一些排序，截取和打印等工作,默认按<code>culativetime</code>排序，打印前<code>100</code>条记录，有其他需求的可以适当修改参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pstats, sys</div><div class="line">file = sys.argv[<span class="number">1</span>]</div><div class="line">p = pstats.Stats(file)</div><div class="line">p.strip_dirs().sort_stats(<span class="string">'cum'</span>).print_stats(<span class="number">100</span>)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ovv1r40we.bkt.clouddn.com/pozza-600x450.png&quot; alt=&quot;Profile&quot;&gt;&lt;/center&gt;

&lt;p&gt;针对&lt;code&gt;OSD&lt;/code&gt;启用过程缓慢进行性能剖析，用到了一系列的脚本，例如批量创建&lt;code&gt;OSD&lt;/code&gt;,批量启用&lt;code&gt;OSD&lt;/code&gt;,&lt;code&gt;Cprofile&lt;/code&gt;装饰器接口等&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Script" scheme="https://tony-yin.github.io/tags/Script/"/>
    
      <category term="OSD" scheme="https://tony-yin.github.io/tags/OSD/"/>
    
      <category term="Profile" scheme="https://tony-yin.github.io/tags/Profile/"/>
    
  </entry>
  
  <entry>
    <title>批量创建和删除磁盘分区脚本</title>
    <link href="https://tony-yin.github.io/2017/10/02/Batch-Create-And-Delete-Disk-Partition-Script/"/>
    <id>https://tony-yin.github.io/2017/10/02/Batch-Create-And-Delete-Disk-Partition-Script/</id>
    <published>2017-10-02T05:07:06.000Z</published>
    <updated>2017-12-07T04:40:52.705Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/floppy_disk_600-450.png" alt="Disk Partition"></center><p>最近在做批量启用<code>OSD</code>的性能优化，需要反复的删除磁盘分区，以保证彻底的删除数据，然后就要批量创建分区，保证足够量的分区数量创建足够多的<code>OSD</code>，由于数量较多，每次手动搞都要二十几次，所以针对创建和删除写了两个脚本，支持单一、批量和选择大小等功能</p><a id="more"></a><h2 id="清空分区"><a href="#清空分区" class="headerlink" title="清空分区"></a>清空分区</h2><h3 id="脚本名称"><a href="#脚本名称" class="headerlink" title="脚本名称"></a>脚本名称</h3><p><code>clean_disks.py</code></p><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ul><li><code>python clean_disks.py [disk_name1, disk_name2 ...]</code> </li><li>支持单磁盘和多磁盘清空</li><li>支持脚本参数，如果没有参数，默认清空所有磁盘分区，加磁盘参数则可清空指定磁盘分区, 多磁盘则累加多位磁盘参数</li><li>为了保证安全，脚本不会清空系统磁盘，脚本会做过滤工作</li></ul><h3 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h3><ul><li>清空所有磁盘分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python clean_disks.py</div></pre></td></tr></table></figure><ul><li>清空<code>sdb</code>的分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python clean_disks.py sdb</div></pre></td></tr></table></figure><ul><li>清空<code>sdb</code>和<code>sdc</code>的分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python clean_disks.py sdb sdc</div></pre></td></tr></table></figure><h3 id="脚本代码"><a href="#脚本代码" class="headerlink" title="脚本代码"></a>脚本代码</h3><blockquote><p><code>do_exec</code>是我自己写一个模块，可以调用<code>shell</code>命令，所以用的时候需要转换一下</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">import do_exec</div><div class="line"></div><div class="line">def clean_disk(disk_name):</div><div class="line">    print &apos;disk: &#123;&#125; clean start ...&apos;.format(disk_name)</div><div class="line">    do_exec(&apos;sgdisk -Zog /dev/&#123;&#125;&apos;.format(disk_name))</div><div class="line">    print &apos;disk: &#123;&#125; clean done ...&apos;.format(disk_name)</div><div class="line"></div><div class="line">mount_info = do_exec(&apos;mount&apos;)</div><div class="line">sys_disk_name = mount_info[5:8]</div><div class="line"></div><div class="line">if len(sys.argv) &gt; 1:</div><div class="line">    disks = sys.argv[1:]</div><div class="line">    for disk_name in disks:</div><div class="line">        if disk_name == sys_disk_name:</div><div class="line">            print &apos;&#123;&#125; is system disk, can\&apos;t be clean!&apos;.format(disk_name)</div><div class="line">        else:</div><div class="line">            clean_disk(disk_name)</div><div class="line">else:</div><div class="line">    all_disks = do_exec(&apos;lsblk&apos;).splitlines()</div><div class="line">    for disk in all_disks:</div><div class="line">        if (disk.startswith(&apos;sd&apos;)):</div><div class="line">            disk_name = disk.split()[0]</div><div class="line">            if disk_name != sys_disk_name:</div><div class="line">                clean_disk(disk_name)</div></pre></td></tr></table></figure><h2 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h2><h3 id="脚本名称-1"><a href="#脚本名称-1" class="headerlink" title="脚本名称"></a>脚本名称</h3><p><code>create_partitions.py</code></p><h3 id="使用说明-1"><a href="#使用说明-1" class="headerlink" title="使用说明"></a>使用说明</h3><ul><li><code>python create_partitions.py size num [disk_name1, disk_name2 ...]</code>, <code>size</code>为分区大小，<code>num</code>为分区数</li><li>支持单磁盘和多磁盘创建分区</li><li>支持脚本参数，如果没有参数，默认为所有磁盘创建分区，加磁盘参数则可清空指定磁盘分区, 多磁盘则累加多位磁盘参数</li><li>为了保证安全，脚本不会为系统磁盘创建磁盘分区，脚本会做过滤工作</li></ul><h3 id="使用范例-1"><a href="#使用范例-1" class="headerlink" title="使用范例"></a>使用范例</h3><ul><li>为<code>sdb</code>和<code>sdc</code>分别都创建两个大小为<code>100G</code>的分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python create_partitions.py 100G 2 sdb sdc</div></pre></td></tr></table></figure><ul><li>为所有磁盘创建三个大小为<code>10G</code>的分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python create_partitions.py 10G 3</div></pre></td></tr></table></figure><ul><li>为<code>sdc</code>创建四个大小为<code>1T</code>的分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python create_partitions.py 1024G 4 sdc</div></pre></td></tr></table></figure><h3 id="脚本代码-1"><a href="#脚本代码-1" class="headerlink" title="脚本代码"></a>脚本代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">import do_exec</div><div class="line"></div><div class="line">size = sys.argv[1]</div><div class="line">num = sys.argv[2]</div><div class="line">mount_info = do_exec(&apos;mount&apos;)</div><div class="line">sys_disk_name = mount_info[5:8]</div><div class="line"></div><div class="line">def parted_disks(num, size, disk):</div><div class="line">    for i in range(int(num)):</div><div class="line">        do_exec(&apos;sgdisk -n &#123;&#125;:0:+&#123;&#125; /dev/&#123;&#125;&apos;.format(i+1, size, disk))</div><div class="line">        print &apos;disk &#123;&#125; partition &#123;&#125; done ...&apos;.format(disk, i+1)</div><div class="line"></div><div class="line">if len(sys.argv) &gt; 3:</div><div class="line">    disks = sys.argv[3:]</div><div class="line">    for disk in disks:</div><div class="line">        if disk == sys_disk_name:</div><div class="line">            print &apos;&#123;&#125; is system disk, can\&apos;t be parted!&apos;.format(disk)</div><div class="line">        else:</div><div class="line">            parted_disks(num, size, disk)</div><div class="line">else:</div><div class="line">    all_disks = do_exec(&apos;lsblk&apos;).splitlines()</div><div class="line">    for disk in all_disks:</div><div class="line">        if (disk.startswith(&apos;sd&apos;)):</div><div class="line">            disk_name = disk.split()[0]</div><div class="line">            if disk_name != sys_disk_name:</div><div class="line">                parted_disks(num, size, disk)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/floppy_disk_600-450.png&quot; alt=&quot;Disk Partition&quot;&gt;&lt;/center&gt;

&lt;p&gt;最近在做批量启用&lt;code&gt;OSD&lt;/code&gt;的性能优化，需要反复的删除磁盘分区，以保证彻底的删除数据，然后就要批量创建分区，保证足够量的分区数量创建足够多的&lt;code&gt;OSD&lt;/code&gt;，由于数量较多，每次手动搞都要二十几次，所以针对创建和删除写了两个脚本，支持单一、批量和选择大小等功能&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="Disk" scheme="https://tony-yin.github.io/tags/Disk/"/>
    
      <category term="Partition" scheme="https://tony-yin.github.io/tags/Partition/"/>
    
      <category term="Script" scheme="https://tony-yin.github.io/tags/Script/"/>
    
  </entry>
  
  <entry>
    <title>JS判断对象是否为空</title>
    <link href="https://tony-yin.github.io/2017/09/28/JS-Object-Null/"/>
    <id>https://tony-yin.github.io/2017/09/28/JS-Object-Null/</id>
    <published>2017-09-28T06:01:42.000Z</published>
    <updated>2017-11-22T01:37:59.939Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/jsbanana-600-450.png" alt="JS"></center><p>今天在改代码的时候中发现一个<code>Bug</code>，通过<code>debug</code>发现最终的原因便是判断对象是否为空导致的错误，一个小小的错误反映出<code>Javascript</code>这门语言的不严谨性，也提醒我们得熟悉它的一些技巧和原理，避免经常在一些问题上踩坑</p><a id="more"></a><p>场景还原：通过<code>if(object)</code>判断对象内容不为空，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">obj = &#123;&#125;;   // obj其实是通过其他方式获得，但是它的内容为空</div><div class="line">if (obj) &#123;</div><div class="line">        xxx;    // 判断当obj不为空的时候，执行判断内的代码</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>那么问题就出现了，即使对象内容为空，这个判断代码块里面的代码还是会被执行<br>用<code>chrome</code>简单的验证了一下：</p><center><img src="http://ow0mgad6r.bkt.clouddn.com/object_empty.png" alt="object empty"></center><p>这和一些其他语言不一样，比如<code>php</code>,<code>python</code>是可以通过<code>if(object)</code>来检查对象是否为空的，但是<code>JS</code>不可以，这个问题要不是遇到了肯定想不到</p><p>那么<code>JS</code>如何判断对象内容是否为空呢？网上搜了下，大概有以下方式：</p><h3 id="通过JSON-stringify将对象转换成字符串进行判断"><a href="#通过JSON-stringify将对象转换成字符串进行判断" class="headerlink" title="通过JSON.stringify将对象转换成字符串进行判断"></a>通过JSON.stringify将对象转换成字符串进行判断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var tt = &#123;&#125;;</div><div class="line">if (JSON.stringify(tt) == &quot;&#123;&#125;&quot;) &#123;</div><div class="line">        console.log(&apos;tt is not empty!&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="通过读取对象元素"><a href="#通过读取对象元素" class="headerlink" title="通过读取对象元素"></a>通过读取对象元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var tt = &#123;&#125;;</div><div class="line">var t = &#123;id: 1&#125;;</div><div class="line">if (tt.id) &#123;</div><div class="line">        console.log(&apos;tt is not empty!&apos;);</div><div class="line">&#125; </div><div class="line">if (t.id) &#123;</div><div class="line">        console.log(&apos;t is not empty&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>方法1相对于方法2来说更加严谨，阅读性高，而方法2的效率却比方法1高</p><h3 id="jQuery提供了判断对象是否为空的API"><a href="#jQuery提供了判断对象是否为空的API" class="headerlink" title="jQuery提供了判断对象是否为空的API"></a>jQuery提供了判断对象是否为空的API</h3><p>如果用的是<code>jquery</code>的话，可以使用其提供的现有方法：<code>isEmptyObject</code>,这是<code>jQuery1.4</code>版本后加入的功能，具体用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var tt = &#123;&#125;; </div><div class="line">if ($.isEmptyObject(tt)) &#123;  // jQuery.isEmptyObject(tt)这样调用也可以</div><div class="line">        console.log(&apos;tt is empty!&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="判断对象是否存在"><a href="#判断对象是否存在" class="headerlink" title="判断对象是否存在"></a>判断对象是否存在</h3><p>借助上面的问题，顺便了解了一下：<a href="http://www.ruanyifeng.com/blog/2011/05/how_to_judge_the_existence_of_a_global_object_in_javascript.html" target="_blank" rel="external">如何判断Javascript对象是否存在</a></p><p>这篇文章里面讲的还是比较全面的，针对不同场景给出了不同的方案</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/jsbanana-600-450.png&quot; alt=&quot;JS&quot;&gt;&lt;/center&gt;

&lt;p&gt;今天在改代码的时候中发现一个&lt;code&gt;Bug&lt;/code&gt;，通过&lt;code&gt;debug&lt;/code&gt;发现最终的原因便是判断对象是否为空导致的错误，一个小小的错误反映出&lt;code&gt;Javascript&lt;/code&gt;这门语言的不严谨性，也提醒我们得熟悉它的一些技巧和原理，避免经常在一些问题上踩坑&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Javascript" scheme="https://tony-yin.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>OSD创建和删除全过程</title>
    <link href="https://tony-yin.github.io/2017/09/27/OSD-Create-And-Delete/"/>
    <id>https://tony-yin.github.io/2017/09/27/OSD-Create-And-Delete/</id>
    <published>2017-09-27T15:05:36.000Z</published>
    <updated>2017-12-07T06:21:22.794Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/5ways-facebook-600-450.png" alt="create and delete process"></center><p><code>OSD</code>是<code>Ceph</code>中最基本也是最常用的功能，所以经常的创建和删除操作少不了，然后这个两个过程并不是一两个命令那么简单，本文就<code>OSD</code>的创建和删除进行内容进行步骤分离和讲解，结尾还有一份一键删除指定<code>OSD</code>的脚本</p><a id="more"></a><h2 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h2><h3 id="创建一个OSD"><a href="#创建一个OSD" class="headerlink" title="创建一个OSD"></a>创建一个OSD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd create [uuid]   #若没有uuid参数，则该命令自动生成一个uuid。该命令产生一个新的osd-number</div></pre></td></tr></table></figure><h3 id="为新的OSD创建默认的工作目录"><a href="#为新的OSD创建默认的工作目录" class="headerlink" title="为新的OSD创建默认的工作目录"></a>为新的OSD创建默认的工作目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir -p /var/lib/ceph/osd/ceph-&#123;osd-number&#125;</div></pre></td></tr></table></figure><h3 id="为新的OSD准备一块磁盘"><a href="#为新的OSD准备一块磁盘" class="headerlink" title="为新的OSD准备一块磁盘"></a>为新的OSD准备一块磁盘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkfs.xfs -f /dev/vde </div><div class="line">mount /dev/vde /var/lib/ceph/osd/ceph-&#123;osd-number&#125;</div></pre></td></tr></table></figure><h3 id="初始化新的OSD工作目录"><a href="#初始化新的OSD工作目录" class="headerlink" title="初始化新的OSD工作目录"></a>初始化新的OSD工作目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-osd -i &#123;osd-number&#125; --mkfs --mkkey</div></pre></td></tr></table></figure><blockquote><p> 注意：在执行上述命令前要求新的OSD工作目录必须为空</p></blockquote><h3 id="注册新的OSD认证密钥"><a href="#注册新的OSD认证密钥" class="headerlink" title="注册新的OSD认证密钥"></a>注册新的OSD认证密钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph auth add osd.&#123;osd-number&#125; osd &apos;allow *&apos; mon &apos;allow rwx&apos; -i /var/lib/ceph/osd/ceph-&#123;osd-number&#125;/keyring</div></pre></td></tr></table></figure><h3 id="将新的OSD添加到Crush-Map中"><a href="#将新的OSD添加到Crush-Map中" class="headerlink" title="将新的OSD添加到Crush Map中"></a>将新的OSD添加到Crush Map中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd crush add osd.&#123;osd-number&#125; &#123;weight&#125; [&#123;bucketype&#125;=&#123;bucket-name&#125;......&#125;</div></pre></td></tr></table></figure><p>此步骤也可以添加buckets后再添加osd，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ceph osd crush add-bucket node5 host     #创建一个名字为node5的bucket</div><div class="line">ceph osd crush move node5 root=default    #将创建出来的bucket放到root下</div><div class="line">ceph osd crush create-or-move osd.&#123;osd-number&#125; 1.0 root=default host=node5     #将新的OSD添加到node5下</div></pre></td></tr></table></figure><h3 id="将新的OSD信息填写到ceph-conf中"><a href="#将新的OSD信息填写到ceph-conf中" class="headerlink" title="将新的OSD信息填写到ceph.conf中"></a>将新的OSD信息填写到ceph.conf中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[osd.&#123;osd-number&#125;]</div><div class="line">host = &#123;hostname&#125;</div><div class="line">devs = /dev/vde</div></pre></td></tr></table></figure><h3 id="启动新的OSD"><a href="#启动新的OSD" class="headerlink" title="启动新的OSD"></a>启动新的OSD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/ceph start osd.&#123;osd-number&#125;</div></pre></td></tr></table></figure><blockquote><p>此时通过集群状态查看命令#ceph -s可以看到OSD数量以及up和in的数量都发生了变化，此时再通过命令#ceph -w可以看到ceph经过peering状态后，最终达到active+clean状态</p></blockquote><h2 id="一键创建OSD脚本"><a href="#一键创建OSD脚本" class="headerlink" title="一键创建OSD脚本"></a>一键创建OSD脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">#! /bin/bash</div><div class="line"></div><div class="line">start_time=`date +%s`</div><div class="line"></div><div class="line">echo &quot;start time: `date -d @$start_time &quot;+%Y-%m-%d %H:%M:%S&quot;`&quot;</div><div class="line"></div><div class="line">disk=/dev/$1</div><div class="line"></div><div class="line">osd_id=`ceph osd create`</div><div class="line"></div><div class="line">osd_dir=/data/osd.$osd_id</div><div class="line"></div><div class="line">host=10.16.100.99</div><div class="line"></div><div class="line">bucket=default_$host</div><div class="line"></div><div class="line">echo &quot;osd $osd_id is created ...&quot;</div><div class="line"></div><div class="line">mkdir -p $osd_dir</div><div class="line"></div><div class="line">echo &quot;osd directory: /data/osd.$osd_id is created ...&quot;</div><div class="line"></div><div class="line">mkfs -t ext4 -m 0 $disk</div><div class="line"></div><div class="line">echo &quot;disk $disk is built with ext4 file system ...&quot;</div><div class="line"></div><div class="line">mount -o noatime,user_xattr $disk $osd_dir</div><div class="line"></div><div class="line">echo &quot;device: $disk is mounted on directory: $osd_dir ...&quot;</div><div class="line"></div><div class="line">ceph mon getmap -o /tmp/monmap</div><div class="line"></div><div class="line">ceph-osd -i $osd_id --monmap /tmp/monmap --mkfs --mkjournal</div><div class="line"></div><div class="line">echo &quot;osd $osd_id is initialized ...&quot;</div><div class="line"></div><div class="line">osd_uuid=`ceph-osd -i $osd_id --get-osd-fsid`</div><div class="line"></div><div class="line">cat &gt;&gt; /etc/ceph/ceph.conf &lt;&lt;EOF</div><div class="line"></div><div class="line">[osd.$osd_id]</div><div class="line">host = $host</div><div class="line">public addr = $host</div><div class="line">cluster addr = $host</div><div class="line">osd uuid = $osd_uuid</div><div class="line">EOF</div><div class="line"></div><div class="line">echo &apos;ceph config file is configured ...&apos;</div><div class="line"></div><div class="line">service ceph start osd.$osd_id</div><div class="line"></div><div class="line">echo &quot;osd $osd_id start ...&quot;</div><div class="line"></div><div class="line">ceph osd crush add $osd_id 0 pool=default host=$bucket</div><div class="line"></div><div class="line">echo &quot;osd $osd_id is added in crush ...&quot;</div><div class="line"></div><div class="line">echo &apos;all works done ...&apos;</div><div class="line"></div><div class="line">end_time=`date +%s`</div><div class="line"></div><div class="line">echo &quot;end time: `date -d @$end_time &quot;+%Y-%m-%d %H:%M:%S&quot;`&quot;</div><div class="line"></div><div class="line">time_consuming=$(($end_time - $start_time))</div><div class="line"></div><div class="line">echo &quot;The total time consuming is $time_consuming s&quot;</div></pre></td></tr></table></figure><h2 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h2><h3 id="将需要删除的OSD在集群中的状态修改为out状态"><a href="#将需要删除的OSD在集群中的状态修改为out状态" class="headerlink" title="将需要删除的OSD在集群中的状态修改为out状态"></a>将需要删除的OSD在集群中的状态修改为out状态</h3><p>假定<code>osd</code>的<code>id</code>为<code>1</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd out osd.1</div></pre></td></tr></table></figure><h3 id="停止OSD进程"><a href="#停止OSD进程" class="headerlink" title="停止OSD进程"></a>停止OSD进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/ceph stop osd.1</div></pre></td></tr></table></figure><h3 id="将OSD从crush-map中删除"><a href="#将OSD从crush-map中删除" class="headerlink" title="将OSD从crush map中删除"></a>将OSD从crush map中删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ceph osd crush remove osd.1    #删除指定的OSD</div><div class="line">ceph osd crush remove node1    #删除OSD所在的bucket（此步骤可以不做）</div></pre></td></tr></table></figure><h3 id="清除到OSD的认证密钥"><a href="#清除到OSD的认证密钥" class="headerlink" title="清除到OSD的认证密钥"></a>清除到OSD的认证密钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph auth del osd.1</div></pre></td></tr></table></figure><h3 id="在OSD-Map中清除OSD"><a href="#在OSD-Map中清除OSD" class="headerlink" title="在OSD Map中清除OSD"></a>在OSD Map中清除OSD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd rm 1</div></pre></td></tr></table></figure><h3 id="从ceph-conf中清除OSD"><a href="#从ceph-conf中清除OSD" class="headerlink" title="从ceph.conf中清除OSD"></a>从ceph.conf中清除OSD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[osd.1]</div><div class="line">    host = &#123;hostname&#125;</div><div class="line">    ...</div></pre></td></tr></table></figure><h2 id="一键删除OSD脚本"><a href="#一键删除OSD脚本" class="headerlink" title="一键删除OSD脚本"></a>一键删除OSD脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#! /bin/bash</div><div class="line"></div><div class="line">osd_id=$1</div><div class="line">ceph osd out osd.$osd_id</div><div class="line">/etc/init.d/ceph stop osd.$osd_id</div><div class="line">ceph osd crush remove osd.$osd_id</div><div class="line">ceph auth del osd.$osd_id</div><div class="line">ceph osd rm $osd_id</div><div class="line"># 清空 ceph.conf</div></pre></td></tr></table></figure><p>参考链接：</p><blockquote><p><a href="https://my.oschina.net/linuxhunter/blog/539312" target="_blank" rel="external">https://my.oschina.net/linuxhunter/blog/539312</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/5ways-facebook-600-450.png&quot; alt=&quot;create and delete process&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;code&gt;OSD&lt;/code&gt;是&lt;code&gt;Ceph&lt;/code&gt;中最基本也是最常用的功能，所以经常的创建和删除操作少不了，然后这个两个过程并不是一两个命令那么简单，本文就&lt;code&gt;OSD&lt;/code&gt;的创建和删除进行内容进行步骤分离和讲解，结尾还有一份一键删除指定&lt;code&gt;OSD&lt;/code&gt;的脚本&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="Ceph" scheme="https://tony-yin.github.io/tags/Ceph/"/>
    
      <category term="OSD" scheme="https://tony-yin.github.io/tags/OSD/"/>
    
  </entry>
  
  <entry>
    <title>如何打造一个好的产品</title>
    <link href="https://tony-yin.github.io/2017/09/21/How-To-Forge-Product/"/>
    <id>https://tony-yin.github.io/2017/09/21/How-To-Forge-Product/</id>
    <published>2017-09-21T05:57:34.000Z</published>
    <updated>2017-11-21T15:43:09.215Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/product-600-450.jpg" alt="product"></center><p>今天<code>BOSS</code>带来一个曾经的得力干将。目前是腾讯一家游戏公司的老总，职位为<code>Producer</code>，在产品方面分享很多观点，受益匪浅。下面是分享过程中我总结的一些自己觉得正确的观点和心得</p><blockquote><p>虽热目前我是一个只负责敲代码的程序猿，产品这种事情好像跟我没多大关系，应该是产品经理的事情，但是其实一个<code>coder</code>想要进步，不仅仅是技术水平越来越强，对产品的理解也非常重要。这能理清自己逻辑，能够发散思维，能够帮你做出更好的产品，你开发出一个没人用的产品和一个上线客户量很大的产品对你自己来说无论是成就感还是技术提升都是天壤之别。也许未来我们可能也会创业，那到时候我们的职责可能是老板，可能是产品，可能是研发，更可能是各种职能集一身，对产品拥有良好理解和恰当的打磨技巧对我们来说都是宝贵的财富。</p></blockquote><a id="more"></a><h2 id="技能心态"><a href="#技能心态" class="headerlink" title="技能心态"></a>技能心态</h2><h3 id="工作强度"><a href="#工作强度" class="headerlink" title="工作强度"></a>工作强度</h3><p><code>BAT</code>加班不比任何一家中小公司少，腾讯一直把自己当做创业型公司，时刻保持压力和紧张感，这或许是其成功的一个很重要的原因（意料之外，之前没想到<code>BAT</code>工作强度这么大）</p><h3 id="不用过多的Design"><a href="#不用过多的Design" class="headerlink" title="不用过多的Design"></a>不用过多的Design</h3><p>因为没有一个产品可以凭借设计文档一步到位的，几乎每个成功的产品都和原来的设计有着天壤之别（仁者见仁，智者见智，把握一个度吧，没必要死扣设计为了最完美化而浪费大量的时间）</p><h3 id="没有具体的Deadline"><a href="#没有具体的Deadline" class="headerlink" title="没有具体的Deadline"></a>没有具体的Deadline</h3><p>每天都是<code>Deadline</code>，每天规定的任务做好了再回去</p><h3 id="谁的声音大听谁的"><a href="#谁的声音大听谁的" class="headerlink" title="谁的声音大听谁的"></a>谁的声音大听谁的</h3><p>不要在内部为了争执一个方案纠结和浪费太多时间，谁的声音大听谁的，因为这绝不是最后一次修改（有性格）</p><h3 id="产品是每个人的"><a href="#产品是每个人的" class="headerlink" title="产品是每个人的"></a>产品是每个人的</h3><p>一个人不应该被他的职位所局限，产品团队中的每个人都应该为这个产品在设计、宣传和包装等方面提意见</p><h3 id="Just-Do-It"><a href="#Just-Do-It" class="headerlink" title="Just Do It"></a>Just Do It</h3><p>很多事情自己不做一下是不知道的，很多行为看起来很low，不符合你的职位，但是只有真正去做了，才代表走过这条路，你才知道这条路可不可行，还有哪些其他路可以尝试（那位大佬制作某款卡牌游戏时，自己找了同类<code>50</code>多种游戏都玩了一遍，而且都玩到了很<code>6</code>的地步，用他的话说最后玩到吐。。。）</p><h3 id="相信自己的潜力"><a href="#相信自己的潜力" class="headerlink" title="相信自己的潜力"></a>相信自己的潜力</h3><p>永远不要觉得自己是做技术的，所以理所当然<code>UI</code>不擅长，宣传不擅长，包装不擅长，做一行就要把自己的头埋进去，逼着自己不断尝试，慢慢可能会发现自己做的不错（他们经常会亲自去<code>QQ</code>群、贴吧和其他社交平台宣传，我去，托这种事原来真的存在）</p><h3 id="学会成熟"><a href="#学会成熟" class="headerlink" title="学会成熟"></a>学会成熟</h3><p>对很多事情都要慢慢做到心里有底，比如清楚上线必有<code>Bug</code>，设计必会被颠覆（他说上线没问题他会很慌。。。）</p><h3 id="明确最终目的"><a href="#明确最终目的" class="headerlink" title="明确最终目的"></a>明确最终目的</h3><p>要明确做产品，开发等工作的目的不是按时完成任务，而是要把产品做起来，最终目的是赚钱，这样你做其他类型的事情就可以想明白很多，有时候开发并不一定是最优先最重要的，植物，但是作为一个开发经历了这些事情你的思维会不一样，做事方向也会不一样</p><h3 id="观察用户习惯"><a href="#观察用户习惯" class="headerlink" title="观察用户习惯"></a>观察用户习惯</h3><p>可以尝试花钱请人来使用产品，内部开发人员在背后观察它的使用习惯，不轻易提示</p><h3 id="用数据说话"><a href="#用数据说话" class="headerlink" title="用数据说话"></a>用数据说话</h3><p>当产品上线后，通过数据采集和分析，哪个页面或者操作用户比较感兴趣，哪一步开始用户量变少，出现这种情况，可以尝试做几个版本，然后让用户使用，选择最优的方案（在这个环节不以职位高低说话，完全靠数据评断）</p><h3 id="要相信自己的技术"><a href="#要相信自己的技术" class="headerlink" title="要相信自己的技术"></a>要相信自己的技术</h3><p>相信自己可以实现用户提的所有需求，当你全身心投入一件事的时候，手段很多，解决的方案也很多，比如这位大佬述说他收集一款游戏的同类游戏的经历，收集渠道除了iOS的还有android的，还有韩国市场的，还有模拟器的，还有页游等等（只有想不到，没有做不到）</p><h3 id="抄袭不丢脸"><a href="#抄袭不丢脸" class="headerlink" title="抄袭不丢脸"></a>抄袭不丢脸</h3><p>互联网产品从<code>0</code>到<code>1</code>很少很少，大家在做一个产品之前都会看看同类产品怎么做的，然后学习每个产品中的精华部分，这个说直接一点就是抄袭，但是不要因为这个觉得丢脸，因为抄袭容易，抄袭得好并不容易（谈到腾讯，大家都会因为<strong>抄袭</strong>而骂声不绝，但是静下想想这的确是个正常套路，一切为了快速出产品）</p><h3 id="不要害怕被告"><a href="#不要害怕被告" class="headerlink" title="不要害怕被告"></a>不要害怕被告</h3><p>等哪天你某些方面抄袭别人的，导致被告，那么说明你已经做大了，产品在某个方面来说已经相当成功了</p><h3 id="被骂是极好的"><a href="#被骂是极好的" class="headerlink" title="被骂是极好的"></a>被骂是极好的</h3><p>很多时候，用户会因为产品一些蹩脚的地方而骂声不断，这时候不要觉得丢脸或者懊恼，相反应该开心，因为很多时候别人愿意骂你说明很大程度上还是很喜欢这个产品的，而真正不喜欢的懒得留下评论</p><h2 id="产品本身"><a href="#产品本身" class="headerlink" title="产品本身"></a>产品本身</h2><h3 id="快速出Demo"><a href="#快速出Demo" class="headerlink" title="快速出Demo"></a>快速出Demo</h3><p>以上说的不用过多<code>Design</code>也好，还是不要过分争执也好，都是为了尽快做出一个产品<code>Demo</code>，就是最起码可以一个<code>work</code>的东西，这很重要，一旦<code>work</code>之后很多想法就会不一样了，他们往往两个星期出一个<code>Demo</code>，这对他们<code>UI</code>来说很有挑战，因为一般设计就要一个星期，然后原型图又是一个星期，但是两个星期就得弄出来，不管是借鉴别人的也好，还是网上买模板也好</p><h3 id="不用太完善"><a href="#不用太完善" class="headerlink" title="不用太完善"></a>不用太完善</h3><p>快速做出来不是说实现所有功能和面面俱到，而是可以做到静态页面或者是设计图去找用户，询问他们的观点和建议，这样既可以缩短时间，也可以通过询问客户的意见走向正确的道路，避免不必要的返工</p><h3 id="尽快让产品上线"><a href="#尽快让产品上线" class="headerlink" title="尽快让产品上线"></a>尽快让产品上线</h3><p>产品上线和不上线是天壤之别，因为自己内部永远是在想当然，而客户的反馈才是最重要的，这样才会往正确的方向不断迭代</p><h3 id="永远不要给用户看到错误信息"><a href="#永远不要给用户看到错误信息" class="headerlink" title="永远不要给用户看到错误信息"></a>永远不要给用户看到错误信息</h3><p>能解决的让系统自己解决，不能解决的人工处理，不要太<strong>实诚</strong>，否则用户会感觉到惊恐</p><h3 id="不要给用户太多选择"><a href="#不要给用户太多选择" class="headerlink" title="不要给用户太多选择"></a>不要给用户太多选择</h3><p>如果一个页面存在两个按钮让用户点击，<code>80%</code>的用户会点<code>A</code>按钮，<code>20%</code>的用户会点<code>B</code>按钮，那么页面就显示一个<code>A</code>按钮就好了，只要保证<code>B</code>按钮能够在页面其他地方能找到就可以了，太多选择会让用户心里没底自己选择的对不对（相信大家脑海里都会浮现某个用户做完一个操作询问对不对的场景吧？）</p><h3 id="数字必有颜色"><a href="#数字必有颜色" class="headerlink" title="数字必有颜色"></a>数字必有颜色</h3><p>这是一个约定俗成的习惯，保证页面的数字有合适的颜色，让用户一眼就能看到最想呈现的元素</p><h3 id="科技感很重要"><a href="#科技感很重要" class="headerlink" title="科技感很重要"></a>科技感很重要</h3><p>要让页面充满科技感，让别人觉得这是一家充满互联网气息的新公司，第一印象好</p><h3 id="恰当的图标"><a href="#恰当的图标" class="headerlink" title="恰当的图标"></a>恰当的图标</h3><p>图标选择要有意义，凸出按钮的作用</p><h3 id="恰当的名词"><a href="#恰当的名词" class="headerlink" title="恰当的名词"></a>恰当的名词</h3><p>用词准备具体，不要让用户去猜，比如下载就是下载，不要说保存</p><h3 id="易懂高大上的名词"><a href="#易懂高大上的名词" class="headerlink" title="易懂高大上的名词"></a>易懂高大上的名词</h3><p>用词不要太专业，这样会让用户不明白，可以高大上一些，比如远程数据复制可以叫云复制</p><h3 id="抓住用户的期望"><a href="#抓住用户的期望" class="headerlink" title="抓住用户的期望"></a>抓住用户的期望</h3><p>产品介绍要突出用户最期望的东西，而不是过分强调技术上面的高档，这不是客户最期望的东西，比如存储你与其说内部实现机制怎么分片，怎么自动控制，不如和用户说我能保证多少数据量的存储，能保证永远不会因为故障丢失数据，能存储多长时间等等</p><h3 id="调节气氛的话语"><a href="#调节气氛的话语" class="headerlink" title="调节气氛的话语"></a>调节气氛的话语</h3><p>多用网络诙谐的话语进行提示，比如亲，朕等等，这样会舒畅用户的心情</p><p>作者： Tony<br>日期： 2017/09/19</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/product-600-450.jpg&quot; alt=&quot;product&quot;&gt;&lt;/center&gt;

&lt;p&gt;今天&lt;code&gt;BOSS&lt;/code&gt;带来一个曾经的得力干将。目前是腾讯一家游戏公司的老总，职位为&lt;code&gt;Producer&lt;/code&gt;，在产品方面分享很多观点，受益匪浅。下面是分享过程中我总结的一些自己觉得正确的观点和心得&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虽热目前我是一个只负责敲代码的程序猿，产品这种事情好像跟我没多大关系，应该是产品经理的事情，但是其实一个&lt;code&gt;coder&lt;/code&gt;想要进步，不仅仅是技术水平越来越强，对产品的理解也非常重要。这能理清自己逻辑，能够发散思维，能够帮你做出更好的产品，你开发出一个没人用的产品和一个上线客户量很大的产品对你自己来说无论是成就感还是技术提升都是天壤之别。也许未来我们可能也会创业，那到时候我们的职责可能是老板，可能是产品，可能是研发，更可能是各种职能集一身，对产品拥有良好理解和恰当的打磨技巧对我们来说都是宝贵的财富。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="summary" scheme="https://tony-yin.github.io/categories/summary/"/>
    
    
      <category term="产品" scheme="https://tony-yin.github.io/tags/%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>PHP-Excel 开发解决方案</title>
    <link href="https://tony-yin.github.io/2017/09/18/PHP-Excel/"/>
    <id>https://tony-yin.github.io/2017/09/18/PHP-Excel/</id>
    <published>2017-09-18T10:37:28.000Z</published>
    <updated>2017-09-20T11:50:15.000Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://ow0mgad6r.bkt.clouddn.com/office-card-game.png" alt="office"></center><p> 过去工作中使用<code>PHPExcel</code>较多，碰到并解决了各种大大小小的问题，总结出这样一篇文章，一方面记录自己踩过的坑，一方面与大家分享，让大家少走弯路，并不断完善之，欢迎大家去<code>github</code>上面<code>star</code>和提交<code>pull request</code>，不断补充和优化，打造最全面的<code>PHPExcel</code>开发解决方案</p><p>Github 地址：<a href="https://github.com/tony-yin/PHPExcel_Road" target="_blank" rel="external">https://github.com/tony-yin/PHPExcel_Road</a><br>原文地址：<a href="https://tony-yin.github.io/2017/09/18/PHP-Excel/">https://tony-yin.github.io/2017/09/18/PHP-Excel/</a></p><a id="more"></a><h2 id="基础：小试牛刀"><a href="#基础：小试牛刀" class="headerlink" title="基础：小试牛刀"></a>基础：小试牛刀</h2><h3 id="1-引用文件"><a href="#1-引用文件" class="headerlink" title="1. 引用文件"></a>1. 引用文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yourpath . /phpexcel/PHPExcel.php</div></pre></td></tr></table></figure><h3 id="2-实例化phpexcel类"><a href="#2-实例化phpexcel类" class="headerlink" title="2. 实例化phpexcel类"></a>2. 实例化phpexcel类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$excel = new PHPExcel();</div></pre></td></tr></table></figure><h3 id="3-获取当前单sheet（多sheet会在下面讲）"><a href="#3-获取当前单sheet（多sheet会在下面讲）" class="headerlink" title="3. 获取当前单sheet（多sheet会在下面讲）"></a>3. 获取当前单sheet（多sheet会在下面讲）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$objexcel = $excel-&gt;getActiveSheet();</div></pre></td></tr></table></figure><h3 id="4-合并单元格"><a href="#4-合并单元格" class="headerlink" title="4. 合并单元格"></a>4. 合并单元格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$objexcel-&gt;mergeCells(&apos;A1:M1&apos;);</div></pre></td></tr></table></figure><h3 id="5-获取一个cell的样式"><a href="#5-获取一个cell的样式" class="headerlink" title="5. 获取一个cell的样式"></a>5. 获取一个cell的样式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$objexcel-&gt;getStyle(&apos;A1&apos;);</div></pre></td></tr></table></figure><ul><li>获取一个cell的字体样式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$cellFont = $objexcel-&gt;getStyle(&apos;A1&apos;)-&gt;getFont();</div></pre></td></tr></table></figure><ul><li>设置字体大小</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$fontStyle-&gt;setSize(15);</div></pre></td></tr></table></figure><ul><li>设置字体是否加粗</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$fontStyle-&gt;setBold(true);</div></pre></td></tr></table></figure><ul><li>设置字体颜色</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$fontStyle-&gt;getColor()-&gt;setARGB(PHPExcel_Style_Color::COLOR_RED);</div></pre></td></tr></table></figure><ul><li>获取一行样式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$rowStyle = $objexcel-&gt;getStyle(1)-&gt;getRowDimension();</div></pre></td></tr></table></figure><ul><li>设置行高度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$rowStyle-&gt;setRowHeight(2);</div></pre></td></tr></table></figure><ul><li>获取一列样式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$columnStyle = $objexcel-&gt;getStyle(&apos;A&apos;)-&gt;getColumnDimension();</div></pre></td></tr></table></figure><ul><li>设置列宽度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$columnStyle-&gt;setWidth(10);</div></pre></td></tr></table></figure><ul><li>获取一列对齐样式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$alignStyle = $objexcel-&gt;getStyle(&apos;A&apos;)-&gt;getAlignment();</div></pre></td></tr></table></figure><ul><li>设置水平居中：同一水平线上居中，即为左右的中间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$alignStyle&gt;setHorizontal(PHPExcel_Style_Alignment::HORIZONTAL_CENTER);</div></pre></td></tr></table></figure><ul><li>设置垂直居中：同一垂直线居中，即为上下的中间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$alignStyle-&gt;setVertical(PHPExcel_Style_Alignment::VERTICAL_CENTER);</div></pre></td></tr></table></figure><ul><li>自动换行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$alignStyle-&gt;setWrapText(true);</div></pre></td></tr></table></figure><h3 id="6-获取指定版本excel写对象"><a href="#6-获取指定版本excel写对象" class="headerlink" title="6. 获取指定版本excel写对象"></a>6. 获取指定版本excel写对象</h3><p>如需更早的版本可将<code>Excel2007</code>换成<code>Excel5</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$write = PHPExcel_IOFactory::createWriter(&quot;xcel, &apos;Excel2007&apos;);</div></pre></td></tr></table></figure></p><h2 id="进阶：一些有用的小知识"><a href="#进阶：一些有用的小知识" class="headerlink" title="进阶：一些有用的小知识"></a>进阶：一些有用的小知识</h2><h3 id="1-行列数字索引方法"><a href="#1-行列数字索引方法" class="headerlink" title="1.行列数字索引方法"></a>1.行列数字索引方法</h3><blockquote><p><code>phpexcel</code>一般获取<code>cell</code>或者获取列都是通过<code>ABC</code>这样的英文字母获取的，它也可以通过<code>0、1、2、3</code>这样的数字表示sheet中的列，从<code>0</code>开始，<code>0</code>对应<code>A</code>，<code>1</code>对应<code>B</code>，基本上大多数方法都是数字行列索引，例如<code>getStyleByColumnAndRow($col,$row)</code>,默认列参数在前，行参数在后，更多的可以参加<code>phpexcel</code>源码；</p></blockquote><h3 id="2-单行或单列参数格式"><a href="#2-单行或单列参数格式" class="headerlink" title="2. 单行或单列参数格式"></a>2. 单行或单列参数格式</h3><blockquote><p>有的时候一个方法需要行列两个参数，例如只需要某一行参数可写成<code>(null, $row)</code>,例如只需要获得某一列参数可写成<code>($col, null)</code></p></blockquote><h3 id="3-列的数字索引格式和字母索引格式互转"><a href="#3-列的数字索引格式和字母索引格式互转" class="headerlink" title="3. 列的数字索引格式和字母索引格式互转"></a>3. 列的数字索引格式和字母索引格式互转</h3><ul><li>数字转字符串</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PHPExcel_Cell::columnIndexFromString(<span class="string">'A'</span>);  <span class="comment">// Return 1 not 0;</span></div></pre></td></tr></table></figure><ul><li>字符串转数字</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PHPExcel_Cell::stringFromColumnIndex(<span class="number">0</span>);    <span class="comment">// Return 'A';</span></div></pre></td></tr></table></figure><h3 id="4-PHPExcel读取数字类型"><a href="#4-PHPExcel读取数字类型" class="headerlink" title="4.PHPExcel读取数字类型"></a>4.PHPExcel读取数字类型</h3><blockquote><p><code>PHPExcel</code>读取的<code>cell</code>数字，类型都是<code>double</code>型，可用<code>gettyle()</code>方法检测类型，当初我一直使用<code>is_int()</code>方法无果，搞得焦头烂额。。。</p></blockquote><h3 id="5-多cell边框线设置"><a href="#5-多cell边框线设置" class="headerlink" title="5. 多cell边框线设置"></a>5. 多cell边框线设置</h3><p><code>PHPExcel</code>生成的表格如果你不加处理，是不会帮你生成边框线的，生成边框线的方法如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$borderArray = <span class="keyword">array</span>(</div><div class="line">    <span class="string">'borders'</span> =&gt; <span class="keyword">array</span>(</div><div class="line">        <span class="string">'allborders'</span> =&gt; <span class="keyword">array</span>(</div><div class="line">            <span class="string">'style'</span> =&gt; PHPExcel_Style_Border::BORDER_THIN</div><div class="line">        )</div><div class="line">    )</div><div class="line">);</div><div class="line">$objexcel-&gt;getStyle($col1, $row1,$col2, $row2)-&gt;applyFromArray($borderArray);</div></pre></td></tr></table></figure></p><blockquote><p>注：<br>1: <code>getStyle()</code>可以看需求改为<code>getStyleByColumnAndRow()</code>方法通过数字行列索引读取<code>style</code><br>2: array中<code>PHPExcel_Style_Border::</code>后面有三种格式分别是<code>BORDER_THIN</code>和<code>BORDR_MEDIUM</code>，表示边框线的粗细；<br>3: <code>getStyle()</code>中的索引可以是静态的，也可以是动态的，一般是在导出<code>excel</code>的数据<code>set</code>完毕后填写左上角的单元格行列索引和右下角的单元格行列索引；</p><p>参考资料</p><p><a href="http://phpexcel.codeplex.com/workitem/22160" target="_blank" rel="external">http://phpexcel.codeplex.com/workitem/22160</a><br><a href="http://phpexcel.codeplex.com/workitem/20150" target="_blank" rel="external">http://phpexcel.codeplex.com/workitem/20150</a></p></blockquote><h3 id="6-多cell字体加粗处理"><a href="#6-多cell字体加粗处理" class="headerlink" title="6. 多cell字体加粗处理"></a>6. 多cell字体加粗处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$objexcel-&gt;getStyle($pCoordinate)-&gt;applyFromArray(array(</div><div class="line">    &apos;font&apos; =&gt; array(  </div><div class="line">        &apos;bold&apos; =&gt; true,                                              </div><div class="line">    ),                                                               </div><div class="line">));</div></pre></td></tr></table></figure><h3 id="7-多cell字体颜色处理"><a href="#7-多cell字体颜色处理" class="headerlink" title="7. 多cell字体颜色处理"></a>7. 多cell字体颜色处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$objexcel-&gt;getStyle($pCoordinate)-&gt;applyFromArray(array(</div><div class="line">    &apos;font&apos; =&gt; array(</div><div class="line">        &apos;color&apos; =&gt; array(</div><div class="line">            &apos;rgb&apos; =&gt; &apos;ff0000&apos;,</div><div class="line">            ),</div><div class="line">        ),</div><div class="line">    )</div><div class="line">);</div></pre></td></tr></table></figure><h3 id="8-多sheet导入"><a href="#8-多sheet导入" class="headerlink" title="8. 多sheet导入"></a>8. 多sheet导入</h3><p>动态为当前<code>sheet</code>设置索引，然后获取当前<code>sheet</code>，便可循环读取每一个<code>sheet</code>内容</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$objexcel-&gt;setActiveSheetIndex($index);   <span class="comment">//$index = 0 1 2 3</span></div><div class="line">$objexcel-&gt;getActiveSheet();    <span class="comment">//return sheet1 sheet2 sheet 3</span></div></pre></td></tr></table></figure><h3 id="9-固定格式excel读取在写入"><a href="#9-固定格式excel读取在写入" class="headerlink" title="9. 固定格式excel读取在写入"></a>9. 固定格式excel读取在写入</h3><blockquote><p>当需求是给定一个一个模板<code>excel</code>，需要往里面塞数据，我们不一定要通过代码给它设定样式，如果这个模板变化不大，我们完全可以存放一个格式相同的静态文件，然后通过<code>PHPExcel</code>读取，再往里面塞数据，最后进行保存操作，可以达到一样的效果，并且可以节省大量的资源。</p></blockquote><h3 id="10-合并单元格导入问题"><a href="#10-合并单元格导入问题" class="headerlink" title="10. 合并单元格导入问题"></a>10. 合并单元格导入问题</h3><blockquote><p>在特殊的表格中，合并单元格普遍存在，而多个单元格合并成的一个单元格，只能<code>setValue()</code>一次，而我们如何判断合并单元格的具体行列呢？</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$range = $start_cell-&gt;getMergeRange();  <span class="comment">// 通过合并单元格的开始单元格比如‘A1’，获取合并范围‘A1:A4’</span></div><div class="line">$cell-&gt;isInRange($range);    <span class="comment">// 遍历之后每一个单元格便可通过isInRange()方法判断当前单元格是否在合并范围内</span></div></pre></td></tr></table></figure><h2 id="高级：特殊场景特殊手段"><a href="#高级：特殊场景特殊手段" class="headerlink" title="高级：特殊场景特殊手段"></a>高级：特殊场景特殊手段</h2><h3 id="1-单元格文本格式数据处理"><a href="#1-单元格文本格式数据处理" class="headerlink" title="1. 单元格文本格式数据处理"></a>1. 单元格文本格式数据处理</h3><blockquote><p>一般excel单元格中数据的格式为数据类型，而<code>PHPExcel</code>中的<code>getValue()</code>方法读取的也是数据类型，当把数据从数据类型改为文本类型后，在<code>PHPExcel</code>中读出来的是<code>PHPExcel_RichText</code>类型，<code>getValue()</code>读取返回<code>PHPExcel_RichText</code>是一个<code>object</code>类型（<code>PHPExcel_RichText</code>数据保存格式）；那如何读取这一类的数据呢？仔细查看读取出来的对象，不难发现有<code>getPlainText()</code>这样的方法可以读取文本类型数据，所以我们只要判断当当前数据为文本数据时用<code>getPlainText()</code>读取，一般数据用<code>getValue()</code>读取</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ($cell-&gt;getValue() <span class="keyword">instanceof</span> PHPExcel_RichText) &#123;</div><div class="line">    $value = $cell-&gt;getValue();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    $value = $cell-&gt;getValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>参考资料</p><p><a href="http://www.cnblogs.com/DS-CzY/p/4955655.html" target="_blank" rel="external">http://www.cnblogs.com/DS-CzY/p/4955655.html</a><br><a href="http://phpexcel.codeplex.com/discussions/34513" target="_blank" rel="external">http://phpexcel.codeplex.com/discussions/34513</a></p></blockquote><h3 id="2-单元格数据算法处理"><a href="#2-单元格数据算法处理" class="headerlink" title="2. 单元格数据算法处理"></a>2. 单元格数据算法处理</h3><blockquote><p><code>excel</code>拥有强大的算法功能，一般算法格式为<code>=A3+A4</code>这类的，复杂的更多，如果使用<code>PHPExcel</code>提供的默认读取方法<code>getValue()</code>读取出来的结果则为字符串<code>=A3+A4</code>,好在<code>PHPExcel</code>也足够强大，提供了相应的接口：<code>getCalculatedValue()</code>，这个方法专门读取算法数据，但是我们不能将这个方法作为默认读取方法，因为这样可能会将一些本来要读成字符串的读成算法数据，而且<code>PHPExcel</code>没有将它作为默认读取方法的另一个重要原因就是算法方式读取很耗时间和性能，一般数据读取根本没有必要这样浪费资源，所以我们可以采用以下这种方式</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (strstr($cell-&gt;getValue(), <span class="string">'='</span>)) &#123;   </div><div class="line">    <span class="comment">// 判断如果cell内容以=号开头便默认为算法数据</span></div><div class="line">    $value = $cell-&gt;getCalculatedValue(); </div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    $value = $cell-&gt;getValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-日期数据处理"><a href="#3-日期数据处理" class="headerlink" title="3. 日期数据处理"></a>3. 日期数据处理</h3><blockquote><p>除了以上所说的文本数据和算法数据外，我还遇到过日期类型数据，比如<code>2016-12-28</code>输入到<code>excel</code>中，它会默认转换成<code>2016/12/28</code>，如果采用一般的<code>getValue()</code>方式读取也会读取到错误的数据，<code>PHPExcel</code>也提供了相应的接口<code>getFormattedValue()</code>,并提供了适配的识别方式<code>PHPExcel_Shared_Date::isDateTime($cell)</code>,所以代码就很好实现了</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (PHPExcel_Shared_Date::isDateTime($cell)) &#123;</div><div class="line">    $value = $cell-&gt;getFormattedValue(); </div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    $value = $cell-&gt;getValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-读取方法封装"><a href="#4-读取方法封装" class="headerlink" title="4. 读取方法封装"></a>4. 读取方法封装</h3><blockquote><p>针对<code>excel</code>各种数据类型，我们可以写一个函数，将原有的<code>getValue()</code>封装一下，这样以后就不用每次都判别一下数据类型了，目前我只遇到上面三种特殊格式，如果有新的，欢迎大家补充，封装函数如下</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_value_of_cell</span><span class="params">($cell)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (strstr($cell-&gt;getValue(), <span class="string">'='</span>)) &#123;   </div><div class="line">        $value = $cell-&gt;getCalculatedValue(); </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ($cell-&gt;getValue() <span class="keyword">instanceof</span> PHPExcel_RichText) &#123;</div><div class="line">        $value = $cell-&gt;getValue();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PHPExcel_Shared_Date::isDateTime($cell)) &#123;</div><div class="line">        $value = $cell-&gt;getFormattedValue(); </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        $value = $cell-&gt;getValue();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="5-导出文件在IE、360等浏览器中文件名中文乱码问题"><a href="#5-导出文件在IE、360等浏览器中文件名中文乱码问题" class="headerlink" title="5. 导出文件在IE、360等浏览器中文件名中文乱码问题"></a>5. 导出文件在IE、360等浏览器中文件名中文乱码问题</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$filename = <span class="string">'xxx导出表'</span>;</div><div class="line"><span class="comment">// 判断如果是IE内核形式的浏览器采用urlencode处理文件名</span></div><div class="line"><span class="keyword">if</span> (!preg_match(<span class="string">"/Firefox/"</span>, $_SERVER[<span class="string">"HTTP_USER_AGENT"</span>])) &#123;</div><div class="line">    $filename = urlencode($filename);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>未完待续。。。<br>期待你的补充和优化</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://ow0mgad6r.bkt.clouddn.com/office-card-game.png&quot; alt=&quot;office&quot;&gt;&lt;/center&gt;

&lt;p&gt; 过去工作中使用&lt;code&gt;PHPExcel&lt;/code&gt;较多，碰到并解决了各种大大小小的问题，总结出这样一篇文章，一方面记录自己踩过的坑，一方面与大家分享，让大家少走弯路，并不断完善之，欢迎大家去&lt;code&gt;github&lt;/code&gt;上面&lt;code&gt;star&lt;/code&gt;和提交&lt;code&gt;pull request&lt;/code&gt;，不断补充和优化，打造最全面的&lt;code&gt;PHPExcel&lt;/code&gt;开发解决方案&lt;/p&gt;
&lt;p&gt;Github 地址：&lt;a href=&quot;https://github.com/tony-yin/PHPExcel_Road&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/tony-yin/PHPExcel_Road&lt;/a&gt;&lt;br&gt;原文地址：&lt;a href=&quot;https://tony-yin.github.io/2017/09/18/PHP-Excel/&quot;&gt;https://tony-yin.github.io/2017/09/18/PHP-Excel/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://tony-yin.github.io/categories/tech/"/>
    
    
      <category term="PHP" scheme="https://tony-yin.github.io/tags/PHP/"/>
    
      <category term="PHPExcel" scheme="https://tony-yin.github.io/tags/PHPExcel/"/>
    
  </entry>
  
</feed>
